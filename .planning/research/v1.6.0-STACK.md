# Technology Stack

**Project:** FlowForge v1.6.0 -- Extension Platform Expansion (Sandboxing, Context Menus, Status Bar, Git Hooks)
**Researched:** 2026-02-10

## Scope

This document covers ONLY the stack additions/changes needed for:
1. Extension sandboxing infrastructure (Worker-based isolation for third-party extensions)
2. Context menu system (right-click menus extensible by extensions)
3. Status bar widget API (bottom bar with extension-contributed widgets)
4. Git operation hook infrastructure (pre/post hooks for commit, push, merge, etc.)

Existing stack is validated and unchanged: Tauri 2.x, React 19, TypeScript 5.9, Tailwind v4, Catppuccin, XState v5, Zustand 5, React Query v5, Monaco, framer-motion, git2-rs, tauri-specta, reqwest, keyring, lucide-react, react-hotkeys-hook, class-variance-authority.

---

## Recommended Stack Additions

### 1. Context Menu System -- @radix-ui/react-context-menu

| Technology | Version | Purpose | Why |
|------------|---------|---------|-----|
| `@radix-ui/react-context-menu` | ^2.2.16 | Headless context menu primitives | Accessible (WAI-ARIA Menu pattern), keyboard navigation, nested submenus, portal rendering. Zero styling opinions -- works with existing Tailwind v4 + Catppuccin tokens. |

**Why this specific package:**

FlowForge has zero Radix dependencies today. The context menu is the first new UI primitive needed that justifies pulling in an external library. Building context menus from scratch requires handling:
- Right-click event capture and coordinate positioning
- Keyboard navigation (arrow keys, typeahead, Enter/Space activation)
- Nested submenu open/close with hover intent
- Portal rendering to escape overflow:hidden containers
- Focus management and screen reader announcements
- Dismissal on outside click, Escape, scroll, and window blur

Radix Context Menu handles all of this in 32 KB (unpacked). The alternative -- building it ourselves -- would be 400-600 lines of non-trivial accessibility code that would need ongoing maintenance.

**Why NOT the unified `radix-ui` package (v1.4.3):**

The unified `radix-ui` monorepo package exports ALL Radix primitives (Dialog, Accordion, Tabs, Popover, etc.). FlowForge only needs ContextMenu. Installing the individual `@radix-ui/react-context-menu` package keeps the dependency tree minimal. If FlowForge later needs 3+ Radix primitives, migrate to the unified package then.

**Why NOT these alternatives:**

| Alternative | Why Not |
|------------|---------|
| `react-contexify` | Styling-opinionated, CSS-module based. Conflicts with Tailwind-only approach. No submenu nesting. |
| `@headlessui/react` | Does not provide a context menu component. Would need to compose from Menu + manual right-click handling. |
| Native `<menu>` element | Not supported cross-browser for context menus. No React integration, no keyboard navigation. |
| Custom implementation | 400-600 lines of ARIA code. Not worth it when a 32 KB package handles it perfectly. Would need to maintain focus trap, typeahead, submenu timing, and portal logic. |

**Integration with Extension System:**

The context menu will be driven by a `ContextMenuRegistry` (new Zustand store, same pattern as ToolbarRegistry and CommandRegistry). Extensions register menu items via `api.contributeContextMenu()`. The registry renders items through Radix primitives. Extensions never touch Radix directly -- they provide data (label, icon, action, when condition), and the core renders it.

**Confidence: HIGH** -- Radix is the de facto headless primitive library for React (1,281 npm dependents for context-menu alone). Version 2.2.16 is current. Works with any styling approach.

**Sources:**
- [Radix Context Menu docs](https://www.radix-ui.com/primitives/docs/components/context-menu)
- [@radix-ui/react-context-menu on npm](https://www.npmjs.com/package/@radix-ui/react-context-menu)

---

### 2. Extension Sandboxing -- Web Workers + MessageChannel (No New Dependencies)

| Technology | Version | Purpose | Why |
|------------|---------|---------|-----|
| Web Worker API | (platform built-in) | Isolate untrusted extension code in separate thread | True thread isolation. No DOM access, no window access, no Tauri IPC access. Already supported by the CSP (`worker-src: 'self' blob:`). |
| MessageChannel API | (platform built-in) | Private bidirectional communication between host and sandbox | Creates paired MessagePorts. Each extension gets its own channel -- no cross-extension message leaks. Structured clone for data safety. |
| Blob URL construction | (platform built-in) | Load extension code into Workers without filesystem paths | Create Worker from `new Blob([code], {type: 'text/javascript'})` + `URL.createObjectURL()`. Works within CSP `blob:` allowance. |

**Why Web Workers (not iframes, not ShadowRealm, not WASM VM):**

This is the most consequential decision in this stack. The options matrix:

| Approach | Thread Isolation | DOM Access | Tauri IPC Access | CSP Compatible | Complexity | Maturity |
|----------|-----------------|------------|-----------------|----------------|------------|----------|
| **Web Worker** | Yes (separate thread) | No | No | Yes (already configured) | Low | Stable everywhere |
| iframe sandbox | No (same thread) | Yes (own DOM) | Possible via postMessage relay | Needs `frame-src` changes | Medium | Stable but tricky in Tauri |
| ShadowRealm | No (same thread) | No | Possible via shared scope | N/A (not shipped) | Low (if available) | Stage 2.7 -- NOT in any browser |
| SES/Compartments | No (same thread) | Depends on grants | Depends on grants | N/A | High | Production-ready (MetaMask uses it) |
| QuickJS/WASM | Yes (WASM sandbox) | No | No | Needs `wasm-unsafe-eval` | Very High | Used by Figma |

**Decision: Web Worker.** Here is the detailed rationale:

1. **Thread isolation is the strongest security guarantee available.** Workers run in a separate OS thread. Even if extension code enters an infinite loop, the main UI thread continues. iframes share the main thread and can cause jank.

2. **No DOM access by design.** Workers cannot access `window`, `document`, or any DOM API. An extension in a Worker literally cannot scrape the UI, inject scripts, or manipulate the page. This is exactly what we want for third-party sandboxing.

3. **No Tauri IPC access.** The Tauri IPC bridge (`window.__TAURI_IPC__`) is unavailable in Workers. Extensions cannot invoke Tauri commands, access the filesystem, or call OS APIs. They can only communicate through the MessageChannel we provide.

4. **CSP is already configured.** The existing `worker-src: 'self' blob:` in `tauri.conf.json` explicitly allows Worker creation. No CSP changes needed.

5. **Cross-platform consistency.** Web Workers are supported by WebKit (macOS), WebView2 (Windows), and WebKitGTK (Linux) -- all three Tauri webview engines. No platform-specific quirks.

6. **Blob URLs for dynamic code loading.** The current extension system loads external extensions via `import(/* @vite-ignore */ entryUrl)` which executes in the main thread. For sandboxed extensions, we fetch the code as text, wrap it in a Blob, and create a Worker from it. The CSP `blob:` allowance covers this.

**Why NOT iframes:**

| Concern | Detail |
|---------|--------|
| Tauri CSP needs modification | Current CSP has `frame-ancestors: 'none'` and no `frame-src`. Would need to add `frame-src blob:` or `frame-src asset:`. |
| Platform inconsistencies | Tauri docs warn: "On Linux and Android, Tauri is unable to distinguish between requests from an embedded iframe and the window itself." This is a security hole for extension isolation. |
| Windows sandbox limitations | Tauri docs: "External files don't load correctly inside sandboxed iframes on Windows." ES Modules don't work in sandboxed iframes on Windows. |
| Same-thread execution | iframes share the main thread. A misbehaving extension blocks the UI. Workers don't. |
| DOM access surface | Even with `sandbox` attribute, iframes have their own DOM. Extensions could render arbitrary HTML. With Workers, there is zero DOM surface. |

**Why NOT ShadowRealm:**

ShadowRealm is at TC39 Stage 2.7 (not yet Stage 3). It is NOT implemented in ANY browser engine as of February 2026. There are polyfills (`shadowrealm-api` on npm), but polyfills cannot provide true isolation -- they run in the same thread and same global scope with shimmed separation. Using a polyfill would provide weaker isolation than Web Workers.

**Why NOT SES/Compartments (Hardened JavaScript):**

SES (`ses` npm package) from Agoric is production-grade and used by MetaMask. However:
- It runs in the same thread (no thread isolation, no protection against infinite loops)
- It requires `lockdown()` which freezes all intrinsics globally -- this affects ALL code in the app, not just extensions
- The learning curve is steep and the API surface is complex
- For a desktop Git client with trusted built-in extensions and curated third-party ones, SES is overkill

SES would be the right choice if FlowForge were running untrusted smart contracts. For Git client extensions, Worker isolation is sufficient and dramatically simpler.

**Why NOT QuickJS/WASM (Figma approach):**

Figma's approach (QuickJS compiled to WASM) provides the strongest isolation. However:
- It requires adding a WASM runtime (~200KB+ for QuickJS)
- The CSP would need `wasm-unsafe-eval` in `script-src` -- a significant security regression
- Extension code runs in a completely different JS engine with subtle compatibility differences
- The build complexity is very high (WASM compilation pipeline, C->WASM toolchain)
- Figma's use case (untrusted plugins from millions of users) justifies this complexity. FlowForge's use case (curated extensions for Git workflows) does not.

**Architecture of the Worker sandbox:**

```
Main Thread (React App)                    Worker Thread (Sandbox)
========================                   ========================
ExtensionHost                              SandboxedRuntime
  |                                          |
  +-- MessageChannel.port1  <------>  MessageChannel.port2
  |   (host side)              |      (extension side)
  |                            |
  +-- SandboxProxy             +-- ExtensionAPI proxy
      (serializes API calls)       (deserializes, executes)
```

The host creates a `MessageChannel` per extension. `port1` stays in the main thread. `port2` is transferred to the Worker via `Worker.postMessage(port, [port])`. All `ExtensionAPI` methods (registerBlade, registerCommand, etc.) become async message-passing calls. The host receives registration messages and applies them to the real registries.

**Key constraint:** Sandboxed extensions cannot register React components directly (Workers have no DOM). They register data-driven contributions: blade type + configuration, command ID + metadata, toolbar action + icon name. The host renders these using built-in renderer components. This is a deliberate restriction that ensures UI consistency and prevents XSS.

**Dual-mode support:** Built-in extensions (Gitflow, CC, Content Viewers, GitHub) continue running in-process for full React component access. Only externally-loaded extensions use the Worker sandbox. The `ExtensionManifest` gains a `sandbox: boolean` field (default `true` for external, `false` for built-in).

**Confidence: HIGH** -- Web Workers are a mature platform API (supported everywhere since 2012). MessageChannel is equally mature. The CSP already allows both. No new dependencies needed.

**Sources:**
- [Tauri CSP Documentation](https://v2.tauri.app/security/csp/)
- [Tauri Isolation Pattern](https://v2.tauri.app/concept/inter-process-communication/isolation/)
- [MDN Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
- [MDN MessageChannel](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel)
- [MDN Structured Clone](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)
- [Browser Sandbox Architecture (Alex Griss)](https://alexgriss.tech/en/blog/javascript-sandboxes/)
- [Figma Plugin Architecture](https://developers.figma.com/docs/plugins/how-plugins-run/)

---

### 3. Status Bar Widget System -- No New Dependencies

| Technology | Version | Purpose | Why |
|------------|---------|---------|-----|
| (existing) Zustand | ^5 | `StatusBarRegistry` store | Same registry pattern as ToolbarRegistry. Extensions register widgets via `api.contributeStatusBar()`. |
| (existing) React | ^19 | Status bar component rendering | Renders registered widgets in a fixed-bottom bar. No new UI primitive needed -- status bar items are simple text/icon elements. |
| (existing) lucide-react | ^0.563 | Status bar icons | Extensions specify icon name from lucide set. Host resolves to component. |
| (existing) framer-motion | ^12 | Entry/exit animations | AnimatePresence for status bar items appearing/disappearing when extensions activate/deactivate. |

**Why no new dependencies:**

A status bar is fundamentally a horizontal strip of small widgets. Each widget shows:
- An optional icon (from lucide)
- A text label or value
- An optional click action
- An optional tooltip
- A visibility condition (like toolbar `when()`)

This is the exact same data-driven pattern as the existing `ToolbarRegistry`. The implementation is a new `StatusBarRegistry` Zustand store + a `<StatusBar />` React component placed after `<main>` in `App.tsx`. No headless UI library needed -- status bar items are not menus, dialogs, or complex interactive widgets. They are clickable icon+text pairs.

**Widget categories** (like VS Code's status bar):

| Position | Purpose | Examples |
|----------|---------|----------|
| Left | Informational (repo context) | Branch name, sync status, Gitflow state |
| Right | Extension status indicators | GitHub auth status, extension health, background operations |

**Integration with Extension System:**

```typescript
// New ExtensionAPI method
api.contributeStatusBar({
  id: "sync-status",
  text: () => "2 ahead, 1 behind",
  icon: "git-compare",       // lucide icon name, resolved by host
  tooltip: "Click to sync",
  alignment: "left",         // "left" | "right"
  priority: 100,
  when: () => !!repoStatus,
  onClick: () => { /* action */ },
});
```

**Confidence: HIGH** -- Same registry pattern used successfully for toolbar and commands. No architectural novelty.

---

### 4. Git Operation Hook Infrastructure -- No New Dependencies

| Technology | Version | Purpose | Why |
|------------|---------|---------|-----|
| (existing) TypeScript | ^5.9 | Hook type definitions and registry | The hook system is a TypeScript EventEmitter/middleware pattern. |
| (existing) Zustand | ^5 | Hook registry store | Extensions register hooks via store actions. |

**Architecture: Middleware-style hook chain, not git hooks.**

This is NOT about running `.git/hooks/pre-commit` scripts. This is about providing extension points around FlowForge's own Git operations, so extensions can:
- **Pre-operation:** Validate, modify, or cancel a Git operation before it executes (e.g., Conventional Commits extension validates commit message format)
- **Post-operation:** React to completed operations (e.g., GitHub extension refreshes PR status after push)

**Why a middleware pattern (not EventEmitter):**

| Pattern | Pre-operation Cancel | Modify Args | Async | Order Control |
|---------|---------------------|-------------|-------|---------------|
| EventEmitter | No (fire-and-forget) | No | Awkward | No |
| Middleware chain | Yes (return false/throw) | Yes (transform context) | Native async/await | Priority-based |

Middleware is the right abstraction because:
1. Pre-commit hooks MUST be able to cancel the operation (e.g., invalid conventional commit message)
2. Hooks may need to modify operation context (e.g., auto-format commit message)
3. Multiple extensions may hook the same operation (need ordered execution)
4. Operations are already async (Tauri command invocations)

**Hook points (the operations that get hooks):**

| Hook Point | Pre | Post | Use Case |
|------------|-----|------|----------|
| `commit` | Yes | Yes | CC validation, auto-format, post-commit notifications |
| `push` | Yes | Yes | Branch protection checks, PR status refresh |
| `pull` | Yes | Yes | Stash-before-pull, conflict notification |
| `merge` | Yes | Yes | Pre-merge review checklist enforcement, post-merge cleanup |
| `checkout` | Yes | Yes | Dirty tree warning, post-checkout setup |
| `stash` | No | Yes | Post-stash notifications |
| `fetch` | No | Yes | Post-fetch remote status update |
| `tag` | Yes | Yes | Version validation, changelog generation |

**Integration with Extension System:**

```typescript
// New ExtensionAPI method
api.onGitOperation("pre:commit", async (context) => {
  // context.message, context.amend, context.files
  const isValid = validateConventionalCommit(context.message);
  if (!isValid) {
    return { cancel: true, reason: "Invalid conventional commit format" };
  }
  // Optionally modify:
  return { message: formatMessage(context.message) };
});

api.onGitOperation("post:push", async (context) => {
  // context.remote, context.branch, context.success
  refreshPRStatus();
});
```

**Where hooks intercept (implementation detail):**

The hook chain wraps the existing `commands.*` calls in the Zustand store slices. For example, `createCommit()` in the staging slice currently calls `commands.createCommit(message, amend)` directly. With hooks:

```
User clicks Commit
  -> Store action `createCommit(message, amend)` called
  -> Run pre:commit hook chain (extensions can cancel/modify)
  -> If not cancelled: `commands.createCommit(finalMessage, amend)` (Tauri IPC)
  -> Run post:commit hook chain (extensions react to result)
  -> UI updates
```

Hooks run in the main thread (they need access to stores and registries). Sandboxed extensions register hooks via their MessageChannel -- the host proxies hook invocations to the Worker and awaits the response.

**Confidence: HIGH** -- Standard middleware pattern. No external libraries needed. The interception points already exist (Zustand store actions that call Tauri commands).

---

### 5. CSP Adjustments -- Configuration Change Only

| Change | From | To | Why |
|--------|------|----|-----|
| No changes needed for Workers | `worker-src: 'self' blob:` | (unchanged) | Already allows Worker creation from blob URLs |
| No changes needed for iframes | `frame-ancestors: 'none'` | (unchanged) | Not using iframes for sandboxing |

The existing CSP in `tauri.conf.json` already supports the Worker-based sandbox approach. This is a key advantage of choosing Workers over iframes -- zero CSP modifications required.

**Confidence: HIGH** -- Verified against the existing `tauri.conf.json` security configuration.

---

## What NOT to Add (Premature Abstractions)

### DO NOT add: iframe-based sandbox

**Why not:** Platform-inconsistent behavior (Linux cannot distinguish iframe requests from main window), Windows limitations with ES Modules in sandboxed iframes, and requires CSP changes. Workers are simpler and more secure.

### DO NOT add: SES/Hardened JavaScript (`ses` npm package)

**Why not:** Requires global `lockdown()` that freezes all intrinsics application-wide. Overkill for curated Git client extensions. Would affect existing code paths (Monaco, React internals, framer-motion all mutate built-in prototypes).

### DO NOT add: QuickJS/WASM sandbox

**Why not:** 200KB+ WASM bundle, requires `wasm-unsafe-eval` CSP, completely different JS engine with compatibility concerns. Justified for Figma (millions of untrusted plugins) but not for a Git client's extension system.

### DO NOT add: `@radix-ui/react-dropdown-menu` (separate from context menu)

**Why not:** The context menu component from Radix already handles submenus, keyboard navigation, and all menu patterns. A separate dropdown menu is only needed if FlowForge adds dropdown-trigger menus elsewhere. Don't add it preemptively.

### DO NOT add: A formal plugin permission/capability system

**Why not yet:** v1.6.0 extracts EXISTING features (Gitflow, CC, Content Viewers) into built-in extensions and adds hook points. These built-in extensions run in-process and are trusted. A formal permission system (declare capabilities in manifest, prompt user for approval) is needed when third-party extensions can be installed from a marketplace. That is a v2.0+ concern. The Worker sandbox provides the security boundary; permissions are the policy layer on top.

### DO NOT add: Extension inter-communication API

**Why not yet:** No current extension needs to communicate with another extension. Adding `api.sendMessage(extensionId, data)` creates coupling between extensions. If needed later, add it then. For now, extensions communicate indirectly through shared registries (a Gitflow extension contributes toolbar buttons; other extensions see those buttons via the ToolbarRegistry).

### DO NOT add: Status bar position persistence or drag reordering

**Why not yet:** Status bar items have a static layout determined by `alignment` + `priority`. User customization (reorder, show/hide individual items) is a polish feature for later. Start with the data-driven registry and default layout.

---

## Alternatives Considered (Summary)

| Category | Recommended | Alternative | Why Not |
|----------|-------------|-------------|---------|
| Context Menu | @radix-ui/react-context-menu | Custom implementation | 400-600 lines of ARIA code vs 32KB package |
| Context Menu | @radix-ui/react-context-menu | react-contexify | CSS-module styling conflicts with Tailwind |
| Context Menu | @radix-ui/react-context-menu | unified `radix-ui` | Only need 1 component; save 90% bundle |
| Sandbox | Web Worker + MessageChannel | iframe sandbox | Platform issues on Linux/Windows in Tauri |
| Sandbox | Web Worker + MessageChannel | ShadowRealm | Not implemented in any browser (Stage 2.7) |
| Sandbox | Web Worker + MessageChannel | SES Compartments | Global lockdown breaks existing code |
| Sandbox | Web Worker + MessageChannel | QuickJS/WASM | Massive complexity, CSP regression |
| Status Bar | Zustand registry | @radix-ui/react-toolbar | Status bar items are not toolbar buttons; wrong abstraction |
| Git Hooks | Middleware chain | EventEmitter | Cannot cancel operations or modify arguments |
| Git Hooks | Middleware chain | Actual git hooks (.git/hooks/) | OS-level scripts, not extension API-level interception |

---

## Installation

```bash
# Single new dependency
npm install @radix-ui/react-context-menu
```

That's it. Everything else uses existing dependencies or platform APIs.

---

## Version Compatibility Matrix

| New Addition | Depends On | Version Constraint | Notes |
|-------------|-----------|-------------------|-------|
| @radix-ui/react-context-menu 2.2.x | React >= 16.8 | Compatible with React 19 | Peer dep is React 16.8+. Verified. |
| Web Worker sandbox | Tauri webview | All platforms | WebKit, WebView2, WebKitGTK all support Workers |
| MessageChannel | Tauri webview | All platforms | Widely supported since 2015+ |
| StatusBarRegistry | Zustand 5 | (existing) | Same store pattern as ToolbarRegistry |
| GitHookRegistry | Zustand 5 | (existing) | Same store pattern |

---

## Integration Points with Existing ExtensionHost and ExtensionAPI

### ExtensionAPI Additions (4 new methods)

The existing `ExtensionAPI` class (currently 3 methods: `registerBlade`, `registerCommand`, `contributeToolbar`) gains 4 new methods:

```typescript
class ExtensionAPI {
  // Existing (unchanged)
  registerBlade(config: ExtensionBladeConfig): void;
  registerCommand(config: ExtensionCommandConfig): void;
  contributeToolbar(config: ExtensionToolbarConfig): void;
  cleanup(): void;

  // New in v1.6.0
  contributeContextMenu(config: ExtensionContextMenuConfig): void;
  contributeStatusBar(config: ExtensionStatusBarConfig): void;
  onGitOperation(hook: GitHookPoint, handler: GitHookHandler): void;
  offGitOperation(hook: GitHookPoint, handler: GitHookHandler): void;
}
```

### ExtensionHost Changes

The `ExtensionHost` Zustand store gains:
- A `sandboxedWorkers` Map alongside the existing `extensionApis` Map
- Modified `activateExtension` that checks `manifest.sandbox` to decide in-process vs Worker
- Worker lifecycle management (create, terminate, restart on crash)
- MessageChannel creation and port transfer

### New Registries (3 new Zustand stores)

| Registry | Pattern | Location |
|----------|---------|----------|
| `ContextMenuRegistry` | Same as ToolbarRegistry | `src/lib/contextMenuRegistry.ts` |
| `StatusBarRegistry` | Same as ToolbarRegistry | `src/lib/statusBarRegistry.ts` |
| `GitHookRegistry` | Middleware chain (new pattern) | `src/lib/gitHookRegistry.ts` |

### New Components (2)

| Component | Location | Purpose |
|-----------|----------|---------|
| `<ContextMenuProvider>` | `src/components/context-menu/` | Wraps blade areas, renders Radix ContextMenu with registered items |
| `<StatusBar>` | `src/components/status-bar/` | Fixed-bottom bar rendering registered status bar widgets |

### App.tsx Layout Change

```tsx
// Current
<div className="flex flex-col h-screen bg-ctp-base text-ctp-text font-sans">
  <Header />
  <main className="flex-1 min-h-0 overflow-hidden">
    {status ? <RepositoryView /> : <WelcomeView />}
  </main>
  <ToastContainer />
  <CommandPalette />
</div>

// After v1.6.0 -- added StatusBar before ToastContainer
<div className="flex flex-col h-screen bg-ctp-base text-ctp-text font-sans">
  <Header />
  <main className="flex-1 min-h-0 overflow-hidden">
    {status ? <RepositoryView /> : <WelcomeView />}
  </main>
  <StatusBar />
  <ToastContainer />
  <CommandPalette />
</div>
```

---

## Sources

### Primary (HIGH confidence)
- [Tauri 2 CSP Documentation](https://v2.tauri.app/security/csp/)
- [Tauri 2 Isolation Pattern](https://v2.tauri.app/concept/inter-process-communication/isolation/)
- [Tauri 2 Webview Reference](https://v2.tauri.app/reference/javascript/api/namespacewebview/)
- [Tauri 2 Capabilities](https://v2.tauri.app/security/capabilities/)
- [MDN Web Workers API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
- [MDN MessageChannel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel)
- [MDN Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)
- [Radix Context Menu Documentation](https://www.radix-ui.com/primitives/docs/components/context-menu)
- [@radix-ui/react-context-menu npm](https://www.npmjs.com/package/@radix-ui/react-context-menu)

### Secondary (MEDIUM confidence)
- [VS Code Extension Host Architecture](https://code.visualstudio.com/api/advanced-topics/extension-host)
- [Figma Plugin Architecture](https://developers.figma.com/docs/plugins/how-plugins-run/)
- [Browser Sandbox Architecture (Alex Griss)](https://alexgriss.tech/en/blog/javascript-sandboxes/)
- [Hardened JavaScript / SES](https://hardenedjs.org/)
- [TC39 ShadowRealm Proposal](https://github.com/tc39/proposal-shadowrealm)

### Contextual (codebase analysis)
- `src/extensions/ExtensionHost.ts` -- Current extension lifecycle
- `src/extensions/ExtensionAPI.ts` -- Current 3-method API facade
- `src/lib/toolbarRegistry.ts` -- Registry pattern to replicate
- `src/lib/commandRegistry.ts` -- Registry pattern to replicate
- `src-tauri/tauri.conf.json` -- CSP configuration (worker-src already set)
- `src/App.tsx` -- Layout structure for StatusBar placement
