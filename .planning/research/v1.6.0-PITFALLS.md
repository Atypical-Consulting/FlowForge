# Domain Pitfalls: Extension Platform Expansion & Feature Extraction

**Domain:** Extracting built-in features to extensions, expanding extension API surface, sandbox preparation
**Project:** FlowForge v1.6.0
**Researched:** 2026-02-10

---

## Critical Pitfalls

Mistakes that cause rewrites, data loss, or multi-week recovery.

---

### Pitfall 1: Gitflow State Machine Split-Brain Between Rust and Extension

**What goes wrong:** The Gitflow state machine lives in Rust (`src-tauri/src/gitflow/machine.rs`, `state.rs`, `commands.rs`) and exposes 8 Tauri commands (`start_feature`, `finish_feature`, `start_release`, `finish_release`, `start_hotfix`, `finish_hotfix`, `get_gitflow_status`, `abort_gitflow`). The frontend Gitflow store (`stores/domain/git-ops/gitflow.slice.ts`) calls these commands directly via `commands.startFeature(name)` etc. When extracting Gitflow to a built-in extension, the temptation is to make the extension own the state -- but the Rust commands still hold the real git state via `RepositoryState`. If the extension maintains its own shadow state that drifts from Rust, you get split-brain: the extension thinks a feature is in progress, Rust thinks we're idle.

**Why it happens:** The extraction refactoring moves the frontend store into the extension but the developer forgets that Rust is the source of truth. Or the extension caches `GitflowStatus` locally and doesn't refresh after operations, creating stale state.

**Consequences:** User starts a feature via extension, extension shows "active", then user switches branches via core Branch panel (which calls `checkout_branch`, not a Gitflow command), and the Gitflow extension still shows the old active flow. Finish operations fail because Rust sees a different branch than expected. Potential for orphaned branches.

**Prevention:**
1. The Gitflow extension MUST NOT own state. It should call Rust commands through the existing `commands` bindings and treat `get_gitflow_status()` as the sole source of truth.
2. After every Gitflow operation in the extension, re-fetch status from Rust. Do not optimistically update UI state.
3. The extension must subscribe to branch change events (reuse the `useBranchStore` subscription pattern from `GitflowPanel.tsx` line 24-26) so it refreshes when branches change outside Gitflow operations.
4. Keep the Rust Gitflow module (`src-tauri/src/gitflow/`) untouched during extraction. The extraction is frontend-only.

**Detection:** Write a test that: (a) starts a feature via Gitflow extension, (b) checks out develop via core Branch API, (c) verifies Gitflow extension shows "Idle" not "Feature active". If it fails, you have split-brain.

**Warning signs:** Any new `useState` or Zustand store in the Gitflow extension holding `activeFlow` or `currentState` that isn't directly sourced from `commands.getGitflowStatus()`.

**Phase:** Address in Phase 1 (Gitflow extraction). This is the single most dangerous pitfall in the entire milestone.

---

### Pitfall 2: Circular Import Death Spiral During Extraction

**What goes wrong:** The Gitflow slice (`gitflow.slice.ts`) is part of the combined `GitOpsStore` which merges 9 slices (`RepositorySlice`, `BranchSlice`, `TagSlice`, `StashSlice`, `WorktreeSlice`, `GitflowSlice`, `UndoSlice`, `TopologySlice`, `CloneSlice`). The Gitflow slice calls `get().loadBranches()` and `get().refreshRepoStatus()` from other slices after operations. When you extract Gitflow to an extension, these cross-slice calls create circular dependencies: the extension needs `loadBranches` from the core store, but if core store imports from the extension, you get a circular import.

**Why it happens:** Zustand's slice pattern works by merging all slices into a single store, giving each slice access to all others via `get()`. This is convenient but creates implicit coupling. When you extract one slice to a separate module (extension), the coupling becomes visible and painful.

**Consequences:** Build fails with circular import errors. Or worse, the build succeeds but the extension module loads before the store is initialized, causing runtime `undefined` errors. In the worst case, HMR breaks and dev experience degrades.

**Prevention:**
1. The Gitflow extension must NOT import `useGitOpsStore` directly. Instead, provide post-operation hooks via the ExtensionAPI: `api.onGitflowComplete(() => { refreshBranches(); refreshStatus(); })`. Or simpler: have the extension emit events and let core subscribe.
2. Before extraction, audit all cross-slice calls in `gitflow.slice.ts`. Lines 61-62, 75-76, 89-90, etc. all call `get().loadBranches()` and `get().refreshRepoStatus()`. These must become indirect (event-based or callback-based).
3. Remove `GitflowSlice` from `GitOpsStore` type union and the `createGitflowSlice` spread. The store shrinks by one slice. This is safe because the shim `stores/gitflow.ts` already exists for backward compatibility.
4. The extension's activate function should subscribe to the `BranchSlice` for branch change events rather than reaching into the store.

**Detection:** After extraction, run `madge --circular src/` to detect circular imports. Any cycle involving `extensions/gitflow` and `stores/domain/git-ops` is a red flag.

**Warning signs:** Import statements in the extension that reference `../../stores/domain/git-ops` or `../../bindings` more than `commands.*` calls.

**Phase:** Address in Phase 1 (Gitflow extraction). Must be resolved before any UI work begins.

---

### Pitfall 3: Breaking the RepositoryView Hardcoded Sidebar

**What goes wrong:** `RepositoryView.tsx` hardcodes the Gitflow section as a `<details>` element (lines 119-127) that directly renders `<GitflowPanel />`. When Gitflow becomes an extension, this hardcoded section must be replaced with a dynamic "sidebar contribution" system. If done incorrectly, the sidebar breaks for ALL users, not just those with Gitflow disabled -- because the layout depends on the `<details>` structure for spacing, scroll behavior, and sticky headers.

**Why it happens:** The sidebar has no extension contribution point. Every section (Branches, Stashes, Tags, Gitflow, Worktrees) is JSX in a single file. There is no registry for sidebar panels. The developer adds a "sidebar registry" but doesn't preserve the sticky header behavior, scroll containment, or the `<details open>` default state.

**Consequences:** Visual regression in the sidebar. Sections stack incorrectly. Sticky headers stop working. The sidebar scroll area breaks. Users who never cared about Gitflow suddenly have a broken UI.

**Prevention:**
1. Create a `SidebarContribution` registry modeled on the existing `BladeRegistration` and `ToolbarAction` patterns. Each contribution specifies: `id`, `title`, `icon`, `component`, `priority`, `defaultOpen`, `source`.
2. Core sidebar sections (Branches, Stashes, Tags, Worktrees) register as `source: "core"`. Gitflow registers via its extension's `activate()` as `source: "ext:gitflow"`.
3. The `RepositoryView` renders contributions in priority order using the SAME `<details>` + sticky header pattern. Extract the current `<details>` pattern into a `<SidebarSection>` component first, BEFORE touching any extension code.
4. Test: disable Gitflow extension, verify sidebar renders 4 core sections with no empty space or layout artifacts.

**Detection:** Visual regression test. Snapshot the sidebar HTML with Gitflow enabled and disabled. Diff should show only the Gitflow section removed, with no structural changes to other sections.

**Warning signs:** PR that modifies `RepositoryView.tsx` and adds conditional rendering (`{gitflowEnabled && <GitflowPanel />}`) instead of a proper registry. This band-aid approach doesn't scale and doesn't support third-party sidebar contributions.

**Phase:** Address in Phase 1 (Gitflow extraction) as the first sub-task. The sidebar registry is a prerequisite for all feature extractions.

---

### Pitfall 4: Conventional Commits Store Entanglement With Tauri Bindings

**What goes wrong:** The Conventional Commits feature has deep coupling to 4 Rust-backed Tauri commands: `validate_conventional_commit`, `suggest_commit_type`, `get_scope_suggestions`, `infer_scope_from_staged`. The store (`stores/conventional.ts`) imports directly from `bindings.ts` (line 1-7). The blade (`ConventionalCommitBlade.tsx`) imports from multiple core paths (`hooks/useConventionalCommit`, `hooks/useCommitExecution`, `hooks/useAmendPrefill`, `stores/conventional`, `hooks/useBladeNavigation`, `components/layout/SplitPaneLayout`). When extracting to an extension, you cannot simply move these files because they import core infrastructure.

**Why it happens:** The conventional commit feature was built as a first-class citizen with deep access to core APIs. This is the right choice for a core feature. But extraction to an extension requires decoupling, and the developer underestimates the number of import paths.

**Consequences:** The extension either imports half the app (defeating the purpose of extraction) or the developer copies code into the extension (creating maintenance nightmare with diverging copies). Build size increases because the same code is bundled twice.

**Prevention:**
1. The Conventional Commits extension should remain a built-in extension (like GitHub) that uses `import()` for its components but can directly import from core. This is the pragmatic approach.
2. Do NOT try to make CC a "pure" extension that doesn't import core modules. The GitHub extension already imports from `../../stores/repository`, `../../lib/bladeOpener`, `../../lib/queryClient`. This establishes the pattern: built-in extensions can import core modules.
3. The extraction boundary should be: the extension's `activate()` registers blades/commands/toolbar via `ExtensionAPI`, but the blade components themselves import whatever they need from core.
4. Later (v1.7+), if third-party CC alternatives are wanted, extract the Tauri commands into an `api.conventional` namespace on `ExtensionAPI`. But not now.

**Detection:** After extraction, check the extension's `index.ts` activate function. If it's >50 lines of import gymnastics to avoid core imports, the boundary is wrong.

**Warning signs:** New "adapter" or "bridge" files that just re-export core utilities for extension consumption. These add complexity without value.

**Phase:** Address in Phase 2 (Conventional Commits extraction). Simpler than Gitflow because there's no Rust state machine -- just Rust utility commands.

---

### Pitfall 5: Extension Deactivation Leaves Orphaned UI and Stale Subscriptions

**What goes wrong:** When a user disables the Gitflow extension, the `GitflowPanel` component must be removed from the sidebar, and all Zustand subscriptions must be cleaned up. But the existing `ExtensionAPI.cleanup()` only handles blade registry, command registry, and toolbar registry (lines 120-134 of `ExtensionAPI.ts`). It does NOT handle:
- Sidebar panel contributions (new registry, not yet built)
- Store subscriptions (e.g., the GitHub extension's `unsubRepoWatch` and `unsubGitHubWatch`)
- React component trees that are still mounted when cleanup runs
- Zustand store slices that have pending async operations

**Why it happens:** The current cleanup is designed for v1.5's scope (blades, commands, toolbar). v1.6 adds new contribution types (sidebar panels, status bar items, context menu entries, hook points) but the developer forgets to extend `cleanup()` to handle them all.

**Consequences:** After disabling an extension: phantom sidebar sections remain visible, click handlers throw errors because the extension's code is gone but the DOM element remains, store subscriptions fire into cleaned-up callbacks causing console errors, and memory leaks from uncollected React component trees.

**Prevention:**
1. For every new registry added in v1.6, add a corresponding `unregisterBySource(source)` method. Audit: does `cleanup()` in `ExtensionAPI.ts` call it?
2. Follow the GitHub extension's pattern (lines 300-322 of `github/index.ts`): return cleanup functions from `onDeactivate()`, not from `activate()`. This ensures the extension controls its own teardown.
3. Add a `disposables` array to `ExtensionAPI` that extensions push cleanup callbacks into. `cleanup()` iterates and calls them all. Pattern: `api.onDispose(() => unsubFromStore())`.
4. Test: activate Gitflow, open Gitflow sidebar, start a feature, then deactivate Gitflow. Verify: no console errors, sidebar section gone, GitflowPanel unmounted, no stale subscriptions firing.

**Detection:** Open browser devtools, disable extension, check console for errors over 10 seconds. Any "Cannot read property of undefined" or "store is destroyed" errors indicate incomplete cleanup.

**Warning signs:** Extension's `onDeactivate()` function is empty or only calls `cancelPolling()`. It should clean up ALL subscriptions created in `onActivate()`.

**Phase:** Address in Phase 1 (Gitflow extraction) because it's the first extraction and sets the pattern. The `api.onDispose()` API must be added to `ExtensionAPI` before any extraction begins.

---

### Pitfall 6: Hook Point Ordering Creates Non-Deterministic Behavior

**What goes wrong:** When adding hook points like `onBeforeCommit`, `onAfterBranchCreate`, `onBeforeGitflowFinish`, multiple extensions can register handlers for the same hook. If execution order is undefined, behavior becomes non-deterministic. Example: Extension A's `onBeforeCommit` adds a "Signed-off-by" trailer, Extension B's `onBeforeCommit` validates the commit message. If B runs before A, the validation passes for the un-modified message but the final message is different. If B runs after A, validation runs on the modified message.

**Why it happens:** The developer implements hooks as a simple `Set` of callbacks, iterated in insertion order. Insertion order depends on extension activation order, which depends on filesystem discovery order (which varies across platforms).

**Consequences:** Intermittent test failures. User reports "it works on my machine but not yours". Hooks that modify data (like commit message transformation) produce different results on different systems.

**Prevention:**
1. Hook handlers must declare a `priority` (default: 0). Higher priority runs first. Same priority: alphabetical by extension ID (deterministic).
2. Hooks should be typed as "tap" (read-only observation) or "intercept" (can modify data). Tap hooks can run in any order. Intercept hooks run in priority order and pass the modified value to the next handler (pipeline pattern).
3. For v1.6, start with tap-only hooks (observation, no modification). Intercept hooks are Phase 2+ complexity. This avoids the ordering problem entirely for the initial release.
4. Document hook execution order in the ExtensionAPI. Extensions must not depend on running before or after another specific extension.

**Detection:** Register two test extensions with the same hook. Verify they always execute in the same order across 100 runs.

**Warning signs:** Hook implementation using `Set<Function>` or `Array.push()` without priority sorting. Any hook that passes mutable data to handlers without a pipeline pattern.

**Phase:** Address in Phase 3 (Hook points). This is architectural -- get it right before shipping any hooks. The tap-only-first strategy reduces risk significantly.

---

## Moderate Pitfalls

Issues that cause multi-day delays or significant rework but not full rewrites.

---

### Pitfall 7: Sandbox iframe Cannot Access Tauri IPC

**What goes wrong:** When building sandbox infrastructure for third-party extensions (iframe/Worker), the sandboxed iframe cannot call Tauri commands because the Tauri IPC bridge (`__TAURI_INVOKE_KEY__`) is not injected into iframe contexts. Tauri v2 actively blocks this for security. The developer spends days trying to make `commands.startFeature()` work from inside an iframe and it simply cannot.

**Why it happens:** The developer assumes iframes in a Tauri webview work like iframes in a browser -- they don't. Tauri's security model deliberately prevents child frames from accessing IPC.

**Consequences:** The entire sandbox strategy based on iframes is blocked. The developer pivots to Web Workers, which also can't access Tauri IPC directly. Weeks of wasted work.

**Prevention:**
1. Accept that sandboxed extensions CANNOT directly call Tauri commands. This is a security feature, not a bug.
2. Design a message-passing bridge: sandboxed extension sends JSON messages to the host via `postMessage`, the host validates and proxies the call to Tauri, then sends the result back via `postMessage`.
3. For v1.6, only PREPARE the sandbox infrastructure. Do not ship sandboxed third-party extension support. All extensions in v1.6 remain in-process (built-in or filesystem-loaded via `import()`).
4. The sandbox prep work should be: define the message protocol, build the proxy bridge prototype, test with a synthetic "sandboxed" built-in extension.

**Detection:** Attempt `window.__TAURI_INVOKE__` from inside a `sandbox="allow-scripts"` iframe. It will be undefined.

**Warning signs:** Any PR that adds `<iframe>` elements for extension hosting without a corresponding `postMessage` bridge implementation.

**Phase:** Address in Phase 5 (Sandbox preparation). This is explicitly prep work, not production deployment. The proxy bridge design is the deliverable, not a working sandbox.

---

### Pitfall 8: Context Menu API Becomes an Unmaintainable Grab Bag

**What goes wrong:** The context menu contribution API starts simple ("add items to right-click menu") but quickly becomes complex: Where does the item appear? What data does it receive? How does it know what's selected? Does it work on multi-selection? What about nested submenus? The developer builds a generic `registerContextMenu()` that accepts arbitrary configuration, and within 3 extensions every call site uses different conventions.

**Why it happens:** Context menus need context. A right-click on a branch needs branch data. A right-click on a file needs file path + status. A right-click on a commit needs commit hash. Without typed contexts, extensions pass `any` and break when the context shape changes.

**Consequences:** Type-unsafe API. Extensions crash when context data is missing. No way to validate menu contributions at registration time. Menu items appear in wrong locations because the `when` clause is too broad.

**Prevention:**
1. Define specific, typed context menu locations as an enum: `"branch-list"`, `"file-tree"`, `"commit-list"`, `"sidebar-section"`, `"blade-header"`. NOT a generic `"context-menu"`.
2. Each location has a typed context interface: `BranchContextMenuContext { branchName: string; isRemote: boolean; isCurrent: boolean }`, `FileContextMenuContext { filePath: string; status: FileStatus; isStaged: boolean }`.
3. Extensions register with: `api.contributeContextMenu("branch-list", { ... })`, getting type safety on the context parameter.
4. Start with 2-3 locations in v1.6 (branch list and file tree). Add more in subsequent versions. Better to have 3 well-typed locations than 10 untyped ones.
5. Provide a `when` clause that operates on the typed context, not arbitrary state. Example: `when: (ctx) => ctx.isRemote && !ctx.isCurrent`.

**Detection:** If the context menu registration function signature has `context: any` or `location: string`, the API is under-typed. It should be `location: ContextMenuLocation` with generic type parameter.

**Warning signs:** A single `registerContextMenu()` function that takes a `location: string` parameter instead of overloaded or location-specific registration methods.

**Phase:** Address in Phase 3 (new hook points / contribution types). Start with branch-list context menu since it's the most requested feature.

---

### Pitfall 9: Content Viewer Extraction Breaks Preview Registry Cascade

**What goes wrong:** Content viewers (code, image, markdown, 3D, nupkg) use two separate registries: `bladeRegistry` for full-page viewing and `previewRegistry` for inline staging previews (`previewRegistrations.ts`). When extracting viewers to extensions, the developer moves the blade registration but forgets the preview registration. Or they move both but the preview registry loads before the extension activates, so file previews fall through to the default text diff for all file types.

**Why it happens:** The preview registry (`lib/previewRegistry.ts`) uses eager `import.meta.glob` via `previewRegistrations.ts` in the staging blade. Blade registrations also use eager glob via `_discovery.ts`. Both assume all registrations happen at module load time. Extensions activate asynchronously after module load. By the time the extension registers its preview handler, the staging blade has already resolved previews for visible files.

**Consequences:** Images show as "text diff" instead of image preview. 3D models show as binary gibberish. NuGet packages lose their metadata viewer. The staging area, which is the most-used blade, regresses visually.

**Prevention:**
1. Do NOT extract content viewers in the same phase as Gitflow/CC. Content viewers are the lowest-risk extraction and should go last.
2. When you do extract viewers (Phase 4), add an `api.registerPreview()` method to `ExtensionAPI` that wraps `registerPreview()` from `lib/previewRegistry.ts`.
3. The preview registry must support late registration. When a new preview handler registers after files are already displayed, the staging blade should re-evaluate visible file previews. Add a `registrationTick` counter (like `toolbarRegistry.visibilityTick`) to trigger re-renders.
4. Keep the default text-diff fallback as a core registration that never gets extracted.

**Detection:** Disable a viewer extension. Open staging blade with a matching file (e.g., `.png` for image viewer). It should show the binary placeholder, not crash. Re-enable the extension. The preview should update to the image viewer without page reload.

**Warning signs:** PR that deletes entries from `previewRegistrations.ts` without adding `api.registerPreview()` in the extension's activate function.

**Phase:** Address in Phase 4 (Content viewer extraction). This is the last extraction phase because viewers are the least coupled and easiest to test.

---

### Pitfall 10: Backward Compatibility Shim Becomes Permanent Technical Debt

**What goes wrong:** During extraction, you create backward compatibility shims (like the existing `stores/gitflow.ts` which re-exports from `domain/git-ops`). For v1.6, you'll create more: the `_discovery.ts` must continue discovering core blades even as some blades move to extensions; the `RepositoryView.tsx` must render the sidebar whether Gitflow is a core component or an extension contribution. Each shim is "temporary" but never gets removed.

**Why it happens:** The shim works, nothing breaks, and removing it requires auditing all consumers. The developer moves on to the next feature. Six months later there are 15 shims and nobody knows which are still needed.

**Consequences:** New developers are confused by two paths to the same thing. A shim re-export masks that the real module moved. Import autocomplete suggests both the old and new paths. Bundle analysis shows duplicate code.

**Prevention:**
1. For every shim created, add a `@deprecated` JSDoc comment with: (a) what to use instead, (b) which version it will be removed in, (c) a link to the tracking issue.
2. Add an ESLint `no-restricted-imports` rule for deprecated shim paths. Set to "warn" during the extraction version, "error" in the next version.
3. Create a `DEPRECATIONS.md` file tracking all shims with their planned removal version.
4. The existing `stores/gitflow.ts` shim (already marked `@deprecated`) should be removed in v1.6 since the extraction will change the import path anyway. Use this as the precedent.

**Detection:** `grep -r "@deprecated" src/ | grep "shim\|compat\|legacy"` should return a manageable number. If >10, shims are accumulating.

**Warning signs:** PR review reveals new files whose sole purpose is `export { X } from "../new/path"`. Each one should have a deprecation annotation and a removal date.

**Phase:** Address in Phase 1 as a process requirement. Every shim created in any phase must follow the deprecation protocol.

---

### Pitfall 11: `_discovery.ts` Exhaustiveness Check Breaks When Blades Move to Extensions

**What goes wrong:** The `_discovery.ts` file (line 17-22) has a dev-mode exhaustiveness check that expects 16 specific blade types. When Gitflow cheatsheet and conventional commit blades move to extensions, they no longer have `registration.ts` files in `src/blades/`. The exhaustiveness check warns about "missing registrations" on every page load in dev mode, causing developer confusion and console noise.

**Why it happens:** The expected types list is hardcoded. Nobody updates it when blades move to extensions because it's "just a dev warning." But every dev sees it and either ignores all warnings (dangerous) or wastes time investigating.

**Consequences:** Warning fatigue. Developers start ignoring the exhaustiveness check. A genuinely missing registration is missed because "that warning always shows up."

**Prevention:**
1. When extracting a blade to an extension, remove its type from `EXPECTED_TYPES` in `_discovery.ts`.
2. Consider adding an `EXPECTED_EXTENSION_TYPES` check that runs after extension activation, verifying that expected built-in extensions registered their expected blade types.
3. Or better: remove the hardcoded list entirely. Instead, have each blade's `registration.ts` export a marker, and the check ensures every `src/blades/*/registration.ts` file was loaded (which `import.meta.glob` already guarantees).

**Detection:** After extracting gitflow-cheatsheet and conventional-commit, check the dev console on app launch. If you see missing registration warnings, the list wasn't updated.

**Warning signs:** `EXPECTED_TYPES` array being modified without a corresponding comment explaining why the type was added or removed.

**Phase:** Address in Phase 1 (first extraction), as a small sub-task alongside the main extraction.

---

### Pitfall 12: Extension Activation Order Creates Hidden Dependencies

**What goes wrong:** Built-in extensions (Gitflow, CC, Viewers) are activated via `registerBuiltIn()` which calls `activate()` immediately. If one extension depends on another's contributions (e.g., a "Gitflow CC" extension that adds conventional commit templates for Gitflow operations), the activation order matters. But `registerBuiltIn()` is called in whatever order the code executes, and the order may differ between production build and dev HMR.

**Why it happens:** The `ExtensionHost.registerBuiltIn()` (line 334-399) activates immediately after registration. There's no dependency resolution. Extensions that call `getBladeRegistration("ext:conventional-commit:form")` during activation will get `undefined` if CC hasn't activated yet.

**Consequences:** Intermittent activation failures. "Works in dev, fails in production" because bundler ordering differs. Extensions that depend on other extensions' contributions silently degrade.

**Prevention:**
1. For v1.6, built-in extensions should NOT depend on each other's registrations. Each extension should be self-contained.
2. If cross-extension dependencies emerge later, add an `after: string[]` field to `BuiltInExtensionConfig` that declares activation dependencies. `ExtensionHost` topologically sorts before activating.
3. For now, the simpler fix: any cross-extension reference should use lazy lookup (resolve at call time, not at activation time). If `getBladeRegistration` returns undefined, show a meaningful error instead of crashing.

**Detection:** Randomize built-in extension activation order in tests. Run 50 times. All activations should succeed regardless of order.

**Warning signs:** An extension's `activate()` function that calls `getBladeRegistration()`, `getCommandById()`, or similar lookups for another extension's contributions.

**Phase:** Address in Phase 2 if CC extraction creates dependencies. For Phase 1 (Gitflow only), this is unlikely because Gitflow doesn't reference other extensions.

---

## Minor Pitfalls

Issues that cause hours of debugging or minor UX problems.

---

### Pitfall 13: Tauri Bindings Regeneration Breaks Extension Type References

**What goes wrong:** Tauri uses `specta` to auto-generate `bindings.ts` on every Rust build. The conventional commit types (`CommitType`, `ValidationResult`, `ScopeSuggestion`, `TypeSuggestion`) and Gitflow types (`GitflowStatus`, `GitflowConfig`, `GitflowState`) are defined in this generated file. If an extension imports these types and the Rust struct changes shape (e.g., adding a field to `GitflowStatus`), the extension may not handle the new field gracefully.

**Why it happens:** Built-in extensions import from `../../bindings` which is always in sync with Rust. But the developer is building toward third-party extensions that would bundle their own type definitions. If FlowForge ships a new Rust type shape, old extensions break.

**Prevention:**
1. For v1.6 (built-in extensions only): this is a non-issue. Built-in extensions import from the same `bindings.ts`.
2. For future third-party extensions: version the API types. The `ExtensionManifest.apiVersion` (currently `"1"`) should be checked against type compatibility.
3. Add a `CHANGELOG-EXTENSION-API.md` that documents type shape changes per API version.

**Detection:** After any Rust struct modification, run `tsc --noEmit` and check for errors in extension files.

**Warning signs:** Extension code that destructures deeply into Tauri-generated types: `const { context: { state: { type } } } = status` will break if nesting changes.

**Phase:** Low priority for v1.6. Document as a future concern for v1.7+ (third-party extension support).

---

### Pitfall 14: Status Bar Contribution Collisions

**What goes wrong:** Multiple extensions contribute status bar items with overlapping information. For example, both the Gitflow extension and a future "Git Status" extension show branch information. The status bar becomes cluttered with redundant items, and the ordering is unpredictable.

**Why it happens:** No coordination mechanism between extensions for status bar real estate. Each extension assumes it's the only one showing branch info.

**Prevention:**
1. Status bar items must declare a `group` (like toolbar actions use `"navigation"`, `"git-actions"`, `"views"`, `"app"`). Define groups: `"branch"`, `"sync"`, `"extension"`, `"info"`.
2. Each group has a maximum display width. Items within a group are priority-sorted.
3. Provide a `conflicts` field: `conflicts: ["core:branch-display"]` means "if core branch display is active, hide my branch display."
4. For v1.6, start simple: extension status bar items go in an "extension" group on the far right. Core items take precedence.

**Detection:** Enable 3+ extensions with status bar contributions. Verify the status bar doesn't overflow or show duplicate information.

**Warning signs:** Status bar API that doesn't include priority, group, or conflict resolution fields.

**Phase:** Address in Phase 3 (status bar contributions).

---

### Pitfall 15: Git Operation Hooks Fire Too Frequently

**What goes wrong:** Hooks like `onAfterCommit`, `onAfterCheckout`, `onAfterFetch` fire on every git operation, including internal operations triggered by other hooks. Extension A's `onAfterCommit` triggers a branch refresh, which triggers `onAfterCheckout` (because the refresh involves branch resolution), which triggers Extension B's handler, creating a cascade.

**Why it happens:** The hook system doesn't distinguish between user-initiated operations and programmatic operations. The Tauri file watcher already triggers store refreshes on git operations; adding hooks on top creates double-refresh storms.

**Consequences:** Performance degradation. UI flickers. Unnecessary Tauri IPC calls. In the worst case, infinite loops if hooks trigger operations that fire hooks.

**Prevention:**
1. Hooks should fire only on user-initiated git operations, not on internal refreshes. Add an `isInternal: boolean` flag to hook context that handlers can check.
2. Implement a re-entrancy guard: if a hook handler triggers a git operation, hooks from that nested operation are suppressed.
3. Debounce hook firing: batch all hooks triggered within a 100ms window into a single invocation.
4. The existing file watcher (`WatcherState`) already handles auto-refresh. Hooks should be for "user-visible events", not "every git state change."

**Detection:** Add a counter to hook dispatch. After a single commit, the counter should be 1, not 5+.

**Warning signs:** Hook dispatch function that calls `commands.*` Tauri functions without a re-entrancy check.

**Phase:** Address in Phase 3 (hook system design). Design the suppression mechanism before implementing any hooks.

---

### Pitfall 16: Extension Manager Blade Doesn't Reflect Real-Time Status

**What goes wrong:** The Extension Manager blade (`ExtensionManagerBlade.tsx`) shows extension status from `useExtensionHost` store. When an extension is activated or deactivated from outside the manager (e.g., via command palette), the manager blade doesn't update because it's using a stale snapshot.

**Why it happens:** The Extension Manager subscribes to the Zustand store, which should auto-update. But if the store update happens via `updateExtension()` (which creates a new Map reference), and the blade renders with a selector that doesn't detect Map changes (because shallow comparison doesn't deep-compare Maps), the UI won't re-render.

**Consequences:** User disables extension via command palette, opens Extension Manager, still sees "Active" status. Clicks "Disable" again, gets an error because it's already disabled.

**Prevention:**
1. The `ExtensionHostState.extensions` is already a `Map` that gets replaced on every update (lines 86-92 of `ExtensionHost.ts`). This should trigger re-renders since it's a new reference.
2. Verify the Extension Manager blade uses `useExtensionHost((s) => s.extensions)` with the Map as the selector value. If it uses `useExtensionHost()` without a selector, it re-renders on any store change (correct but wasteful).
3. Add a `statusVersion` counter to the store that increments on every status change, and use it as a dependency for memo'd components.

**Detection:** Open Extension Manager. In another terminal, call `useExtensionHost.getState().deactivateExtension("gitflow")`. Verify the Extension Manager updates within 1 render cycle.

**Warning signs:** Extension Manager using `useMemo` or `React.memo` on extension lists without proper dependency on the extensions Map.

**Phase:** Address in Phase 1 alongside Gitflow extraction, since the manager is the primary UI for enable/disable.

---

## Integration Pitfalls: Rust Backend + Frontend Extension System

---

### Integration Pitfall A: Rust Commands Cannot Be Dynamically Registered

**What goes wrong:** The developer wants to let extensions add new Tauri commands dynamically. For example, a "Git LFS" extension that adds `lfs_fetch`, `lfs_push` commands. But Tauri v2's `invoke_handler` is built at compile time via `collect_commands![]` (line 63 of `lib.rs`). You cannot add commands at runtime.

**Why it happens:** Tauri's command system is designed for compile-time safety. The `specta` type generation, the `collect_commands![]` macro, and the `invoke_handler` are all static. There is no `register_command_at_runtime()` API.

**Consequences:** Extensions cannot add Rust-side functionality. The extension system is frontend-only. Any feature that needs new Rust logic requires rebuilding the app.

**Prevention:**
1. Accept this limitation for v1.6. Extensions are frontend-only contributions (blades, commands, toolbar, sidebar, hooks) that call EXISTING Tauri commands.
2. For Rust-side extensibility, use a different mechanism: define a generic `extension_invoke(extension_id: String, method: String, args: serde_json::Value) -> Result<serde_json::Value>` Tauri command that dispatches to Rust-side extension modules.
3. This is v1.7+ scope. For v1.6, document the limitation clearly in the extension API docs.

**Detection:** N/A for v1.6. If someone asks "can my extension add a Tauri command?", the answer is "not yet."

**Warning signs:** Any attempt to modify `lib.rs` `collect_commands![]` dynamically or at runtime.

**Phase:** Acknowledge in Phase 1 documentation. Do not attempt to solve.

---

### Integration Pitfall B: Gitflow Rust Commands Remain Registered Even When Extension Is Disabled

**What goes wrong:** The 8 Gitflow Tauri commands (`start_feature`, `finish_feature`, etc.) are registered in `lib.rs` at compile time. When the user disables the Gitflow extension, the frontend UI goes away, but the Rust commands remain callable via IPC. A malicious or buggy script could still invoke `startFeature` even though the user explicitly disabled Gitflow.

**Why it happens:** Tauri commands are registered unconditionally. There's no way to enable/disable them at runtime based on extension state.

**Consequences:** Minor security/integrity concern. The user's intent (disable Gitflow) is not enforced at the IPC boundary. However, since Gitflow operations are destructive (creating/deleting branches, merging), an unintended invocation could modify the repository.

**Prevention:**
1. For v1.6, this is acceptable. The Gitflow Tauri commands are only called from the Gitflow frontend extension. If the extension is disabled, nothing calls them.
2. For v1.7+, add a Rust-side middleware that checks extension state before executing commands. Pattern: `#[extension_guard("gitflow")]` attribute macro that checks `ExtensionState` before proceeding.
3. Alternatively, the `get_gitflow_status` command could return a "Gitflow not enabled" error if the frontend extension isn't active, but this requires Rust to know about frontend extension state, which couples the layers.

**Detection:** With Gitflow extension disabled, manually invoke `commands.startFeature("test")` from the browser console. It will succeed. This is the known limitation.

**Warning signs:** N/A for v1.6. Document as a known limitation.

**Phase:** Acknowledge in documentation. Address in v1.7+.

---

### Integration Pitfall C: Specta-Generated Bindings Type for GitflowConfig Leaks Into Core

**What goes wrong:** `InitGitflowDialog.tsx` imports `GitflowConfig` from `../../bindings`. After Gitflow extraction, this import is in an extension file, but `bindings.ts` is a core file regenerated by Rust. If the Gitflow Rust module is ever extracted to a separate Tauri plugin (future work), the type disappears from bindings and all extension files break.

**Why it happens:** Specta generates types for ALL commands in `collect_commands![]`. The frontend assumes all types in `bindings.ts` are permanent.

**Consequences:** If Gitflow is extracted to a Tauri plugin in the future, the type removal causes compile errors in the Gitflow extension.

**Prevention:**
1. For v1.6: non-issue. Gitflow Rust module stays in `src-tauri/src/gitflow/`.
2. As a future-proofing measure: the Gitflow extension could define its own TypeScript types that mirror the Rust types, with a runtime check that they match. But this is over-engineering for v1.6.
3. Keep the Rust Gitflow module in the main binary for v1.6. Extraction to a Tauri plugin is v2.0 scope.

**Detection:** `grep "from.*bindings" src/extensions/gitflow/` should show import count. More than 5 unique type imports suggests tight coupling.

**Warning signs:** Extension code importing >10 types from `bindings.ts`.

**Phase:** Acknowledge. No action needed for v1.6.

---

## Phase-Specific Warnings

| Phase Topic | Likely Pitfall | Severity | Mitigation |
|-------------|---------------|----------|------------|
| Phase 1: Gitflow extraction | Split-brain state (#1) | CRITICAL | Rust is source of truth, never cache state in extension |
| Phase 1: Gitflow extraction | Circular imports (#2) | CRITICAL | Event-based communication, no direct store imports |
| Phase 1: Gitflow extraction | Sidebar breakage (#3) | CRITICAL | Build sidebar registry FIRST, then extract |
| Phase 1: Gitflow extraction | Orphaned UI on deactivate (#5) | CRITICAL | Add `api.onDispose()` before first extraction |
| Phase 1: Gitflow extraction | _discovery.ts warnings (#11) | MODERATE | Update EXPECTED_TYPES list |
| Phase 2: CC extraction | Store entanglement (#4) | MODERATE | Built-in extensions can import core; don't over-decouple |
| Phase 2: CC extraction | Activation ordering (#12) | MODERATE | Lazy lookup for cross-extension references |
| Phase 3: Hook points | Non-deterministic ordering (#6) | CRITICAL | Priority system, tap-only first, no intercept hooks |
| Phase 3: Context menus | Untyped grab bag (#8) | MODERATE | Typed locations, specific context interfaces |
| Phase 3: Status bar | Collisions (#14) | MINOR | Groups with priority, conflict declarations |
| Phase 3: Hook points | Hook cascade (#15) | MODERATE | Re-entrancy guard, debounce, isInternal flag |
| Phase 4: Viewer extraction | Preview registry timing (#9) | MODERATE | Late registration support, registrationTick |
| Phase 5: Sandbox prep | iframe IPC blocked (#7) | MODERATE | postMessage bridge, NOT direct Tauri access |
| All phases | Shim accumulation (#10) | MODERATE | Deprecation protocol, ESLint rules, removal timeline |

---

## "Looks Done But Isn't" Checklist for Extension Extraction

Use this checklist when reviewing each feature extraction PR:

### Registration completeness
- [ ] Extension's `activate()` registers ALL contribution types the feature previously used (blades, commands, toolbar, sidebar, previews)
- [ ] Extension's `onDeactivate()` cleans up ALL subscriptions created in `activate()`
- [ ] `ExtensionAPI.cleanup()` handles ALL new registry types added in this version
- [ ] `_discovery.ts` EXPECTED_TYPES updated (blade type removed from core list)

### State management
- [ ] Extension does NOT hold duplicate state that Rust owns
- [ ] Extension re-fetches state after operations (no optimistic-only updates)
- [ ] Extension subscribes to relevant store changes for cross-cutting concerns (branch changes, repo changes)
- [ ] No circular imports between extension and core stores (run `madge --circular`)

### Graceful degradation
- [ ] Disabling the extension removes ALL UI contributions (sidebar, toolbar, blades, commands)
- [ ] No console errors after disabling (check for 10 seconds)
- [ ] No layout artifacts (empty sidebar sections, phantom toolbar buttons)
- [ ] Core features (commit, branch, push, pull) work identically with extension enabled or disabled
- [ ] Extension can be re-enabled without app restart
- [ ] Re-enabling restores ALL contributions

### Backward compatibility
- [ ] Any shim files have `@deprecated` annotation with removal version
- [ ] ESLint no-restricted-imports configured for deprecated paths
- [ ] Existing tests pass without modification (or test changes are reviewed separately)
- [ ] Keyboard shortcuts still work after extraction

### Performance
- [ ] Extension activation takes <100ms (measure in production build)
- [ ] Disabling extension doesn't cause visible UI flicker
- [ ] No duplicate event listeners (extension subscribing to same events as core)
- [ ] Bundle size: extension code is properly code-split, not duplicated in main chunk

---

## Sources

- FlowForge codebase analysis: `src/extensions/`, `src-tauri/src/gitflow/`, `src/stores/domain/git-ops/`, `src/blades/`, `src/lib/bladeRegistry.ts`, `src/lib/commandRegistry.ts`, `src/lib/toolbarRegistry.ts`, `src/lib/previewRegistry.ts`
- [Tauri v2 Isolation Pattern](https://v2.tauri.app/concept/inter-process-communication/isolation/) - IPC security model for iframe sandboxing
- [Tauri v2 Security](https://v2.tauri.app/security/) - WebView security constraints
- [Tauri iframe IPC vulnerability advisory](https://github.com/tauri-apps/tauri/security/advisories/GHSA-57fm-592m-34r7) - iframes bypass origin checks
- [Tauri iframe sandbox feature request](https://github.com/tauri-apps/tauri/issues/5755) - network sandboxing limitations
- [VS Code Contribution Points](https://code.visualstudio.com/api/references/contribution-points) - Context menu contribution patterns
- [VS Code Context Menu UX Guidelines](https://code.visualstudio.com/api/ux-guidelines/context-menus) - Menu design best practices
- [VS Code Extension Lifecycle](https://github.com/microsoft/vscode/issues/98732) - Hook ordering and activation lifecycle issues
- [Zustand Slices Pattern](https://zustand.docs.pmnd.rs/guides/slices-pattern) - Slice extraction patterns
- [Monolith to Plugin Architecture](https://medium.com/better-programming/our-journey-to-a-segmented-monolith-with-plug-ins-and-why-9554c570e1f4) - Extraction strategy
- [7 Pitfalls in Application Refactoring](https://vfunction.com/blog/7-pitfalls-to-avoid-in-application-refactoring-projects/) - Incremental extraction best practices
- [AWS Graceful Degradation](https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/rel_mitigate_interaction_failure_graceful_degradation.html) - Making dependencies soft
