# Project Research Summary

**Project:** FlowForge v1.7.0 — Extract Topology, Worktrees, Init Repo into Extensions + Registry Zustand Migration
**Domain:** Desktop Git GUI (Tauri v2 + React) — Extension system maturation phase 2
**Researched:** 2026-02-11
**Confidence:** HIGH (based on codebase analysis and v1.6.0 proven patterns)

## Executive Summary

This milestone continues the v1.6.0 extension extraction work by moving three more core features into toggleable built-in extensions: Topology Graph (commit graph visualization), Worktree Management (Git worktrees UI), and Init Repository (new repo setup wizard). Unlike v1.6.0's extractions which were all "leaf" features, these three have deeper architectural integration. Topology is a navigation process root hardcoded in the XState navigation machine, worktrees are embedded in RepositoryView's sidebar with split dialog state management, and init-repo serves dual contexts (blade + standalone component in WelcomeView). The research reveals that all three can be extracted using the established `registerBuiltIn()` + `coreOverride` pattern, but each requires careful handling of its specific coupling points.

The recommended approach is **incremental extraction with data-layer stability**: keep topology and worktree Zustand slices in the core GitOpsStore (data layer) while moving UI components into extensions. This mirrors the v1.6.0 Gitflow extraction pattern and avoids the complexity of splitting the monolithic GitOpsStore. The registry migration tech debt (commandRegistry and previewRegistry from plain Maps to Zustand stores) can proceed independently using the proven pattern from bladeRegistry. No new dependencies are needed — every capability required already exists in the current stack.

The key risk is that **Topology is structural, not just feature-level**. It underpins the navigation system as one of two process types (`"staging" | "topology"`). Extraction requires navigation-aware fallbacks and careful auditing of cross-cutting references in App.tsx (file watcher auto-refresh), useKeyboardShortcuts.ts (Enter key handler), and GeneralSettings.tsx (default tab). The recommended mitigation is `coreOverride: true` blade registration with a graceful degradation pattern when disabled, keeping the blade type name stable while allowing the extension to be toggled.

## Key Findings

### Recommended Stack

**No new dependencies required.** The entire milestone is achievable with the current dependency set: Zustand 5.0.11 (reactive stores), React 19.2.4 (UI), TypeScript 5.9.3 (type safety), Tauri v2 (git commands), and the existing ExtensionAPI facade. The extension lifecycle system built in v1.6.0 provides everything needed: `registerBlade()` with `coreOverride`, `contributeSidebarPanel()`, `registerCommand()`, `contributeToolbar()`, and automatic cleanup via `ExtensionAPI.cleanup()`.

**Core technologies (unchanged):**
- **Zustand 5.0.11:** State management + registry pattern migration target — the migration from plain Maps (commandRegistry, previewRegistry) to Zustand stores follows the established pattern from bladeRegistry.ts (Zustand + devtools + backward-compatible function exports)
- **React 19.2.4:** UI framework — lazy component loading via React.lazy() defers extension code until blade render
- **ExtensionAPI facade:** Built-in extension registration with `coreOverride: true` preserves blade type names (`"topology-graph"`, not `"ext:topology:topology-graph"`) for navigation compatibility
- **GitOpsStore (composite):** Topology and worktree data slices remain in core — extensions own UI layer only, following Gitflow precedent

**Registry migration targets:**
- **commandRegistry:** Plain `Map<string, Command>` → Zustand store with backward-compat exports (fixes reactivity gap in CommandPalette)
- **previewRegistry:** Plain sorted array → Zustand store with source tracking for extension cleanup

### Expected Features

**Must have (table stakes):**
- **Extension enable/disable persistence** — already free via v1.5.0 persistDisabledExtensions(), zero work needed
- **Topology fallback when disabled** — topology is a navigation process root; fallback must render gracefully (not crash) when extension disabled
- **Worktree sidebar disappears cleanly** — hardcoded RepositoryView section must move to contributeSidebarPanel() with self-contained dialog state
- **Init Repo works from WelcomeView** — dual-context usage (blade + standalone) requires BladeRegistry lookup, not direct import
- **Clean lifecycle (activate/deactivate)** — ExtensionAPI.cleanup() already handles all 6+ registry types atomically
- **coreOverride blade type names** — topology-graph and init-repo types preserved for navigation machine compatibility
- **Command palette entries** — all three features register commands that appear/disappear with extension toggle

**Should have (differentiators):**
- **Process navigation becomes extension-contributed** — defer to v1.8.0; current milestone uses conditional tab hiding (simpler)
- **Worktree status badge** — SidebarPanelConfig already has `badge?: () => number | string | null` support
- **Topology toolbar action** — `contributeToolbar()` for "Refresh Graph" button (proven pattern)
- **Worktree context menu items** — uses existing ContextMenuRegistry (requires new ContextMenuLocation)
- **Git hook integration** — onDidGit("checkout") for auto-refresh (proven in GitHub extension)

**Defer (v2+):**
- **Dynamic process registry** — allowing extensions to register arbitrary process types requires rewriting navigation machine
- **Moving topology/worktree slices to extensions** — extracting data from GitOpsStore requires store plugin system (massive scope increase)
- **Topology SVG virtualization** — performance optimization, not related to extraction
- **Init Repo template marketplace** — feature addition, not extraction concern

### Architecture Approach

The architecture follows a **data-layer stability principle**: topology and worktree Zustand slices stay in GitOpsStore (core), extensions own only the UI registration (blades, sidebar panels, commands, toolbar). This is the same pattern established by Gitflow extraction in v1.6.0 where `gitflow.slice.ts` remained in core while `src/extensions/gitflow/` provided the UI. Built-in extensions import core stores directly (proven by GitHub extension importing useGitOpsStore).

**Major components:**
1. **Topology Extension (`src/extensions/topology/`)** — Registers "topology-graph" blade with `coreOverride: true`, contributes toolbar refresh button, reads from core TopologySlice; navigation machine references stay unchanged because blade type name preserved
2. **Worktree Extension (`src/extensions/worktrees/`)** — Contributes self-contained sidebar panel (WorktreePanel + Create/Delete dialogs), replacing hardcoded RepositoryView section; requires pre-extraction refactoring to move dialog state from parent into panel
3. **Init Repo Extension (`src/extensions/init-repo/`)** — Registers "init-repo" blade, activates during `registerBuiltIn()` (before repo open) for WelcomeView compatibility; WelcomeView uses BladeRegistry lookup not direct import
4. **Registry Migration (commandRegistry, previewRegistry)** — Zustand stores with backward-compatible function exports matching bladeRegistry pattern; enables reactive subscriptions in CommandPalette and source-based cleanup for extensions

**Key patterns to follow:**
- **coreOverride blade registration** — preserves blade type names for navigation compatibility (proven by Conventional Commits, Gitflow, Content Viewers)
- **Sidebar panel contribution** — `contributeSidebarPanel()` with self-contained component (proven by Gitflow)
- **Lazy component imports** — `React.lazy()` with dynamic import in onActivate (proven by all v1.6.0 extensions)
- **Backward-compatible registry exports** — Zustand store internals with imperative function facade (proven by bladeRegistry.ts)

### Critical Pitfalls

1. **Topology is a navigation process root, not just a blade** — The XState navigation machine hardcodes `ProcessType = "staging" | "topology"` and `rootBladeForProcess("topology")` returns `"topology-graph"`. Extraction without `coreOverride: true` breaks the navigation system. Mitigation: preserve blade type name, add fallback blade that renders "Topology extension disabled" message, keep TopologySlice facade in GitOpsStore even when extension disabled.

2. **TopologySlice cross-store access from App.tsx file watcher** — App.tsx lines 130-136 directly call `useTopologyStore.getState().loadGraph()` for auto-refresh on repository-changed events. This runs in core, not in extension. Mitigation: move file watcher subscription into topology extension's onActivate using gitHookBus or Tauri event listener, audit all core files for topology state references (useKeyboardShortcuts.ts line 224-231 also accesses topology store).

3. **Worktree switchToWorktree() calls openRepository() — store entanglement** — WorktreeSlice method `switchToWorktree()` calls `get().openRepository()` from RepositorySlice (cross-slice coupling). Mitigation: either emit gitHookBus event for repository switch, or accept that built-in extensions import core stores directly (established pattern from GitHub extension).

4. **Worktree sidebar hardcoded with dialog state in RepositoryView** — RepositoryView manages `showWorktreeDialog` and `worktreeToDelete` state for dialogs rendered outside the sidebar panel. Extension sidebar panels must be self-contained. Mitigation: pre-extraction refactoring to move CreateWorktreeDialog and DeleteWorktreeDialog INSIDE WorktreePanel before extension work begins.

5. **Init Repo used in two contexts — blade AND standalone WelcomeView** — WelcomeView directly imports InitRepoBlade for first-run experience (before repo open), but extensions activate after repo open. Mitigation: Init Repo must activate during `registerBuiltIn()` (runs on mount) not `activateAll()` (runs after repo open); WelcomeView uses BladeRegistry lookup to render component dynamically.

## Implications for Roadmap

Based on research, suggested phase structure with dependency-driven ordering:

### Phase 1: Infrastructure Prep (Registry Migration)
**Rationale:** Registry migration is a structural prerequisite. commandRegistry must have source-based cleanup before extensions can safely register/unregister commands. Topology auto-refresh and WelcomeView fallback patterns need infrastructure changes before extractions begin.

**Delivers:**
- commandRegistry as Zustand store with backward-compatible exports
- previewRegistry with source tracking and unregisterBySource
- Process tab visibility hook for ProcessNavigation.tsx
- WelcomeView BladeRegistry fallback pattern

**Addresses:**
- v1.6.0 tech debt (commandRegistry plain Map, previewRegistry lacking source tracking)
- Reactivity gap in CommandPalette (currently re-reads commands only on open, misses extension-contributed commands until second open)

**Avoids:**
- Pitfall #6 (registry migration breaking non-reactive consumers)
- Pitfall Int-A (module-load registration timing)
- Pitfall Int-B (Zustand Map equality re-render storm)
- Pitfall Int-C (preview registry lacking cleanup)

**Complexity:** Medium (registry migrations are well-understood; follow bladeRegistry.ts pattern exactly)

### Phase 2: Worktree Extraction (Lowest Risk)
**Rationale:** Worktrees follow the exact Gitflow extraction pattern: hardcoded RepositoryView section → contributeSidebarPanel(). Worktrees have no navigation machine entanglement, limited consumer count (4 files), and proven sidebar panel contribution pattern.

**Delivers:**
- Self-contained WorktreeSidebarPanel (panel + dialogs)
- Extension registration via contributeSidebarPanel() with priority=60
- Worktree commands in command palette
- Optional toolbar action for quick worktree creation

**Uses:**
- ExtensionAPI.contributeSidebarPanel() (proven in Gitflow)
- Sidebar panel `renderAction` for "+" button
- Zustand commandRegistry for "Create Worktree" / "List Worktrees" commands

**Addresses:**
- Worktree Management feature from FEATURES.md (table stakes)

**Avoids:**
- Pitfall #3 (cross-slice openRepository call — accept direct store import or use gitHookBus)
- Pitfall #4 (dialog state split — pre-extraction refactoring required)
- Pitfall #12 (BranchSlice import — accept built-in extension can import core)

**Complexity:** Medium (main work is self-contained panel wrapper)

### Phase 3: Init Repo Extraction (Moderate Risk)
**Rationale:** Init Repo is self-contained (own createBladeStore, no cross-slice dependencies) but has dual-context usage requiring lifecycle nuance. Extract third to validate early-activation pattern before tackling topology.

**Delivers:**
- Init Repo extension with early activation (registerBuiltIn, not activateAll)
- WelcomeView integration via BladeRegistry lookup
- Fallback "Run git init" button when extension disabled
- Command palette entry for "Initialize Repository"

**Uses:**
- coreOverride blade registration (preserves "init-repo" type)
- Early activation path (registerBuiltIn runs on mount, before repo open)
- BladeRegistry dynamic component lookup

**Implements:**
- Init Repo feature from FEATURES.md (table stakes for first-run UX)

**Avoids:**
- Pitfall #5 (dual context blade+WelcomeView — early activation + BladeRegistry lookup)
- Pitfall #10 (react-query cache + pending promises — abort controller)
- Pitfall #13 (createBladeStore lifecycle race — explicit reset in onDeactivate)

**Complexity:** Medium (lifecycle handling more complex than worktrees but fewer coupling points than topology)

### Phase 4: Topology Extraction (Highest Risk)
**Rationale:** Topology is the most entangled feature: navigation process root, 18+ core consumers, file watcher integration, keyboard shortcuts, settings. Must be last to validate all patterns (coreOverride, graceful degradation, process tab hiding) are working before tackling the hardest case.

**Delivers:**
- Topology extension with coreOverride blade registration
- Navigation fallback (process tab hiding when disabled)
- Auto-refresh moved from App.tsx into extension
- Keyboard shortcut integration via extension-contributed command
- Settings default tab conditional availability

**Uses:**
- coreOverride blade registration (preserves "topology-graph" type for navigation machine)
- Process tab visibility hook from Phase 1
- gitHookBus or Tauri event listener for file watcher (replaces App.tsx direct access)
- TopologySlice stays in GitOpsStore (data layer stability)

**Implements:**
- Topology Graph feature from FEATURES.md (table stakes for commit visualization)

**Avoids:**
- Pitfall #1 (navigation process root breakage — coreOverride + fallback blade)
- Pitfall #2 (App.tsx file watcher cross-store — move to extension)
- Pitfall #8 (branchClassifier shared ownership — keep in core as stable API)
- Pitfall #9 (_discovery.ts exhaustiveness — split CORE vs EXTENSION types)
- Pitfall #11 (defaultTab "topology" persistence — fallback to "changes" if missing)

**Complexity:** High (deep navigation integration, many core reference sites)

### Phase 5: Tech Debt Cleanup
**Rationale:** After all extractions, verify completeness and remove scaffolding.

**Delivers:**
- Empty directories removed (src/blades/topology-graph/, src/blades/init-repo/, src/components/worktree/)
- _discovery.ts EXPECTED_TYPES updated (split into CORE and EXTENSION lists)
- Tests for extension enable/disable toggles
- Documentation updated

**Addresses:**
- Final verification of all "Looks Done But Isn't" checklist items from PITFALLS.md

**Complexity:** Low (cleanup, no new features)

### Phase Ordering Rationale

- **Phase 1 first:** Registry migration is a structural dependency for clean command/preview cleanup in all three extractions. Process tab visibility and WelcomeView fallback patterns needed before any extraction.
- **Phase 2 before 3 before 4:** Extraction complexity increases (worktrees = medium, init-repo = medium+, topology = high). Validate patterns on simpler cases before tackling navigation-entangled topology.
- **Worktrees before init-repo:** Sidebar panel contribution is proven (Gitflow). Init Repo's dual-context usage is more nuanced. Worktrees are a good warmup.
- **Init Repo before topology:** Self-contained store with no cross-slice dependencies. Topology has deep navigation integration. Test early-activation pattern on simpler case first.
- **Topology last:** Most dangerous extraction (navigation process root, 18+ core consumers). All fallback patterns must be validated before attempting.

### Research Flags

**Phases needing deeper research during planning:**
- **Phase 4 (Topology extraction):** Navigation machine fallback pattern needs careful design (render blank vs error vs fallback blade). File watcher integration with gitHookBus or Tauri event listener needs pattern validation.
- **Phase 1 (Registry migration):** Verify no circular imports exist before migration (run `madge --circular src/lib/commandRegistry.ts`). Test CommandPalette reactivity after migration.

**Phases with standard patterns (skip research-phase):**
- **Phase 2 (Worktree extraction):** Exact Gitflow sidebar panel pattern, no new research needed.
- **Phase 3 (Init Repo extraction):** coreOverride + early activation patterns already proven, no new research.
- **Phase 5 (Cleanup):** Standard cleanup, no research needed.

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | Direct codebase inspection confirms Zustand 5.0.11, ExtensionAPI patterns, zero new deps needed |
| Features | HIGH | All features defined via codebase analysis (no external domain research needed) |
| Architecture | HIGH | v1.6.0 extraction patterns proven with 4 extensions; data-layer-stability principle validated by Gitflow |
| Pitfalls | HIGH | Navigation entanglement analyzed from navigationMachine.ts, actions.ts; cross-slice coupling verified in worktrees.slice.ts; dual-context usage confirmed in WelcomeView.tsx |

**Overall confidence:** HIGH

### Gaps to Address

**Navigation fallback UX:** When topology extension is disabled, should the "Topology" tab (1) hide completely, (2) grey out and show tooltip, or (3) remain clickable but render "extension disabled" message? Research recommends option (1) for cleanest UX, but this requires ProcessNavigation.tsx understanding which processes are available. Validate during Phase 1.

**Worktree cross-slice coupling resolution:** Two options for `switchToWorktree()` calling `openRepository()`: (A) emit gitHookBus event that core subscribes to, or (B) accept direct store import as established pattern. Research leans toward (B) for simplicity, but gitHookBus may be more architecturally pure. Decide during Phase 2 planning.

**TypeScript path aliases:** Deep relative imports (`../../../../lib/branchClassifier`) are fragile. Consider adding `"@core/*": ["./src/*"]` path alias to tsconfig.json before extractions to stabilize import paths. Pre-Phase 1 task.

**commandRegistry migration timing:** Verify `create()` completes before side-effect imports in `App.tsx` call `registerCommand()`. Zustand create is synchronous but circular import detection needed. Run `madge --circular` as Phase 1 validation step.

## Sources

### Primary (HIGH confidence)
- **FlowForge codebase** (entire milestone based on direct file inspection):
  - `src/machines/navigation/` — Process type hardcoding, rootBladeForProcess
  - `src/stores/domain/git-ops/` — GitOpsStore composition, topology.slice.ts, worktrees.slice.ts
  - `src/components/RepositoryView.tsx` — Hardcoded worktree sidebar
  - `src/components/WelcomeView.tsx` — InitRepoBlade direct import
  - `src/blades/_discovery.ts` — EXPECTED_TYPES exhaustiveness check
  - `src/lib/bladeRegistry.ts` — Zustand registry pattern reference (96 lines of backward-compat exports)
  - `src/lib/commandRegistry.ts` — Plain Map migration target (110 lines)
  - `src/lib/previewRegistry.ts` — Plain array migration target (31 lines)
  - `src/extensions/ExtensionAPI.ts` — coreOverride pattern, cleanup() (449 lines)
  - `src/extensions/gitflow/index.ts` — Reference coreOverride extension (v1.6.0)
  - `src/App.tsx` — Topology auto-refresh (lines 130-136), extension registration
  - `src/hooks/useKeyboardShortcuts.ts` — Topology keyboard handler (lines 224-231)
- **v1.6.0 research artifacts** — Extraction patterns, pitfalls, architecture validated in previous milestone

### Secondary (MEDIUM confidence)
- **Zustand documentation** — create() synchronous initialization, shallow comparison for selectors, slices pattern (official docs)

---
*Research completed: 2026-02-11*
*Ready for roadmap: yes*
*Next step: Roadmap creation via gsd-roadmapper agent*
