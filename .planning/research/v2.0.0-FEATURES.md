# Feature Landscape

**Domain:** Framework extraction and monorepo conversion (Tauri+React+TypeScript desktop app)
**Researched:** 2026-02-15
**Overall confidence:** HIGH

## Table Stakes

Features that are non-negotiable for the extraction to succeed. Missing any of these means the monorepo is unusable or the second app cannot be built.

### Package Structure and Build

| Feature | Why Expected | Complexity | Notes |
|---------|--------------|------------|-------|
| pnpm workspace configuration | Required for monorepo package resolution; all internal packages need `workspace:*` protocol | Low | `pnpm-workspace.yaml` with `packages: ["apps/*", "packages/*"]` |
| TypeScript project references | Required for cross-package type checking and incremental builds | Med | Each package needs its own `tsconfig.json` with `references` and `composite: true` |
| Package `exports` field | Required so consuming apps import from `@flowforge/core` not deep paths | Low | Map `"."`, `"./layout"`, `"./extensions"` etc. to built output |
| Peer dependency declarations | React, Zustand, XState must be peerDependencies in framework packages to avoid duplicate instances | Med | **Critical:** Zustand stores break with duplicate React -- see Pitfalls |
| Shared Biome config package | Consistent linting across all packages and apps | Low | `packages/config-biome` with shared `biome.json` |
| Shared TypeScript config package | Base `tsconfig.json` extended by all packages | Low | `packages/config-ts` with `tsconfig.base.json`, `tsconfig.react.json` |

### Core Framework Package (`@flowforge/core`)

| Feature | Why Expected | Complexity | Notes |
|---------|--------------|------------|-------|
| Blade navigation system extraction | The blade stack FSM + registry is the central UI paradigm; must work standalone | High | `navigationMachine.ts`, `bladeRegistry.ts`, `BladeRenderer.tsx`, `BladeContainer.tsx`, etc. -- ~15 files tightly coupled |
| Navigation guard system | Dirty-blade confirmation dialogs are integral to blade nav; cannot be separated | Med | `NavigationGuardDialog.tsx`, `guards.ts`, `confirmingDiscard` state in FSM |
| Workflow registry extraction | Apps define their own workflows (staging, topology); framework provides the registration mechanism | Low | `workflowRegistry.ts` is already clean -- just needs the `TypedBlade` type decoupled from FlowForge-specific blade types |
| Generic `createRegistry<T>()` factory | 6+ registries (toolbar, context menu, sidebar, status bar, machine, blade) all use this pattern | Low | Already framework code at `framework/stores/createRegistry.ts` -- clean extraction |
| `createBladeStore()` factory | Per-blade isolated stores are a core framework capability | Low | Already in `framework/stores/createBladeStore.ts` |
| Toast notification system | Used by nav machine, extension host, and throughout the app | Low | `framework/stores/toast.ts` -- self-contained |
| Store reset registry | `resetAllStores()` + `registerStoreForReset()` needed for app lifecycle (e.g., repo switches) | Low | `framework/stores/registry.ts` -- already isolated |
| Command palette | Core framework feature: fuzzy search, keyboard shortcut registration, command execution | Med | `framework/command-palette/` -- 6 files, depends on `commandRegistry` which is framework-level |
| Layout presets | Resizable panel configuration (sidebar + blade strip layout) | Low | `layoutPresets.ts`, `ResizablePanelLayout.tsx`, `SplitPaneLayout.tsx` |
| Theme system extraction | Catppuccin theming with dark/light mode toggle must be reusable | Low | `framework/theme/` -- 2 files, already isolated |

### Extension Platform Package (`@flowforge/extensions`)

| Feature | Why Expected | Complexity | Notes |
|---------|--------------|------------|-------|
| ExtensionHost store extraction | The Zustand store managing extension lifecycle (discover/activate/deactivate) | High | Currently depends on `@tauri-apps/api/core` (`convertFileSrc`) and `@tauri-apps/plugin-store` -- **must be abstracted** |
| ExtensionAPI facade extraction | The per-extension API surface (registerBlade, registerCommand, contributeToolbar, etc.) | Med | Well-structured class but references 6 registry stores -- needs all registries available |
| Dependency injection for platform specifics | `configureExtensionHost()` pattern already exists for `discoverExtensions`; needs expanding to cover persistence and asset loading | Med | Currently only DI for discovery; persistence (`getStore`) and `convertFileSrc` are hard-coded Tauri deps |
| Extension manifest system | `manifest.ts` types + validation for extension metadata | Low | Pure types, no runtime deps |
| Built-in extension registration | `registerBuiltIn()` flow for bundled extensions that skip filesystem discovery | Low | Already works; just needs to move with ExtensionHost |
| Extension event bus | Inter-extension pub/sub communication | Low | `eventBus.ts` -- self-contained, no external deps |
| Operation bus (git hooks) | Pre/post operation hooks for extensions to intercept domain operations | Low | `operationBus.ts` -- generic pattern, not Git-specific despite naming |
| Extension settings (per-extension KV store) | Each extension gets namespaced persistent settings | Med | Currently depends on `@tauri-apps/plugin-store` via `getStore()` -- needs persistence adapter |

### Persistence Abstraction Layer

| Feature | Why Expected | Complexity | Notes |
|---------|--------------|------------|-------|
| Storage adapter interface | ExtensionHost, ExtensionSettings, and disabled-extensions persistence all depend on Tauri's plugin-store; second app may not use Tauri | Med | Define `StorageAdapter { get<T>(key): Promise<T>, set(key, value): Promise<void>, save(): Promise<void> }` |
| Tauri storage adapter (default) | Wraps existing `@tauri-apps/plugin-store` as one implementation | Low | Mostly extracting existing `persistence/tauri.ts` |
| LocalStorage adapter (fallback) | For web-based or Electron apps that don't have Tauri | Low | Simple implementation for testing and non-Tauri targets |

### Blade Type System Generalization

| Feature | Why Expected | Complexity | Notes |
|---------|--------------|------------|-------|
| Generic blade type definitions | `BladeType`, `TypedBlade`, `BladePropsMap` must be extensible per-app, not hard-coded to FlowForge's 22+ types | High | Currently uses TypeScript module augmentation (`declare module`) -- pattern needs to survive package boundaries |
| Module augmentation bridge | Apps declare their own blade types that merge into the framework's `BladePropsMap` interface | Med | Already using this pattern in `framework/layout/bladeTypes.ts` + `core/stores/bladeTypes.ts` -- but cross-package augmentation needs careful `tsconfig` setup |

### App Skeleton / Template

| Feature | Why Expected | Complexity | Notes |
|---------|--------------|------------|-------|
| Minimal working app that imports framework | Proves extraction works; serves as reference for building new apps | Med | Needs: App shell, NavigationProvider, at least 1 workflow, 1 blade type, extension host init |
| App bootstrap function | Single entry point like `createFlowForgeApp({ workflows, extensions, storage, theme })` to wire everything | Med | Reduces boilerplate; FlowForge's `App.tsx` is 400+ lines of wiring |
| Default layout shell component | Header + sidebar + blade strip + status bar -- the "chrome" around content | Med | Currently in `core/components/` -- needs to be extracted as a composable shell |

## Differentiators

Features that improve the framework quality but are not strictly required for extraction to work.

| Feature | Value Proposition | Complexity | Notes |
|---------|-------------------|------------|-------|
| `create-flowforge-app` CLI scaffolding | Instantly scaffold new apps using the framework; similar to `create-react-app` | Med | Not needed for initial extraction but valuable once framework stabilizes |
| Framework DevTools panel | Inspect blade stack, registry contents, extension states, FSM visualization in dev mode | High | XState inspector integration exists; extending to all registries adds significant DX value |
| Extension sandbox (Web Worker isolation) | Untrusted extensions run in sandboxed Workers with message-passing API | High | Prototype exists in `extensions/sandbox/` -- significant work to make production-ready |
| Hot module replacement for extensions | Extensions can be reloaded without full app restart during development | Med | Would accelerate extension development; requires careful cleanup/re-registration |
| Type-safe extension contribution points | Extensions declare contributions in manifest; framework validates at registration time | Med | Currently contributions are validated at runtime via `ExtensionAPI` methods; schema validation would catch errors earlier |
| Theming token system (beyond Catppuccin) | Allow apps to define their own theme tokens while keeping the framework's theme infrastructure | Low | Currently hard-coded to Catppuccin; abstracting to CSS custom properties with a Catppuccin preset would make it generic |
| Automated dependency graph visualization | Show which packages depend on what; detect circular deps early | Low | `madge` or `nx graph` integration |
| Turborepo build caching | Skip rebuilding unchanged packages across the monorepo | Med | Turborepo's `turbo.json` pipeline config; significant CI speedup |
| Changeset-based versioning | Track changes per-package for coordinated internal versioning | Low | `@changesets/cli` -- overkill for internal-only packages initially but useful as complexity grows |

## Anti-Features

Features to explicitly NOT build during extraction. These add complexity without proportional value.

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| npm publishing pipeline | Internal monorepo only; publishing adds semver management, changelogs, registry auth complexity | Use `workspace:*` protocol for all inter-package references |
| Runtime plugin marketplace / download | FlowForge's extension system supports filesystem discovery but a marketplace is a product, not a framework feature | Keep `discoverExtensions` DI; marketplace is app-level concern |
| Framework-level routing (react-router integration) | Blade navigation IS the routing; mixing URL-based routing creates confusion about who owns navigation state | Keep `NavigationProvider` + XState FSM as sole navigation mechanism |
| Multi-framework support (Vue, Svelte, etc.) | Framework is deeply React-specific (hooks, JSX components, Zustand); abstracting gains nothing | Stay React-only; document this as a conscious constraint |
| Abstracting away XState | The navigation FSM is the framework's most complex and valuable piece; replacing it with simpler state management loses guard logic, dirty-blade handling, and formal verifiability | Keep XState as a hard dependency; document FSM design for consumers |
| Server-side rendering support | Desktop app framework; SSR adds complexity with no benefit | Mark framework as client-only in docs |
| Backwards compatibility with pre-monorepo imports | Maintaining `@/framework/...` path aliases alongside new package imports creates confusion | Clean break: update all imports to `@flowforge/core`, `@flowforge/extensions` |
| Extracting domain stores (GitOps, Preferences, UIState) | These are FlowForge-specific, not framework; extracting them creates false abstraction | Keep in `apps/flowforge`; framework provides `createBladeStore()` and `createRegistry()` factories |
| Over-abstracting the toolbar | `ToolbarGroup` type currently has 4 values; making it fully dynamic adds complexity without demand | Keep current union type; apps can extend via TypeScript module augmentation if needed |

## Feature Dependencies

```
pnpm workspace config
  -> TypeScript project references
    -> Package exports field
      -> Peer dependency declarations (React, Zustand, XState)
        -> Core framework package (@flowforge/core)
          -> Blade navigation system
            -> Workflow registry
            -> Navigation guard system
            -> Blade type system generalization
              -> Module augmentation bridge
          -> Generic createRegistry<T>()
          -> Command palette
          -> Layout presets
          -> Toast notifications
          -> Store reset registry
          -> Theme system
        -> Extension platform package (@flowforge/extensions)
          -> ExtensionHost (depends on core registries)
          -> ExtensionAPI facade (depends on all registries)
          -> Persistence abstraction layer
            -> Storage adapter interface
            -> Tauri storage adapter
          -> Extension manifest system
          -> Extension event bus
          -> Operation bus
        -> App skeleton
          -> Minimal working app (depends on core + extensions)
          -> App bootstrap function
          -> Default layout shell
```

Key dependency insight: The extension platform depends on the core framework because `ExtensionAPI` registers into blade, command, toolbar, context menu, sidebar, status bar, and machine registries -- all of which live in core. This means `@flowforge/extensions` has `@flowforge/core` as a dependency, not the other way around.

## MVP Recommendation

**Phase 1 -- Monorepo scaffolding (foundation)**
1. pnpm workspace configuration
2. Shared config packages (TypeScript, Biome)
3. TypeScript project references
4. Peer dependency declarations

**Phase 2 -- Core framework extraction (`@flowforge/core`)**
1. `createRegistry<T>()` factory (foundation for everything)
2. Toast notification system
3. Store reset registry
4. Blade type system with module augmentation
5. Blade navigation FSM + registry + renderer
6. Workflow registry
7. Command palette
8. Layout presets + shell components
9. Theme system

**Phase 3 -- Extension platform extraction (`@flowforge/extensions`)**
1. Persistence abstraction layer (storage adapter interface)
2. Extension manifest types
3. Extension event bus + operation bus
4. ExtensionAPI facade
5. ExtensionHost store
6. Built-in extension registration flow

**Phase 4 -- App skeleton + validation**
1. Minimal second app importing `@flowforge/core` + `@flowforge/extensions`
2. App bootstrap function
3. Verify all 15 FlowForge extensions still work with extracted packages
4. Update FlowForge itself to import from packages instead of relative paths

**Defer:**
- `create-flowforge-app` CLI: Wait until framework API stabilizes after real usage
- Extension sandbox: Prototype exists but production isolation is a separate milestone
- Framework DevTools: Nice-to-have once extraction is complete
- Turborepo: Add when build times become a pain point (monorepo starts small)

## Sources

- FlowForge codebase analysis (direct code review, HIGH confidence)
- [Zustand external package discussion](https://github.com/pmndrs/zustand/discussions/2870) -- critical gotcha about duplicate React instances in monorepos
- [Monorepo tools overview](https://monorepo.tools/) -- pnpm workspaces recommended
- [Nhost pnpm+Turborepo configuration](https://nhost.io/blog/how-we-configured-pnpm-and-turborepo-for-our-monorepo)
- [Nx blog: Managing TS packages in monorepos](https://nx.dev/blog/managing-ts-packages-in-monorepos)
- [Plugin architecture design patterns](https://www.devleader.ca/2023/09/07/plugin-architecture-design-pattern-a-beginners-guide-to-modularity/)
- [Backstage frontend system architecture](https://backstage.io/docs/frontend-system/architecture/naming-patterns/) -- naming patterns for plugin systems
- [Robin Wieruch: JavaScript Monorepos](https://www.robinwieruch.de/javascript-monorepos/) -- workspace protocol and build ordering
