# Architecture Patterns

**Domain:** Extension extraction for Topology Graph, Worktree Management, and Init Repo in Tauri v2 + React Git GUI
**Researched:** 2026-02-11
**Overall confidence:** HIGH

---

## Executive Summary

This milestone extracts three more core features -- Topology Graph, Worktree Management, and Init Repo -- into toggleable built-in extensions using the same `registerBuiltIn()` + `coreOverride` pattern established in v1.6.0. The architecture is well-understood because v1.6.0 already extracted four features (Gitflow, CC, Content Viewers, GitHub) using this exact approach. The challenge here is that **Topology is the default root blade and deeply entangled with both the navigation state machine and the GitOps domain store**, making it the most architecturally sensitive extraction. Worktrees live as a hardcoded sidebar section in `RepositoryView.tsx` (similar to how Gitflow was before v1.6.0). Init Repo is the most self-contained -- it's already a blade with its own store and only surfaces in `WelcomeView.tsx`.

The key architectural decision is: **keep topology and worktree data in the GitOps store slices** but route UI rendering through the extension system. Extensions register blades and sidebar panels via the ExtensionAPI; data access remains through the existing store. This follows the precedent set by the Gitflow extraction where `gitflow.slice.ts` stayed in GitOpsStore while the UI moved to `src/extensions/gitflow/`.

---

## Current Architecture (As-Is)

### Topology Graph Integration Points

```
Navigation Machine (src/machines/navigation/)
  actions.ts:           rootBladeForProcess("topology") returns { type: "topology-graph" }
  types.ts:             ProcessType = "staging" | "topology"
  navigationMachine.ts: SWITCH_PROCESS action uses rootBladeForProcess()

Blade System (src/blades/topology-graph/)
  registration.ts:      Direct registerBlade() call (not through ExtensionAPI)
  TopologyRootBlade.tsx: Contains sub-navigation (Graph | History tabs)
                         Renders <TopologyPanel /> and <CommitHistory />
                         Uses useBladeNavigation() for commit details drill-down
  components/:
    TopologyPanel.tsx:   SVG+DOM hybrid graph renderer
    CommitBadge.tsx:     Commit node labels
    LaneHeader.tsx:      Branch lane column headers
    LaneBackground.tsx:  Lane guide lines
    layoutUtils.ts:      Layout computation (node positioning, edge paths)
    TopologyEmptyState.tsx: Empty state when no commits

Data Store (src/stores/domain/git-ops/)
  topology.slice.ts:    TopologySlice with nodes, edges, loadGraph(), loadMore(), selectCommit()
  index.ts:             topology.slice merged into monolithic GitOpsStore

Hooks
  useCommitGraph.ts:    Wraps TopologySlice, triggers loadGraph() on repoStatus change

App.tsx (line 132-136): Auto-refreshes topology on "repository-changed" events
  topologyState.loadGraph() called directly from file watcher listener

BladePropsMap (src/stores/bladeTypes.ts):
  "topology-graph": Record<string, never>  -- typed in the core props map

_discovery.ts: EXPECTED_TYPES includes "topology-graph" in exhaustiveness check
```

**Key entanglement:** The navigation state machine hardcodes `"topology-graph"` as the root blade for the topology process. If the extension is disabled, the topology process has no root blade to render.

### Worktree Management Integration Points

```
Sidebar (src/components/)
  RepositoryView.tsx:       Hardcoded <details> section with:
                            - <WorktreePanel onOpenDeleteDialog={...} />
                            - <CreateWorktreeDialog open={...} onOpenChange={...} />
                            - <DeleteWorktreeDialog worktreeName={...} onOpenChange={...} />
                            - State: showWorktreeDialog, worktreeToDelete

Components (src/components/worktree/)
  WorktreePanel.tsx:        Lists worktrees from GitOps store, handles selection/actions
  WorktreeItem.tsx:         Single worktree row with status, actions (switch, open, delete)
  CreateWorktreeDialog.tsx: Form dialog using GitOps store + branch store
  DeleteWorktreeDialog.tsx: Confirmation dialog using GitOps store

Data Store (src/stores/domain/git-ops/)
  worktrees.slice.ts:       WorktreeSlice with loadWorktrees(), createWorktree(), deleteWorktree()
  index.ts:                  worktrees.slice merged into monolithic GitOpsStore

Command Registry (src/lib/commandRegistry.ts):
  CoreCommandCategory includes "Worktrees"

BladePropsMap: No worktree-specific blade type exists (worktrees live in sidebar only)
```

**Key entanglement:** Worktrees are rendered as a hardcoded `<details>` section in `RepositoryView.tsx`, identical to how Gitflow was before v1.6.0 extraction. The extraction pattern is proven: move to `contributeSidebarPanel()`.

### Init Repo Integration Points

```
Blade System (src/blades/init-repo/)
  registration.ts:       Direct registerBlade() call (not through ExtensionAPI)
  InitRepoBlade.tsx:     Main blade with SplitPaneLayout, hydrates store from directoryPath prop
  store.ts:              createBladeStore("init-repo") -- self-contained Zustand store
  components/:
    InitRepoForm.tsx:    Multi-step form (gitignore, readme, commit settings)
    InitRepoPreview.tsx: Live preview of generated files
    CategoryFilter.tsx:  Gitignore template category filtering
    TemplatePicker.tsx:  Gitignore template browser
    TemplateChips.tsx:   Selected template pills
    ProjectDetectionBanner.tsx: Auto-detected project type banner

WelcomeView (src/components/WelcomeView.tsx):
  Lines 11, 23, 117-126: Imports and renders <InitRepoBlade> directly
  Conditional: showInitRepo && pendingInitPath shows the blade inline
  Line 235-239: "Setup" button triggers setShowInitRepo(true)

Hooks
  useGitignoreTemplates.ts: useProjectDetection(), useGitignoreTemplateList()

Data Store:
  init-repo/store.ts:       Self-contained blade store (NOT in GitOpsStore)

BladePropsMap: "init-repo": { directoryPath: string }
_discovery.ts: EXPECTED_TYPES includes "init-repo"
```

**Key entanglement:** `WelcomeView.tsx` directly imports and renders `InitRepoBlade` as a child component (not through blade navigation). This is a unique pattern -- the blade is used both as a navigable blade AND as an inline component in the welcome flow.

---

## Recommended Architecture (To-Be)

### Design Principle: Data Stays, UI Moves

The topology and worktree data slices (`topology.slice.ts`, `worktrees.slice.ts`) remain in the GitOpsStore. Extensions own only the **UI layer** -- blade registration, sidebar panel contribution, toolbar/command registration. This follows the Gitflow precedent where `gitflow.slice.ts` stayed in GitOpsStore while `src/extensions/gitflow/` owns the UI.

**Rationale:**
1. Data slices have cross-cutting concerns (topology auto-refresh in App.tsx, worktree switch triggers `openRepository()`)
2. Extracting data slices would require a store plugin/injection system that adds complexity without clear benefit
3. Extensions already access stores freely (Gitflow extension imports `useGitOpsStore`)

### Component Boundaries

| Component | Responsibility | Communicates With |
|-----------|---------------|-------------------|
| `src/extensions/topology/` | Registers "topology-graph" blade, toolbar action, commands | BladeRegistry, CommandRegistry, ToolbarRegistry |
| `src/extensions/topology/components/` | TopologyRootBlade, TopologyPanel, CommitBadge, etc. | GitOpsStore (topology slice), useCommitGraph hook |
| `src/extensions/worktrees/` | Registers sidebar panel, toolbar action, commands | SidebarPanelRegistry, CommandRegistry, ToolbarRegistry |
| `src/extensions/worktrees/components/` | WorktreePanel, WorktreeItem, Create/Delete dialogs | GitOpsStore (worktree slice, branch slice) |
| `src/extensions/init-repo/` | Registers "init-repo" blade, commands | BladeRegistry, CommandRegistry |
| `src/extensions/init-repo/components/` | InitRepoBlade, InitRepoForm, InitRepoPreview | Self-contained store, bindings (Rust commands) |
| `src/machines/navigation/actions.ts` | Provides fallback root blade when topology extension disabled | BladeRegistry |
| `src/components/RepositoryView.tsx` | Removes hardcoded worktree section (replaced by DynamicSidebarPanels) | SidebarPanelRegistry |
| `src/components/WelcomeView.tsx` | Uses fallback for init-repo when extension disabled | BladeRegistry |
| `src/blades/_discovery.ts` | Removes topology-graph and init-repo from EXPECTED_TYPES | N/A |
| `src/stores/bladeTypes.ts` | Keeps all types (coreOverride means types are still "core") | N/A |

### Data Flow: Extension Activation

```
App.tsx: registerBuiltIn({ id: "topology", ... })
  -> ExtensionHost creates ExtensionAPI("topology")
  -> topology/index.ts: onActivate(api) called
     -> api.registerBlade({ type: "topology-graph", coreOverride: true, ... })
     -> api.contributeToolbar({ id: "refresh-graph", ... })
     -> api.registerCommand({ id: "open-topology", ... })
  -> BladeRegistry now has "topology-graph" registration
  -> Navigation machine's rootBladeForProcess("topology") still works

App.tsx: registerBuiltIn({ id: "worktrees", ... })
  -> ExtensionHost creates ExtensionAPI("worktrees")
  -> worktrees/index.ts: onActivate(api) called
     -> api.contributeSidebarPanel({ id: "worktree-panel", ... })
     -> api.registerCommand({ id: "create-worktree", ... })
     -> api.registerCommand({ id: "list-worktrees", ... })
  -> SidebarPanelRegistry renders WorktreePanel in sidebar
  -> RepositoryView.tsx no longer has hardcoded worktree section

App.tsx: registerBuiltIn({ id: "init-repo", ... })
  -> ExtensionHost creates ExtensionAPI("init-repo")
  -> init-repo/index.ts: onActivate(api) called
     -> api.registerBlade({ type: "init-repo", coreOverride: true, ... })
     -> api.registerCommand({ id: "init-repo", ... })
  -> BladeRegistry now has "init-repo" registration
```

### Data Flow: Extension Deactivation (Graceful Degradation)

```
Topology disabled:
  -> "topology-graph" blade unregistered from BladeRegistry
  -> Navigation machine's rootBladeForProcess("topology") returns type "topology-graph"
  -> BladeRenderer finds no registration -> renders fallback "Extension disabled" message
  -> topology.slice data stays in GitOpsStore but is inert (no UI consumes it)
  -> App.tsx auto-refresh still calls loadGraph() harmlessly (data loads, nobody renders)

Worktrees disabled:
  -> SidebarPanelRegistry removes worktree panel
  -> RepositoryView sidebar no longer shows worktrees section
  -> worktrees.slice data stays in GitOpsStore (inert)
  -> Users lose worktree management UI but git worktrees still exist on disk

Init Repo disabled:
  -> "init-repo" blade unregistered from BladeRegistry
  -> WelcomeView: init button hidden or shows fallback message
  -> Users can still use `git init` from terminal
```

---

## Extraction Details Per Feature

### 1. Topology Graph Extension

**New directory:** `src/extensions/topology/`

```
src/extensions/topology/
  index.ts                    -- onActivate/onDeactivate (entry point)
  blades/
    TopologyRootBlade.tsx     -- MOVED from src/blades/topology-graph/
  components/
    TopologyPanel.tsx         -- MOVED from src/blades/topology-graph/components/
    CommitBadge.tsx           -- MOVED
    LaneHeader.tsx            -- MOVED
    LaneBackground.tsx        -- MOVED
    layoutUtils.ts            -- MOVED
    TopologyEmptyState.tsx    -- MOVED
```

**index.ts pattern:**
```typescript
import { lazy } from "react";
import { Network, RefreshCw } from "lucide-react";
import type { ExtensionAPI } from "../ExtensionAPI";
import { openBlade } from "../../lib/bladeOpener";
import { useGitOpsStore } from "../../stores/domain/git-ops";

export async function onActivate(api: ExtensionAPI): Promise<void> {
  const TopologyRootBlade = lazy(() =>
    import("./blades/TopologyRootBlade").then((m) => ({
      default: m.TopologyRootBlade,
    }))
  );

  api.registerBlade({
    type: "topology-graph",
    title: "Topology",
    component: TopologyRootBlade,
    lazy: true,
    coreOverride: true,
    wrapInPanel: false,
    showBack: false,
  });

  api.contributeToolbar({
    id: "refresh-topology",
    label: "Refresh Graph",
    icon: RefreshCw,
    group: "views",
    priority: 20,
    when: () => !!useGitOpsStore.getState().repoStatus,
    execute: () => useGitOpsStore.getState().loadGraph(),
  });

  api.registerCommand({
    id: "open-topology",
    title: "Open Topology Graph",
    description: "View the commit graph visualization",
    category: "Navigation",
    icon: Network,
    action: () => openBlade("topology-graph", {} as Record<string, never>),
    enabled: () => !!useGitOpsStore.getState().repoStatus,
  });
}

export function onDeactivate(): void {
  // api.cleanup() handles all unregistrations
}
```

**Files to modify:**

| File | Change | Why |
|------|--------|-----|
| `src/blades/topology-graph/` | DELETE entire directory | Components move to extension |
| `src/blades/_discovery.ts` | Remove "topology-graph" from EXPECTED_TYPES | No longer a core registration |
| `src/machines/navigation/actions.ts` | Add BladeRegistry check for graceful fallback | Handle disabled extension |
| `src/App.tsx` | Add `registerBuiltIn({ id: "topology", ... })` | Register as built-in extension |
| `src/App.tsx` | Keep topology auto-refresh as-is | Data layer stays in core |
| `src/hooks/useCommitGraph.ts` | KEEP in src/hooks/ (shared hook) | May be used by other features |

**Critical architecture decision -- Navigation fallback:**

The `rootBladeForProcess("topology")` in `actions.ts` hardcodes `"topology-graph"`. When the extension is disabled, the blade type is unregistered but the navigation machine still tries to render it. Two options:

**Option A (RECOMMENDED): Keep blade type reference, let BladeRenderer handle missing registration.**
The `BladeContainer` should already handle unregistered blade types with a fallback UI. If it does not, add a small fallback component that says "This feature is provided by the Topology extension, which is currently disabled." This is the simplest approach and matches how other extensions degrade.

**Option B: Make rootBladeForProcess() dynamic.** Query BladeRegistry and fall back to a generic "no-topology" blade. This adds complexity to the navigation machine for minimal benefit.

### 2. Worktree Management Extension

**New directory:** `src/extensions/worktrees/`

```
src/extensions/worktrees/
  index.ts                      -- onActivate/onDeactivate (entry point)
  components/
    WorktreePanel.tsx            -- MOVED from src/components/worktree/WorktreePanel.tsx
    WorktreeItem.tsx             -- MOVED from src/components/worktree/WorktreeItem.tsx
    CreateWorktreeDialog.tsx     -- MOVED from src/components/worktree/CreateWorktreeDialog.tsx
    DeleteWorktreeDialog.tsx     -- MOVED from src/components/worktree/DeleteWorktreeDialog.tsx
```

**index.ts pattern:**
```typescript
import { FolderGit2, Plus } from "lucide-react";
import type { ExtensionAPI } from "../ExtensionAPI";
import { useGitOpsStore } from "../../stores/domain/git-ops";
import { WorktreeSidebarPanel } from "./components/WorktreeSidebarPanel";

export async function onActivate(api: ExtensionAPI): Promise<void> {
  // Contribute sidebar panel (replaces hardcoded RepositoryView section)
  api.contributeSidebarPanel({
    id: "worktree-panel",
    title: "Worktrees",
    icon: FolderGit2,
    component: WorktreeSidebarPanel,
    priority: 60,  // Below core panels (branches=90, stash=80, tags=70)
    defaultOpen: false,
    badge: () => {
      const count = useGitOpsStore.getState().worktreeList.length;
      return count > 1 ? count : null;  // Only show badge if >1 worktree
    },
  });

  api.registerCommand({
    id: "create-worktree",
    title: "Create Worktree",
    description: "Create a new Git worktree",
    category: "Worktrees",
    icon: Plus,
    action: () => {
      document.dispatchEvent(new CustomEvent("create-worktree-dialog"));
    },
    enabled: () => !!useGitOpsStore.getState().repoStatus,
  });

  api.registerCommand({
    id: "list-worktrees",
    title: "List Worktrees",
    category: "Worktrees",
    icon: FolderGit2,
    action: () => useGitOpsStore.getState().loadWorktrees(),
    enabled: () => !!useGitOpsStore.getState().repoStatus,
  });
}

export function onDeactivate(): void {
  // api.cleanup() handles all unregistrations
}
```

**New wrapper component needed:** `WorktreeSidebarPanel.tsx`

The current worktree UI is split across `RepositoryView.tsx` (dialogs, state) and `WorktreePanel.tsx` (list). The extension needs a self-contained sidebar panel component that owns its own dialog state:

```typescript
// src/extensions/worktrees/components/WorktreeSidebarPanel.tsx
export function WorktreeSidebarPanel() {
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [worktreeToDelete, setWorktreeToDelete] = useState<string | null>(null);

  // Listen for command palette trigger
  useEffect(() => {
    const handler = () => setShowCreateDialog(true);
    document.addEventListener("create-worktree-dialog", handler);
    return () => document.removeEventListener("create-worktree-dialog", handler);
  }, []);

  return (
    <>
      <WorktreePanel onOpenDeleteDialog={(name) => setWorktreeToDelete(name)} />
      <CreateWorktreeDialog
        open={showCreateDialog}
        onOpenChange={setShowCreateDialog}
      />
      <DeleteWorktreeDialog
        worktreeName={worktreeToDelete}
        onOpenChange={(open) => !open && setWorktreeToDelete(null)}
      />
    </>
  );
}
```

**Files to modify:**

| File | Change | Why |
|------|--------|-----|
| `src/components/worktree/` | DELETE entire directory | Components move to extension |
| `src/components/RepositoryView.tsx` | Remove hardcoded worktree `<details>` section, remove dialog state/imports | Worktrees now via SidebarPanelRegistry |
| `src/App.tsx` | Add `registerBuiltIn({ id: "worktrees", ... })` | Register as built-in extension |

**Important note about sidebar panel priority:**

The existing hardcoded sidebar order in `RepositoryView.tsx` is: Branches, Stashes, Tags, Worktrees, then dynamic extension panels. After extraction, Worktrees becomes a dynamic panel. The Gitflow extension already uses `priority: 65`. The sidebar panel registry sorts by priority descending, so:

- Branches, Stashes, Tags: hardcoded (stay in RepositoryView, priority 90+)
- Gitflow: `priority: 65` (dynamic)
- Worktrees: `priority: 60` (dynamic, renders below Gitflow)

This maintains the same visual order. The `renderAction` prop can provide the "+" button for creating worktrees.

### 3. Init Repo Extension

**New directory:** `src/extensions/init-repo/`

```
src/extensions/init-repo/
  index.ts                        -- onActivate/onDeactivate (entry point)
  blades/
    InitRepoBlade.tsx             -- MOVED from src/blades/init-repo/InitRepoBlade.tsx
  components/
    InitRepoForm.tsx              -- MOVED from src/blades/init-repo/components/
    InitRepoPreview.tsx           -- MOVED
    CategoryFilter.tsx            -- MOVED
    TemplatePicker.tsx            -- MOVED
    TemplateChips.tsx             -- MOVED
    ProjectDetectionBanner.tsx    -- MOVED
  store.ts                        -- MOVED from src/blades/init-repo/store.ts
```

**index.ts pattern:**
```typescript
import { lazy } from "react";
import { FolderPlus } from "lucide-react";
import type { ExtensionAPI } from "../ExtensionAPI";

export async function onActivate(api: ExtensionAPI): Promise<void> {
  const InitRepoBlade = lazy(() =>
    import("./blades/InitRepoBlade").then((m) => ({
      default: m.InitRepoBlade,
    }))
  );

  api.registerBlade({
    type: "init-repo",
    title: "Initialize Repository",
    component: InitRepoBlade,
    lazy: true,
    singleton: true,
    coreOverride: true,
  });

  api.registerCommand({
    id: "init-repo",
    title: "Initialize Repository",
    description: "Set up a new Git repository with gitignore and README",
    category: "Repository",
    icon: FolderPlus,
    action: () => {
      // Emit event that WelcomeView can listen for
      document.dispatchEvent(new CustomEvent("open-init-repo"));
    },
  });
}

export function onDeactivate(): void {
  // api.cleanup() handles all unregistrations
}
```

**Files to modify:**

| File | Change | Why |
|------|--------|-----|
| `src/blades/init-repo/` | DELETE entire directory | Components move to extension |
| `src/blades/_discovery.ts` | Remove "init-repo" from EXPECTED_TYPES | No longer a core registration |
| `src/components/WelcomeView.tsx` | Add fallback for missing init-repo blade | Graceful degradation |
| `src/App.tsx` | Add `registerBuiltIn({ id: "init-repo", ... })` | Register as built-in extension |

**WelcomeView integration challenge:**

`WelcomeView.tsx` renders `InitRepoBlade` directly as a child component (not through blade navigation). When the init-repo extension is disabled, this import will fail or the component won't be registered. Two options:

**Option A (RECOMMENDED): Dynamic import with BladeRegistry lookup.**
Instead of a static import, `WelcomeView` looks up the "init-repo" blade registration from BladeRegistry and renders it dynamically. If not found, show a simplified "Run `git init` in your terminal" fallback.

```typescript
// In WelcomeView.tsx
const initRepoBlade = useBladeRegistry(s => s.blades.get("init-repo"));
// ...
{showInitRepo && pendingInitPath && initRepoBlade ? (
  <initRepoBlade.component directoryPath={pendingInitPath} onCancel={...} onComplete={...} />
) : showInitRepo && pendingInitPath ? (
  <FallbackInitMessage />
) : null}
```

**Option B: Keep InitRepoBlade import in WelcomeView.** This creates a hard dependency that defeats the purpose of extraction. Not recommended.

---

## Patterns to Follow

### Pattern 1: coreOverride Blade Registration

**What:** Built-in extensions register blade types using the original core type name (e.g., `"topology-graph"`) with `coreOverride: true`, bypassing the `ext:{id}:{type}` namespace prefix.

**When:** Always for built-in extensions that replace previously-core blades.

**Why:** Navigation machine, toolbar commands, and other consumers reference blade types by string. Changing `"topology-graph"` to `"ext:topology:topology-graph"` would require cascading changes to every reference site. `coreOverride` allows surgical extraction with zero changes to consumers.

**Example:** Already used by Conventional Commits, Gitflow, Content Viewers in v1.6.0.

### Pattern 2: Sidebar Panel via contributeSidebarPanel()

**What:** Extensions register sidebar panel components with the `SidebarPanelRegistry`. The `DynamicSidebarPanels` component in `RepositoryView.tsx` renders all registered panels.

**When:** For features that were hardcoded in the RepositoryView sidebar.

**Why:** Established by Gitflow extraction in v1.6.0. Gitflow's sidebar section moved from a hardcoded `<details>` block in RepositoryView to `api.contributeSidebarPanel()`.

**Example:**
```typescript
api.contributeSidebarPanel({
  id: "worktree-panel",
  title: "Worktrees",
  icon: FolderGit2,
  component: WorktreeSidebarPanel,
  priority: 60,
  defaultOpen: false,
  renderAction: () => (
    <button onClick={() => setShowCreateDialog(true)}>
      <Plus className="w-3.5 h-3.5" />
    </button>
  ),
});
```

### Pattern 3: Self-Contained Sidebar Panel Component

**What:** When extracting a sidebar section that has associated dialogs (Create, Delete), wrap everything in a single self-contained component that owns its own dialog state.

**When:** The original implementation split state across the parent (`RepositoryView.tsx`) and the panel component.

**Why:** The sidebar panel registry renders components in isolation. Dialog state must be co-located with the panel, not in a parent component.

### Pattern 4: Lazy Component Imports in Extensions

**What:** Use `React.lazy()` with dynamic `import()` in the `onActivate` function body.

**When:** Always for blade components registered by extensions.

**Why:** Prevents loading heavy component trees during extension activation. The component code loads only when the blade is first rendered. Established pattern in all v1.6.0 extensions.

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: Extracting Data Slices from GitOpsStore

**What:** Moving `topology.slice.ts` or `worktrees.slice.ts` into the extension directory.

**Why bad:** The GitOpsStore is a monolithic Zustand store with cross-slice dependencies (`worktrees.switchToWorktree` calls `get().openRepository()`). Extracting slices would require a store plugin/injection system, break HMR, and add complexity. The Gitflow extraction kept `gitflow.slice.ts` in GitOpsStore for the same reason.

**Instead:** Keep data slices in GitOpsStore. Extensions import and use the store directly (they have `built-in` trust level = full access).

### Anti-Pattern 2: Changing Navigation Machine Blade Types

**What:** Renaming `"topology-graph"` to `"ext:topology:topology-graph"` in the navigation machine.

**Why bad:** The `coreOverride` pattern exists specifically to avoid this. Every consumer of `"topology-graph"` (navigation machine, toolbar commands, blade navigation calls) would need updates. Future extensions might need to provide alternative root blades, but that's a v2.0 concern.

**Instead:** Use `coreOverride: true` in blade registration. The blade type string stays the same.

### Anti-Pattern 3: Dual Registration (Core + Extension)

**What:** Keeping `src/blades/topology-graph/registration.ts` AND registering the same blade type in the extension.

**Why bad:** Both would race to register `"topology-graph"`. The `_discovery.ts` glob runs eagerly on import. Extension activation runs after. This causes duplicate registration warnings or the core registration overriding the extension.

**Instead:** Remove the `src/blades/` directory entirely when extracting to an extension. The extension becomes the sole registrar.

### Anti-Pattern 4: Hardcoded Feature Detection in WelcomeView

**What:** `WelcomeView.tsx` doing `import { InitRepoBlade } from "../blades/init-repo"` directly.

**Why bad:** Creates a static import dependency that can't be toggled. If init-repo extension is disabled, the import still succeeds (code is bundled), but the blade registration is absent, causing inconsistent behavior.

**Instead:** Use BladeRegistry lookup to dynamically resolve the component. If the blade is not registered (extension disabled), show a text-only fallback.

---

## Tech Debt to Address

### commandRegistry: Plain Map (Not Reactive)

The v1.6.0 milestone noted that `commandRegistry` uses a plain `Map<string, Command>`, not a Zustand store. This means command unregistration on extension deactivation does NOT trigger re-renders in the command palette. The `ExtensionAPI.cleanup()` calls `unregisterCommand()` which deletes from the Map, but `CommandPalette` won't see the change until it re-renders for another reason.

**Impact on this milestone:** LOW. Command palette is opened on-demand (Cmd+K), so stale commands are unlikely to be visible. But this should be fixed eventually -- either by migrating commandRegistry to a Zustand store or adding a counter/tick mechanism.

### previewRegistry: Plain Map (Not Reactive)

Same issue as commandRegistry. Not directly relevant to this milestone but noted for completeness.

### Topology Auto-Refresh Coupling in App.tsx

Lines 132-136 of `App.tsx` directly access `useTopologyStore.getState()` and call `loadGraph()` on file watcher events. This is a core-level concern (auto-refreshing data when the filesystem changes) and should remain in `App.tsx` even after extraction. The topology data stays in GitOpsStore, so this code continues to work regardless of whether the topology extension is enabled.

---

## Build Order (Dependency-Driven)

### Phase 1: Init Repo Extraction (Simplest, No Dependencies)

**Rationale:** Init Repo is the most self-contained feature. It has:
- Its own Zustand store (`createBladeStore`)
- No sidebar integration (blade-only)
- No navigation machine entanglement
- Only one consumer outside the blade directory (`WelcomeView.tsx`)

This is the safest first extraction -- if anything goes wrong, it affects only the "new repo" flow, not the main application.

**Risk:** LOW. The WelcomeView integration requires a dynamic component lookup, but this is straightforward.

### Phase 2: Worktree Extraction (Sidebar Pattern, Proven by Gitflow)

**Rationale:** Worktrees follow the exact same pattern as the v1.6.0 Gitflow extraction:
1. Remove hardcoded `<details>` section from `RepositoryView.tsx`
2. Create self-contained sidebar panel component
3. Register via `contributeSidebarPanel()`

The main work is wrapping the worktree components + dialogs into a self-contained panel component. The dialog state that currently lives in `RepositoryView.tsx` must move into the panel.

**Risk:** LOW. Gitflow proved this pattern works. The only difference is that Worktrees also has Create/Delete dialogs that need to move into the panel component.

### Phase 3: Topology Extraction (Most Complex, Navigation Machine Dependency)

**Rationale:** Topology is the most entangled feature:
1. It's the default root blade for the "topology" process
2. The navigation machine hardcodes the blade type
3. `App.tsx` has direct auto-refresh logic
4. `CommitHistory` (used inside TopologyRootBlade) lives in `src/components/commit/`
5. The `useCommitGraph` hook wraps the topology store slice

Topology should be extracted LAST because:
- It needs the graceful degradation pattern to be well-understood (tested with Init Repo and Worktrees first)
- The navigation machine fallback must be carefully implemented
- `CommitHistory` is a shared component that may need to stay in `src/components/` (it's not topology-specific, it's a commit list view)

**Risk:** MEDIUM. The navigation machine coupling is the main concern. The fallback for disabled topology extension must be user-friendly.

### Phase 4: Tech Debt Cleanup

**Rationale:** After all three extractions, clean up:
1. Remove empty directories (`src/blades/topology-graph/`, `src/blades/init-repo/`, `src/components/worktree/`)
2. Update `_discovery.ts` EXPECTED_TYPES (remove extracted types)
3. Add tests for extension enable/disable toggles
4. Update documentation

---

## Shared Components Decision

### CommitHistory -- Keep in src/components/

`CommitHistory` (235 lines, `src/components/commit/CommitHistory.tsx`) is imported by `TopologyRootBlade` but is NOT topology-specific. It's a general commit list view. Keep it in `src/components/commit/` and import it from the topology extension.

### useCommitGraph -- Keep in src/hooks/

`useCommitGraph` (45 lines, `src/hooks/useCommitGraph.ts`) wraps the topology store slice. It could move into the extension, but keeping it in `src/hooks/` is cleaner because it's a thin adapter over the store and could be useful to other extensions.

### useGitignoreTemplates -- Keep in src/hooks/

`useGitignoreTemplates.ts` is used by `InitRepoBlade` but is a general-purpose hook for Rust command wrappers. Keep in `src/hooks/`.

---

## Scalability Considerations

| Concern | Current (7 extensions) | After (10 extensions) | At 20+ extensions |
|---------|----------------------|----------------------|-------------------|
| Activation time | ~5ms per built-in | ~7ms per built-in (no measurable change) | Consider parallel activation |
| BladeRegistry size | ~15 registrations | ~17 registrations | Still O(1) lookup, no concern |
| Sidebar panels | ~2 dynamic panels | ~3 dynamic panels | May need collapse/organize UX |
| Bundle size | All built-in code bundled | Same (lazy imports defer loading) | May need code splitting per extension |
| Store cross-deps | GitOpsStore has 9 slices | Still 9 slices (no new slices) | Consider slice extraction at 15+ |

---

## Summary of New vs Modified Files

### New Files (Create)

| File | Purpose |
|------|---------|
| `src/extensions/topology/index.ts` | Topology extension entry point |
| `src/extensions/topology/blades/TopologyRootBlade.tsx` | MOVED (not new code, new location) |
| `src/extensions/topology/components/*.tsx` | MOVED (6 files) |
| `src/extensions/worktrees/index.ts` | Worktrees extension entry point |
| `src/extensions/worktrees/components/WorktreeSidebarPanel.tsx` | NEW wrapper for self-contained panel |
| `src/extensions/worktrees/components/WorktreePanel.tsx` | MOVED |
| `src/extensions/worktrees/components/WorktreeItem.tsx` | MOVED |
| `src/extensions/worktrees/components/CreateWorktreeDialog.tsx` | MOVED |
| `src/extensions/worktrees/components/DeleteWorktreeDialog.tsx` | MOVED |
| `src/extensions/init-repo/index.ts` | Init Repo extension entry point |
| `src/extensions/init-repo/blades/InitRepoBlade.tsx` | MOVED |
| `src/extensions/init-repo/components/*.tsx` | MOVED (6 files) |
| `src/extensions/init-repo/store.ts` | MOVED |

### Modified Files

| File | Change |
|------|--------|
| `src/App.tsx` | Add 3 registerBuiltIn() calls + imports |
| `src/components/RepositoryView.tsx` | Remove hardcoded worktree section (~30 lines) |
| `src/components/WelcomeView.tsx` | Dynamic InitRepoBlade lookup from BladeRegistry |
| `src/blades/_discovery.ts` | Remove "topology-graph" and "init-repo" from EXPECTED_TYPES |
| `src/machines/navigation/actions.ts` | (Optional) Add BladeRegistry fallback check |

### Deleted Files/Directories

| Path | Reason |
|------|--------|
| `src/blades/topology-graph/` | Moved to `src/extensions/topology/` |
| `src/blades/init-repo/` | Moved to `src/extensions/init-repo/` |
| `src/components/worktree/` | Moved to `src/extensions/worktrees/` |

---

## Sources

- All findings verified directly from codebase analysis (HIGH confidence)
- v1.6.0 extension extraction patterns: `/Users/phmatray/Repositories/github-phm/FlowForge/.planning/research/v1.6.0-ARCHITECTURE.md`
- Extension system implementation: `src/extensions/ExtensionHost.ts`, `src/extensions/ExtensionAPI.ts`
- Reference extensions: `src/extensions/conventional-commits/index.ts`, `src/extensions/gitflow/index.ts`
- Navigation machine: `src/machines/navigation/actions.ts`, `src/machines/navigation/types.ts`
- Current feature implementations: `src/blades/topology-graph/`, `src/blades/init-repo/`, `src/components/worktree/`
