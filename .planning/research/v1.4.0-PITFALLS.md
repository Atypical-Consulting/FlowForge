# Domain Pitfalls: FlowForge v1.4.0

**Domain:** Desktop Git client -- XState migration, test infrastructure, API integration
**Researched:** 2026-02-08

## Critical Pitfalls

Mistakes that cause rewrites or major issues.

### Pitfall 1: Big-Bang XState Migration

**What goes wrong:** Attempting to replace `useBladeStore` (Zustand) with XState in a single PR across all ~30 consuming files. Something breaks, rollback is painful, half the app is in an intermediate state.

**Why it happens:** XState looks simple in examples but replacing an existing state management system touches every component that reads or writes navigation state.

**Consequences:** Broken navigation, merge conflicts with parallel work, lost developer productivity for days.

**Prevention:**
1. Create XState machine that mirrors current `useBladeStore` behavior exactly (same actions, same state shape)
2. Create a `useNavigation()` hook that wraps XState with the same API as `useBladeNavigation()`
3. Swap the implementation behind the hook, not the hook itself
4. Run both systems in parallel during migration (XState primary, Zustand as shadow for comparison in dev mode)
5. Remove Zustand blade store only after all consumers are verified

**Detection:** If a PR touches more than 10 files to "integrate XState", it's too big. Break it up.

### Pitfall 2: XState Replacing ALL Zustand Stores

**What goes wrong:** Enthusiasm for XState leads to converting simple get/set stores (toasts, theme, dropdowns) into state machines. The result is over-engineered stores with more code than before.

**Why it happens:** XState is powerful and its `setup()` API makes everything look like it should be a state machine. But a toast notification queue is just a list, not an FSM.

**Consequences:** 3x more code for simple stores, harder to onboard new contributors, XState devtools cluttered with trivial machines.

**Prevention:** Clear ownership rule: XState owns ONLY the navigation FSM. All other state stays in Zustand. If a store has fewer than 3 states and no conditional transitions, it does not need XState.

**Detection:** Code review flag: any new `createMachine()` call outside the `src/machines/` directory.

### Pitfall 3: Tauri IPC Mocking Gaps in Tests

**What goes wrong:** Tests pass locally but fail in CI, or worse, tests that should fail pass because Tauri mocks return stale/incorrect shapes. The `bindings.ts` file is auto-generated -- mocks drift from actual types silently.

**Why it happens:** Mock factories are hand-written with `vi.fn().mockResolvedValue(...)`. When a Rust command changes its return type, the mock still returns the old shape. TypeScript won't catch it because mock return types are often `any`.

**Consequences:** False confidence in tests. Bugs in Rust-TypeScript contract go undetected.

**Prevention:**
1. Type mock factories against the actual binding types: `vi.fn<typeof commands.getStagingStatus>()`
2. Use `satisfies` to ensure mock return values match expected types
3. Run `tsc --noEmit` in CI separately from tests to catch type drift
4. Consider a `src/test/bindings-mock.ts` that imports types from `bindings.ts` and enforces shape

**Detection:** Any mock that uses `as any` or untyped `mockResolvedValue()`.

## Moderate Pitfalls

### Pitfall 4: `useActor` Performance Trap

**What goes wrong:** Using `useActor(machine)` or `useMachine(machine)` in components that render frequently (blade list, virtualized scroll). Every navigation state change triggers re-renders in all these components.

**Prevention:** Use `useSelector(navActor, specificSelector)` to subscribe only to the data needed. Use `useActorRef(machine)` for components that only dispatch events. Reserve `useActor` for top-level components or debugging.

### Pitfall 5: XState Machine Coupling to React

**What goes wrong:** Putting React-specific logic (refs, hooks, DOM manipulation) inside XState machine actions or guards. Makes the machine untestable without React rendering.

**Prevention:** XState machine should be pure logic -- guards check context/event data, actions use `assign()` or fire side effects via `fromPromise()`. React integration happens exclusively through hooks (`useSelector`, `useActorRef`). Test the machine in isolation with `createActor(machine).send(...)`.

### Pitfall 6: GitHub API Rate Limiting Surprise

**What goes wrong:** Init Repo blade fetches template list on every open, hits 60/hour limit when user is experimenting.

**Prevention:**
1. React Query with `staleTime: Infinity` -- fetch once, cache forever per session
2. Prefetch template list on app startup or first repo open
3. Bundle top 10-20 templates as fallback JSON for offline/rate-limited scenarios
4. Show clear error message when rate limited, not a generic failure

### Pitfall 7: reqwest Blocking the Async Runtime

**What goes wrong:** Using `reqwest::blocking::Client` instead of the async client in Tauri commands, blocking the tokio runtime.

**Prevention:** Always use `reqwest::Client` (async) with `.await`. Tauri commands are already async (`pub async fn`). Never use `reqwest::blocking` in the Tauri context.

### Pitfall 8: Test File Organization Sprawl

**What goes wrong:** Tests placed in a separate `tests/` directory, mirroring the `src/` structure. Leads to long import paths, forgotten tests when files move, and low discoverability.

**Prevention:** Co-locate test files: `Component.test.tsx` next to `Component.tsx`. Vitest's `include: ["src/**/*.test.{ts,tsx}"]` pattern already supports this. The test setup file (`src/test/setup.ts`) and utilities (`src/test/tauri-mocks.ts`) are the only files in a dedicated test directory.

### Pitfall 9: Snapshot Testing Addiction

**What goes wrong:** Starting with `toMatchSnapshot()` for quick "test coverage" numbers. Snapshots pass on write, fail on any UI change, get updated mindlessly, and catch nothing.

**Prevention:** Ban snapshot tests. Use Testing Library queries: `screen.getByRole()`, `screen.getByText()`, `userEvent.click()`. Test behavior, not markup.

## Minor Pitfalls

### Pitfall 10: Vitest `globals: true` Type Confusion

**What goes wrong:** Setting `globals: true` in Vitest config but forgetting to add `"vitest/globals"` to `tsconfig.json` types. TypeScript doesn't recognize `describe`, `it`, `expect` etc.

**Prevention:** Add to `tsconfig.json`:
```json
{
  "compilerOptions": {
    "types": ["vitest/globals"]
  }
}
```
Or use explicit imports: `import { describe, it, expect } from 'vitest'`.

### Pitfall 11: Forgetting `cleanup` After Tests

**What goes wrong:** Component state leaks between tests because `@testing-library/react` doesn't auto-cleanup in Vitest.

**Prevention:** Add to `src/test/setup.ts`:
```typescript
import { cleanup } from '@testing-library/react';
import { afterEach } from 'vitest';
afterEach(cleanup);
```

### Pitfall 12: XState Actor Not Started

**What goes wrong:** Creating the navigation actor with `createActor(machine)` but forgetting to call `.start()`. All `.send()` calls are silently ignored.

**Prevention:** Start the actor immediately after creation in the module scope. Use a pattern that makes forgetting impossible:
```typescript
export const navActor = createActor(machine).start();
```
Or start in `App.tsx` useEffect and verify with a dev-mode assertion.

### Pitfall 13: reqwest Version Conflict with Tauri

**What goes wrong:** Adding `reqwest = "0.12"` to Cargo.toml when Tauri's `tauri-plugin-http` (if ever added) uses a different version, causing duplicate `reqwest` versions in the dependency tree.

**Prevention:** Since we are NOT adding `tauri-plugin-http`, this is not an immediate risk. But if added later, ensure both use the same `reqwest` major version. Check with `cargo tree -d` for duplicates.

## Phase-Specific Warnings

| Phase Topic | Likely Pitfall | Mitigation |
|-------------|---------------|------------|
| Test Infrastructure | Pitfall 3 (mock type drift) | Type mocks against bindings types from day one |
| Test Infrastructure | Pitfall 10 (Vitest globals) | Add `vitest/globals` to tsconfig types |
| Test Infrastructure | Pitfall 11 (cleanup) | Setup file with afterEach(cleanup) |
| XState Navigation | Pitfall 1 (big-bang migration) | Wrapper hook, swap implementation not consumers |
| XState Navigation | Pitfall 2 (overuse) | Clear ownership rule: only navigation FSM |
| XState Navigation | Pitfall 4 (useActor perf) | useSelector everywhere, useActor only for debug |
| XState Navigation | Pitfall 5 (React coupling) | Pure machine, React integration via hooks only |
| XState Navigation | Pitfall 12 (actor not started) | `.start()` chained on creation |
| Init Repo Blade | Pitfall 6 (rate limiting) | React Query staleTime: Infinity, offline fallback |
| Gitignore API | Pitfall 7 (blocking reqwest) | Always async client, never reqwest::blocking |
| Conventional Commit | (none specific) | Standard blade pattern, low risk |
| Store Consolidation | Pitfall 2 (XState overuse) | Only consolidate Zustand stores, don't convert to XState |

## Sources

- [XState migration guide](https://stately.ai/docs/migration) -- common migration pitfalls
- [XState useSelector best practices](https://github.com/statelyai/xstate/discussions/3886) -- performance patterns
- [@testing-library/react setup](https://testing-library.com/docs/react-testing-library/setup/) -- cleanup requirements
- [Vitest globals config](https://vitest.dev/config/#globals) -- TypeScript type configuration
- [GitHub API rate limits](https://docs.github.com/en/rest/using-the-rest-api/rate-limits-for-the-rest-api) -- 60/hour unauthenticated
- Current codebase: `stores/blades.ts` used in ~30 files, `hooks/useBladeNavigation.ts` used in ~15 files
