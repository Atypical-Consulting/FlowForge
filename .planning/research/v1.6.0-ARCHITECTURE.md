# Architecture Patterns

**Domain:** Extension platform expansion and feature extraction for Tauri v2 + React Git GUI
**Researched:** 2026-02-10
**Overall confidence:** HIGH

---

## Executive Summary

FlowForge v1.6.0 needs three interrelated architectural changes: (1) expand the ExtensionAPI with new contribution points (context menus, status bar, sidebar panels, git operation hooks), (2) extract Gitflow, Conventional Commits, and content viewers from core into built-in extensions that consume those same APIs, and (3) lay sandbox infrastructure for future third-party isolation. The existing architecture -- ExtensionHost lifecycle, ExtensionAPI facade with namespaced registrations, and the `registerBuiltIn()` pattern established by the GitHub extension -- provides a proven template. The challenge is that Gitflow and CC have deep tentacles: Gitflow's UI lives in the sidebar (`RepositoryView.tsx`), its state lives in a GitOpsStore slice, and its operations live in Rust `gitflow::commands`. Extraction requires new API surfaces to contribute sidebar panels and intercept git operations, plus careful decoupling from the monolithic domain store.

---

## Current Architecture (As-Is)

### Component Inventory

```
FRONTEND (React + TypeScript)
  src/extensions/
    ExtensionAPI.ts          -- Per-extension facade (blade, command, toolbar registration)
    ExtensionHost.ts         -- Zustand store: discovery, activation, deactivation lifecycle
    extensionTypes.ts        -- ExtensionInfo, ExtensionStatus, BuiltInExtensionConfig
    extensionManifest.ts     -- Re-exports Rust-generated manifest types
    github/                  -- Reference built-in extension (7 blades, 5 commands, 4 toolbar)

  src/lib/
    bladeRegistry.ts         -- Module-level Map<string, BladeRegistration> with source tagging
    commandRegistry.ts       -- Module-level Map<string, Command> with source/category
    toolbarRegistry.ts       -- Zustand store: ToolbarAction with group/priority/when()
    bladeOpener.ts           -- openBlade() sends PUSH_BLADE to XState navigation actor
    fileDispatch.ts          -- Maps file extensions to blade types (viewer routing)

  src/machines/navigation/
    navigationMachine.ts     -- XState v5 FSM: push/pop/replace/reset with dirty-blade guards
    types.ts                 -- BladeType = CoreBladeType | ExtensionBladeType

  src/stores/
    domain/git-ops/          -- Monolithic GitOpsStore with 9 slices (repository, branches,
                                tags, stash, worktrees, GITFLOW, undo, topology, clone)
    domain/ui-state/         -- UIStore (staging, command palette)
    domain/preferences/      -- PreferencesStore (theme, settings, navigation, branch metadata)
    conventional.ts          -- createBladeStore for CC form state

  src/blades/
    _discovery.ts            -- import.meta.glob for registration.ts auto-discovery
    conventional-commit/     -- CC blade + registration (core blade, not extension)
    gitflow-cheatsheet/      -- Gitflow guide blade (core blade)
    viewer-{code,image,markdown,3d,nupkg}/  -- Content viewers (core blades)

  src/components/
    gitflow/                 -- GitflowPanel, StartFlowDialog, FinishFlowDialog, InitGitflowDialog
    viewers/ViewerRegistry.ts -- Separate matcher-based registry for inline file viewers
    RepositoryView.tsx       -- Hardcoded sidebar: branches, stash, tags, GITFLOW, worktrees

RUST BACKEND (src-tauri/src/)
  gitflow/                   -- State machine, commands, policy, init, merge (Tauri IPC)
  git/conventional.rs        -- CC parsing, validation, type inference (Tauri IPC)
  extensions/                -- Discovery, manifest parsing, install/uninstall
```

### Current Data Flow

```
Extension Activation:
  ExtensionHost.registerBuiltIn(config)
    -> creates ExtensionAPI(id)
    -> calls config.activate(api)
    -> api.registerBlade()       -> bladeRegistry with "ext:{id}:{type}" namespace
    -> api.registerCommand()     -> commandRegistry with "ext:{id}:{cmd}" namespace
    -> api.contributeToolbar()   -> toolbarRegistry with "ext:{id}:{action}" namespace

Extension Deactivation:
  ExtensionHost.deactivateExtension(id)
    -> calls module.onDeactivate()
    -> api.cleanup() -> unregisters ALL blades, commands, toolbar by namespace

Navigation:
  openBlade(type, props) -> navigationActor.send(PUSH_BLADE)
  BladeRenderer reads bladeStack, looks up BladeRegistration, renders component

Gitflow (current tight coupling):
  RepositoryView.tsx hardcodes <GitflowPanel /> in sidebar
  GitflowPanel reads useGitflowStore() (alias for useGitOpsStore)
  gitflow.slice.ts calls Rust commands.startFeature/finishFeature/etc.
  After each operation: get().refreshGitflow() + get().loadBranches() + get().refreshRepoStatus()
```

---

## Recommended Architecture (To-Be)

### New Registries and API Surfaces

#### 1. ContextMenuRegistry (NEW)

**What:** A registry for right-click context menu items, scoped by location (file-tree, branch-list, commit-list, diff-hunk, stash-list, tag-list, blade-tab).

**Why:** Extensions need to add context-sensitive actions. Gitflow needs "Start Feature from here" on branches. GitHub needs "Open PR for branch." Context menus are a standard extension surface in VS Code and JetBrains IDEs.

```typescript
// src/lib/contextMenuRegistry.ts
export type ContextMenuLocation =
  | "file-tree"
  | "branch-list"
  | "commit-list"
  | "diff-hunk"
  | "stash-list"
  | "tag-list"
  | "blade-tab";

export interface ContextMenuItem {
  id: string;                              // Namespaced: "ext:gitflow:start-feature-from"
  label: string;
  icon?: LucideIcon;
  location: ContextMenuLocation;
  group?: string;                          // Separator grouping (e.g., "gitflow", "navigation")
  priority?: number;                       // Sort order within group
  when?: (context: ContextMenuContext) => boolean;
  execute: (context: ContextMenuContext) => void | Promise<void>;
  source?: string;
}

export interface ContextMenuContext {
  location: ContextMenuLocation;
  branchName?: string;
  filePath?: string;
  commitOid?: string;
  stashIndex?: number;
  tagName?: string;
}
```

**Implementation:** Zustand store mirroring the ToolbarRegistry pattern. UI components call `getMenuItemsForLocation(location, context)` to build menus.

#### 2. SidebarPanelRegistry (NEW)

**What:** A registry that lets extensions contribute collapsible panels to the repository sidebar (currently hardcoded in `RepositoryView.tsx`).

**Why:** This is the extraction unlock. Gitflow currently renders `<GitflowPanel />` directly in `RepositoryView.tsx` (line 120-127). After extraction, the Gitflow extension contributes its panel via this registry. No core UI changes needed for future sidebar contributors.

```typescript
// src/lib/sidebarPanelRegistry.ts
export interface SidebarPanelConfig {
  id: string;
  title: string;
  icon: LucideIcon;
  component: ComponentType<any>;
  priority: number;                        // Higher = renders higher in sidebar
  when?: () => boolean;                    // Visibility (e.g., only when repo open)
  defaultOpen?: boolean;
  source?: string;
}
```

**Implementation:** Zustand store. `RepositoryView.tsx` reads registered panels and renders them dynamically within `<details>` wrappers, interspersed with core sidebar sections at their priority positions.

#### 3. StatusBarRegistry (NEW)

**What:** A registry for status bar widgets at the bottom of the application window.

**Why:** Gitflow needs to show active flow status (e.g., "Feature: login"). GitHub shows auth status. CC could show last commit type. Status bar is a standard extension surface in VS Code and IntelliJ.

```typescript
// src/lib/statusBarRegistry.ts
export type StatusBarAlignment = "left" | "right";

export interface StatusBarItem {
  id: string;
  alignment: StatusBarAlignment;
  priority: number;                        // Higher = closer to respective edge
  renderCustom: (tabIndex: number) => ReactNode;
  when?: () => boolean;
  execute?: () => void | Promise<void>;    // Click handler
  source?: string;
}
```

**Implementation:** Zustand store following ToolbarRegistry pattern. A new `<StatusBar />` component renders items grouped by alignment.

#### 4. GitHookBus (NEW)

**What:** A pub/sub event bus for pre/post hooks on git operations, exposed through ExtensionAPI.

**Why:** Gitflow needs to react to branch switches and merges. CC might validate commit messages before commit. This replaces the tight coupling where `gitflow.slice.ts` directly calls cross-slice methods like `get().loadBranches()` and `get().refreshRepoStatus()`.

```typescript
// src/lib/gitHookBus.ts
export type GitHookPhase = "before" | "after";
export type GitOperation =
  | "commit" | "branch-create" | "branch-delete" | "branch-checkout"
  | "merge" | "push" | "pull" | "fetch" | "stash" | "tag-create";

export interface GitHookContext {
  operation: GitOperation;
  phase: GitHookPhase;
  branchName?: string;
  commitOid?: string;
  error?: string;           // Present on "after" phase when operation failed
}

class GitHookBus {
  private listeners = new Map<string, Set<(ctx: GitHookContext) => void | Promise<void>>>();

  on(operation: GitOperation, phase: GitHookPhase, handler: Function): () => void {
    const key = `${phase}:${operation}`;
    if (!this.listeners.has(key)) this.listeners.set(key, new Set());
    this.listeners.get(key)!.add(handler);
    return () => this.listeners.get(key)?.delete(handler);
  }

  async emit(phase: GitHookPhase, operation: GitOperation, partial: Partial<GitHookContext>) {
    const key = `${phase}:${operation}`;
    const ctx = { operation, phase, ...partial } as GitHookContext;
    for (const handler of this.listeners.get(key) ?? []) {
      try { await handler(ctx); }
      catch (e) { console.error(`Git hook error [${key}]:`, e); }
    }
  }
}

export const gitHookBus = new GitHookBus();
```

**ExtensionAPI surface:**

```typescript
registerGitHook(config: {
  operation: GitOperation;
  phase: GitHookPhase;
  handler: (context: GitHookContext) => void | Promise<void>;
}): void;
```

#### 5. ViewerContributionAPI (NEW -- on ExtensionAPI)

**What:** Extension API methods to register file content viewers and file dispatch mappings.

**Why:** Content viewers (image, markdown, 3D, nupkg, code) need to become extension-contributed. The existing `ViewerRegistry` matcher pattern maps well. The `FILE_DISPATCH_MAP` in `fileDispatch.ts` needs to become extensible.

```typescript
// New methods on ExtensionAPI:
registerViewer(config: {
  id: string;
  matcher: (file: { path: string; status: string }) => boolean;
  component: ComponentType<ViewerProps>;
  priority?: number;
}): void;

registerFileDispatch(config: {
  extensions: string[];          // ["png", "jpg", "webp"]
  bladeType: string;             // The extension's namespaced blade type
}): void;
```

**Implementation:** `registerViewer` delegates to existing `ViewerRegistry.registerViewer()` with source tagging for cleanup. `registerFileDispatch` adds entries to `fileDispatch.ts` (which needs refactoring from static `ReadonlyMap` to mutable + overlay).

### ExtensionAPI Expansion Summary

```typescript
class ExtensionAPI {
  // EXISTING (v1.5.0):
  registerBlade(config: ExtensionBladeConfig): void;
  registerCommand(config: ExtensionCommandConfig): void;
  contributeToolbar(config: ExtensionToolbarConfig): void;
  cleanup(): void;

  // NEW (v1.6.0):
  contributeContextMenu(config: ContextMenuItemConfig): void;
  contributeSidebarPanel(config: SidebarPanelConfig): void;
  contributeStatusBar(config: StatusBarItemConfig): void;
  registerGitHook(config: GitHookConfig): void;
  registerViewer(config: ViewerConfig): void;
  registerFileDispatch(config: FileDispatchConfig): void;

  // Pattern: All methods namespace IDs, register in registry, track for cleanup()
}
```

### Component Boundaries

| Component | Responsibility | Communicates With |
|-----------|---------------|-------------------|
| **ExtensionAPI** | Per-extension facade, namespacing, cleanup tracking | All registries |
| **ExtensionHost** | Lifecycle management (discover, activate, deactivate) | ExtensionAPI, Rust discovery |
| **BladeRegistry** | Blade type -> component mapping | Navigation machine, BladeRenderer |
| **CommandRegistry** | Command palette entries | CommandPalette component |
| **ToolbarRegistry** | Toolbar actions with groups/priority/when() | Toolbar component |
| **ContextMenuRegistry** (NEW) | Right-click menu items by location | BranchItem, FileTreeItem, etc. |
| **SidebarPanelRegistry** (NEW) | Sidebar collapsible panels | RepositoryView |
| **StatusBarRegistry** (NEW) | Bottom status bar widgets | StatusBar component |
| **GitHookBus** (NEW) | Pre/post git operation event bus | GitOps store slices, extensions |
| **ViewerRegistry** (MODIFIED) | File content viewer matching | StagingChanges, fileDispatch |
| **FileDispatch** (MODIFIED) | File extension -> blade type routing | bladeOpener, repo-browser |

### Data Flow for New Surfaces

#### Context Menu Flow

```
User right-clicks on branch "develop"
  -> BranchItem.tsx calls getMenuItemsForLocation("branch-list", { branchName: "develop" })
  -> ContextMenuRegistry filters by location + when(context)
  -> Renders <ContextMenu> with sorted/grouped items
  -> User clicks "Start Feature"
  -> item.execute({ branchName: "develop" })
  -> Gitflow extension opens StartFlowDialog
```

#### Git Hook Flow

```
User clicks "Finish Feature" in Gitflow extension
  -> Gitflow extension store calls Rust IPC finishFeature()
  -> On success, fires gitHookBus.emit("after", "merge", { branchName: "develop" })
  -> Core BranchSlice listener: auto-reloads branches
  -> Core RepositorySlice listener: auto-refreshes repo status
  -> GitHub extension listener (optional): checks if PR should be suggested
```

#### Sidebar Panel Flow

```
App startup:
  -> registerBuiltIn({ id: "gitflow", ... activate(api) })
  -> api.contributeSidebarPanel({
       id: "panel", component: GitflowPanel,
       icon: GitMerge, priority: 40, title: "Gitflow"
     })
  -> SidebarPanelRegistry stores entry

RepositoryView.tsx render:
  -> reads useSidebarPanelRegistry(state => state.getPanels())
  -> renders panels dynamically with <details> wrappers
  -> No hardcoded <GitflowPanel /> import
```

#### StatusBar Flow

```
Gitflow extension activate:
  -> api.contributeStatusBar({
       id: "active-flow",
       alignment: "left",
       priority: 80,
       when: () => !!gitflowStore.getState().gitflowStatus?.activeFlow,
       renderCustom: () => <GitflowStatusWidget />,
     })

StatusBar component:
  -> reads useStatusBarRegistry(state => state.getItems())
  -> renders left-aligned items (sorted by priority) | right-aligned items
```

---

## Extraction Strategy

### Feature 1: Gitflow Extension

**Current locations (5 layers):**

| Layer | Files | Dependencies |
|-------|-------|-------------|
| Rust backend | `src-tauri/src/gitflow/` (commands, machine, policy, init, merge, state, error) | git2 crate, RepositoryState |
| Store slice | `src/stores/domain/git-ops/gitflow.slice.ts` | commands binding, GitOpsStore cross-slice calls |
| Components | `src/components/gitflow/` (GitflowPanel, Start/Finish/InitDialog, ActionCards, Diagram, BranchReference) | useGitflowStore, useBranchStore, useBladeNavigation |
| Blade | `src/blades/gitflow-cheatsheet/` | bladeRegistry |
| Layout | `RepositoryView.tsx` line 120-127 (hardcoded `<GitflowPanel />`) | Direct import |
| Toolbar | `toolbar-actions.ts` `tb:gitflow-guide` | openBlade, toolbarRegistry |

**Extraction target:**

```
src/extensions/gitflow/
  index.ts                  -- onActivate/onDeactivate (modeled on github/index.ts)
  gitflowStore.ts           -- Standalone Zustand store (extracted from gitflow.slice)
  blades/
    GitflowCheatsheetBlade.tsx
  components/
    GitflowPanel.tsx
    StartFlowDialog.tsx
    FinishFlowDialog.tsx
    InitGitflowDialog.tsx
    GitflowActionCards.tsx
    GitflowDiagram.tsx
    GitflowBranchReference.tsx
    GitflowStatusBarItem.tsx     -- NEW: status bar widget
```

**Critical decoupling: Cross-slice dependency resolution**

The `gitflow.slice.ts` currently calls `get().loadBranches()` and `get().refreshRepoStatus()` after every gitflow operation. These are methods from `BranchSlice` and `RepositorySlice` respectively, available because all slices compose into one GitOpsStore.

After extraction, the gitflow store is standalone. Replace cross-slice calls with git hook emissions:

```typescript
// BEFORE (in gitflow.slice, inside GitOpsStore):
const result = await commands.startFeature(name);
if (result.status === "ok") {
  await get().refreshGitflow();     // Same store
  await get().loadBranches();       // Cross-slice: BranchSlice
  await get().refreshRepoStatus();  // Cross-slice: RepositorySlice
}

// AFTER (in gitflow extension store, standalone):
const result = await commands.startFeature(name);
if (result.status === "ok") {
  await get().refreshGitflow();     // Same store (still works)
  gitHookBus.emit("after", "branch-create", { branchName: `feature/${name}` });
  // BranchSlice and RepositorySlice listen to hooks and refresh themselves
}
```

**Core BranchSlice wiring (in GitOpsStore, stays in core):**

```typescript
// In src/stores/domain/git-ops/branches.slice.ts or a setup file:
gitHookBus.on("branch-create", "after", () => useGitOpsStore.getState().loadBranches());
gitHookBus.on("branch-delete", "after", () => useGitOpsStore.getState().loadBranches());
gitHookBus.on("branch-checkout", "after", () => useGitOpsStore.getState().refreshRepoStatus());
gitHookBus.on("merge", "after", () => {
  useGitOpsStore.getState().loadBranches();
  useGitOpsStore.getState().refreshRepoStatus();
});
```

**Rust backend:** Stays as-is. Gitflow IPC commands (`startFeature`, `finishFeature`, `getGitflowStatus`, etc.) remain in `src-tauri/src/gitflow/commands.rs`. They are core git capabilities exposed over IPC. The frontend extension consumes them through the `commands` binding object.

**Registrations made by Gitflow extension:**
- 1 sidebar panel (GitflowPanel)
- 1 blade (gitflow-cheatsheet)
- 6+ commands (start/finish feature/release/hotfix, abort, init)
- 1 toolbar action (gitflow-guide)
- 1 status bar item (active flow indicator)
- 3+ context menu items on branch-list (Start Feature, Start Release, Start Hotfix contextually)

### Feature 2: Conventional Commits Extension

**Current locations:**

| Layer | Files | Dependencies |
|-------|-------|-------------|
| Rust backend | `src-tauri/src/git/conventional.rs` | git2 crate, staging types |
| Store | `src/stores/conventional.ts` (standalone createBladeStore) | commands binding |
| Hook | `src/hooks/useConventionalCommit.ts` | useConventionalStore |
| Components | `src/components/commit/` (CharacterProgress, ScopeAutocomplete, BreakingChangeSection, ValidationErrors, CommitDetails, CommitHistory, CommitSearch) | store, bindings |
| Blade | `src/blades/conventional-commit/` | bladeRegistry |
| Lib | `src/lib/conventional-utils.ts`, `src/lib/commit-type-theme.ts` | pure utilities |

**Extraction target:**

```
src/extensions/conventional-commits/
  index.ts
  conventionalStore.ts           -- Moved from stores/conventional.ts
  hooks/
    useConventionalCommit.ts     -- Moved
  blades/
    ConventionalCommitBlade.tsx  -- Moved
  components/
    CharacterProgress.tsx        -- Moved
    ScopeAutocomplete.tsx
    BreakingChangeSection.tsx
    ValidationErrors.tsx
  lib/
    conventional-utils.ts        -- Moved
    commit-type-theme.ts         -- Moved
```

**Key notes:**
- The CC store is already standalone (uses `createBladeStore`, not a GitOpsStore slice). This makes extraction straightforward.
- The `CommitForm` component (sidebar bottom) has a "CC" button that opens the conventional-commit blade. After extraction, this button's action references `ext:conventional-commits:commit-form` blade type. The CC extension registers a command for this.
- Rust `conventional.rs` stays in core (same reasoning as gitflow).
- Some commit components (CommitHistory, CommitSearch, CommitDetails) are used by the main commit-details blade and should stay in core. Only CC-specific components move.

**Registrations:**
- 1 blade (conventional-commit form)
- 3+ commands (open CC form, validate message, suggest type)
- 1 toolbar action (open CC form shortcut)
- Optional: 1 git hook (before:commit for message validation)

### Feature 3: Content Viewers Extension

**Current locations:**

| Layer | Files |
|-------|-------|
| Blades | `src/blades/viewer-{code,image,markdown,3d,nupkg}/` (5 blade dirs) |
| Viewer registry | `src/components/viewers/ViewerRegistry.ts` |
| NuGet viewer | `src/components/viewers/NugetPackageViewer.tsx` |
| File dispatch | `src/lib/fileDispatch.ts` (static FILE_DISPATCH_MAP) |

**Extraction target:**

```
src/extensions/content-viewers/
  index.ts
  blades/
    ViewerCodeBlade.tsx
    ViewerImageBlade.tsx
    ViewerMarkdownBlade.tsx
    Viewer3dBlade.tsx
    ViewerNupkgBlade.tsx
  components/
    NugetPackageViewer.tsx
    MarkdownRenderer.tsx       -- If not shared elsewhere
```

**Key notes:**
- This is the simplest extraction. No state coupling, no cross-slice deps.
- Each blade registration moves from core `registration.ts` to `api.registerBlade()` in extension activate.
- File dispatch entries move from static `FILE_DISPATCH_MAP` to `api.registerFileDispatch()`.
- `ViewerRegistry.ts` stays in core as infrastructure (matcher pattern). The extension uses `api.registerViewer()` which delegates to it.

**Registrations:**
- 5 blades (viewer-code, viewer-image, viewer-markdown, viewer-3d, viewer-nupkg)
- 5 file dispatch registrations (image extensions, .md/.mdx, .glb/.gltf, .nupkg, code fallback)
- 0 commands (viewers are opened by file dispatch, not command palette)

---

## Sandbox Infrastructure

### Architecture Decision: Layered Trust Model

Built-in extensions (Gitflow, CC, Viewers, GitHub) run in the main thread with full access -- they are bundled with the app and trusted. Third-party extensions need isolation. Full sandbox is NOT implemented in v1.6.0 but the architecture should be sandbox-compatible.

### Why Web Workers over Iframes for Future Sandboxing

Per the [Tauri Isolation Pattern documentation](https://v2.tauri.app/concept/inter-process-communication/isolation/), Tauri's built-in iframe isolation has a significant limitation: "external files do not load correctly inside sandboxed iframes on Windows" and "ES Modules will not successfully load." This makes iframes unsuitable for running extension JavaScript that uses modern module patterns.

Web Workers are the better path because:
- True thread isolation without DOM access concerns
- Structured cloning for data transfer (efficient for common types)
- Standard pattern for untrusted code execution in browser environments
- No Windows-specific module loading issues

### Sandbox Design (Preparatory -- Not Fully Implemented in v1.6.0)

```
                    MAIN THREAD                          WORKER THREAD
              +-----------------------+            +---------------------+
              |  ExtensionHost        |            |  SandboxedRuntime   |
              |    |                  |            |    |                |
              |    v                  |            |    v                |
              |  SandboxBridge        |<---------->|  ExtensionProxy     |
              |  (MessagePort)        |  postMsg   |  (mirrors API)      |
              |    |                  |            |    |                |
              |    v                  |            |    v                |
              |  ExtensionAPI         |            |  extension code     |
              |  (real registries)    |            |  (untrusted JS)     |
              +-----------------------+            +---------------------+
```

### What v1.6.0 Prepares

1. **Trust flag:** Add `trusted: boolean` to `ExtensionInfo`. Built-in = true. Filesystem-loaded = configurable.
2. **Serialization audit:** Ensure registration configs are JSON-serializable except React component references (which are trusted-only).
3. **Permission gate design:** Map manifest `permissions` array to Tauri IPC capability scoping.
4. **API surface classification:** Document which ExtensionAPI methods are available to sandboxed (future) vs trusted-only.

### Trust Level Summary

| Level | Access | Examples |
|-------|--------|---------|
| **Trusted (built-in)** | Full API, direct store access, React components, all Tauri IPC | Gitflow, CC, Viewers, GitHub |
| **Trusted (user-installed)** | Full API via dynamic import, Tauri IPC through permissions | Community extensions with user approval |
| **Sandboxed (future v1.7.0+)** | Worker-isolated, serialized API subset, iframe blade rendering | Untrusted marketplace extensions |

---

## Patterns to Follow

### Pattern 1: Built-In Extension Registration (Proven -- GitHub Extension)

**What:** Use `registerBuiltIn()` with `onActivate`/`onDeactivate` lifecycle, lazy component loading via `ensureComponents()`.

**When:** For every extracted feature.

**Example (Gitflow extension activate):**

```typescript
// src/extensions/gitflow/index.ts
export async function onActivate(api: ExtensionAPI): Promise<void> {
  await ensureComponents();

  api.registerBlade({ type: "cheatsheet", title: "Gitflow Guide", component: CheatsheetBlade!, ... });

  api.contributeSidebarPanel({
    id: "panel", title: "Gitflow", icon: GitMerge,
    component: GitflowPanel!, priority: 40,
    when: () => !!useRepositoryStore.getState().repoStatus,
  });

  api.contributeStatusBar({
    id: "active-flow", alignment: "left", priority: 80,
    when: () => !!gitflowStore.getState().gitflowStatus?.activeFlow,
    renderCustom: () => createElement(GitflowStatusWidget!),
  });

  api.registerCommand({ id: "start-feature", title: "Start Feature", ... });
  api.contributeToolbar({ id: "guide", label: "Gitflow Guide", ... });
  api.contributeContextMenu({
    id: "ctx-start-feature", location: "branch-list",
    label: "Start Feature", when: (ctx) => ctx.branchName === "develop",
    execute: () => { /* open dialog */ },
  });

  // Subscribe to repo changes for status refresh
  unsubRepoWatch = useRepositoryStore.subscribe(/* ... */);
}
```

### Pattern 2: Registry as Zustand Store (Proven -- ToolbarRegistry)

**What:** Each new registry is a Zustand store with `register`, `unregister`, `unregisterBySource`, and a filtered accessor.

**When:** For every new contribution point.

**Reference:** `src/lib/toolbarRegistry.ts` -- exact template to follow. The pattern:
- Map<string, Item> as primary storage
- Immutable updates (new Map for Zustand reactivity)
- Source-based batch unregister
- devtools middleware for debugging
- Sorted/filtered accessor method

### Pattern 3: Decoupled Git Operations via GitHookBus (New)

**What:** Replace cross-slice `get().loadBranches()` calls with a pub/sub GitHookBus.

**When:** Whenever a git operation in one domain needs to trigger refreshes in other domains.

**How it replaces current coupling:**

```
BEFORE: gitflow.slice calls get().loadBranches() (cross-slice in monolithic store)
AFTER:  gitflow extension emits gitHookBus.emit("after", "merge", {...})
        branch.slice subscribes to "after:merge" and calls loadBranches()
```

### Pattern 4: Lazy Component Loading in Extensions (Proven)

**What:** Extensions lazy-load components in `ensureComponents()` before registration.

**When:** Always, for all extensions. Prevents circular deps and enables code splitting.

**Reference:** `src/extensions/github/index.ts` lines 32-65.

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: Moving Rust Commands into Extensions

**What:** Trying to move `gitflow::commands` or `git::conventional` into extension-specific Rust modules.

**Why bad:** Tauri commands are registered at app startup in `main.rs`. Dynamic command registration is not supported. The Rust backend is not extensible at runtime.

**Instead:** Keep all Rust commands in core. Extensions consume them through the `commands` binding object. Rust is the capability layer; the extension boundary is frontend-only.

### Anti-Pattern 2: Shared Mutable State Between Extensions

**What:** Extensions importing each other's Zustand stores (e.g., Gitflow extension importing `useGitOpsStore.loadBranches()`).

**Why bad:** Creates invisible coupling. Deactivating one extension breaks another. Violates isolation.

**Instead:** Use GitHookBus for cross-domain communication. Extensions emit events; subscribers react independently.

### Anti-Pattern 3: Hardcoding Extension UI in Core Layout

**What:** Adding `<GitflowPanel />`, `<GitHubPanel />` etc. as direct imports in `RepositoryView.tsx`.

**Why bad:** Every new extension requires a core UI change. Defeats the extension system.

**Instead:** Use SidebarPanelRegistry. `RepositoryView.tsx` dynamically renders whatever panels are registered.

### Anti-Pattern 4: Extracting Store Slices While Keeping Cross-Slice Calls

**What:** Moving `gitflow.slice.ts` to standalone but importing `useGitOpsStore` for `loadBranches()`.

**Why bad:** Creates circular dependency between extension and core store.

**Instead:** GitHookBus emission on the extension side, hook subscription on the core side.

### Anti-Pattern 5: Premature Full Sandbox Implementation

**What:** Building Worker isolation, MessagePort bridge, and iframe blade rendering for v1.6.0.

**Why bad:** No untrusted extensions exist yet. Full sandbox is complex (serialization, async bridge, iframe rendering protocol). Building it before real use cases risks over-engineering.

**Instead:** Prepare (trust flags, serialization audit, API classification) but defer implementation to v1.7.0+ when marketplace/community extensions create real demand.

---

## Modifications to Existing Components

### Components to MODIFY

| File | Change | Rationale |
|------|--------|-----------|
| `src/extensions/ExtensionAPI.ts` | Add 6 new registration methods + cleanup tracking | New contribution points |
| `src/components/RepositoryView.tsx` | Read SidebarPanelRegistry, remove hardcoded `<GitflowPanel />` | Dynamic sidebar |
| `src/stores/domain/git-ops/index.ts` | Remove GitflowSlice from GitOpsStore composition | Gitflow extraction |
| `src/stores/bladeTypes.ts` | Remove `"gitflow-cheatsheet"`, `"conventional-commit"`, `"viewer-*"` from BladePropsMap | These become extension blades |
| `src/blades/_discovery.ts` | Remove extracted types from EXPECTED_TYPES | No longer core blades |
| `src/lib/fileDispatch.ts` | Refactor from static ReadonlyMap to mutable + registerFileDispatch/unregister | Extension viewer contribution |
| `src/commands/toolbar-actions.ts` | Remove `tb:gitflow-guide` core action | Moves to Gitflow extension |
| `src/stores/domain/git-ops/branches.slice.ts` | Add GitHookBus subscription for auto-refresh | Replace cross-slice coupling |
| `src/stores/domain/git-ops/repository.slice.ts` | Add GitHookBus subscription for auto-refresh | Replace cross-slice coupling |

### Components to CREATE

| File | Purpose |
|------|---------|
| `src/lib/contextMenuRegistry.ts` | Context menu item registry (Zustand store) |
| `src/lib/sidebarPanelRegistry.ts` | Sidebar panel registry (Zustand store) |
| `src/lib/statusBarRegistry.ts` | Status bar item registry (Zustand store) |
| `src/lib/gitHookBus.ts` | Git operation event bus |
| `src/components/ui/StatusBar.tsx` | Status bar UI component |
| `src/components/ui/ContextMenu.tsx` | Generic context menu component |
| `src/extensions/gitflow/` | Extracted Gitflow extension (7+ files) |
| `src/extensions/conventional-commits/` | Extracted CC extension (8+ files) |
| `src/extensions/content-viewers/` | Extracted viewers extension (6+ files) |

### Components to DELETE (after extraction)

| File | Replaced By |
|------|------------|
| `src/stores/domain/git-ops/gitflow.slice.ts` | `src/extensions/gitflow/gitflowStore.ts` |
| `src/components/gitflow/*.tsx` | `src/extensions/gitflow/components/*.tsx` |
| `src/blades/gitflow-cheatsheet/` | `src/extensions/gitflow/blades/` |
| `src/blades/conventional-commit/` | `src/extensions/conventional-commits/blades/` |
| `src/blades/viewer-{code,image,markdown,3d,nupkg}/` | `src/extensions/content-viewers/blades/` |
| `src/stores/conventional.ts` | `src/extensions/conventional-commits/conventionalStore.ts` |
| `src/hooks/useConventionalCommit.ts` | `src/extensions/conventional-commits/hooks/` |

---

## Build Order (Dependency-Driven)

The order matters because later phases depend on API surfaces from earlier phases.

### Phase 1: New Registries and API Expansion (Foundation)

Must come first because all extraction work depends on these contribution points.

1. ContextMenuRegistry -- Zustand store + types
2. SidebarPanelRegistry -- Zustand store + types
3. StatusBarRegistry -- Zustand store + types
4. GitHookBus -- Event bus module
5. ExtensionAPI expansion -- Add 6 new methods, update cleanup()
6. FileDispatch refactor -- Make extensible (registerFileDispatch/unregister)
7. ViewerRegistry source tagging -- Add source param for cleanup

### Phase 2: Core UI Surfaces

Build the UI components that consume the new registries.

1. Generic `<ContextMenu />` component
2. Dynamic sidebar in `RepositoryView.tsx` (read SidebarPanelRegistry)
3. `<StatusBar />` component at app bottom
4. GitHookBus wiring -- Core store slices emit and subscribe to hooks

### Phase 3: Feature Extraction (ordered by complexity, ascending)

1. **Content Viewers** -- Simplest: no state coupling, just blade + dispatch registrations
2. **Conventional Commits** -- Medium: standalone store already, minimal coupling to resolve
3. **Gitflow** -- Hardest: cross-slice deps need GitHookBus replacement, sidebar panel contribution, status bar widget

### Phase 4: Sandbox Preparation

1. Add `trusted` flag to ExtensionInfo
2. Serialization audit of registration configs
3. API surface classification (trusted-only vs sandbox-compatible)
4. Design doc for Worker bridge protocol (defer implementation)

### Phase Ordering Rationale

- **Registries before UI:** You cannot build dynamic sidebar without SidebarPanelRegistry
- **UI before extraction:** Extensions need contribution points to exist before they can contribute
- **Viewers before CC before Gitflow:** Ascending complexity. Viewers validate the pattern with zero risk. CC validates standalone store extraction. Gitflow tackles the hardest problem (cross-slice decoupling) last, with proven patterns.
- **Sandbox after extraction:** Extraction validates the API contract. Sandbox preparation ensures the contract is sandbox-compatible but does not require the full isolation implementation.

---

## Scalability Considerations

| Concern | At 5 extensions | At 20 extensions | At 50+ extensions |
|---------|----------------|-----------------|------------------|
| Registry size | Map lookups, negligible | Still negligible | Consider lazy registration |
| Context menu items | 3-5 items per location | Group separators essential | Sub-menus, search |
| Sidebar panels | 5-6 panels | Collapsible, scrollable | Panel visibility preferences, drag-reorder |
| Git hooks | ~10 listeners | 20-30 listeners | Priority ordering, timeout enforcement |
| Toolbar overflow | Existing overflow menu | Grouping critical | Configurable toolbar layout |
| Extension load time | Lazy imports, fast | Parallel activation | Activation priority, on-demand activation |
| Status bar | 3-4 items | Overflow/truncation needed | Configurable visibility |

---

## Sources

### Official Documentation
- [Tauri v2 Isolation Pattern](https://v2.tauri.app/concept/inter-process-communication/isolation/) -- iframe sandboxing, Windows ES Module limitations (HIGH confidence)
- [Tauri v2 Capabilities](https://v2.tauri.app/security/capabilities/) -- Permission system for IPC access (HIGH confidence)
- [Tauri v2 Future Security Work](https://v2.tauri.app/security/future/) -- Planned sandboxing improvements (MEDIUM confidence -- forward-looking)

### Extension System Patterns
- [VS Code Context Menus UX](https://code.visualstudio.com/api/ux-guidelines/context-menus) -- Context menu contribution pattern (HIGH confidence)
- [VS Code Contribution Points](https://code.visualstudio.com/api/references/contribution-points) -- General extension contribution architecture (HIGH confidence)
- [VS Code Status Bar](https://code.visualstudio.com/api/ux-guidelines/status-bar) -- Status bar widget pattern (HIGH confidence)
- [IntelliJ Status Bar Widgets](https://plugins.jetbrains.com/docs/intellij/status-bar-widgets.html) -- StatusBarWidgetFactory pattern (HIGH confidence)

### Sandboxing Research
- [Web Worker Sandboxing](https://gist.github.com/pfrazee/8949363) -- In-application sandboxing (MEDIUM confidence)
- [Building Secure Web Apps with Workers](https://engineering.mercari.com/en/blog/entry/20220930-building-secure-apps-using-web-workers/) -- Worker isolation patterns (MEDIUM confidence)

### Internal Codebase (PRIMARY -- HIGH confidence)
- `src/extensions/github/index.ts` -- Reference built-in extension implementation
- `src/lib/toolbarRegistry.ts` -- Reference Zustand registry pattern
- `src/stores/domain/git-ops/gitflow.slice.ts` -- Cross-slice deps to decouple
- `src/stores/domain/git-ops/index.ts` -- GitOpsStore composition (9 slices)
- `src-tauri/src/gitflow/commands.rs` -- Rust commands stay in core
- `src-tauri/src/git/conventional.rs` -- Rust CC stays in core
- `src/components/RepositoryView.tsx` -- Hardcoded sidebar to make dynamic
- `src/lib/fileDispatch.ts` -- Static dispatch map to make extensible
