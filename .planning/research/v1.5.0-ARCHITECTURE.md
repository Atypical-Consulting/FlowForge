# Architecture Patterns

**Domain:** Extension System, GitHub Integration, Toolbar UX for Desktop Git Client
**Researched:** 2026-02-09

---

## Recommended Architecture

### High-Level Component Map

```
+------------------------------------------------------------------+
|                        FlowForge App                              |
|                                                                   |
|  +---------------------------+  +------------------------------+  |
|  |     Toolbar System        |  |     Extension Host           |  |
|  |  - ToolbarItemRegistry    |  |  - ExtensionLoader           |  |
|  |  - useOverflowToolbar     |  |  - ExtensionRegistry         |  |
|  |  - ToolbarPreferences     |  |  - ExtensionAPI (sandboxed)  |  |
|  +---------------------------+  +------------------------------+  |
|                                                                   |
|  +---------------------------+  +------------------------------+  |
|  |     GitHub Extension      |  |     Core Registries          |  |
|  |  - GitHubStore (Zustand)  |  |  - BladeRegistry (existing)  |  |
|  |  - Octokit + React Query  |  |  - CommandRegistry (existing)|  |
|  |  - PR/Issue Blades        |  |  - ToolbarItemRegistry (new) |  |
|  +---------------------------+  +------------------------------+  |
|                                                                   |
+------------------------------------------------------------------+
|                        Tauri IPC Bridge                           |
+------------------------------------------------------------------+
|                                                                   |
|  +---------------------------+  +------------------------------+  |
|  |  GitHub Auth Module       |  |  Extension FS Module         |  |
|  |  (src-tauri/src/github/)  |  |  (src-tauri/src/extensions/) |  |
|  |  - device_flow.rs         |  |  - loader.rs                 |  |
|  |  - token.rs (keyring)     |  |  - manifest.rs               |  |
|  |  - commands.rs            |  |  - watcher.rs                |  |
|  +---------------------------+  +------------------------------+  |
|                                                                   |
+------------------------------------------------------------------+
```

### Component Boundaries

| Component | Responsibility | Communicates With |
|-----------|---------------|-------------------|
| **ExtensionLoader** (Rust) | Scan `.flowforge/extensions/`, parse manifests, validate | ExtensionRegistry (via IPC), Watcher |
| **ExtensionRegistry** (TS) | Track loaded extensions, lifecycle state, provide API | BladeRegistry, CommandRegistry, ToolbarItemRegistry |
| **ExtensionAPI** (TS) | Constrained API surface exposed to extensions | All registries (via proxy), GitHubStore (for GitHub ext) |
| **GitHubAuthModule** (Rust) | Device Flow, token storage/retrieval, token refresh | Keyring (OS), GitHub endpoints (reqwest) |
| **GitHubStore** (TS/Zustand) | Auth state, current user, repo detection | Rust backend (token commands), Octokit client |
| **GitHubExtension** (TS) | PR/Issue blades, commands, toolbar items | ExtensionAPI, GitHubStore, React Query + Octokit |
| **ToolbarItemRegistry** (TS) | Data-driven toolbar item management | Header component, preferences store |
| **useOverflowToolbar** (hook) | Measure/track which items fit in container | ToolbarItemRegistry, ResizeObserver |

### Data Flow

```
1. App Startup
   Rust: scan extensions dir -> parse manifests -> IPC: extension_list
   JS: ExtensionRegistry receives list -> for each enabled: dynamic import() bundle
       -> extension.activate(extensionAPI) -> registers blades/commands/toolbar items

2. OAuth Device Flow
   User: clicks "Sign in with GitHub"
   JS: calls Rust command `github_start_device_flow`
   Rust: POST github.com/login/device/code -> returns {user_code, verification_uri}
   JS: shows modal with code + "Open GitHub" button
   User: clicks button -> openUrl(verification_uri)
   Rust: polls github.com/login/oauth/access_token every 5s
   Rust: receives token -> stores in keyring -> returns success to JS
   JS: GitHubStore.setAuthenticated(true) -> triggers React Query to fetch user/PRs

3. Toolbar Overflow
   ResizeObserver fires on container resize
   useOverflowToolbar: measures each item ref width
   Calculates which items fit, moves rest to overflow array
   Header renders: visible items inline + "..." button with overflow dropdown
```

---

## Extension System Architecture

### Extension Manifest Format

Inspired by VS Code's `package.json` contribution points, adapted for FlowForge's simpler model.

```json
{
  "name": "github-integration",
  "version": "1.0.0",
  "displayName": "GitHub Integration",
  "description": "PR and issue management for GitHub repositories",
  "author": "FlowForge Team",
  "main": "dist/index.js",
  "icon": "github",
  "activationEvents": ["onRepo:github.com"],
  "contributes": {
    "blades": [
      {
        "type": "github-prs",
        "title": "Pull Requests",
        "singleton": true
      },
      {
        "type": "github-issues",
        "title": "Issues",
        "singleton": true
      },
      {
        "type": "github-create-pr",
        "title": "Create Pull Request"
      }
    ],
    "commands": [
      {
        "id": "github.viewPRs",
        "title": "View Pull Requests",
        "category": "GitHub",
        "icon": "git-pull-request"
      }
    ],
    "toolbarItems": [
      {
        "id": "github.prs",
        "command": "github.viewPRs",
        "icon": "git-pull-request",
        "group": "integrations",
        "priority": 100
      }
    ],
    "settings": {
      "github.defaultBase": {
        "type": "string",
        "default": "main",
        "description": "Default base branch for new PRs"
      }
    }
  }
}
```

### Extension Loading Sequence

```
1. Rust scans ~/.flowforge/extensions/ (or .flowforge/extensions/ per-repo)
2. For each dir: read manifest.json, validate structure, return to JS
3. JS ExtensionRegistry receives manifest list
4. For each enabled extension:
   a. Check activationEvents (e.g., "onRepo:github.com" matches current remote)
   b. If activated: dynamic import("extension-path/dist/index.js")
   c. Call extension.activate(api) where api is the constrained ExtensionAPI
   d. Extension calls api.registerBlade(), api.registerCommand(), etc.
5. On deactivation: call extension.deactivate(), unregister contributions
```

### ExtensionAPI Surface

```typescript
interface ExtensionAPI {
  // Registration
  registerBlade(config: ExtensionBladeConfig): Disposable;
  registerCommand(config: ExtensionCommandConfig): Disposable;
  registerToolbarItem(config: ExtensionToolbarConfig): Disposable;

  // Repository context
  getRepoPath(): string | null;
  getRemotes(): Promise<RemoteInfo[]>;
  getCurrentBranch(): string | null;

  // Settings (scoped to this extension)
  getSetting<T>(key: string): T | undefined;
  setSetting<T>(key: string, value: T): Promise<void>;

  // UI
  openBlade(type: string, props: Record<string, unknown>): void;
  showToast(message: string, type: "info" | "success" | "error"): void;

  // Lifecycle
  onDidChangeRepo(callback: () => void): Disposable;
}
```

**What ExtensionAPI does NOT expose:**
- Direct Tauri IPC (`invoke`)
- File system access
- Other extension state
- Global app state mutation
- Zustand store internals

### Extension Directory Structure

```
.flowforge/extensions/
  github-integration/
    manifest.json
    dist/
      index.js          (bundled extension code)
      index.js.map      (optional source map)
    assets/
      icon.svg          (optional)
```

---

## GitHub Integration Architecture

### Rust Module Structure

```
src-tauri/src/github/
  mod.rs              // Module declarations
  commands.rs         // Tauri commands (start_device_flow, get_token, etc.)
  device_flow.rs      // OAuth Device Flow implementation
  token.rs            // Keyring-based token storage
  types.rs            // Shared types (DeviceCode, TokenInfo, etc.)
```

### Token Storage Design

```rust
// token.rs
use keyring::Entry;

const SERVICE_NAME: &str = "com.flowforge.desktop";

pub fn store_token(account: &str, token: &str) -> Result<(), keyring::Error> {
    let entry = Entry::new(SERVICE_NAME, account)?;
    entry.set_password(token)
}

pub fn get_token(account: &str) -> Result<Option<String>, keyring::Error> {
    let entry = Entry::new(SERVICE_NAME, account)?;
    match entry.get_password() {
        Ok(token) => Ok(Some(token)),
        Err(keyring::Error::NoEntry) => Ok(None),
        Err(e) => Err(e),
    }
}
```

### Frontend GitHub Store

```typescript
// stores/domain/github/github.slice.ts (new domain store)
interface GitHubState {
  isAuthenticated: boolean;
  username: string | null;
  avatarUrl: string | null;
  currentRepoOwner: string | null;
  currentRepoName: string | null;
  isDetectingRepo: boolean;

  // Actions
  startDeviceFlow: () => Promise<DeviceFlowStatus>;
  checkAuthStatus: () => Promise<void>;
  signOut: () => Promise<void>;
  detectGitHubRepo: () => Promise<void>;
}
```

### React Query Integration

```typescript
// GitHub extension uses React Query for API data
const usePullRequests = (owner: string, repo: string) =>
  useQuery({
    queryKey: ["github", "prs", owner, repo],
    queryFn: () => octokit.rest.pulls.list({ owner, repo, state: "open" }),
    staleTime: 30_000,      // 30s -- PRs change frequently
    refetchInterval: 60_000, // Refetch every minute
  });

const useIssues = (owner: string, repo: string) =>
  useQuery({
    queryKey: ["github", "issues", owner, repo],
    queryFn: () => octokit.rest.issues.listForRepo({ owner, repo, state: "open" }),
    staleTime: 60_000,
  });
```

---

## Toolbar Architecture

### Data-Driven Toolbar Model

Current Header.tsx has hardcoded buttons. Transform to data-driven:

```typescript
interface ToolbarItem {
  id: string;
  label: string;
  icon: LucideIcon;
  action: () => void;
  group: "repo" | "navigation" | "tools" | "integrations" | "settings";
  priority: number;       // Lower = more important = shown first
  visible: boolean;       // User preference
  enabled: () => boolean; // Dynamic enable/disable
  requiresRepo: boolean;  // Only show when repo is open
  source: "core" | string; // "core" or extension name
}
```

### ToolbarItemRegistry

```typescript
// New registry, analogous to blade/command registries
const items = new Map<string, ToolbarItem>();

export function registerToolbarItem(item: ToolbarItem): void { ... }
export function unregisterToolbarItem(id: string): void { ... }
export function getToolbarItems(): ToolbarItem[] { ... }
export function getVisibleToolbarItems(): ToolbarItem[] { ... }
```

### useOverflowToolbar Hook

```typescript
function useOverflowToolbar(items: ToolbarItem[]) {
  const containerRef = useRef<HTMLDivElement>(null);
  const itemRefs = useRef<Map<string, HTMLElement>>(new Map());
  const [visibleCount, setVisibleCount] = useState(items.length);

  useEffect(() => {
    const observer = new ResizeObserver(([entry]) => {
      const containerWidth = entry.contentRect.width;
      let usedWidth = OVERFLOW_BUTTON_WIDTH;
      let count = 0;

      for (const item of items) {
        const el = itemRefs.current.get(item.id);
        const itemWidth = el?.getBoundingClientRect().width ?? ITEM_DEFAULT_WIDTH;
        if (usedWidth + itemWidth > containerWidth) break;
        usedWidth += itemWidth;
        count++;
      }

      setVisibleCount(count);
    });

    if (containerRef.current) observer.observe(containerRef.current);
    return () => observer.disconnect();
  }, [items]);

  return {
    containerRef,
    itemRefs,
    visibleItems: items.slice(0, visibleCount),
    overflowItems: items.slice(visibleCount),
  };
}
```

---

## Patterns to Follow

### Pattern 1: Disposable Registration

**What:** Every registration returns a `Disposable` that unregisters when called.
**When:** Extension registers blades, commands, toolbar items.
**Why:** Clean deactivation. Extension calls `disposable.dispose()` in its `deactivate()` function.

```typescript
interface Disposable {
  dispose(): void;
}

function registerBlade(config: BladeRegistration): Disposable {
  registry.set(config.type, config);
  return {
    dispose: () => registry.delete(config.type),
  };
}
```

### Pattern 2: Activation Events

**What:** Extensions declare when they should activate (not always-on).
**When:** GitHub extension activates only for repos with a github.com remote.
**Why:** Performance. Don't load/initialize extensions that aren't relevant.

```typescript
// activationEvents: ["onRepo:github.com"]
function shouldActivate(events: string[], context: AppContext): boolean {
  return events.some(event => {
    if (event === "*") return true;
    if (event.startsWith("onRepo:")) {
      const pattern = event.slice(7);
      return context.remotes.some(r => r.url.includes(pattern));
    }
    return false;
  });
}
```

### Pattern 3: Constrained API Surface

**What:** Extensions receive a limited API object, not full app access.
**When:** Extension `activate()` function is called.
**Why:** Security boundary. Extensions can't bypass intended integration points.

```typescript
function createExtensionAPI(extensionId: string): ExtensionAPI {
  return {
    registerBlade: (config) => {
      // Prefix blade type to avoid collisions
      const prefixedConfig = { ...config, type: `ext:${extensionId}:${config.type}` };
      return registerBlade(prefixedConfig);
    },
    // ... other constrained methods
  };
}
```

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: Global Octokit Instance

**What:** Creating a single global Octokit instance at app startup.
**Why bad:** Token might not exist yet. Token expires and needs refresh. Multiple GitHub accounts possible.
**Instead:** Create Octokit instance lazily in React Query's `queryFn`, getting token from GitHubStore each time. If token is invalid, React Query's error handling triggers re-auth.

### Anti-Pattern 2: Extension Direct Store Access

**What:** Letting extensions import and call Zustand stores directly.
**Why bad:** Tight coupling, no upgrade path, extensions can corrupt state.
**Instead:** ExtensionAPI provides controlled access to repo context, settings, and UI actions.

### Anti-Pattern 3: Hardcoded Toolbar in JSX

**What:** Keeping the current pattern of 15 `<Button>` elements in Header.tsx.
**Why bad:** Can't support extension-contributed items, can't overflow, can't customize visibility.
**Instead:** Data-driven ToolbarItemRegistry. Header.tsx renders from registry, not hardcoded elements.

### Anti-Pattern 4: Storing OAuth Tokens in tauri-plugin-store

**What:** Saving GitHub tokens in the same JSON file as settings.
**Why bad:** `flowforge-settings.json` is a plain file on disk. Tokens are sensitive credentials.
**Instead:** Use keyring crate for OS-native encrypted credential storage.

### Anti-Pattern 5: Synchronous Extension Loading

**What:** Loading all extension bundles before rendering the app.
**Why bad:** Extensions might be large or numerous. Blocks initial render.
**Instead:** Load extension manifests synchronously (they're small JSON), then `import()` bundles asynchronously after app renders. Use React Suspense boundaries for extension blades.

---

## Scalability Considerations

| Concern | 1-2 Extensions | 10 Extensions | 50+ Extensions |
|---------|----------------|---------------|----------------|
| Load time | Negligible (dynamic import) | ~200ms if bundled well | Need lazy activation + code splitting |
| Memory | No concern | Moderate (each extension has React components) | Need unload inactive extensions |
| Toolbar | 1-3 extra items | Overflow menu essential | Need categories/sections in overflow |
| Command palette | Works naturally | Category filtering becomes important | Need search + fuzzy matching (already have) |
| Settings UI | Simple list | Collapsible sections per extension | Searchable settings (defer) |

---

## Sources

- [VS Code Extension Manifest](https://code.visualstudio.com/api/references/extension-manifest) -- manifest format inspiration
- [VS Code Contribution Points](https://code.visualstudio.com/api/references/contribution-points) -- contribution point model
- [Chrome Extension Manifest V3](https://developer.chrome.com/docs/extensions/reference/manifest) -- manifest validation patterns
- [Tauri v2 Plugin Development](https://v2.tauri.app/develop/plugins/) -- Tauri extension patterns
- [keyring crate docs](https://docs.rs/keyring) -- token storage API
- [GitHub OAuth Device Flow](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps) -- auth flow
- [ResizeObserver MDN](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) -- overflow measurement
- [Collapsible Overflow Menu in React](https://dev.to/shubhamreacts/how-to-implement-a-collapsible-overflow-menu-in-react-5cn8) -- implementation pattern
