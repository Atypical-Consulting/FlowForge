# Research Summary: FlowForge v1.4.0

**Domain:** Desktop Git client -- navigation architecture, testing, API integration
**Researched:** 2026-02-08
**Overall confidence:** HIGH

## Executive Summary

FlowForge v1.4.0 introduces three orthogonal capabilities: a formalized navigation finite state machine (XState), a test infrastructure foundation (Vitest + Testing Library), and GitHub gitignore template integration for the Init Repo blade. Research confirms all three are straightforward additions with no architectural conflicts.

The XState navigation FSM is the most architecturally significant change. The current blade navigation system (21 Zustand stores, implicit stack-based FSM in `useBladeStore`, ad-hoc singleton guards in `useBladeNavigation`) works but has no formal transition rules. XState v5.26 with `@xstate/react` v6 provides type-safe state machines that coexist cleanly with Zustand -- XState owns the navigation FSM while Zustand retains ownership of simple UI state (toasts, theme, dropdowns). The `useSelector` hook enables granular subscriptions that avoid performance pitfalls.

The test infrastructure is a greenfield addition -- FlowForge currently has zero frontend test files (Rust side has some via `#[cfg(test)]`). Vitest 4.0 is the natural choice: it shares Vite 7.3's config natively, supports React 19 through `@testing-library/react` v16, and its jsdom environment handles the project's complex DOM dependencies (Monaco, Three.js, framer-motion). The main challenge is mocking Tauri IPC calls (`invoke`), which requires a clean mock strategy for the 50+ specta-generated commands.

GitHub gitignore API integration is the simplest addition. The public API (`GET /gitignore/templates`) requires no authentication and returns a simple string array. Following the established pattern, this should be a Rust Tauri command using `reqwest` (already a transitive dependency) rather than the `@tauri-apps/plugin-http` frontend plugin. This keeps HTTP calls in the Rust layer, consistent with the project's architecture.

## Key Findings

**Stack:** Add `xstate` + `@xstate/react` for navigation FSM, `vitest` + Testing Library for tests, and `reqwest` (Rust) for GitHub API. No existing dependencies change.
**Architecture:** XState replaces `useBladeStore` Zustand store; all other 20 Zustand stores remain unchanged. Navigation becomes a singleton XState actor.
**Critical pitfall:** XState and Zustand store confusion -- must draw a clear ownership boundary. XState owns navigation transitions; Zustand owns simple state.

## Implications for Roadmap

Based on research, suggested phase structure:

1. **Test Infrastructure Foundation** - Set up Vitest, write first tests for pure utilities
   - Addresses: Zero test coverage, establishes patterns for Tauri mock strategy
   - Avoids: Starting XState migration without a safety net
   - Rationale: Tests first -- they validate the XState migration and all subsequent work

2. **XState Navigation FSM** - Replace `useBladeStore` with XState machine
   - Addresses: Implicit navigation states, missing transition guards, singleton detection
   - Avoids: Big-bang rewrite; can coexist with Zustand during migration
   - Rationale: Depends on test infra being in place to validate transition logic

3. **Zustand Store Consolidation** - Merge related stores, clean up tech debt
   - Addresses: 21 scattered stores, duplicated patterns
   - Avoids: Consolidating before navigation FSM is stable (would create merge conflicts)
   - Rationale: Once navigation is in XState, remaining Zustand stores are simpler to reason about

4. **Init Repo Blade + Gitignore Templates** - New blade with GitHub API integration
   - Addresses: Missing repo initialization UI, gitignore template search
   - Avoids: Building UI before navigation FSM handles the new blade type
   - Rationale: New blade type registered in XState machine; uses test infra for validation

5. **Conventional Commit Blade** - Dedicated commit composition UI
   - Addresses: Scattered commit UI, existing `git-conventional` Rust crate underutilized
   - Avoids: Building before store consolidation (would create yet another store)
   - Rationale: Depends on consolidated stores and XState navigation for blade management

**Phase ordering rationale:**
- Test infra first because it validates everything that follows
- XState before store consolidation because navigation FSM extraction simplifies what remains
- Init Repo blade after XState because it needs to be registered as a new state in the machine
- Conventional Commit blade last because it depends on both navigation and store consolidation

**Research flags for phases:**
- Phase 2 (XState): Needs careful migration plan -- `useBladeStore` is used in ~30 files
- Phase 4 (Gitignore API): Standard pattern, unlikely to need research. GitHub API is simple and well-documented.
- Phase 5 (Conventional Commit): May need UX research on commit message composition patterns

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack (XState) | HIGH | Versions verified via npm, peer deps confirmed compatible |
| Stack (Vitest) | HIGH | Versions verified, Vite 7 support confirmed in Vitest 4 |
| Stack (reqwest) | HIGH | Already transitive dep, tokio runtime available |
| Features | MEDIUM | Feature scope is defined but UX for Init Repo blade and Conventional Commit blade need design |
| Architecture (XState + Zustand) | HIGH | Well-documented coexistence pattern, singleton actor approach proven |
| Architecture (Tauri commands) | HIGH | Established pattern with 50+ existing commands |
| Pitfalls | HIGH | XState migration complexity is the main risk, well-understood |

## Gaps to Address

- **XState machine design:** The exact states, events, and guards for the navigation FSM need detailed design during implementation. Research confirms the tooling; the state chart itself is domain-specific.
- **Tauri IPC mocking patterns:** Need to establish a reusable mock factory for `tauri-specta` generated bindings in tests. No existing pattern in the codebase.
- **Offline gitignore fallback:** What happens when GitHub API is unreachable? Need a small bundled fallback set or graceful degradation.
- **CI test integration:** The existing CI workflows (GitHub Actions) need `test:run` added. Currently only builds and type-checks.
