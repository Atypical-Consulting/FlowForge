# Project Research Summary

**Project:** FlowForge v1.6.0 — Refactor to Extensions
**Domain:** Desktop Git client extension platform expansion
**Researched:** 2026-02-10
**Confidence:** HIGH

## Executive Summary

FlowForge v1.6.0 represents a critical architectural evolution: extracting three major built-in features (Gitflow, Conventional Commits, and content viewers) from core into extensions, while expanding the extension API to support context menus, sidebar panels, status bar widgets, and git operation hooks. Expert research reveals this follows established patterns from VS Code, JetBrains IDEs, and Zed—registry-based contribution systems with typed context surfaces and event-driven decoupling. The recommended approach uses Web Workers for future third-party isolation (avoiding Tauri's problematic iframe sandbox limitations on Windows), while built-in extensions continue running in-process with full React component access.

The critical risk is state split-brain during Gitflow extraction. Gitflow's state machine lives in Rust, but the current frontend slice lives in a combined GitOpsStore with cross-slice calls to other domains. Extraction requires event-based decoupling via a new GitHookBus to prevent circular imports while preserving the single source of truth in Rust. The second major risk is sidebar breakage—the RepositoryView currently hardcodes the GitflowPanel, so a registry-based sidebar panel contribution system must be built BEFORE extraction begins to avoid visual regressions.

Confidence is high because FlowForge already has a proven extension pattern (GitHub extension), established registry infrastructure (blades, commands, toolbar), and the research identifies specific extraction boundaries for each feature. The stack requires only ONE new dependency (@radix-ui/react-context-menu), with all other surfaces built on existing primitives (Zustand registries, React components, platform Web Worker APIs).

## Key Findings

### Recommended Stack

FlowForge's existing stack (Tauri 2, React 19, TypeScript 5.9, Zustand 5, XState v5) remains unchanged. The only addition is @radix-ui/react-context-menu for accessible right-click menus—a 32KB dependency that handles ARIA keyboard navigation, nested submenus, portal rendering, and dismissal logic that would require 400-600 lines of custom code. Web Workers (platform built-in) provide thread-isolated sandboxing for future third-party extensions without CSP changes, avoiding Tauri's documented Windows ES Module limitations with iframes.

**Core additions:**
- @radix-ui/react-context-menu (v2.2.16): Headless context menu primitives — mature library (1,281+ dependents), works with existing Tailwind v4 styling, handles all accessibility concerns
- Web Worker API (platform built-in): True thread isolation for sandboxed extensions — no DOM access, no Tauri IPC access, already allowed by CSP worker-src directive
- MessageChannel API (platform built-in): Private bidirectional communication between host and sandbox — structured clone protocol, per-extension channels prevent cross-extension leaks
- Zustand registries (existing): New registries for context menus, sidebar panels, status bar, git hooks — proven pattern from toolbar/blade/command registries

**Critical decision:** Web Workers over iframes for future sandboxing. Tauri documentation explicitly warns "external files do not load correctly inside sandboxed iframes on Windows" and "ES Modules will not successfully load in sandboxed iframes." Workers provide true thread isolation, no DOM access (preventing UI scraping), and no Tauri IPC access (preventing filesystem/OS calls). Alternative approaches (SES/Hardened JS requires global lockdown affecting all code; QuickJS/WASM adds 200KB+ and requires wasm-unsafe-eval CSP regression; ShadowRealm not implemented in any browser as of Feb 2026).

### Expected Features

**Must have (table stakes):**
- Context menu system with typed locations (file-list, branch-list, commit-list, blade-tab, sidebar-section) — every extensible editor provides this, critical for feature discoverability after extraction
- Sidebar panel contribution API with priority ordering and visibility conditions — required to remove hardcoded GitflowPanel from RepositoryView.tsx
- Extension enable/disable with graceful UI absence — users already toggle GitHub extension; extracted features inherit this pattern
- Git operation hooks (at minimum: onWillCommit, onDidCommit) — enables Conventional Commits validation without core commit form knowing about CC format
- Clean lifecycle activation/deactivation with subscription cleanup — already proven by GitHub extension, must extend to new registries

**Should have (competitive differentiators):**
- Status bar widget system with left/right alignment — standard in all editors, natural home for extension indicators (branch state, flow status, sync status)
- Extension settings contribution via unified Settings blade — Gitflow needs prefix config, CC needs scope count settings; fragmented per-extension settings blades harm discoverability
- Pre/post hooks for all major git operations — unique advantage since FlowForge owns the Rust backend (VS Code's Git extension is opaque to other extensions)

**Defer (v2+):**
- Full process isolation / Worker sandbox implementation — prep the API boundary, but defer actual sandboxing until third-party extensions exist
- Extension marketplace infrastructure — no demand exists at v1.6 stage
- Permission/capability system — only matters when untrusted third-party extensions are installed
- Extension-to-extension communication API — no current extension needs it; adds coupling; add when proven necessary
- Activation events / lazy loading refinement — current "activate on repo open" works fine for 5-6 built-in extensions

### Architecture Approach

The extension platform expansion follows the proven pattern established by the GitHub extension: registry-based contributions with namespaced IDs, ExtensionAPI facade for registration, ExtensionHost lifecycle management, and source-tagged cleanup. The critical architectural challenge is decoupling Gitflow from the monolithic GitOpsStore (9 slices combined) without breaking cross-domain refresh logic.

**Major components:**

1. **New Registries (4 Zustand stores)** — ContextMenuRegistry, SidebarPanelRegistry, StatusBarRegistry, GitHookRegistry — follow exact pattern from ToolbarRegistry (Map-based storage, source tagging, priority sorting, visibility conditions)

2. **ExtensionAPI Expansion** — Add 6 new methods: contributeContextMenu, contributeSidebarPanel, contributeStatusBar, registerGitHook, registerViewer, registerFileDispatch — maintain existing namespacing and cleanup tracking pattern

3. **GitHookBus Event System (NEW pattern)** — Pub/sub middleware for git operations replacing cross-slice calls — extensions emit events after operations (gitHookBus.emit("after", "merge", {...})), core slices subscribe to refresh themselves, eliminates circular import risk during extraction

4. **Extraction Boundaries:**
   - Gitflow: Move slice to standalone extension store, 7 components to extension dir, contribute sidebar panel/status bar/context menus via API, emit GitHookBus events instead of calling get().loadBranches()
   - Conventional Commits: Already standalone store (createBladeStore pattern), move blade + components to extension, register onWillCommit hook for validation
   - Content Viewers: Simplest extraction — each viewer is self-contained blade, no state coupling, register via api.registerBlade() + api.registerFileDispatch()

5. **Rust Backend** — STAYS IN CORE (not extracted) — Tauri commands cannot be dynamically registered; gitflow::commands and git::conventional remain as IPC-exposed capabilities that extensions consume; extraction is frontend-only

**Key pattern: Built-in extensions run in-process with full React component access. Future third-party extensions run in Workers with serialized API subset. The ExtensionManifest gains a sandbox: boolean field (default true for external, false for built-in).**

### Critical Pitfalls

1. **Gitflow State Split-Brain** — The Rust state machine (gitflow/machine.rs) is the sole source of truth, but extraction tempts caching state in the extension store. If the extension holds stale GitflowStatus while user switches branches via core UI (checkout_branch, not a Gitflow command), extension shows wrong active flow. Prevention: Extension MUST re-fetch from commands.getGitflowStatus() after every operation, never optimistically cache state. Subscribe to BranchSlice changes to detect external checkouts.

2. **Circular Import Death Spiral** — Gitflow slice currently calls get().loadBranches() and get().refreshRepoStatus() (cross-slice in combined store). After extraction to standalone extension store, these become circular imports: extension needs core store, core would import extension. Prevention: GitHookBus decouples — extension emits events, core subscribes. Zero direct imports between extension and GitOpsStore.

3. **RepositoryView Sidebar Breakage** — Lines 119-127 hardcode `<GitflowPanel />` in JSX. Extraction without registry-based dynamic rendering breaks layout for ALL users (spacing, scroll, sticky headers). Prevention: Build SidebarPanelRegistry FIRST as Phase 1 prerequisite. Extract `<details>` pattern into `<SidebarSection>` component, register core sections (Branches, Stashes, Tags, Worktrees) as source:"core", then extract Gitflow panel via api.contributeSidebarPanel().

4. **Extension Deactivation Orphans UI** — Current cleanup() only handles blade/command/toolbar registries. New registries (sidebar, status bar, context menu, hooks) need corresponding unregisterBySource() calls. Prevention: Extend cleanup() to cover all new registries. Add api.onDispose(callback) method that extensions use to register custom teardown (Zustand subscriptions, timers, etc.). Test: disable extension, verify no console errors for 10 seconds, verify UI contributions removed.

5. **Hook Ordering Non-Determinism** — Multiple extensions registering onBeforeCommit handlers execute in insertion order (depends on activation order, varies by platform). If one modifies commit message and another validates it, order matters. Prevention: For v1.6, use tap-only hooks (observation without modification) to avoid pipeline complexity. Add priority field for v1.7+ intercept hooks. Document that extensions must not depend on execution order relative to other extensions.

## Implications for Roadmap

Based on research, suggested phase structure with strict dependency ordering:

### Phase 1: Foundation — New Registries and API Expansion
**Rationale:** All extraction work depends on these contribution points existing first. Building registries before extracting features eliminates rework.

**Delivers:**
- ContextMenuRegistry (Zustand store with typed location contexts)
- SidebarPanelRegistry (priority-ordered panel contributions)
- StatusBarRegistry (left/right aligned widget system)
- GitHookRegistry / GitHookBus (pub/sub event system for git operations)
- ExtensionAPI expansion (6 new methods with namespace/cleanup tracking)
- FileDispatch refactor (make extensible from static ReadonlyMap)
- ViewerRegistry source tagging (enable cleanup by extension)

**Addresses:** Table stakes features (context menus, sidebar contributions, status bar)

**Avoids:** Pitfall #2 (circular imports) by providing event-based decoupling before extraction starts

**Research flag:** Standard patterns — ToolbarRegistry provides exact template. Skip research-phase.

### Phase 2: Core UI Surfaces
**Rationale:** Build UI components that consume new registries. Must happen before extraction so extensions have rendering targets.

**Delivers:**
- Generic `<ContextMenu />` component (Radix integration)
- Dynamic sidebar in RepositoryView (reads SidebarPanelRegistry, replaces hardcoded sections)
- `<StatusBar />` component at app bottom (renders registered widgets)
- GitHookBus wiring in core stores (BranchSlice/RepositorySlice subscribe to refresh)

**Uses:** @radix-ui/react-context-menu for accessible menus

**Addresses:** Prevents Pitfall #3 (sidebar breakage) — registry-based rendering in place before touching Gitflow

**Research flag:** Radix Context Menu integration — well-documented library, skip research-phase.

### Phase 3: Content Viewer Extraction (Prove the Pattern)
**Rationale:** Viewers are the simplest extraction (no state coupling, self-contained blades). Validates the entire extraction pattern with minimal risk before tackling complex features.

**Delivers:**
- viewer-code, viewer-image, viewer-markdown, viewer-3d, viewer-nupkg extracted to extensions/content-viewers/
- Each viewer registers via api.registerBlade() + api.registerFileDispatch()
- Context menu "Open with..." contributions

**Addresses:** Proves extraction pattern, reduces bundle size (Three.js, Monaco, react-markdown become optional)

**Avoids:** Low complexity, no pitfalls apply — this is the risk-free validation phase

**Research flag:** Standard blade extraction — skip research-phase.

### Phase 4: Conventional Commits Extraction
**Rationale:** Medium complexity — standalone store already exists (createBladeStore), minimal core coupling compared to Gitflow.

**Delivers:**
- CC blade, store, components, utilities moved to extensions/conventional-commits/
- onWillCommit hook registration for commit message validation
- Toolbar action to open CC blade
- Extension settings for scope count, type suggestions

**Addresses:** Differentiator feature (commit message interceptor)

**Avoids:** Pitfall #4 (entanglement) — built-in extensions can import core modules; don't over-decouple

**Research flag:** Hook system design needs validation — run targeted research-phase on onWillCommit middleware pattern and cancellation semantics.

### Phase 5: Gitflow Extraction (Hardest Challenge)
**Rationale:** Most complex extraction — cross-slice dependencies, Rust state machine coordination, largest UI surface area. Tackle last with proven patterns from viewer and CC extractions.

**Delivers:**
- Gitflow slice moved to standalone extension store (extensions/gitflow/gitflowStore.ts)
- GitflowPanel contributed via api.contributeSidebarPanel()
- Status bar widget showing active flow
- Context menu actions on branches (Start Feature, Start Release, Start Hotfix)
- GitHookBus emission after operations instead of cross-slice get() calls
- 7 components, 1 blade, 6+ commands, settings integration

**Addresses:** Enables "plain Git client" use case (disable Gitflow if not using that workflow)

**Avoids:** Pitfall #1 (split-brain) via Rust-as-source-of-truth discipline, Pitfall #2 (circular imports) via GitHookBus, Pitfall #5 (deactivation) via api.onDispose()

**Research flag:** State machine coordination — run targeted research-phase on managing Rust state machine through frontend extension boundary, ensure no split-brain patterns.

### Phase 6: Sandbox Preparation (Not Production Deployment)
**Rationale:** With all built-in extensions proven, prepare API boundary for future third-party isolation. This is architectural prep, not working sandbox.

**Delivers:**
- Add trusted: boolean flag to ExtensionInfo (built-in = true)
- Serialization audit of registration configs (ensure JSON-safe except React components)
- API surface classification (which ExtensionAPI methods are sandbox-compatible vs trusted-only)
- Design doc for Worker MessageChannel bridge protocol (proof-of-concept, not production)
- Permission/capability mapping design (ExtensionManifest.permissions -> Tauri IPC scope)

**Addresses:** Future-proofing for v1.7+ third-party extensions

**Avoids:** Pitfall #7 (iframe IPC blocked) by using Worker design, not iframes

**Research flag:** Worker sandbox architecture — needs targeted research-phase on MessageChannel bridge protocol, structured clone limitations, and async API wrapping.

### Phase Ordering Rationale

- **Registries before UI before extraction:** You cannot extract features to use APIs that don't exist. Registries -> UI surfaces -> feature extraction is the only dependency-safe order.
- **Viewers first, CC second, Gitflow last:** Ascending complexity. Viewers validate the pattern with zero state coupling. CC validates store extraction with standalone store. Gitflow tackles the hardest problem (cross-slice decoupling + Rust state) last with proven patterns.
- **Sandbox prep after all extractions:** Extraction validates the API contract. Sandbox prep ensures the contract is sandbox-compatible but defers implementation until third-party demand exists (v1.7+).
- **GitHookBus in Phase 1, not Phase 5:** The decoupling mechanism must exist BEFORE Gitflow extraction begins. Building it during Gitflow extraction creates chicken-and-egg coupling.

### Research Flags

Phases likely needing deeper research during planning:

- **Phase 4 (CC Extraction):** Commit message interceptor middleware — needs validation of cancellation semantics, async handler coordination, and error propagation to UI. Run targeted research-phase on VS Code's pre-commit validation pattern.
- **Phase 5 (Gitflow Extraction):** Rust state machine coordination — needs validation that no split-brain patterns emerge. Run targeted research-phase specifically on "frontend extension managing Rust state machine" patterns and event-driven state sync.
- **Phase 6 (Sandbox Prep):** Worker MessageChannel bridge — needs deep dive on structured clone algorithm limitations, async API wrapping patterns, and transferable object handling. Run research-phase on VS Code's Extension Host process architecture and Figma's WASM plugin boundary.

Phases with standard patterns (skip research-phase):

- **Phase 1 (Registries):** ToolbarRegistry provides exact template. Zustand store with Map<string, Item>, source tagging, priority sorting, visibility conditions. Zero novelty.
- **Phase 2 (UI Surfaces):** Dynamic rendering from registries already proven in BladeRenderer. Radix Context Menu is well-documented. Sidebar is just mapped `<details>` elements.
- **Phase 3 (Viewers):** Blade extraction with no state coupling. Each viewer is 1 blade + 1 fileDispatch entry. Mechanical refactor.

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | Only 1 new dependency. Web Worker choice validated against Tauri v2 docs. CSP compatibility verified. |
| Features | HIGH | Table stakes features identified from VS Code/JetBrains patterns. GitHub extension proves viability. |
| Architecture | HIGH | ToolbarRegistry pattern proven, GitHookBus follows standard pub/sub, extraction boundaries clear. |
| Pitfalls | HIGH | Codebase analysis identified all cross-slice coupling points. Gitflow state machine risk explicitly documented in Rust code. |

**Overall confidence:** HIGH

All recommendations are grounded in existing FlowForge patterns (GitHub extension, registry infrastructure) and industry-standard extension architectures (VS Code contribution points, JetBrains extension points). The only novel elements are (1) GitHookBus for cross-domain event coordination and (2) Worker sandbox prep—both well-researched with clear precedents.

### Gaps to Address

1. **Commit message validation UX:** Research identified that CC needs onWillCommit hook to validate messages, but didn't specify how validation failures surface to the user. During Phase 4 planning, validate whether: (a) hook throws error that commit form catches, (b) hook returns { cancel: true, reason: "..." } that form displays, or (c) hook shows toast notification and returns quietly. VS Code pattern research suggested (b).

2. **Extension activation timing:** If Gitflow extension registers a sidebar panel during activate(), but RepositoryView renders before activation completes, the panel won't appear until state update. During Phase 2 planning, ensure SidebarPanelRegistry triggers re-render when new panels register (likely via Zustand subscription, already handled by selector pattern).

3. **Context menu location granularity:** Research suggests 5-7 menu locations, but didn't specify sub-locations (e.g., does "branch-list" need separate contexts for local vs remote branches, current vs non-current?). During Phase 1 planning, audit all list components to identify context variations needed for when() clauses.

4. **Hook re-entrancy scenarios:** Pitfall #15 warns about hook cascades (hook triggers operation that fires hook), but research didn't enumerate all re-entrancy paths. During Phase 4 planning (hook system design), map all git operations to their potential downstream operations and design suppression strategy (isInternal flag + re-entrancy guard).

## Sources

### Primary (HIGH confidence)
- [Tauri v2 CSP Documentation](https://v2.tauri.app/security/csp/) — Worker CSP compatibility, iframe limitations
- [Tauri v2 Isolation Pattern](https://v2.tauri.app/concept/inter-process-communication/isolation/) — Windows ES Module sandbox issues
- [MDN Web Workers API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) — Thread isolation capabilities
- [MDN MessageChannel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel) — Bidirectional communication protocol
- [Radix Context Menu Documentation](https://www.radix-ui.com/primitives/docs/components/context-menu) — Accessibility patterns, keyboard navigation
- [@radix-ui/react-context-menu npm](https://www.npmjs.com/package/@radix-ui/react-context-menu) — Version compatibility, peer deps
- [VS Code Contribution Points](https://code.visualstudio.com/api/references/contribution-points) — Extension architecture patterns
- [VS Code Context Menu UX Guidelines](https://code.visualstudio.com/api/ux-guidelines/context-menus) — Menu location design
- [VS Code Status Bar API](https://code.visualstudio.com/api/ux-guidelines/status-bar) — Widget alignment patterns
- [IntelliJ Status Bar Widgets](https://plugins.jetbrains.com/docs/intellij/status-bar-widgets.html) — StatusBarWidgetFactory pattern
- FlowForge codebase — ExtensionHost.ts, ExtensionAPI.ts, toolbarRegistry.ts, bladeRegistry.ts, github/index.ts, gitflow.slice.ts, RepositoryView.tsx (direct analysis)

### Secondary (MEDIUM confidence)
- [VS Code Extension Host Architecture](https://code.visualstudio.com/api/advanced-topics/extension-host) — Process isolation patterns
- [Figma Plugin Architecture](https://developers.figma.com/docs/plugins/how-plugins-run/) — WASM sandbox alternative
- [Browser Sandbox Architecture (Alex Griss)](https://alexgriss.tech/en/blog/javascript-sandboxes/) — Worker vs iframe tradeoffs
- [Hardened JavaScript / SES](https://hardenedjs.org/) — Compartment-based isolation (not chosen)
- [TC39 ShadowRealm Proposal](https://github.com/tc39/proposal-shadowrealm) — Stage 2.7 status (not browser-ready)
- [Zustand Slices Pattern](https://zustand.docs.pmnd.rs/guides/slices-pattern) — Slice extraction best practices
- [IntelliJ Plugin Extensions](https://plugins.jetbrains.com/docs/intellij/plugin-extensions.html) — Extension point registration patterns

### Tertiary (LOW confidence)
- [Tauri Future Security Work](https://v2.tauri.app/security/future/) — Forward-looking plans (not yet implemented)
- [Web Worker Sandboxing Gist](https://gist.github.com/pfrazee/8949363) — In-app sandboxing experiments (needs validation)

---
*Research completed: 2026-02-10*
*Ready for roadmap: yes*
