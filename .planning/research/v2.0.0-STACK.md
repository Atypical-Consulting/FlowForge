# Technology Stack: Monorepo Conversion

**Project:** FlowForge v2.0.0 -- Monorepo & Framework Extraction
**Researched:** 2026-02-15
**Overall Confidence:** HIGH

## Context

FlowForge is a 60K LOC Tauri desktop app currently structured as a single package. The goal is to extract reusable packages (UI framework, extension platform, store patterns) into an internal monorepo while keeping FlowForge working identically. A second empty app skeleton must prove the framework works.

**Existing stack (DO NOT change):** Vite 7.3, React 19, TypeScript 5.9, Tailwind v4, Biome 2.3, Vitest 4, Tauri 2 CLI.

---

## Recommended Stack Additions

### Package Manager: pnpm 10.x with Workspaces

| Technology | Version | Purpose | Why |
|------------|---------|---------|-----|
| pnpm | ^10.29 | Package manager + workspace orchestration | Strict `node_modules` prevents phantom dependencies (critical when extracting packages). Content-addressable store saves disk space. Native workspace protocol (`workspace:*`) for internal package linking. npm is currently used but lacks workspace support and strict isolation. |

**Migration from npm:** One-time switch. Delete `node_modules` and `package-lock.json`, run `pnpm import` if needed, then `pnpm install`. The `pnpm-workspace.yaml` file defines workspace members.

**Confidence:** HIGH -- pnpm workspaces are the de facto standard for TypeScript monorepos. Official Tauri documentation acknowledges pnpm as a supported package manager. Known issue: `tauri add` may not detect pnpm in workspaces (GitHub issue #12706), workaround is to run from the app directory.

### Task Orchestration: Turborepo 2.8.x

| Technology | Version | Purpose | Why |
|------------|---------|---------|-----|
| turbo | ^2.8.7 | Build orchestration, caching, task pipelines | Adds to existing pnpm workspace in under 10 minutes. Zero-config for basic use. Understands package dependency graph for correct build order. Remote caching optional (not needed initially). Written in Rust -- fast. |

**Why Turborepo over Nx:** FlowForge is a JS/TS-focused project with a simple dependency graph (3-5 packages initially). Turborepo is the right tool because:
- Nx is overkill: its plugin system, generators, and dependency graph visualization solve enterprise problems FlowForge does not have.
- Turborepo is additive: it layers on top of pnpm workspaces without restructuring. Nx wants to own the workspace.
- Migration from Nx is hard; migration from Turborepo is trivial (it is just a `turbo.json` config).
- Nx would require learning its mental model. Turborepo requires learning one config file.

**Why NOT "just pnpm scripts":** pnpm `--filter` and `-r` can orchestrate builds, but Turborepo adds intelligent caching (hash-based), parallel execution with dependency awareness, and pipeline definitions. These matter once you have 5+ packages with interdependencies.

**Confidence:** HIGH -- Turborepo 2.8.x is current stable. Widely used with Vite, React, and Tauri projects.

### Internal Package Strategy: Just-in-Time (No Build Step)

| Strategy | Purpose | Why |
|----------|---------|-----|
| Just-in-Time Packages | Export raw TypeScript from internal packages | All consumers (FlowForge app, second app skeleton) use Vite, which natively handles TypeScript transpilation. No need for a separate `tsc` build per package. Faster development cycle -- edit a package file, consumer hot-reloads immediately. |

**How it works:** Each internal package's `package.json` points `exports` directly to `.ts`/`.tsx` source files. The consuming app's Vite bundler transpiles everything. No `dist/` directory, no build step per package.

```json
{
  "name": "@flowforge/ui",
  "exports": {
    ".": "./src/index.ts",
    "./button": "./src/components/button.tsx"
  }
}
```

**Trade-off acknowledged:** Turborepo cannot cache Just-in-Time package builds (there is no build to cache). This is acceptable because:
1. The app build itself is cached by Turborepo.
2. TypeScript type-checking (`tsc --noEmit`) per package IS cacheable.
3. The package count is small (3-5 packages), so build times remain fast.

**When to switch to Compiled:** If a package needs to be published to npm externally, convert that specific package to a compiled strategy with `tsc` or `tsup`. This is a per-package decision, not a monorepo-wide one.

**Confidence:** HIGH -- This is Turborepo's officially documented and recommended approach for internal packages that will not be published to npm.

### TypeScript Project References: YES, But Lightweight

| Technology | Version | Purpose | Why |
|------------|---------|---------|-----|
| TypeScript composite projects | TS 5.9 (existing) | Incremental type-checking across packages | Enables `tsc --build` to type-check only changed packages. Produces `.tsbuildinfo` for incremental rebuilds. Works with existing `tsconfig.node.json` pattern. |

**Configuration approach:**

Root `tsconfig.json` becomes a "solution" file that references all packages:
```json
{
  "references": [
    { "path": "packages/core" },
    { "path": "packages/ui" },
    { "path": "packages/extensions" },
    { "path": "apps/flowforge" },
    { "path": "apps/skeleton" }
  ],
  "files": []
}
```

Each package has `"composite": true` and `"declaration": true` in its `tsconfig.json`.

**Why not skip project references entirely?** Turborepo's blog post "You Might Not Need TypeScript Project References" argues they add complexity. However, for FlowForge:
- The existing codebase already uses `references` (`tsconfig.node.json`).
- With 60K LOC, incremental type-checking provides real speedup.
- Project references enforce package boundaries at the type level -- a package cannot accidentally import from another package's internals.

**Confidence:** HIGH -- TypeScript project references are well-documented and the existing project already uses the pattern.

### Shared Configuration Packages

| Package | Purpose | Contents |
|---------|---------|----------|
| `@flowforge/tsconfig` | Shared TypeScript config | Base `tsconfig.json` files for app, library, and test contexts |
| `@flowforge/biome-config` | Shared Biome config | Single `biome.json` extended by all packages |

**Why these two only:** Keep shared config minimal. Vite config is NOT shared because each app may have different plugins (Tauri plugin, svgr, etc.). Tailwind config is NOT shared because Tailwind v4 uses CSS-based configuration (`@theme {}` blocks), not JS config files.

**Biome v2 monorepo support:** Biome v2 natively supports monorepos. Nested `biome.json` files with `"root": false` inherit from the root config. Alternatively, use `"extends": "//"` to explicitly follow root config. A shared package (`@flowforge/biome-config`) is cleaner for the `extends` pattern.

**Confidence:** HIGH -- Biome v2's monorepo support is documented. TypeScript config sharing via packages is a standard Turborepo pattern.

### Vitest Workspace Configuration

| Technology | Version | Purpose | Why |
|------------|---------|---------|-----|
| Vitest workspace | 4.x (existing) | Run tests across all packages from root | Vitest natively supports workspace configuration via `vitest.workspace.ts`. Discovers test files across packages. Shared setup (jsdom, globals) can be inherited. |

**Configuration:**
```typescript
// vitest.workspace.ts (root)
export default ['packages/*', 'apps/*'];
```

Each package retains its own `vitest.config.ts` for package-specific setup (e.g., jsdom environment for UI packages, node for utility packages).

**Confidence:** HIGH -- Vitest workspace support is stable and well-documented.

---

## Workspace Structure

```
flowforge/                          # monorepo root
  pnpm-workspace.yaml             # workspace member definitions
  turbo.json                       # Turborepo pipeline config
  tsconfig.json                    # solution-style references only
  biome.json                       # root Biome config
  vitest.workspace.ts              # test workspace
  package.json                     # root scripts, turbo devDep

  packages/
    tsconfig/                      # @flowforge/tsconfig
      base.json
      react-library.json
      app.json
      package.json
    biome-config/                  # @flowforge/biome-config
      biome.json
      package.json
    core/                          # @flowforge/core
      src/                         # extracted from src/core/
      package.json
      tsconfig.json
    ui/                            # @flowforge/ui (framework)
      src/                         # extracted from src/framework/
      package.json
      tsconfig.json
    extensions/                    # @flowforge/extensions
      src/                         # extracted from src/extensions/
      package.json
      tsconfig.json

  apps/
    flowforge/                     # existing app (relocated)
      src/
      src-tauri/                   # Rust side stays here
      package.json
      tsconfig.json
      vite.config.ts
    skeleton/                      # second app proving framework works
      src/
      src-tauri/
      package.json
      tsconfig.json
      vite.config.ts
```

---

## Alternatives Considered

| Category | Recommended | Alternative | Why Not |
|----------|-------------|-------------|---------|
| Package manager | pnpm 10 | npm workspaces | npm lacks strict `node_modules`, no content-addressable store, weaker workspace protocol |
| Package manager | pnpm 10 | yarn 4 (berry) | PnP mode has compatibility issues with Tauri CLI. Classic mode offers no advantage over pnpm. |
| Package manager | pnpm 10 | bun | Bun's workspace support is less mature. Tauri CLI integration untested. |
| Task runner | Turborepo 2.8 | Nx | Overkill for 5-package monorepo. Invasive setup. Harder to remove later. |
| Task runner | Turborepo 2.8 | pnpm scripts only | No caching, no parallel task awareness, manual dependency ordering |
| Task runner | Turborepo 2.8 | moon | Less ecosystem adoption, Rust-focused tooling adds complexity |
| Build strategy | Just-in-Time | tsup per package | Unnecessary build step for internal-only packages consumed by Vite |
| Build strategy | Just-in-Time | tsc per package | Slower dev cycle, more config to maintain, not needed when Vite transpiles |
| Linter config | Biome shared package | Root biome.json only | Shared package is more explicit, works better with `extends` pattern |
| Linter config | Biome shared package | ESLint + Prettier | Project already uses Biome. No reason to switch. |

---

## What NOT to Add

These are commonly seen in monorepo guides but are unnecessary for FlowForge:

| Tool | Why Skip |
|------|----------|
| **Changesets** | Internal monorepo, not publishing to npm. Version management is overkill. |
| **Lerna** | Legacy tool. Turborepo + pnpm workspaces replace it entirely. |
| **syncpack** | Useful for enforcing version consistency, but with 3-5 packages the overhead is not justified yet. |
| **nx** (even as plugin) | Adding `nx` alongside Turborepo creates confusion. Pick one. |
| **tsup/tsdown/unbuild** | Not needed for Just-in-Time internal packages. Only add if publishing to npm. |
| **Husky/lint-staged** | Orthogonal to monorepo conversion. If wanted later, add separately. |
| **Docker/containerization** | Desktop app. Not applicable. |
| **publint/arethetypeswrong** | Only relevant for npm-published packages. Internal packages do not need this. |

---

## Installation

### Step 1: Install pnpm globally

```bash
# Using corepack (recommended, ships with Node.js)
corepack enable
corepack prepare pnpm@latest --activate

# Or standalone
npm install -g pnpm@^10
```

### Step 2: Root package.json additions

```bash
# Turborepo (root devDependency only)
pnpm add -Dw turbo
```

### Step 3: Per-package dependencies

Internal packages use `workspace:*` protocol:
```json
{
  "dependencies": {
    "@flowforge/core": "workspace:*",
    "@flowforge/ui": "workspace:*"
  }
}
```

No additional npm packages are required for the monorepo conversion itself beyond `turbo` and `pnpm`.

---

## Integration Points with Existing Toolchain

### Vite 7.3

- Just-in-Time packages work natively: Vite resolves `workspace:*` dependencies via pnpm symlinks and transpiles TypeScript source.
- The existing `resolve.alias` (`@` -> `/src`) continues to work per-app.
- `optimizeDeps.include` may need updating if internal packages re-export heavy deps (Monaco, Three.js).
- Tailwind v4's `@tailwindcss/vite` plugin works per-app. Each app imports its own `index.css` with `@theme {}`.

### Tauri 2 CLI

- The `tauri` CLI runs from within `apps/flowforge/` (or `apps/skeleton/`).
- `src-tauri/` stays inside each app directory. The Rust side is not affected by the JS monorepo structure.
- Cargo workspace for Rust crates is independent and optional (only needed if extracting shared Rust code).
- Tauri's `frontendDist` and `devUrl` in `tauri.conf.json` point to the app's Vite dev server -- no change needed.

### Biome 2.3

- Root `biome.json` applies to all packages.
- The existing schema reference (`https://biomejs.dev/schemas/1.9.0/schema.json`) should be updated to the Biome v2 schema.
- `pnpm biome check .` from root checks everything. Turborepo can cache per-package lint results.

### Vitest 4

- `vitest.workspace.ts` at root discovers all package test suites.
- Existing test setup (jsdom, globals, mocks in root `__mocks__/`) works with workspace config.
- `pnpm test` from root runs all tests. `pnpm --filter @flowforge/core test` runs one package's tests.

---

## Key Configuration Files

### pnpm-workspace.yaml

```yaml
packages:
  - 'packages/*'
  - 'apps/*'
```

### turbo.json

```json
{
  "$schema": "https://turborepo.dev/schema.json",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "check-types": {
      "dependsOn": ["^check-types"]
    },
    "test": {
      "dependsOn": ["^build"]
    },
    "lint": {},
    "dev": {
      "persistent": true,
      "cache": false
    }
  }
}
```

Note: With Just-in-Time packages, most packages will not have a `build` task. Only the apps have meaningful builds. The `check-types` task (`tsc --noEmit`) is the primary cacheable task for packages.

---

## Sources

- [Turborepo Internal Packages](https://turborepo.dev/docs/core-concepts/internal-packages) -- Just-in-Time vs Compiled strategy documentation
- [Turborepo Creating Internal Packages](https://turborepo.dev/docs/crafting-your-repository/creating-an-internal-package) -- Package structure and configuration
- [You Might Not Need TypeScript Project References](https://turborepo.dev/blog/you-might-not-need-typescript-project-references) -- Trade-offs of project references in monorepos
- [pnpm Workspaces](https://pnpm.io/workspaces) -- Workspace protocol and configuration
- [Biome Big Projects Guide](https://biomejs.dev/guides/big-projects/) -- Monorepo configuration patterns
- [TypeScript Project References](https://nx.dev/blog/typescript-project-references) -- Comprehensive guide to composite projects
- [Tauri Monorepo with pnpm](https://melvinoostendorp.nl/blog/tauri-v2-nextjs-monorepo-guide) -- Tauri v2 monorepo patterns
- [Tauri issue #12706](https://github.com/tauri-apps/tauri/issues/12706) -- `tauri add` pnpm workspace detection bug
- [Turborepo 2.7 Release](https://turborepo.dev/blog/turbo-2-7) -- Latest features including Biome integration
- [pnpm Monorepo Guide (2025)](https://jsdev.space/complete-monorepo-guide/) -- Complete pnpm workspace setup patterns
