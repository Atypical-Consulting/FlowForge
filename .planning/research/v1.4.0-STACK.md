# v1.4.0 Stack Additions

**Project:** FlowForge
**Researched:** 2026-02-08
**Scope:** New dependencies for XState navigation FSM, test infrastructure, and GitHub gitignore API integration
**Overall Confidence:** HIGH

---

## Context

FlowForge v1.3.0 has a validated, frozen stack (Tauri 2 / React 19 / TypeScript 5.9 / Vite 7.3 / Zustand 5 / React Query 5 / Monaco / framer-motion / Catppuccin / 21 Zustand stores / 50+ Tauri commands). This document covers ONLY the new dependencies needed for v1.4.0 features. Nothing in the existing stack needs replacing.

---

## Summary: What to Add

| Feature | New Frontend Packages | New Rust Crates | Dev-Only |
|---------|----------------------|-----------------|----------|
| Navigation FSM | `xstate`, `@xstate/react` | None | No |
| Test Runner | `vitest`, `jsdom` | None | Yes |
| Test Utilities | `@testing-library/react`, `@testing-library/jest-dom`, `@testing-library/user-event` | None | Yes |
| Coverage | `@vitest/coverage-v8` | None | Yes |
| Gitignore API | None | `reqwest` (explicit, with `json` feature) | No |

---

## 1. XState Navigation FSM

### Why XState

The current navigation system is an implicit FSM: `useBladeStore` manages a `bladeStack` array with `pushBlade`, `popBlade`, `setProcess`, and `resetStack`. The `ProcessType` discriminant (`"staging" | "topology"`) switches root blades. This works but has no transition guards -- any blade can be pushed from any state, singleton detection is manual, and the relationship between processes/blades/allowed transitions lives across `useBladeNavigation`, `bladeOpener`, and `SINGLETON_TYPES` arrays.

XState v5 formalizes this into a single, visualizable statechart where:
- States represent navigation contexts (idle, repo-open, staging, topology, init-repo, conventional-commit)
- Events are explicit (`OPEN_REPO`, `PUSH_BLADE`, `POP_BLADE`, `SWITCH_PROCESS`)
- Guards prevent invalid transitions (e.g., cannot push diff blade when no repo is open)
- Actions fire side effects (e.g., reset blade stack on process switch)
- The state machine is testable in isolation without React

### Packages

| Package | Version | Peer Dependencies | Size |
|---------|---------|-------------------|------|
| `xstate` | ^5.26.0 | TypeScript >=5.0 | ~47kB minified |
| `@xstate/react` | ^6.0.0 | `xstate ^5.20.0`, `react ^19.0.0` | ~4kB minified |

**Confidence:** HIGH -- Versions verified via `npm view` on 2026-02-08. Peer dependencies satisfied by project's TypeScript ^5.9.3 and React ^19.2.4.

### XState + Zustand Coexistence

XState does NOT replace Zustand. They coexist with clear ownership:

| Concern | Owner | Rationale |
|---------|-------|-----------|
| Navigation FSM (blade stack, process switching, transition guards) | **XState** | Complex state transitions with rules |
| Simple UI state (toasts, theme, dropdowns, command palette) | **Zustand** | Simple get/set, no transition logic |
| Async server state (commits, staging, branches) | **React Query** | Cache invalidation, refetching |
| Persisted preferences (pinned repos, settings) | **Zustand + Tauri Store** | Key-value persistence |

**Integration pattern:** Create a singleton XState actor for navigation. Components read state via `useSelector(navActor, selector)` (re-renders only on selected slice changes). Components send events via `navActor.send({ type: 'PUSH_BLADE', ... })`. The existing `useBladeStore` Zustand store gets replaced by the XState machine; other Zustand stores remain untouched.

### Key Hooks

| Hook | Use Case | Re-render Behavior |
|------|----------|-------------------|
| `useSelector(actor, selector)` | Read specific state slice | Only when selected value changes |
| `useActorRef(machine)` | Get actor reference without subscribing | Never re-renders |
| `useActor(machine)` / `useMachine(machine)` | Full state + send + ref | Every state transition |

**Performance recommendation:** Use `useSelector` for components that read navigation state. Use `useActorRef` in components that only send events. Avoid `useActor`/`useMachine` in frequently-rendered components.

### TypeScript Setup Pattern

```typescript
import { setup, assign } from 'xstate';

const navigationMachine = setup({
  types: {
    context: {} as {
      bladeStack: TypedBlade[];
      activeProcess: ProcessType;
    },
    events: {} as
      | { type: 'PUSH_BLADE'; blade: TypedBlade }
      | { type: 'POP_BLADE' }
      | { type: 'POP_TO_INDEX'; index: number }
      | { type: 'SWITCH_PROCESS'; process: ProcessType }
      | { type: 'RESET_STACK' },
  },
  guards: {
    canPushBlade: ({ context, event }) => { /* singleton check, etc */ },
    hasBlades: ({ context }) => context.bladeStack.length > 1,
  },
  actions: {
    pushBlade: assign({ /* ... */ }),
    popBlade: assign({ /* ... */ }),
  },
}).createMachine({
  id: 'navigation',
  initial: 'idle',
  context: { bladeStack: [], activeProcess: 'staging' },
  states: {
    idle: { /* ... */ },
    browsing: { /* ... */ },
  },
});
```

### tsconfig Compatibility

XState v5 requires:
- `strictNullChecks: true` -- Already enabled (`strict: true` in tsconfig.json)
- `skipLibCheck: true` -- Already enabled
- TypeScript >=5.0 -- Project has ^5.9.3

No tsconfig changes needed.

---

## 2. Test Infrastructure

### Why Vitest 4

The project has zero test files. Vitest 4 is the natural choice because:
1. **Native Vite integration** -- shares vite.config.ts (plugins, aliases, transforms). Zero additional bundler config.
2. **Vite 7 support** -- Vitest 4.x fully supports Vite 7.3 (the project's current version).
3. **API-compatible with Jest** -- `describe`, `it`, `expect`, `vi.fn()`, `vi.mock()`. Familiar for anyone who's used Jest.
4. **Watch mode** -- uses Vite's module graph for instant re-runs on file change.
5. **ESM-first** -- the project is `"type": "module"`. No CJS transform hacks needed.

### Packages

| Package | Version | Purpose | Dev-Only |
|---------|---------|---------|----------|
| `vitest` | ^4.0.18 | Test runner, assertions, mocking | Yes |
| `jsdom` | ^28.0.0 | DOM environment for component tests | Yes |
| `@testing-library/react` | ^16.3.2 | Component rendering + queries | Yes |
| `@testing-library/jest-dom` | ^6.9.1 | DOM assertion matchers | Yes |
| `@testing-library/user-event` | ^14.6.1 | User interaction simulation | Yes |
| `@vitest/coverage-v8` | ^4.0.18 | V8-based code coverage | Yes |

**Confidence:** HIGH -- All versions verified via `npm view` on 2026-02-08. Peer dependencies cross-checked.

### Why jsdom over happy-dom

happy-dom is faster (~2-3x) but has incomplete Web API coverage. FlowForge uses:
- **Monaco Editor** -- complex DOM API usage (MutationObserver, Range, Selection)
- **framer-motion** -- animation APIs, computed styles
- **react-virtuoso** -- scroll APIs, ResizeObserver
- **Three.js** -- canvas, WebGL stubs

jsdom's more complete API surface prevents mysterious test failures from missing browser APIs. The speed tradeoff is negligible for a project this size (~30K LOC).

### Configuration

Add test config to existing `vite.config.ts` (Vitest reads this natively):

```typescript
/// <reference types="vitest/config" />
import { defineConfig } from "vite";
// ... existing imports ...

export default defineConfig({
  // ... existing config ...
  test: {
    globals: true,
    environment: "jsdom",
    setupFiles: ["./src/test/setup.ts"],
    include: ["src/**/*.test.{ts,tsx}"],
    exclude: ["src/bindings.ts"],
    coverage: {
      provider: "v8",
      include: ["src/**/*.{ts,tsx}"],
      exclude: [
        "src/bindings.ts",
        "src/test/**",
        "**/*.d.ts",
      ],
    },
  },
});
```

### Setup File

Create `src/test/setup.ts`:

```typescript
import "@testing-library/jest-dom/vitest";
import { cleanup } from "@testing-library/react";
import { afterEach } from "vitest";

afterEach(() => {
  cleanup();
});
```

### Package.json Scripts

```json
{
  "test": "vitest",
  "test:run": "vitest run",
  "test:coverage": "vitest run --coverage"
}
```

### Mocking Strategy for Tauri Commands

Tauri IPC calls (`invoke`) need mocking in tests. Pattern:

```typescript
import { vi } from 'vitest';

// Mock Tauri invoke globally in setup or per-test
vi.mock('@tauri-apps/api/core', () => ({
  invoke: vi.fn(),
}));
```

For specta-generated bindings (`src/bindings.ts`), mock at the module level:

```typescript
vi.mock('../bindings', () => ({
  commands: {
    getStagingStatus: vi.fn().mockResolvedValue({ staged: [], unstaged: [] }),
    // ...
  },
}));
```

### Test File Naming Convention

Follow existing file structure: `ComponentName.test.tsx` co-located with the component, or in a `__tests__/` directory for complex test suites.

### Version Compatibility

| Package | Version | Requires | Project Has | OK |
|---------|---------|----------|-------------|-----|
| vitest | 4.0.18 | node ^20 or ^22 or >=24 | node 22 (CI) | YES |
| @testing-library/react | 16.3.2 | react ^19.0.0 | ^19.2.4 | YES |
| @testing-library/jest-dom | 6.9.1 | (none) | -- | YES |
| @testing-library/user-event | 14.6.1 | @testing-library/dom >=7.21.4 | transitive | YES |
| @vitest/coverage-v8 | 4.0.18 | vitest 4.0.18 | matched | YES |
| jsdom | 28.0.0 | (vitest peer, optional) | -- | YES |

---

## 3. GitHub Gitignore API Integration

### Approach: Rust Tauri Command (NOT frontend HTTP plugin)

**Decision:** Add `reqwest` explicitly to `Cargo.toml` and expose two new Tauri commands via `tauri-specta`. Do NOT use `@tauri-apps/plugin-http`.

**Rationale:**
1. The project already has 50+ Tauri commands -- this is the established pattern
2. `tokio` with full features and `serde_json` are already in Cargo.toml
3. `reqwest` is already a transitive dependency (Tauri uses it internally)
4. Desktop apps have no CORS restrictions from Rust side
5. Avoids adding Rust plugin registration, npm package, and capability permissions for a single API
6. `tauri-specta` auto-generates TypeScript bindings -- zero manual type synchronization

### Cargo.toml Addition

```toml
[dependencies]
reqwest = { version = "0.12", features = ["json"] }
```

### GitHub API Endpoints

Both endpoints work without authentication:

| Endpoint | Method | Response | Rate Limit |
|----------|--------|----------|------------|
| `/gitignore/templates` | GET | `string[]` (template names) | 60/hour unauthenticated |
| `/gitignore/templates/{name}` | GET | `{ name: string, source: string }` | 60/hour unauthenticated |

Required headers: `Accept: application/vnd.github+json`, `User-Agent: FlowForge`

**Confidence:** HIGH -- Verified against [GitHub REST API docs](https://docs.github.com/en/rest/gitignore/gitignore).

### Rate Limit Consideration

60 requests/hour unauthenticated is sufficient for this use case. The template list should be cached on the frontend (React Query with `staleTime: Infinity` since the list rarely changes). Individual template fetches happen on user selection.

### Tauri Command Design

```rust
// src-tauri/src/git/gitignore.rs

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct GitignoreTemplate {
    pub name: String,
    pub source: String,
}

#[tauri::command]
#[specta::specta]
pub async fn list_gitignore_templates() -> Result<Vec<String>, GitError> {
    let client = reqwest::Client::new();
    let templates = client
        .get("https://api.github.com/gitignore/templates")
        .header("Accept", "application/vnd.github+json")
        .header("User-Agent", "FlowForge")
        .send().await
        .map_err(|e| GitError::NetworkError(e.to_string()))?
        .json::<Vec<String>>().await
        .map_err(|e| GitError::ParseError(e.to_string()))?;
    Ok(templates)
}

#[tauri::command]
#[specta::specta]
pub async fn get_gitignore_template(name: String) -> Result<GitignoreTemplate, GitError> {
    let client = reqwest::Client::new();
    let template = client
        .get(format!("https://api.github.com/gitignore/templates/{}", name))
        .header("Accept", "application/vnd.github+json")
        .header("User-Agent", "FlowForge")
        .send().await
        .map_err(|e| GitError::NetworkError(e.to_string()))?
        .json::<GitignoreTemplate>().await
        .map_err(|e| GitError::ParseError(e.to_string()))?;
    Ok(template)
}
```

These commands get registered in `lib.rs` and auto-exported to TypeScript via `tauri-specta`.

---

## What NOT to Add

| Category | Rejected | Why Not |
|----------|----------|---------|
| Frontend HTTP | `@tauri-apps/plugin-http` | Overkill for 2 endpoints. Requires Rust plugin init, capability permissions, and npm package. Rust command approach is simpler and consistent with existing 50+ commands. |
| State machine | `@xstate/store` | For simple key-value stores, not FSMs. Navigation needs actual statecharts with guards and hierarchical states. |
| State machine | `zustand-middleware-xstate` | Unnecessary coupling. XState and Zustand should be independent -- different concerns, different ownership. |
| Testing | `jest` | Requires additional transform config. Vitest shares Vite's module graph natively. |
| Testing | `happy-dom` | Incomplete DOM APIs. FlowForge uses Monaco, Three.js, framer-motion, react-virtuoso -- all probe many DOM APIs. |
| Testing | `@vitest/browser` | Browser-mode testing (real Chromium) is valuable for e2e but heavy for unit/component tests. Defer to future milestone. |
| Testing | `playwright` / `cypress` | E2e testing for Tauri requires `tauri-driver` or special setup. Out of scope for test infrastructure foundation. |
| Git hooks | `commitlint` / `husky` | Already have `git-conventional` (Rust) and Biome. Would duplicate existing validation. |
| HTTP caching | `swr` | React Query is already in the stack. Use it for gitignore template caching. |

---

## Installation Commands

```bash
# XState -- runtime dependency
npm install xstate @xstate/react

# Test infrastructure -- dev dependencies
npm install -D vitest @vitest/coverage-v8 jsdom \
  @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

```toml
# In src-tauri/Cargo.toml, add to [dependencies]:
reqwest = { version = "0.12", features = ["json"] }
```

---

## Full Version Compatibility Matrix

| Package | Version | Requires | Project Has | Compatible |
|---------|---------|----------|-------------|------------|
| xstate | 5.26.0 | TS >=5.0 | TS ^5.9.3 | YES |
| @xstate/react | 6.0.0 | xstate ^5.20.0, react ^19.0.0 | 5.26.0, 19.2.4 | YES |
| vitest | 4.0.18 | node ^20/^22/>=24 | node 22 (CI) | YES |
| @testing-library/react | 16.3.2 | react ^19.0.0, react-dom ^19.0.0 | ^19.2.4 | YES |
| @testing-library/jest-dom | 6.9.1 | (none) | -- | YES |
| @testing-library/user-event | 14.6.1 | @testing-library/dom >=7.21.4 | transitive | YES |
| jsdom | 28.0.0 | (vitest peer, optional) | -- | YES |
| @vitest/coverage-v8 | 4.0.18 | vitest 4.0.18 | matched | YES |
| reqwest (Rust) | 0.12 | tokio runtime | tokio ^1 full | YES |

---

## Sources

- [XState GitHub](https://github.com/statelyai/xstate) -- v5.26.0 confirmed via `npm view`
- [@xstate/react docs](https://stately.ai/docs/xstate-react) -- hooks API, peer deps, useSelector patterns
- [XState TypeScript docs](https://stately.ai/docs/typescript) -- setup() pattern, TS 5.0+ requirement
- [XState machines docs](https://stately.ai/docs/machines) -- createMachine, state definition
- [XState + React global state](https://stately.ai/blog/2024-02-12-xstate-react-global-state) -- singleton actor pattern
- [Vitest official site](https://vitest.dev/) -- v4.0.18, Vite 7 compat
- [Vitest environment docs](https://vitest.dev/guide/environment) -- jsdom vs happy-dom
- [Vitest 4.0 announcement](https://vitest.dev/blog/vitest-4) -- workspace deprecation, projects config
- [GitHub Gitignore REST API](https://docs.github.com/en/rest/gitignore/gitignore) -- endpoints, no auth needed
- [Tauri v2 HTTP plugin](https://v2.tauri.app/plugin/http-client/) -- evaluated and rejected
- [@testing-library/react npm](https://www.npmjs.com/package/@testing-library/react) -- v16.3.2
- [@testing-library/jest-dom npm](https://www.npmjs.com/package/@testing-library/jest-dom) -- v6.9.1
- [@testing-library/user-event npm](https://www.npmjs.com/package/@testing-library/user-event) -- v14.6.1
