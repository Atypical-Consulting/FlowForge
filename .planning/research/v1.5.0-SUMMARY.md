# Research Summary: FlowForge v1.5.0

**Domain:** Extension System, GitHub Integration, Toolbar UX for Desktop Git Client
**Researched:** 2026-02-09
**Overall confidence:** HIGH

## Executive Summary

FlowForge v1.5.0 adds three interconnected capabilities: an extension system, GitHub integration (shipping as the first extension), and a toolbar UX overhaul. The research reveals that the existing stack is remarkably well-positioned for all three features -- only one new Rust dependency (`keyring ^3`) and three new npm packages (`@octokit/rest`, `@octokit/graphql`, `@octokit/auth-oauth-device`) are needed.

The extension system requires no new dependencies at all. The existing blade registry, command registry, `notify` crate (for directory watching), `serde_json` (for manifest parsing), and `tokio::fs` (for async file I/O) provide everything needed. The architecture mirrors VS Code's contribution point model, adapted for FlowForge's simpler blade/command paradigm.

GitHub integration uses a hybrid Rust+JS approach: the Rust backend handles OAuth Device Flow (leveraging the existing `reqwest` dependency) and secure token storage (via the `keyring` crate for OS-native credential storage). The JavaScript frontend uses Octokit for typed GitHub API access, wrapped with React Query for caching and refetching. This split keeps authentication secure on the backend while giving the frontend rich, typed API access.

The toolbar overhaul transforms the current hardcoded 15-button Header.tsx into a data-driven ToolbarItemRegistry. A custom `useOverflowToolbar` hook uses ResizeObserver (native Web API) to measure available space and move excess items into an overflow dropdown. No UI library is needed -- the existing framer-motion and Tailwind CSS stack handles the dropdown animation and styling.

## Key Findings

**Stack:** Only 4 new packages needed (1 Rust crate + 3 npm). Everything else leverages existing dependencies.
**Architecture:** Extension system builds on existing blade/command registries. GitHub integration is a hybrid Rust (auth) + JS (API) design. Toolbar is a data-driven registry + ResizeObserver hook.
**Critical pitfall:** Token storage MUST use OS keychain (keyring crate), not the plain-file tauri-plugin-store. This is a security requirement.

## Implications for Roadmap

Based on research, suggested phase structure:

1. **Toolbar Refactor** -- Lowest risk, unblocks extension toolbar contributions
   - Addresses: Overflow menu, show/hide customization, data-driven toolbar
   - Avoids: Breaking existing Header.tsx incrementally; easier to refactor before adding extension hooks
   - Dependencies: None (all existing stack)

2. **Extension System Core** -- Foundation for GitHub integration
   - Addresses: Manifest format, loader, registry, lifecycle, ExtensionAPI
   - Avoids: Over-engineering by starting with first-party extension only; can iterate on manifest format
   - Dependencies: None (all existing stack)

3. **GitHub OAuth + Token Storage** -- Authentication prerequisite
   - Addresses: Device Flow implementation, keyring integration, auth state management
   - Avoids: Token storage pitfall by mandating keyring from day one; Linux keyring fallback
   - Dependencies: `keyring` crate (new)

4. **GitHub Extension (PR/Issue Blades)** -- Primary user value
   - Addresses: PR list, issue list, create PR, GitHub repo auto-detection
   - Avoids: Rate limiting pitfall via React Query caching; API over-fetching via GraphQL for nested data
   - Dependencies: `@octokit/rest`, `@octokit/graphql`, `@octokit/auth-oauth-device` (new)

5. **Extension Settings + Polish** -- Complete the feature set
   - Addresses: Extension settings UI, enable/disable, install from GitHub URL
   - Avoids: Extension bundle size issues by keeping GitHub extension as part of main build for v1.5

**Phase ordering rationale:**
- Toolbar refactor first because it's self-contained and produces the data-driven model that extensions contribute to
- Extension system before GitHub because GitHub ships AS an extension -- it validates the extension framework
- OAuth before GitHub extension because the extension needs a token to function
- Settings/polish last because the core features must work before configuration UX matters

**Research flags for phases:**
- Phase 3 (OAuth): Needs deeper research on Linux keyring fallback strategy (what specific Secret Service daemons to detect, fallback encryption approach)
- Phase 4 (GitHub Extension): Needs deeper research on GitHub GraphQL schema for PR reviews, checks, and merge status queries
- Phase 1 (Toolbar): Standard patterns, unlikely to need research
- Phase 2 (Extension System): Standard patterns, unlikely to need research

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | Verified versions on npm/crates.io. keyring v3.6.3 published recently. Octokit v22.0.1 active. |
| Features | HIGH | Feature set derived from codebase analysis (existing registries) + GitHub API documentation. |
| Architecture | HIGH | Extension model follows proven VS Code pattern. Hybrid Rust/JS for GitHub follows Tauri best practices. |
| Pitfalls | HIGH | Pitfalls identified from OAuth documentation (expiry, polling), security analysis (token storage), and existing codebase review (registry collisions). |

## Gaps to Address

- **Linux keyring fallback:** Need to test `keyring` crate behavior on systems without Secret Service. May need encrypted file fallback with tauri-plugin-store.
- **Octokit v22 module resolution:** Need to verify that current Vite + TypeScript config resolves Octokit's conditional exports correctly. Test with actual import before committing to architecture.
- **GitHub Enterprise support:** Architecture assumes `github.com`. Enterprise users have custom domains. Extension settings should allow configurable GitHub host. Not a v1.5.0 blocker but should be considered in manifest/settings design.
- **Extension HMR during development:** The existing blade discovery uses `import.meta.glob` + HMR. Extension bundles loaded via `import()` won't have HMR. Developer workflow for extension authoring needs consideration.
- **@octokit/graphql exact version:** Listed as ^8 based on search results, but exact latest minor version was not verified via npm page (403 on fetch). Confidence MEDIUM for exact version.
