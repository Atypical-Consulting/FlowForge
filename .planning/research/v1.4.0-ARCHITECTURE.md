# Architecture Patterns: FlowForge v1.4.0

**Domain:** Desktop Git client -- navigation FSM, test architecture, API integration
**Researched:** 2026-02-08

## Current Architecture (Before v1.4.0)

```
React Components
    |
    +--> useBladeNavigation (hook)
    |       |
    |       +--> useBladeStore (Zustand) -- blade stack, process switching
    |       +--> bladeRegistry (Map<BladeType, Registration>)
    |       +--> bladeOpener (non-React context bridge)
    |
    +--> 20 other Zustand stores (navigation, staging, topology, ...)
    |
    +--> React Query (async data fetching)
    |
    +--> Tauri IPC (invoke) --> Rust commands (50+)
```

**Problems with current navigation:**
1. `useBladeStore` is an implicit FSM -- `pushBlade`, `popBlade`, `setProcess` are transitions without guards
2. `SINGLETON_TYPES` array is a manual guard, duplicated in `useBladeNavigation` and `bladeOpener`
3. No way to express "this blade can only be opened when a repo is open" or "switching process resets related stores"
4. `ProcessType` (`"staging" | "topology"`) will grow with Init Repo and Conventional Commit processes but has no formal state graph

## Recommended Architecture (After v1.4.0)

```
React Components
    |
    +--> useSelector(navActor, selector) -- read navigation state
    +--> navActor.send({ type: ... })    -- dispatch navigation events
    |
    +--> XState Navigation Actor (singleton)
    |       |
    |       +--> States: idle | repoOpen.staging | repoOpen.topology | repoOpen.initRepo | ...
    |       +--> Context: { bladeStack, activeProcess, repoPath }
    |       +--> Guards: canPushBlade, isRepoOpen, isSingleton
    |       +--> Actions: pushBlade, popBlade, resetStack, notifyStores
    |
    +--> Zustand stores (18-20 remaining, simple UI state only)
    |
    +--> React Query (async data + gitignore template cache)
    |
    +--> Tauri IPC (invoke) --> Rust commands (52+, including gitignore)
```

### Component Boundaries

| Component | Responsibility | Communicates With |
|-----------|---------------|-------------------|
| XState Navigation Actor | Owns blade stack, process type, transition guards, singleton enforcement | React components (via hooks), Zustand stores (via subscriptions) |
| Zustand UI Stores | Simple UI state: toasts, theme, dropdowns, command palette visibility | React components (direct hook usage) |
| Zustand Persistence Stores | Persisted preferences: pinned repos, recent branches, settings | Tauri Store plugin, React components |
| React Query | Async server state: commit history, staging status, gitignore templates | Tauri IPC, React components |
| Tauri IPC Layer | Type-safe Rust command invocation via specta bindings | React Query (as query functions), XState actions |
| Blade Registry | Component resolution: maps BladeType to React component + metadata | XState (for validation), BladeRenderer (for rendering) |

### Data Flow: Opening a Blade

```
User clicks file in staging list
    |
    v
Component calls: navActor.send({ type: 'PUSH_BLADE', bladeType: 'diff', props: { source } })
    |
    v
XState machine evaluates:
  1. Guard: canPushBlade? (not singleton already open, repo is open)
  2. Action: assign new blade to context.bladeStack
  3. Transition: stay in current state (repoOpen.staging)
    |
    v
useSelector(navActor, selectBladeStack) triggers re-render in BladeRenderer
    |
    v
BladeRenderer looks up component in bladeRegistry, renders it
```

### Data Flow: Switching Process

```
User clicks "Topology" tab
    |
    v
navActor.send({ type: 'SWITCH_PROCESS', process: 'topology' })
    |
    v
XState machine:
  1. Transition: repoOpen.staging --> repoOpen.topology
  2. Entry action: resetBladeStack to topology root blade
  3. Exit action: (optional) cleanup staging-specific state
    |
    v
useSelector subscriptions fire, UI updates
```

## Patterns to Follow

### Pattern 1: Singleton XState Actor

**What:** Create the navigation actor once at app startup, export it for direct use.

**When:** Always. Navigation is global state.

**Example:**

```typescript
// src/machines/navigationActor.ts
import { createActor } from 'xstate';
import { navigationMachine } from './navigationMachine';

export const navActor = createActor(navigationMachine, {
  inspect: import.meta.env.DEV
    ? (event) => { /* Stately inspector integration */ }
    : undefined,
});

navActor.start();
```

```typescript
// In React components:
import { useSelector } from '@xstate/react';
import { navActor } from '../machines/navigationActor';

function BladeRenderer() {
  const bladeStack = useSelector(navActor, (s) => s.context.bladeStack);
  // ...
}
```

### Pattern 2: XState Guards for Navigation Rules

**What:** Express navigation constraints as guards, not ad-hoc conditionals scattered across hooks.

**When:** Any rule about "can this blade be opened from this state?"

**Example:**

```typescript
const navigationMachine = setup({
  types: { /* ... */ },
  guards: {
    isSingleton: ({ context, event }) => {
      if (event.type !== 'PUSH_BLADE') return false;
      const SINGLETONS: BladeType[] = ['settings', 'changelog', 'gitflow-cheatsheet'];
      return SINGLETONS.includes(event.bladeType) &&
        context.bladeStack.some(b => b.type === event.bladeType);
    },
    isRepoOpen: ({ context }) => !!context.repoPath,
  },
}).createMachine({
  // ...
  states: {
    idle: {
      on: {
        OPEN_REPO: { target: 'repoOpen', guard: 'isRepoOpen' },
      },
    },
    repoOpen: {
      on: {
        PUSH_BLADE: {
          guard: { type: 'not', params: { guard: 'isSingleton' } },
          actions: 'pushBlade',
        },
      },
    },
  },
});
```

### Pattern 3: React Query for Gitignore Template Cache

**What:** Use React Query's cache for GitHub API responses with aggressive caching.

**When:** Fetching gitignore template list and individual templates.

**Example:**

```typescript
// src/hooks/useGitignoreTemplates.ts
import { useQuery } from '@tanstack/react-query';
import { commands } from '../bindings';

export function useGitignoreTemplates() {
  return useQuery({
    queryKey: ['gitignore', 'templates'],
    queryFn: () => commands.listGitignoreTemplates(),
    staleTime: Infinity,  // Template list rarely changes
    gcTime: 1000 * 60 * 60 * 24,  // Keep in cache for 24 hours
  });
}

export function useGitignoreTemplate(name: string) {
  return useQuery({
    queryKey: ['gitignore', 'template', name],
    queryFn: () => commands.getGitignoreTemplate(name),
    enabled: !!name,
    staleTime: Infinity,
  });
}
```

### Pattern 4: Tauri Mock Factory for Tests

**What:** A reusable mock setup for `tauri-specta` generated bindings in tests.

**When:** Any component test that renders components using Tauri commands.

**Example:**

```typescript
// src/test/tauri-mocks.ts
import { vi } from 'vitest';

export function createTauriMocks(overrides: Partial<typeof import('../bindings').commands> = {}) {
  return {
    commands: {
      getStagingStatus: vi.fn().mockResolvedValue({ staged: [], unstaged: [], untracked: [] }),
      listGitignoreTemplates: vi.fn().mockResolvedValue(['Node', 'Rust', 'Python']),
      getGitignoreTemplate: vi.fn().mockResolvedValue({ name: 'Node', source: 'node_modules/' }),
      ...overrides,
    },
  };
}

// Usage in test:
vi.mock('../bindings', () => createTauriMocks({
  getStagingStatus: vi.fn().mockResolvedValue({ staged: [{ path: 'foo.ts' }], unstaged: [], untracked: [] }),
}));
```

### Pattern 5: Co-located Test Files

**What:** Place test files next to the code they test.

**When:** Always. Co-location improves discoverability and reduces import path length.

**Example:**

```
src/
  machines/
    navigationMachine.ts
    navigationMachine.test.ts    <-- FSM logic tests (no DOM needed)
  hooks/
    useGitignoreTemplates.ts
    useGitignoreTemplates.test.ts
  components/
    blades/
      InitRepoBlade.tsx
      InitRepoBlade.test.tsx     <-- Component test with RTL
  stores/
    toast.ts
    toast.test.ts               <-- Zustand store test
```

## Anti-Patterns to Avoid

### Anti-Pattern 1: Zustand Store as FSM

**What:** Using Zustand's `set()` to model state transitions with ad-hoc conditionals.

**Why bad:** No visualization, no formal guards, transition logic scattered across multiple files, impossible states representable.

**Instead:** Use XState for anything with more than two states and conditional transitions. Keep Zustand for simple get/set state.

### Anti-Pattern 2: `useActor` in Frequently-Rendered Components

**What:** Using `useActor(machine)` or `useMachine(machine)` which re-renders on every state change.

**Why bad:** Every navigation event (push, pop, process switch) triggers re-render in every component using `useActor`.

**Instead:** Use `useSelector(actor, selectSpecificSlice)` to subscribe only to the data each component needs. Use `useActorRef` for components that only send events.

### Anti-Pattern 3: Mocking Implementation Details in Tests

**What:** Testing that a Zustand store's `set()` was called with specific arguments.

**Why bad:** Couples tests to implementation. Store can be refactored (e.g., migrated to XState) and tests break even if behavior is unchanged.

**Instead:** Test observable behavior: "after clicking the file, does the diff blade appear?" Uses Testing Library's `screen.getByText()` etc.

### Anti-Pattern 4: Fetching GitHub API from Frontend

**What:** Using `@tauri-apps/plugin-http` or `fetch()` directly from React to call GitHub API.

**Why bad:** Inconsistent with the project's architecture (all external I/O goes through Rust). Requires plugin registration, capability permissions. CORS is a non-issue in desktop but the pattern matters.

**Instead:** Rust Tauri command with `reqwest`. Auto-generated TypeScript bindings via `tauri-specta`.

### Anti-Pattern 5: Giant Test Setup Files

**What:** Putting all mocks, providers, and test utilities in a single `setup.ts`.

**Why bad:** Every test imports everything. Slow test startup, unclear what each test actually needs.

**Instead:** Minimal `setup.ts` (cleanup + jest-dom matchers). Test-specific mocks created per-file or per-suite with `createTauriMocks()` factory.

## Scalability Considerations

| Concern | Current (13 blades) | At 25 blades | At 50+ blades |
|---------|---------------------|--------------|---------------|
| Navigation state | XState machine with flat states | Add hierarchical states (grouped by domain) | Consider parallel states for independent panels |
| Blade registry | Map lookup O(1) | Same | Same -- Map scales fine |
| Test suite | 10-20 tests, <5s | 50-100 tests, <15s | Enable Vitest's `pool: 'threads'` for parallel |
| Gitignore templates | ~150 from API, filter in React | Same (API is stable) | Same |
| Zustand stores | 18-20 stores | Consolidate by domain (5-8 stores) | Consider React Context for deeply nested state |

## Sources

- [XState machines docs](https://stately.ai/docs/machines) -- state machine patterns
- [XState + React global state](https://stately.ai/blog/2024-02-12-xstate-react-global-state) -- singleton actor pattern
- [@xstate/react useSelector](https://stately.ai/docs/xstate-react) -- performance patterns
- [Vitest test environment](https://vitest.dev/guide/environment) -- jsdom configuration
- [Testing Library philosophy](https://testing-library.com/docs/react-testing-library/intro/) -- behavior-based testing
- Current codebase: `stores/blades.ts`, `hooks/useBladeNavigation.ts`, `lib/bladeOpener.ts`, `lib/bladeRegistry.ts`
