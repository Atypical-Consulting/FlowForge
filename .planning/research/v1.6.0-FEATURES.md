# Feature Landscape: Extension Platform Expansion & Feature Extraction

**Domain:** Desktop Git client extension system (Tauri + React)
**Researched:** 2026-02-10
**Milestone:** v1.6.0

## Table Stakes

Features users expect from a mature extension platform. Missing = the extraction feels broken or arbitrary.

| Feature | Why Expected | Complexity | Notes |
|---------|--------------|------------|-------|
| Extension enable/disable with persistence | Users already toggle GitHub extension on/off. Extracting Gitflow/CC without this feels like a regression. | Low | Already exists via `persistDisabledExtensions` in ExtensionHost. Extraction inherits this for free. |
| Graceful UI absence when extension disabled | Disabling Gitflow must remove its sidebar panel, toolbar items, commands, and blades -- not leave empty shells. | Med | VS Code pattern: `when` clauses hide UI contributions. FlowForge has `when()` on toolbar; needs same for sidebar panels. |
| Context menu system | Right-click actions are table stakes in any desktop app. Every extensible editor (VS Code, IntelliJ, Atom, Zed) provides this. | Med | VS Code offers 30+ menu locations. FlowForge needs ~5: file-list-item, branch-item, commit-item, blade-tab, sidebar-section. |
| Status bar / footer area | Every major editor has a status bar for ambient info (branch, sync status, extension indicators). | Med | VS Code: extensions create `StatusBarItem` with text/icon/command. FlowForge: new registry pattern like toolbar. |
| Extension settings contribution | Extensions must expose configuration knobs (e.g., Gitflow prefix naming, CC scope suggestions count). | Med | VS Code: `contributes.configuration`. IntelliJ: `applicationConfigurable`. FlowForge: extend existing settings blade to render extension-contributed sections. |
| Clean lifecycle (activate/deactivate) | Extensions that leak state on deactivation break the app. The GitHub extension already demonstrates proper cleanup. | Low | Already built. `ExtensionAPI.cleanup()` handles blades, commands, toolbar. Extend to cover new registries. |
| Built-in extension pattern | Gitflow/CC/viewers are bundled, not downloaded. They need a first-class built-in path. | Low | Already exists: `registerBuiltIn()` creates synthetic manifest, activates through standard API facade. GitHub uses this. |

## Differentiators

Features that set FlowForge apart from other Git clients. Not expected, but valuable.

| Feature | Value Proposition | Complexity | Notes |
|---------|-------------------|------------|-------|
| Git operation hooks (pre/post) | Extensions can react to git events (pre-commit validation, post-merge refresh, branch-switch cleanup). No other desktop Git client exposes this. | High | VS Code's Git extension is opaque -- other extensions cannot hook into its operations. FlowForge owns the Rust backend and can emit events. Pattern: EventEmitter on ExtensionAPI with `onWillCommit`, `onDidCommit`, `onWillCheckout`, `onDidCheckout`, etc. |
| Sidebar panel contribution | Extensions can inject panels into the left sidebar (like Gitflow panel). More powerful than just blades. | Med | VS Code: `contributes.views` + `contributes.viewsContainers`. FlowForge equivalent: `api.contributeSidebarPanel()` with priority/group/when visibility. |
| Commit message interceptors | Extensions can modify or validate commit messages before submission. Enables CC enforcement, linting, template insertion. | Med | This is the key integration point for extracting Conventional Commits. The core commit form fires `onWillCommit` with the message; CC extension can transform or reject it. |
| Extension-to-extension API | Extensions can expose services to other extensions. E.g., the Gitflow extension exposes branch state that a CI extension could consume. | High | VS Code: `vscode.extensions.getExtension('id').exports`. IntelliJ: extension points declared by plugins, consumed by others. Defer to v1.7.0+ unless needed for extraction. |
| Activation events / lazy loading | Extensions activate only when their features are needed, not at startup. | Med | VS Code: 25 activation event types. FlowForge needs fewer: `onStartup`, `onCommand`, `onBladeOpen`, `onRepoOpen`. Current system activates all on repo open -- good enough for built-ins. |
| Permission/capability system | Extensions declare what they can access (filesystem, network, git operations). | High | Zed does this with `granted_extension_capabilities`. Only matters for third-party extensions. Defer to post-v1.6.0. |
| Sandboxing / isolation | Extensions run in isolated contexts to prevent crashes from affecting the core app. | Very High | VS Code runs extensions in a separate Extension Host process. Zed uses WASM sandboxing. FlowForge runs in-process (React components). Full sandboxing is a v2.0 concern. For v1.6.0, focus on error boundaries and cleanup guarantees. |

## Anti-Features

Features to explicitly NOT build in v1.6.0.

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| Extension marketplace / store | Massive infrastructure (hosting, review, versioning, trust). Zero user demand at this stage. | Keep install-from-URL for external extensions. Focus on built-in extraction quality. |
| Full process isolation / WASM sandboxing | Enormous complexity for in-process React extensions. VS Code took years to get this right and still runs extensions in shared memory. | Use React error boundaries per extension blade. Catch activation failures and roll back cleanly (already built). Add `try/catch` wrappers around extension event handlers. |
| Declarative manifest-only contributions (no code) | VS Code's package.json contribution model is powerful but requires a JSON schema validator, lazy activation engine, and manifest-to-runtime pipeline. Over-engineering for 3-5 built-in extensions. | Keep the imperative `api.registerX()` pattern from `onActivate()`. It is simpler, type-safe, and already working for GitHub extension. |
| Extension auto-update mechanism | Only relevant with a marketplace. Built-ins ship with the app binary. | Update built-in extensions by updating the app. External extensions: user re-installs from URL. |
| Custom theme contributions from extensions | Catppuccin is the theme system. Allowing extensions to contribute themes adds complexity with no clear user value. | Extensions use `--ctp-*` tokens. No custom theme registration needed. |
| Drag-and-drop sidebar panel reordering | Nice UX but complex and tangential to the extraction goal. | Fixed panel order with visibility toggling. Extensions appear in registration order within their group. |

## Feature Dependencies

```
Context Menu Registry -----> Feature Extraction (Gitflow)
     |                              |
     v                              v
Sidebar Panel Registry ----> Feature Extraction (CC)
     |                              |
     v                              v
Status Bar Registry -------> Feature Extraction (Viewers)
     |
     v
Git Operation Hooks -------> Commit Message Interceptors
     |
     v
Extension Settings --------> All extracted extensions need config
```

### Dependency Chain (Critical Path)

```
1. Context Menu Registry
   - No dependencies on other new features
   - Needed by: Gitflow extraction (right-click branch -> Start Feature)
   - Needed by: CC extraction (right-click staged file -> Infer Scope)
   - Needed by: Viewer extraction (right-click file -> Open with...)

2. Sidebar Panel Contribution API
   - No dependencies on other new features
   - Needed by: Gitflow extraction (contributes sidebar panel)
   - Enables graceful absence (panel disappears when extension disabled)

3. Status Bar Registry
   - No dependencies on other new features
   - Needed by: Gitflow extraction (show current flow state)
   - Needed by: CC extraction (show commit type indicator)
   - Lower priority than context menu + sidebar panel

4. Git Operation Hooks / Events
   - No hard dependencies, but better with context menus
   - Needed by: CC extraction (commit message interceptor)
   - Enables: Pre-merge checklist enforcement by Gitflow extension

5. Extension Settings Contribution
   - Needs existing settings blade infrastructure
   - Needed by: All extracted extensions (prefix config, scope count, etc.)

6. Feature Extraction: Gitflow
   - Depends on: Sidebar Panel API, Context Menu (branch actions), Status Bar (flow indicator)
   - Largest extraction surface area (sidebar panel, dialogs, store slice, toolbar actions, blade)

7. Feature Extraction: Conventional Commits
   - Depends on: Commit Message Interceptors, Context Menu (scope inference), Extension Settings
   - Integration with core commit form requires careful hook design

8. Feature Extraction: Content Viewers
   - Depends on: Context Menu (open-with actions)
   - Simplest extraction: each viewer is already a self-contained blade
```

## Detailed Feature Specifications

### 1. Context Menu Registry

**What:** A registry-based system for context menu contributions, analogous to the existing toolbar and command registries.

**Why essential:** VS Code's `contributes.menus` is arguably its most important extension point -- it is how extensions inject actions into specific UI contexts. Without context menus, extracted features lose discoverability.

**Design (informed by VS Code pattern):**

```typescript
interface ContextMenuContribution {
  id: string;             // Namespaced: ext:{extId}:{name}
  location: MenuLocation; // Where the menu appears
  group: string;          // Grouping within menu (e.g., "navigation", "1_actions")
  order: number;          // Sort order within group
  label: string;
  icon?: LucideIcon;
  command: string;        // Command ID to execute
  when?: () => boolean;   // Visibility condition
}

type MenuLocation =
  | "file-list/context"      // Right-click on staged/unstaged file
  | "branch-list/context"    // Right-click on branch in sidebar
  | "commit-list/context"    // Right-click on commit in history
  | "blade-tab/context"      // Right-click on blade tab
  | "sidebar-section/context" // Right-click on sidebar section header
  | "stash-list/context"     // Right-click on stash entry
  | "tag-list/context";      // Right-click on tag
```

**VS Code parallel:** VS Code has 30+ menu locations. FlowForge needs only 7 for v1.6.0. The `group` property follows VS Code's `"groupName@orderNumber"` pattern for item ordering within sections separated by dividers.

**Complexity:** Medium. The registry itself is straightforward (same pattern as toolbar). The rendering work is in each list component to detect right-click, gather contributions, and render a popover menu.

### 2. Sidebar Panel Contribution API

**What:** Extensions can contribute collapsible panels to the left sidebar (where Branches, Stashes, Tags, Gitflow, Worktrees live).

**Why essential:** The Gitflow panel is currently hardcoded in `RepositoryView.tsx` with a `<details>` element. Extracting it to an extension requires a contribution API so the panel appears/disappears based on extension state.

**Design:**

```typescript
interface SidebarPanelContribution {
  id: string;               // Namespaced
  title: string;
  icon: LucideIcon;
  component: ComponentType<any>;
  group: "source-control" | "workflow" | "info"; // Section grouping
  priority: number;         // Higher = appears first
  defaultOpen?: boolean;    // Initial collapsed state
  when?: () => boolean;     // Visibility condition
}
```

**Graceful degradation pattern:** When Gitflow extension is disabled, the sidebar panel is unregistered from the sidebar panel registry. The `RepositoryView` iterates over registered panels instead of hardcoding them. Core panels (Branches, Stashes, Tags) remain as always-present core registrations.

**IntelliJ parallel:** IntelliJ's `toolWindow` extension point lets plugins contribute tool windows to the IDE. Each has an activation condition, icon, and content factory. FlowForge's sidebar panels are a simpler version of this concept.

### 3. Status Bar Registry

**What:** A horizontal strip at the bottom of the window showing ambient status information contributed by extensions.

**Why essential:** Branch name, sync status, and extension indicators are standard in every code editor. Currently FlowForge has no status bar. This is a natural home for extension state that does not warrant a full toolbar button.

**Design:**

```typescript
interface StatusBarContribution {
  id: string;               // Namespaced
  alignment: "left" | "right";
  priority: number;         // Higher = closer to edge
  text: string | (() => string);
  icon?: LucideIcon;
  tooltip?: string;
  command?: string;         // Click action
  when?: () => boolean;
  color?: "default" | "warning" | "error";
}
```

**VS Code parallel:** VS Bar items are scoped by alignment -- left items are workspace-scoped, right items are file-scoped. For FlowForge v1.6.0, a simpler model: left = git state (branch, ahead/behind), right = extension indicators (Gitflow flow state, CC type).

**Complexity:** Medium. New UI component + new registry. Lower priority than context menus and sidebar panels because toolbar buttons already serve some of this purpose.

### 4. Git Operation Hooks / Events

**What:** An event system on ExtensionAPI that lets extensions react to git operations before and after they happen.

**Why essential:** This is the key differentiator for FlowForge's extension system. VS Code's built-in Git extension is a black box -- other extensions cannot hook into its commit/push/pull operations. Because FlowForge owns its Rust git backend, it can emit typed events.

**Design:**

```typescript
// On ExtensionAPI:
interface GitEventAPI {
  onWillCommit: Event<WillCommitEvent>;      // Before commit, can cancel/modify
  onDidCommit: Event<DidCommitEvent>;        // After successful commit
  onWillCheckout: Event<WillCheckoutEvent>;  // Before branch switch
  onDidCheckout: Event<DidCheckoutEvent>;    // After branch switch
  onWillMerge: Event<WillMergeEvent>;        // Before merge
  onDidMerge: Event<DidMergeEvent>;          // After merge
  onWillPush: Event<WillPushEvent>;          // Before push
  onDidPush: Event<DidPushEvent>;            // After push
  onDidStageChange: Event<StageChangeEvent>; // Files staged/unstaged
}

interface WillCommitEvent {
  message: string;
  amend: boolean;
  cancel(): void;
  setMessage(msg: string): void; // Interceptor pattern
}
```

**Commit message interceptor pattern:** The core commit flow fires `onWillCommit` with a mutable event object. The CC extension listens, validates the message format, and can either modify it or cancel the commit with an error message. This is how CC extraction works without the core commit form knowing about conventional commits.

**Implementation:** The Rust backend already calls discrete Tauri commands for each operation. The hook integration point is in the TypeScript store layer that wraps these commands. Each git-ops slice method (commit, checkout, merge, push) wraps its call with before/after event emission.

**Complexity:** High. Requires careful async sequencing (await all `onWill*` handlers before proceeding, any handler can cancel). The event subscription/unsubscription must be tracked by ExtensionAPI for cleanup.

### 5. Extension Settings Contribution

**What:** Extensions can declare configuration sections that appear in the Settings blade.

**Why essential:** Gitflow needs prefix configuration (feature/, release/, hotfix/). CC needs scope suggestion count, type auto-detection sensitivity. Without this, each extension would need its own settings blade -- fragmented and hard to discover.

**Design:**

```typescript
interface ExtensionSettingsContribution {
  id: string;
  title: string;
  icon?: LucideIcon;
  component: ComponentType<{
    values: Record<string, unknown>;
    onChange: (key: string, value: unknown) => void;
  }>;
  defaults: Record<string, unknown>;
}
```

**Storage:** Extension settings persisted via `tauri-plugin-store` under `ext:{id}:settings` key, separate from core settings. The existing `getStore()` pattern handles this cleanly.

**Complexity:** Medium. Need to extend the Settings blade to iterate over contributed sections and render them. Each extension provides its own settings component -- no schema-driven form generation needed for v1.6.0.

### 6. Feature Extraction: Gitflow

**What:** Move all Gitflow functionality from core into a built-in extension.

**Extraction surface:**
- **Sidebar panel:** `GitflowPanel` in `RepositoryView.tsx` (hardcoded `<details>` block)
- **Components:** `StartFlowDialog`, `FinishFlowDialog`, `InitGitflowDialog`, `GitflowPanel`, `GitflowDiagram`, `GitflowBranchReference`, `GitflowActionCards` (7 components)
- **Blade:** `gitflow-cheatsheet` blade (already registered via registration.ts)
- **Store:** `gitflow.slice.ts` in git-ops domain store
- **Commands:** Gitflow-related entries in `toolbar-actions.ts` and `navigation.ts`
- **Branch coloring:** `branchClassifier.ts` uses gitflow prefixes for coloring
- **Guards:** Navigation guards that check gitflow state

**Graceful degradation when disabled:**
1. Sidebar: Gitflow `<details>` section disappears (contributed via sidebar panel API)
2. Toolbar: Gitflow actions removed (already handled by toolbar registry cleanup)
3. Commands: Gitflow commands removed from palette (already handled by command registry cleanup)
4. Branch coloring: Falls back to default coloring (classifier checks if gitflow extension is active)
5. Navigation guards: Skip gitflow-specific guards (guard checks extension availability)

**Challenge: Store extraction.** The `gitflow.slice.ts` lives inside the combined `git-ops` store. Extraction requires either:
- (a) Moving the slice into the extension and having it create its own Zustand store, or
- (b) Keeping the slice in git-ops but having the extension control its initialization

Recommendation: **(a)** -- move the store into the extension. The extension creates `useGitflowStore` as a standalone Zustand store within its module. This follows the GitHub extension pattern (which has `githubStore.ts` as a standalone store). The git-ops store drops the gitflow slice.

**Complexity:** High. Largest extraction. Many tentacles into core UI (sidebar panel, branch classifier, navigation guards). Requires sidebar panel API and context menu API to be built first.

### 7. Feature Extraction: Conventional Commits

**What:** Move Conventional Commits from core into a built-in extension.

**Extraction surface:**
- **Blade:** `conventional-commit` blade (registration.ts, ConventionalCommitBlade.tsx)
- **Store:** `conventional.ts` (standalone store, clean extraction)
- **Components:** `ConventionalCommitForm.tsx`, `TypeSelector.tsx`, `CommitTypeIcon.tsx`, `ValidationErrors.tsx` (4 components)
- **Hooks:** `useConventionalCommit.ts`, `useAmendPrefill.ts` (CC-specific parts)
- **Utilities:** `conventional-utils.ts`, `commit-templates.ts`, `commit-type-theme.ts`
- **Integration point:** `CommitForm.tsx` has a toggle for conventional commit mode and imports `ConventionalCommitForm`
- **Changelog blade:** `changelog` blade depends on conventional commit parsing

**Graceful degradation when disabled:**
1. Commit form: The toggle for "conventional commit mode" disappears. Core commit form works as a plain textarea.
2. Commit history: Conventional commit badges/parsing falls back to showing raw messages
3. Changelog blade: Either disabled entirely, or shows raw commit list without type grouping
4. Type inference: No type suggestions in staging view
5. Scope suggestions: No scope autocomplete

**Integration pattern:** The core `CommitForm` fires an `onWillCommit` event. The CC extension:
1. Contributes a toolbar action to open the CC blade
2. Registers a `onWillCommit` handler that validates message format (if CC mode is active)
3. Contributes a command "Open Conventional Commit Composer"
4. Optionally contributes a sidebar panel showing scope frequency chart

The key design question: **should the CC form replace the core commit form, or be a separate blade?**
Recommendation: Keep it as a separate blade (current behavior). The core commit form is a simple textarea. The CC extension adds a toolbar button "Compose Conventional Commit" that opens the CC blade. When the user commits from the CC blade, it constructs the formatted message and executes the commit. This is cleanly separated.

**Complexity:** Medium. The store and components are already well-isolated. The main work is extracting the `ConventionalCommitForm` import from `CommitForm.tsx` and replacing it with an extension-contributed integration point.

### 8. Feature Extraction: Content Viewers

**What:** Move Markdown preview, Code viewer, 3D model viewer, NuPkg viewer, and Image viewer into extensions.

**Extraction surface per viewer:**
- **viewer-markdown:** `ViewerMarkdownBlade.tsx` + registration.ts (depends on react-markdown, remark-gfm)
- **viewer-code:** Code viewer blade (depends on Monaco editor)
- **viewer-3d:** 3D model viewer (depends on Three.js, heavy)
- **viewer-nupkg:** NuPkg metadata viewer
- **viewer-image:** Image viewer

**Graceful degradation when disabled:**
1. File opens that would normally use a viewer fall back to the raw diff view
2. Context menu "Open with..." items for disabled viewers disappear
3. No broken blade if a viewer extension is disabled -- the blade type is unregistered, so opening it is a no-op or shows a "viewer not available" message

**Why extract these:** Content viewers are the cleanest extraction candidates. Each is a self-contained blade with no integration into core workflows. They add heavy dependencies (Three.js, Monaco, react-markdown) that some users may not want loaded. Making them optional reduces bundle size for minimal installs.

**Complexity:** Low per viewer. Each viewer is already a single blade component with a registration file. The extraction is mechanical: wrap in `onActivate`/`onDeactivate`, move to `src/extensions/viewer-*`, register via `api.registerBlade()`.

**Context menu integration:** After extraction, viewers contribute context menu items like "Preview Markdown" on markdown files, "View 3D Model" on .obj/.stl files. This requires the context menu registry to be built first, but the viewers can be extracted without it (they would just lose right-click discoverability until context menus land).

## MVP Recommendation

Prioritize for v1.6.0 in this order:

1. **Context Menu Registry** -- foundation for all extractions' discoverability
2. **Sidebar Panel Contribution API** -- required for Gitflow extraction
3. **Content Viewer Extraction** -- easiest wins, proves the extraction pattern, reduces bundle
4. **Commit Message Interceptors** (subset of Git Operation Hooks) -- required for CC extraction
5. **Feature Extraction: Conventional Commits** -- medium complexity, high user value
6. **Feature Extraction: Gitflow** -- most complex, highest impact for "plain Git client" use case
7. **Extension Settings Contribution** -- needed for extracted features' configuration
8. **Status Bar Registry** -- nice to have, not blocking any extraction

**Defer to v1.7.0+:**
- Full git operation hooks (onWillPush, onWillMerge, etc.) -- only onWillCommit needed for v1.6.0
- Extension-to-extension API
- Permission/capability system
- Sandboxing beyond error boundaries
- Activation events / lazy loading refinement

## Graceful Degradation Patterns (Detailed)

### Pattern 1: Registry-Based UI Contribution

**How it works:** All extensible UI surfaces (sidebar panels, context menus, status bar, toolbar) are driven by registries. When an extension deactivates, its contributions are removed from registries. UI components subscribe to registry state and re-render automatically.

**Already proven:** Toolbar and blade registries work this way. Disabling the GitHub extension removes its toolbar buttons and blade types instantly.

**Apply to:** Sidebar panels, context menus, status bar items.

### Pattern 2: Hook Point with Fallthrough

**How it works:** Core operations define hook points where extensions can intercept. If no extension handles the hook, the core proceeds with default behavior.

**Example:** The commit flow fires `onWillCommit`. If the CC extension is active, it validates the message. If CC is disabled, no handler fires and the commit proceeds normally. The core commit form never imports or references conventional commit logic.

**Apply to:** Commit message validation/transformation, pre-merge checklist enforcement, branch naming validation.

### Pattern 3: Capability Query with Fallback

**How it works:** Core UI code queries whether a capability is available before rendering dependent UI.

```typescript
// Core code:
const hasConventionalCommits = useExtensionHost
  .getState()
  .extensions.get("conventional-commits")?.status === "active";

// Render CC toggle only if extension is active
{hasConventionalCommits && <CCToggleButton />}
```

**Better pattern** (decoupled): Instead of checking extension IDs, check for contributed capabilities:

```typescript
// Extension registers a capability:
api.contributeCapability("commit.composer", { ... });

// Core checks for capability presence:
const hasCommitComposer = useCapabilityRegistry
  .getState()
  .has("commit.composer");
```

**Apply to:** Commit form CC toggle, branch list gitflow badges, file list viewer options.

### Pattern 4: Error Boundary Isolation

**How it works:** Each extension-contributed UI component is wrapped in a React error boundary. If an extension component crashes, it shows a "Extension error" fallback instead of crashing the whole app.

**Apply to:** All extension blades (already partially done with lazy loading Suspense), sidebar panels, status bar items.

### Pattern 5: Slot/Placeholder Architecture

**How it works:** Core UI defines named "slots" where extensions can inject content. If no extension fills a slot, the slot renders nothing (or a default).

**Example:** The commit form has a slot `commit-form.actions` where CC can inject its "Compose" button. If CC is disabled, the slot is empty -- no broken UI.

```typescript
<ExtensionSlot name="commit-form.actions" />
// Renders all components contributed to this slot, or nothing
```

**Apply to:** Commit form auxiliary actions, branch list decorations, commit list badges.

## Sources

- [VS Code Contribution Points](https://code.visualstudio.com/api/references/contribution-points) -- HIGH confidence. Official documentation listing all 30+ contribution points.
- [VS Code Common Capabilities](https://code.visualstudio.com/api/extension-capabilities/common-capabilities) -- HIGH confidence. Commands, configuration, context menus, data storage, notifications.
- [VS Code Activation Events](https://code.visualstudio.com/api/references/activation-events) -- HIGH confidence. 25 activation event types for lazy extension loading.
- [VS Code SCM Provider API](https://code.visualstudio.com/api/extension-guides/scm-provider) -- HIGH confidence. SourceControl, ResourceGroup, ResourceState interfaces.
- [VS Code Extension Sandboxing Blog](https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox) -- MEDIUM confidence. Process sandboxing migration details.
- [VS Code Git Extension Architecture (DeepWiki)](https://deepwiki.com/microsoft/vscode/10-git-extension) -- MEDIUM confidence. CommandCenter pattern, activation strategy, public API exposure.
- [Zed Extension Capabilities](https://zed.dev/docs/extensions/capabilities) -- HIGH confidence. Capability-based permission model (process:exec, download_file, npm:install).
- [IntelliJ Plugin Extensions](https://plugins.jetbrains.com/docs/intellij/plugin-extensions.html) -- HIGH confidence. Extension point registration, ExtensionNotApplicableException for graceful degradation.
- [IntelliJ Plugin Dependencies](https://plugins.jetbrains.com/docs/intellij/plugin-dependencies.html) -- HIGH confidence. Optional dependencies with `config-file` attribute for conditional loading.
- [IntelliJ Plugin Services](https://plugins.jetbrains.com/docs/intellij/plugin-services.html) -- HIGH confidence. Application/project/module service scoping pattern.
- FlowForge codebase analysis: `ExtensionAPI.ts`, `ExtensionHost.ts`, `toolbarRegistry.ts`, `bladeRegistry.ts`, `commandRegistry.ts`, `github/index.ts` -- HIGH confidence. Direct code review.
