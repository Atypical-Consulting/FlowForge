# Domain Pitfalls

**Domain:** Extension System, GitHub Integration, Toolbar UX for Desktop Git Client
**Researched:** 2026-02-09

---

## Critical Pitfalls

Mistakes that cause rewrites or major issues.

### Pitfall 1: OAuth Client ID Exposure

**What goes wrong:** Embedding the GitHub OAuth App client ID in the frontend JavaScript bundle. Users extract it, impersonate FlowForge to request permissions.
**Why it happens:** Device Flow doesn't require a client secret, so developers assume the client ID is safe to embed.
**Consequences:** Phishing attacks using FlowForge's OAuth App identity. GitHub might revoke the app.
**Prevention:** The client ID for Device Flow is inherently public (it appears in URLs). This is expected and safe per GitHub's design. However, the client _secret_ must never be included. Device Flow explicitly does not use the secret. Verify no code path sends the secret. Keep the client ID in Rust-side configuration, not in the JS bundle.
**Detection:** `grep -r "client_secret" src/` returns any matches.

### Pitfall 2: Token Storage in Plain Files

**What goes wrong:** Storing GitHub OAuth tokens in `flowforge-settings.json` (tauri-plugin-store) instead of OS keychain.
**Why it happens:** tauri-plugin-store is already set up and easy to use. Developer takes the path of least resistance.
**Consequences:** Tokens readable by any process with filesystem access. Security vulnerability. Users store tokens for private repos with write access.
**Prevention:** Use the keyring crate to store tokens in macOS Keychain / Windows Credential Manager / Linux Secret Service. Never write tokens to the Store plugin.
**Detection:** Code review flag: any `.set()` call on the Store with keys containing "token", "auth", "credential".

### Pitfall 3: Extension Namespace Collisions

**What goes wrong:** Two extensions register a blade with the same type string (e.g., "issues"). The second registration silently overwrites the first.
**Why it happens:** The existing blade registry uses `Map.set()` which overwrites on key collision.
**Consequences:** One extension's views disappear. Subtle, hard-to-debug breakage.
**Prevention:** Namespace extension contributions with the extension ID prefix. Blade type `"issues"` from extension `"github"` becomes `"ext:github:issues"`. Enforce this in the ExtensionAPI, not by trusting extensions to self-prefix.
**Detection:** Registry logging in dev mode when a registration overwrites an existing entry.

### Pitfall 4: Blocking UI During Device Flow Polling

**What goes wrong:** Polling for the OAuth token on the main thread or showing a blocking modal that prevents any other interaction.
**Why it happens:** Device Flow polling can take 30-60 seconds while user switches to browser. Developer doesn't consider the wait time UX.
**Consequences:** App appears frozen. User force-quits. Token retrieval fails.
**Prevention:** Run polling in a Rust background task (tokio::spawn). Show a non-modal notification or dismissible panel in the UI. Allow user to cancel and retry. The Device Flow code expires after 15 minutes -- show a countdown.
**Detection:** UI freeze during auth flow testing.

### Pitfall 5: Dynamic import() Security with Extension Bundles

**What goes wrong:** Using `import()` to load arbitrary JS files from the filesystem without validation. Malicious extension code runs with full webview privileges.
**Why it happens:** Dynamic `import()` executes JavaScript with the same privileges as the host application.
**Consequences:** Extension code can access all DOM, all JavaScript APIs, potentially all Tauri IPC if not constrained.
**Prevention:**
1. For v1.5 (first-party only): acceptable risk since we author all extensions.
2. Validate manifest before loading bundle. Check that `main` field points to a file within the extension directory (path traversal check).
3. Extensions receive `ExtensionAPI`, NOT direct access to registries. The API object is the security boundary.
4. For future third-party: consider Content Security Policy restrictions, iframe sandboxing, or WebAssembly-based isolation.
**Detection:** Security review of extension loading code. Test with path traversal in manifest `main` field.

---

## Moderate Pitfalls

### Pitfall 6: ResizeObserver Infinite Loop

**What goes wrong:** Overflow menu calculation causes a layout change that triggers another ResizeObserver callback, creating an infinite loop.
**Why it happens:** Moving items to overflow reduces toolbar width, which triggers ResizeObserver, which recalculates, which might move items back.
**Prevention:** Use `requestAnimationFrame` for debouncing. Calculate overflow based on container width vs. total item widths (measured once), not based on current visible items. Avoid setState inside the observer callback without a guard.
**Detection:** Console warning: "ResizeObserver loop completed with undelivered notifications."

### Pitfall 7: GitHub API Rate Limiting

**What goes wrong:** Hitting GitHub's API rate limit (5,000 requests/hour for authenticated users, 60 for unauthenticated).
**Why it happens:** Aggressive polling, refetching on every blade open, or fetching full PR details for list views.
**Prevention:**
1. Use React Query's `staleTime` (30-60s for PRs/issues).
2. Use GraphQL to batch related queries (PR + reviews + checks in one request).
3. Show rate limit remaining in GitHub status indicator.
4. Cache aggressively: don't refetch on blade re-focus if data is fresh.
**Detection:** HTTP 403 responses with `X-RateLimit-Remaining: 0` header.

### Pitfall 8: Extension Activation Event Mismatch

**What goes wrong:** GitHub extension doesn't activate because remote URL parsing is too strict. e.g., `git@github.com:user/repo.git` doesn't match `onRepo:github.com` because the URL is SSH format.
**Why it happens:** Only checking for `https://github.com` prefix, missing SSH URLs.
**Prevention:** Parse both SSH (`git@github.com:user/repo.git`) and HTTPS (`https://github.com/user/repo`) remote URLs. Use a URL normalization function that handles both formats. Test with all common GitHub URL patterns.
**Detection:** Extension doesn't appear when repo has SSH remote.

### Pitfall 9: Keyring Access Denied on Linux

**What goes wrong:** The keyring crate fails to store/retrieve tokens on Linux because no Secret Service provider (GNOME Keyring, KWallet) is running.
**Why it happens:** Headless Linux environments, minimal desktop setups, or WSL don't have a Secret Service daemon.
**Consequences:** OAuth flow completes but token can't be stored. User has to re-authenticate on every app restart.
**Prevention:**
1. Detect keyring availability at startup: try a test write/read/delete cycle.
2. If keyring unavailable: fall back to encrypted file storage (tauri-plugin-store with a derived key), and warn the user that security is reduced.
3. Show clear error message, not a generic "authentication failed".
**Detection:** Test on minimal Linux (Xfce, i3, headless).

### Pitfall 10: Toolbar Reorder Persistence Desync

**What goes wrong:** User customizes toolbar (hides items), then an extension adds new items. The persisted toolbar state doesn't include the new items, so they're invisible.
**Why it happens:** Persistence stores a complete list of items with visibility flags. New items not in the list default to... what?
**Prevention:** Persistence stores only *overrides* from defaults, not the complete list. If an item ID is not in the override map, it uses the item's default visibility. New items from extensions appear with their manifest-declared default visibility.
**Detection:** Install extension, check toolbar, uninstall, reinstall -- toolbar item should reappear.

---

## Minor Pitfalls

### Pitfall 11: Octokit TypeScript Module Resolution

**What goes wrong:** Octokit v22 uses conditional exports requiring `"moduleResolution": "node16"` in tsconfig. Project might use `"bundler"` or `"node"`.
**Why it happens:** Octokit shifted to ESM-first with conditional exports in v21+.
**Prevention:** Check current `tsconfig.json` `moduleResolution` setting. Vite + `@vitejs/plugin-react` with `"moduleResolution": "bundler"` typically resolves conditional exports correctly. Test import before assuming it works.
**Detection:** TypeScript compilation errors on `import { Octokit } from "@octokit/rest"`.

### Pitfall 12: Device Flow Expiry Without User Feedback

**What goes wrong:** User opens auth URL but gets distracted. Code expires after 15 minutes. No feedback in the app.
**Why it happens:** Developer doesn't implement the expiry countdown or retry logic.
**Prevention:** Show countdown timer. When expired, show "Code expired, try again" with a retry button. The Device Flow response includes `expires_in` -- use it.
**Detection:** Manual test: start auth flow, wait 15 minutes without completing.

### Pitfall 13: Stale GitHub Data After Branch Switch

**What goes wrong:** User is on `feature/foo` looking at PRs. Switches to `main`. PR list still shows `feature/foo`'s PR context.
**Why it happens:** React Query cache is keyed by `["github", "prs", owner, repo]` which doesn't change on branch switch.
**Prevention:** The PR list blade shows all PRs for the repo (not branch-specific). Mark the current branch's PR with a visual indicator. Alternatively, if showing branch-specific PR view, include branch in the cache key and invalidate on branch change.
**Detection:** Branch switch + PR blade inspection.

### Pitfall 14: Extension Bundle Size Uncontrolled

**What goes wrong:** Extension authors bundle large dependencies (React, Octokit, etc.) into their extension, duplicating what the host app already provides.
**Why it happens:** No guidance or mechanism for using host-provided dependencies.
**Prevention:** Document that extensions should mark host-provided packages as `externals` in their build config. Provide a list of available host packages (React, framer-motion, Lucide, Octokit, etc.). For v1.5 (first-party only), bundle the GitHub extension as part of the main app build -- this is the simplest approach.
**Detection:** Extension bundle > 500KB is a red flag.

---

## Phase-Specific Warnings

| Phase Topic | Likely Pitfall | Mitigation |
|-------------|---------------|------------|
| Extension manifest design | Over-engineering the schema | Start with <15 fields. Add only when a real extension needs more. VS Code's manifest grew over 10 years -- don't front-load. |
| Extension loader (Rust) | Path traversal in manifest `main` field | Canonicalize paths. Ensure resolved path is within extension directory. |
| OAuth Device Flow | Race condition: multiple auth flows started | Use a mutex/flag in Rust to prevent concurrent device flows. |
| Token storage | keyring crate feature flags | Must explicitly enable `apple-native`, `windows-native`, `linux-native` features. No defaults. |
| PR list blade | Performance with 100+ open PRs | Paginate (GitHub API paginates at 30). Use `react-virtuoso` (already a dependency) for the list. |
| Toolbar refactor | Breaking existing Header.tsx tests | Current Header.tsx is complex (400+ lines). Refactor incrementally: extract ToolbarItemRegistry first, then swap rendering. |
| Toolbar customization | Accessibility of overflow menu | Overflow menu must be keyboard-navigable. Use `role="menu"`, `aria-expanded`, focus management. Already have patterns from command palette. |
| GitHub repo detection | Enterprise GitHub instances | URL parsing should handle `github.example.com` not just `github.com`. Accept configurable domain. |

---

## Sources

- [GitHub OAuth Device Flow](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps) -- expiry, polling interval
- [GitHub API Rate Limiting](https://docs.github.com/en/rest/rate-limit) -- rate limit details
- [keyring crate docs](https://docs.rs/keyring) -- platform-specific credential storage, feature flags
- [ResizeObserver MDN](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) -- loop detection
- [Tauri Security](https://v2.tauri.app/security/) -- CSP, isolation patterns
- [VS Code Extension Security](https://code.visualstudio.com/api/extension-guides/web-extensions) -- extension sandboxing considerations
- [Tauri secure storage discussion](https://github.com/tauri-apps/tauri/discussions/7846) -- community approaches to credential storage
