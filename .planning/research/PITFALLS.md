# Domain Pitfalls

**Domain:** Monorepo conversion and framework extraction from a 60K LOC Tauri+React desktop app
**Researched:** 2026-02-15

## Critical Pitfalls

Mistakes that cause rewrites, broken builds, or significant velocity loss.

### Pitfall 1: Circular Dependencies Between Extracted Packages

**What goes wrong:** The current codebase has bidirectional imports between all three layers. `framework` imports from `core` (3 occurrences in 2 files: `NavigationGuardDialog.tsx` and `BladeErrorBoundary.tsx` both import UI primitives like `Button` and `Dialog`). `core` imports from `extensions` (3 occurrences in 3 files: `bladeTypes.ts` and `previewRegistry.ts` import `DiffSource` type, `CommitListFallbackBlade.tsx` imports `CommitHistory` component). TypeScript project references forbid circular dependencies entirely -- `tsc --build` will error if package A references B and B references A.

**Why it happens:** In a single-package app, cross-layer imports are invisible pain. Developers import what they need without considering dependency direction because the path alias (`@/`) makes everything feel flat. During extraction, these violations surface as hard errors.

**Consequences:** The build breaks immediately. You cannot create packages with project references until every circular import is resolved. If you try to work around it by avoiding project references, you lose incremental builds and type-checking isolation -- defeating the purpose of the monorepo.

**Prevention:**
1. Before any package extraction, audit and fix all dependency direction violations. The specific violations found:
   - `framework` -> `core`: Move `Button` and `Dialog` components into `framework` or create a shared `ui-primitives` package
   - `core` -> `extensions`: Extract `DiffSource` type to `core` or `framework` types, replace `CommitHistory` import with a registry/slot pattern
2. Establish the dependency rule: `extensions` -> `core` -> `framework` (framework is the leaf, extensions are the consumers)
3. Add a lint rule (e.g., eslint-plugin-import with `no-restricted-paths`) that enforces layer boundaries before extraction begins
4. Run `madge --circular src/` to detect hidden cycles in the existing codebase

**Detection:** `tsc --build` fails with "Output file has not been built from source file" errors. Imports that cross package boundaries in the wrong direction.

**Confidence:** HIGH -- verified by direct codebase analysis of 312 cross-module imports.

---

### Pitfall 2: Tauri bindings.ts Becomes Unreachable or Duplicated

**What goes wrong:** The auto-generated `bindings.ts` file (produced by `tauri-specta`) lives at `src/bindings.ts` and is imported by 99 files across `core`, `framework`, and `extensions`. When these become separate packages, they all need access to the bindings types, but `bindings.ts` is generated by the Rust build into a single location configured via `builder.path("../src/bindings.ts")`. You cannot generate it into multiple packages, and you cannot import it across package boundaries without declaring it as a dependency.

**Why it happens:** `tauri-specta` generates a single TypeScript file at a configured path. In a monorepo, the generated file must live in exactly one package, but consumers span all packages.

**Consequences:** Either every package duplicates the bindings (drift risk), or you create an awkward dependency where the lowest-level package contains Tauri-specific generated code that conceptually belongs to the app layer.

**Prevention:**
1. Create a dedicated `@flowforge/bindings` package that contains only the generated `bindings.ts` file
2. Update `tauri-specta` builder path to point to this package's source directory
3. All other packages depend on `@flowforge/bindings` for types
4. Pre-existing TS2440 error in `bindings.ts` (line 1493) must be suppressed via `skipLibCheck` or fixed upstream -- it will block `tsc --build` for the bindings package specifically

**Detection:** Build failures referencing missing types from `bindings`. Multiple copies of binding types appearing in different packages.

**Confidence:** HIGH -- verified by codebase analysis showing 99 files import from bindings across all three layers.

---

### Pitfall 3: Vite Path Aliases Break Across Package Boundaries

**What goes wrong:** The app currently uses `@/` as a path alias (mapped to `src/` in both `tsconfig.json` and `vite.config.ts`). When code moves to separate packages, `@/` resolves relative to each package's root, not the app root. A component in `@flowforge/framework` that imports `@/core/components/ui/button` will fail because there is no `core/` directory in the framework package.

**Why it happens:** Vite resolves aliases from the importing package's root directory, not the consuming app's root. This is documented in [Vite issue #13404](https://github.com/vitejs/vite/issues/13404). The `@/` alias that unified 312 import sites becomes 312 breakpoints.

**Consequences:** Every import using `@/` that crosses a package boundary breaks. With 312 cross-module `@/` imports and 155 `@/framework` imports from extensions alone, this is a massive find-and-replace that must be done atomically -- partial migration leaves the app broken.

**Prevention:**
1. Before extraction, convert all cross-layer `@/` imports to use the future package names: `@flowforge/core`, `@flowforge/framework`, `@flowforge/extensions`
2. Use TypeScript path aliases to map these names to their current locations in the monorepo: `"@flowforge/core": ["src/core"]`
3. Within-package imports can keep using relative paths or a package-local `@/` alias
4. Do this refactor BEFORE creating separate packages -- it is safe to do in the current single-package structure and validates the dependency graph
5. Configure Vite's `resolve.alias` to match the TypeScript paths for dev server compatibility

**Detection:** Vite dev server fails to resolve imports. TypeScript reports "Cannot find module" errors after package extraction.

**Confidence:** HIGH -- verified by codebase analysis and confirmed by Vite ecosystem reports.

---

### Pitfall 4: Zustand Store Singleton Breakage in Multi-Package Setup

**What goes wrong:** Zustand stores are module-level singletons. When a store definition lives in one package and is imported by another, npm/pnpm can resolve the `zustand` dependency to different copies if versions diverge or hoisting goes wrong. Two instances of `zustand` means two separate store registries, and hooks in one package cannot read state written by another.

**Why it happens:** Package managers may install duplicate copies of `zustand` if different packages declare different version ranges, or if hoisting fails to deduplicate. This is the "multiple React instances" problem applied to state management. The project uses `zustand: "^5"` which is a wide range.

**Consequences:** Silent data loss. Stores appear empty. UI components render stale or missing state. Extremely difficult to debug because there are no error messages -- the stores just do not share state.

**Prevention:**
1. Pin `zustand` (and `react`, `react-dom`) as `peerDependencies` in all extracted packages, with the app providing the single copy
2. Add `zustand` to the workspace root's `dependencies` or use npm/pnpm `overrides` to force a single version
3. Verify deduplication: `npm ls zustand` should show exactly one resolved version
4. The existing Zustand auto-reset mock (`__mocks__/zustand.ts`) must remain at the workspace root for tests to work (see Pitfall 8)

**Detection:** `npm ls zustand` shows multiple resolved versions. State written in one package is not visible in components from another package.

**Confidence:** HIGH -- well-documented problem in [pmndrs/zustand discussion #2870](https://github.com/pmndrs/zustand/discussions/2870).

---

### Pitfall 5: Tailwind CSS v4 Utility Classes Not Generated for Shared Packages

**What goes wrong:** Tailwind v4 scans source files to determine which utility classes to generate. When UI components move to a separate package (e.g., `@flowforge/framework`), Tailwind's scanner does not automatically scan those files because they are outside the app's source tree. Components render without styles -- buttons have no padding, colors are missing, layout breaks.

**Why it happens:** Tailwind v4 replaced `content` configuration with automatic source detection based on the project root. In a monorepo, shared packages are outside the app's detection scope. The `@source` directive is required to explicitly tell Tailwind where to look.

**Consequences:** Shipped components appear completely unstyled. Since styles are missing silently (no build error), this can reach production. The Catppuccin theme tokens (`--catppuccin-color-*`, `--ctp-*`) defined in `index.css` and `@theme {}` block will not be available in packages that have their own CSS processing pipeline.

**Prevention:**
1. Add `@source` directives in the app's `index.css` pointing to all shared packages: `@source "../packages/framework/src/**/*.{ts,tsx}";`
2. Keep the `@theme {}` block (custom animations, fonts) and Catppuccin imports in the app's entry CSS -- shared packages should not independently import Tailwind
3. Shared packages export components that USE Tailwind classes but do not PROCESS them -- the consuming app's Tailwind pipeline handles class generation
4. Test extracted components by building the app and visually inspecting, not by building packages in isolation

**Detection:** Components appear unstyled in the running app. `tailwindcss` build output is smaller than expected. Missing classes in the generated CSS output.

**Confidence:** HIGH -- confirmed by [Tailwind CSS discussion #18770](https://github.com/tailwindlabs/tailwindcss/discussions/18770) and Tailwind monorepo guides.

---

## Moderate Pitfalls

### Pitfall 6: Tauri Build Pipeline Breaks with Changed frontendDist Path

**What goes wrong:** `tauri.conf.json` has `"frontendDist": "../dist"` and `"beforeBuildCommand": "npm run build"`. In a monorepo, the app's `dist` directory may move (e.g., to `apps/desktop/dist`), but Tauri's config path is relative to `src-tauri/`. If the Cargo workspace root changes or the app moves, Tauri cannot find the built frontend assets.

**Why it happens:** Tauri resolves `frontendDist` relative to the `tauri.conf.json` file location. Moving the frontend app within the monorepo without updating this path causes `cargo tauri build` to fail or bundle an empty/stale dist.

**Prevention:**
1. Keep `src-tauri/` as a sibling to the frontend app package, not at the monorepo root
2. Update `frontendDist` and `devUrl` paths after any directory restructuring
3. Add `cargo tauri build` to CI immediately after restructuring to catch path errors
4. The Cargo workspace (if you create one) should reference `src-tauri/Cargo.toml` at its current relative position

**Detection:** `cargo tauri build` succeeds (Rust compiles) but the app launches with a blank window or "file not found" error. The Tauri dev server cannot connect to Vite.

**Confidence:** HIGH -- Tauri's path configuration is well-documented.

---

### Pitfall 7: Vite HMR Stops Working for Extracted Packages

**What goes wrong:** Vite watches files within the app's module graph for HMR. When components move to a separate workspace package, Vite may pre-bundle them (treating them like `node_modules` dependencies) and cache the result. Changes to the package source do not trigger HMR -- developers must restart the dev server or manually invalidate the cache.

**Why it happens:** Vite's `optimizeDeps` pre-bundles workspace dependencies by default. The current config already includes `optimizeDeps.include: ["dagre-d3-es", "monaco-editor"]`. Workspace packages may be added to this pre-bundling list automatically, breaking live reload.

**Consequences:** Development velocity drops significantly. The tight feedback loop that makes Vite fast becomes "change code, restart server, wait." For a 60K LOC app with 20+ extensions, this compounds.

**Prevention:**
1. Configure `optimizeDeps.exclude` for all workspace packages: `exclude: ["@flowforge/core", "@flowforge/framework"]`
2. Point package.json `main`/`module` fields to source files (`.ts`/`.tsx`), not built artifacts, during development
3. Use Vite's `server.watch` to explicitly include workspace package source directories
4. Consider `@antdevx/vite-plugin-hmr-sync` if standard watching proves insufficient
5. Test HMR after each package extraction -- do not batch this validation

**Detection:** Changing a component in a shared package does not update the running app. Browser console shows no HMR updates. Vite logs show the package in `optimized deps`.

**Confidence:** MEDIUM -- confirmed pattern from [Vite issue #819](https://github.com/vitejs/vite/issues/819) and [discussion #7155](https://github.com/vitejs/vite/discussions/7155), but exact behavior depends on package manager and Vite version.

---

### Pitfall 8: Test Infrastructure Breaks Across Package Boundaries

**What goes wrong:** The test setup has several cross-cutting concerns that break when packages are extracted:
- `__mocks__/zustand.ts` at project root -- Vitest looks for `__mocks__/` relative to the project root of each package
- `src/core/test-utils/setup.ts` mocks 5 Tauri plugins globally -- packages need this setup but cannot import it across boundaries without circular deps
- `vi.mock("zustand")` in setup.ts enables auto-mocking for all 295 tests
- `vitest.config.ts` merges with `vite.config.ts` -- each package needs its own config

**Why it happens:** Vitest's module resolution and mock system operates per-package in a monorepo workspace. Global mocks and setup files do not automatically apply to other packages' test runs.

**Consequences:** Tests pass in the old structure but fail in the new one. False confidence if tests are not run during extraction. Mocking Tauri APIs must be duplicated or extracted into a shared test-utils package, creating a new dependency.

**Prevention:**
1. Create a `@flowforge/test-utils` package containing:
   - Zustand auto-reset mock
   - Tauri API mocks (commands, events, plugins)
   - Polyfills (ResizeObserver, crypto)
   - Common render helpers
2. Each package's `vitest.config.ts` references the shared setup
3. Copy `__mocks__/zustand.ts` to each package that uses Zustand, or use explicit `vi.mock()` calls in the shared setup
4. Run `npm test` from workspace root to test all packages -- do not rely on individual package tests passing in isolation
5. Keep the existing 295 tests green throughout migration by running them after each extraction step

**Detection:** Tests fail with "Cannot find module" errors for Tauri APIs. Zustand stores are not reset between tests. Setup file is not found by Vitest.

**Confidence:** HIGH -- verified by codebase analysis of test infrastructure.

---

### Pitfall 9: TypeScript Declaration Files and Module Resolution Mismatches

**What goes wrong:** The current `tsconfig.json` uses `"noEmit": true` and `"moduleResolution": "bundler"`. When extracting packages, each needs to emit declarations (`.d.ts` files) for consumers. But `"moduleResolution": "bundler"` allows import patterns that do not work with `"moduleResolution": "node"` or `"node16"`. If any consumer uses a different resolution mode, imports fail silently or produce wrong types.

**Why it happens:** `"allowImportingTsExtensions": true` in the current config means imports like `from "./foo.ts"` may exist. These are valid with `"noEmit": true` but invalid in packages that need to produce `.d.ts` output. The `"bundler"` module resolution is also not compatible with `"composite": true` required for project references in some TypeScript versions.

**Consequences:** Package consumers get `any` types or missing types. IDE experience degrades with red squiggles on valid imports. Build may succeed while type safety is silently lost.

**Prevention:**
1. Audit for `.ts`/`.tsx` extension imports -- replace with extensionless imports before extraction
2. Use `"composite": true` and `"declaration": true` in each package's `tsconfig.json`
3. Keep `"moduleResolution": "bundler"` across all packages for consistency
4. Use `tsc --build` for the entire workspace to validate project references
5. Add `"declarationMap": true` for click-through-to-source in IDE

**Detection:** Consumers see `any` types. `tsc --build` produces errors about incompatible module resolution. `.d.ts` files are not generated.

**Confidence:** MEDIUM -- depends on TypeScript version specifics, but the pattern is well-known.

---

### Pitfall 10: npm Workspaces Hoisting Breaks Tauri Plugin Resolution

**What goes wrong:** npm workspaces hoist dependencies to the monorepo root `node_modules/`. Tauri plugins (`@tauri-apps/plugin-dialog`, `@tauri-apps/plugin-store`, etc.) may be hoisted away from the app package. If the Tauri build process or runtime looks for plugins relative to the app's `node_modules/`, it fails to find them.

**Why it happens:** npm's hoisting algorithm moves shared dependencies to the root to save space. Tauri's Vite plugin and its runtime module loader may not follow symlinks correctly, depending on the version.

**Consequences:** Build succeeds but runtime crashes with "Plugin not found" errors. Or dev server starts but Tauri commands fail silently.

**Prevention:**
1. Test all Tauri plugin functionality after monorepo migration, not just builds
2. Use `"workspaces"` configuration carefully -- consider `nohoist` for `@tauri-apps/*` packages if issues arise
3. Keep all `@tauri-apps/*` dependencies in the app package, not in shared packages
4. Verify with `ls -la node_modules/@tauri-apps/` from the app directory to ensure correct resolution

**Detection:** Runtime errors like "Plugin X not registered." Tauri commands return errors about unregistered plugins. Works in single-package but fails in monorepo.

**Confidence:** MEDIUM -- Tauri monorepo support is documented but edge cases exist per [discussion #7368](https://github.com/tauri-apps/tauri/discussions/7368).

---

## Minor Pitfalls

### Pitfall 11: Package.json Exports Field Misconfiguration

**What goes wrong:** Extracted packages need proper `"exports"` field configuration to control what consumers can import. Missing or incorrect exports cause "Package subpath is not defined by exports" errors. Over-broad exports (e.g., `"./*": "./src/*"`) expose internal implementation details.

**Prevention:**
1. Define explicit exports for each package's public API
2. Use `"types"` condition alongside `"import"` and `"require"` for proper TypeScript support
3. Start with barrel exports (`"."`: `"./src/index.ts"`) and add subpath exports as needed
4. Test imports from the consumer app to verify exports work

**Confidence:** HIGH -- standard package authoring concern.

---

### Pitfall 12: Git History Loss During File Moves

**What goes wrong:** Moving files from `src/framework/` to `packages/framework/src/` with `git mv` preserves history, but bulk operations or copy-delete patterns lose it. Some monorepo migration tools restructure by deleting and recreating files.

**Prevention:**
1. Use `git mv` for all file moves, one directory at a time
2. Do structural moves in dedicated commits (no code changes in the same commit)
3. Verify with `git log --follow packages/framework/src/layout/BladeContainer.tsx` to confirm history is preserved
4. Never combine file moves with code refactoring in the same commit

**Confidence:** HIGH -- git behavior is well-understood.

---

### Pitfall 13: CI Pipeline Complexity Explosion

**What goes wrong:** The current CI likely runs `npm test` and `npm run build` once. In a monorepo, you need to determine which packages changed and only build/test affected ones. Without this, CI time grows linearly with packages, or worse, every PR runs all tests.

**Prevention:**
1. Start with "build everything, test everything" -- correctness over speed
2. Add selective testing (Turborepo, Nx, or custom git-diff scripts) only after the monorepo structure stabilizes
3. Ensure CI runs `tsc --build` (incremental) rather than per-package `tsc`
4. Cache `node_modules` and TypeScript build info files in CI

**Confidence:** MEDIUM -- depends on CI system specifics.

---

### Pitfall 14: Version Drift Between Workspace Packages

**What goes wrong:** After extraction, shared packages may drift in their dependency versions. One package updates `react` to 19.3 while another stays on 19.2. TypeScript types diverge, runtime behavior differs subtly.

**Prevention:**
1. Use shared `peerDependencies` for `react`, `react-dom`, `zustand`, `xstate`, and `@tauri-apps/*`
2. Keep a single `package.json` at the workspace root with `overrides` to pin critical versions
3. Use Renovate or Dependabot configured for monorepo-aware updates (group updates by package)

**Confidence:** HIGH -- standard monorepo hygiene.

---

## Integration Pitfalls (Cross-Cutting)

### I-1: The Big Bang vs Incremental Extraction Trap

**What goes wrong:** Teams attempt to extract all packages simultaneously in a single massive PR. The number of simultaneous breakages (paths, imports, types, tests, build config) makes it impossible to determine which change caused which failure. The PR grows to thousands of changed files and becomes unreviewable.

**Why it happens:** It feels more efficient to "just do it all at once." In reality, the compound interaction of path changes + import rewrites + config changes + test infrastructure changes creates an exponential debugging surface.

**Prevention:**
1. Extract ONE package at a time, in this order:
   - Phase A: `@flowforge/bindings` (smallest, no dependencies, validates the monorepo setup)
   - Phase B: `@flowforge/test-utils` (enables other packages to have tests)
   - Phase C: `@flowforge/framework` (leaf dependency, no outgoing deps)
   - Phase D: `@flowforge/core` (depends on framework and bindings)
   - Phase E: `@flowforge/extensions` (depends on core and framework)
2. After each extraction: verify build, verify tests, verify HMR, verify Tauri dev works
3. Each extraction should be a single PR that can be reverted cleanly
4. Keep the app functional throughout -- never have a state where `cargo tauri dev` does not work

**Detection:** PR with more than 200 files changed that includes structural moves AND code changes. Multiple unrelated test failures.

**Confidence:** HIGH -- universal pattern in large-scale refactoring.

---

### I-2: Store Registry Reset Mechanism Breaks with Package Boundaries

**What goes wrong:** FlowForge has a store reset registry (`registry.ts`) that clears all Zustand stores when switching repositories. If stores move to different packages, the registry in `core` cannot discover stores defined in `extensions` unless extensions explicitly register with it. Missing registration means stale data from the previous repo contaminates the new one.

**Prevention:**
1. The registry must be in the lowest-level package (framework or core) so all layers can import it
2. Each package's store definitions must call `registerStoreForReset()` during module initialization
3. Test specifically: open repo A, navigate to a feature, switch to repo B -- verify all state is fresh
4. Consider making store registration automatic via a factory function that wraps `zustand.create()` with auto-registration

**Detection:** Switching repositories shows stale data from the previous repo in some views. Stores from extracted packages are not reset.

**Confidence:** HIGH -- verified by codebase analysis of the existing `registry.ts` pattern.

---

### I-3: Module Augmentation and Type Extensions Break

**What goes wrong:** The recent refactor (commit `df76fd2`) moved blade type definitions to framework with module augmentation. Module augmentation (`declare module "@flowforge/framework"`) requires the augmenting file to be included in the consumer's TypeScript compilation. If the augmentation is in a package that is consumed as pre-built `.d.ts` files, the augmentation may not be applied.

**Prevention:**
1. Ensure all module augmentation files are explicitly included in the consumer's `tsconfig.json` `include` array
2. Test that augmented types are available in consuming packages
3. Consider using a central type registry pattern instead of module augmentation if it proves brittle across package boundaries

**Detection:** Types that should be augmented show as `unknown` or `never` in consuming packages. TypeScript does not error but types are incomplete.

**Confidence:** MEDIUM -- module augmentation across packages is a known pain point but behavior depends on TypeScript version and configuration.

---

## Phase-Specific Warnings

| Phase Topic | Likely Pitfall | Mitigation |
|-------------|---------------|------------|
| **Dependency audit** | Circular dependencies not fully mapped (Pitfall 1) | Run `madge --circular` and fix ALL violations before extraction begins |
| **Package extraction - framework** | `framework` imports `core` UI primitives (Button, Dialog) (Pitfall 1) | Move UI primitives INTO framework or create a shared ui-primitives package first |
| **Package extraction - core** | `core` imports `DiffSource` from `extensions`, `CommitHistory` from `extensions` (Pitfall 1) | Extract shared types to core; replace component imports with registry patterns |
| **Bindings package** | Pre-existing TS2440 error blocks `tsc --build` (Pitfall 2) | Suppress with `// @ts-expect-error` or configure `skipLibCheck` for the bindings package only |
| **Path alias migration** | 312 `@/` imports become invalid across package boundaries (Pitfall 3) | Refactor to package-name imports BEFORE extraction, while still in single-package |
| **Build pipeline** | `tauri.conf.json` paths break, HMR dies (Pitfalls 6, 7) | Validate `cargo tauri dev` and HMR after EACH structural change, not at the end |
| **Test migration** | 295 tests break due to mock/setup changes (Pitfall 8) | Create shared test-utils package early; run full test suite after each extraction step |
| **Tailwind theming** | Extracted components render without styles (Pitfall 5) | Add `@source` directives immediately; test visually, not just by build success |
| **TypeScript config** | `noEmit` + `allowImportingTsExtensions` incompatible with declaration output (Pitfall 9) | Audit and fix extension imports before enabling `composite: true` |
| **Singleton dependencies** | Zustand/React duplicate instances break state (Pitfall 4) | Pin as peerDependencies, verify with `npm ls`, use workspace overrides |
| **Module augmentation** | Blade type extensions not applied across packages (I-3) | Test augmented types in consumers, ensure augmentation files are included |

## Sources

- Codebase analysis: 312 `@/` cross-module imports across 173 files, 99 files importing `bindings.ts`, 3 framework->core imports, 3 core->extensions imports, 155 extensions->framework imports
- [Vite monorepo alias issues - #13404](https://github.com/vitejs/vite/issues/13404)
- [Vite HMR with local dependencies - #819](https://github.com/vitejs/vite/issues/819)
- [Vite HMR discussion - #7155](https://github.com/vitejs/vite/discussions/7155)
- [Zustand external package issue - #2870](https://github.com/pmndrs/zustand/discussions/2870)
- [Tailwind v4 monorepo styles - #18770](https://github.com/tailwindlabs/tailwindcss/discussions/18770)
- [Nx: Configure Tailwind 4 with Vite in npm workspace](https://nx.dev/blog/setup-tailwind-4-npm-workspace)
- [Tauri monorepo discussion - #7368](https://github.com/tauri-apps/tauri/discussions/7368)
- [TypeScript circular project references - #33685](https://github.com/microsoft/TypeScript/issues/33685)
- [Nx: Managing TS packages in monorepos](https://nx.dev/blog/managing-ts-packages-in-monorepos)
- [Moonrepo: TypeScript project references guide](https://moonrepo.dev/docs/guides/javascript/typescript-project-refs)
