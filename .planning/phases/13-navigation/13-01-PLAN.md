---
phase: 13-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/branch.rs
  - src-tauri/src/lib.rs
  - src/bindings.ts
autonomous: true

must_haves:
  truths:
    - "Backend can list both local and remote branches via a single command"
    - "Backend can checkout a remote branch by creating a local tracking branch"
    - "BranchInfo type distinguishes local from remote branches"
  artifacts:
    - path: "src-tauri/src/git/branch.rs"
      provides: "list_all_branches and checkout_remote_branch commands"
      contains: "list_all_branches"
    - path: "src/bindings.ts"
      provides: "TypeScript bindings for new commands"
      contains: "listAllBranches"
  key_links:
    - from: "src/bindings.ts"
      to: "src-tauri/src/git/branch.rs"
      via: "tauri-specta code generation"
      pattern: "listAllBranches|checkoutRemoteBranch"
---

<objective>
Extend the Rust backend to support listing remote branches and checking out remote branches as local tracking branches. This is a prerequisite for the branch switcher's remote branch toggle feature.

Purpose: The existing `list_branches` command only returns local branches. Phase 13 requires showing remote branches with a toggle and allowing users to checkout remote branches, which creates local tracking branches.

Output: Two new Tauri commands (`list_all_branches`, `checkout_remote_branch`), extended `BranchInfo` type with `is_remote` and `remote_name` fields, regenerated TypeScript bindings.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-navigation/13-CONTEXT.md
@.planning/phases/13-navigation/13-RESEARCH.md

@src-tauri/src/git/branch.rs
@src-tauri/src/git/error.rs
@src-tauri/src/lib.rs
@src/bindings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend BranchInfo and add list_all_branches command</name>
  <files>src-tauri/src/git/branch.rs</files>
  <action>
  1. Add two new fields to the `BranchInfo` struct:
     - `pub is_remote: bool` -- true for remote tracking branches, false for local
     - `pub remote_name: Option<String>` -- e.g., "origin" for remote branches, None for local

  2. Update the existing `list_branches` function to populate the new fields with `is_remote: false` and `remote_name: None` for all local branches. This preserves backward compatibility.

  3. Create a new `list_all_branches` Tauri command:
     ```rust
     #[tauri::command]
     #[specta::specta]
     pub async fn list_all_branches(
         include_remote: bool,
         state: State<'_, RepositoryState>,
     ) -> Result<Vec<BranchInfo>, GitError>
     ```
     - Always iterate `BranchType::Local` (same logic as existing `list_branches`)
     - If `include_remote` is true, also iterate `BranchType::Remote`
     - For remote branches:
       - Set `is_remote: true`
       - Parse remote name from the full branch name (e.g., "origin" from "origin/feature/x")
       - Set `remote_name: Some("origin".to_string())`
       - Use the full remote reference name as `name` (e.g., "origin/feature/x")
       - Get commit info the same way as local branches
       - Set `is_merged` using the same HEAD merge-base check
       - Skip `HEAD` references (remote repos have `origin/HEAD -> origin/main` pointers)
     - Sort: local HEAD first, then local alphabetically, then remote alphabetically

  4. Create a new `checkout_remote_branch` Tauri command:
     ```rust
     #[tauri::command]
     #[specta::specta]
     pub async fn checkout_remote_branch(
         remote_branch: String,
         state: State<'_, RepositoryState>,
     ) -> Result<(), GitError>
     ```
     - Parse the remote branch name to extract local name (e.g., "origin/feature/x" -> "feature/x")
     - Check if a local branch with that name already exists. If yes, just checkout it (call the existing checkout logic: `set_head` + `checkout_head`).
     - If no local branch exists:
       a. Find the remote reference via `repo.find_branch(&remote_branch, BranchType::Remote)`
       b. Get the commit it points to
       c. Create a local branch from that commit: `repo.branch(&local_name, &commit, false)`
       d. Set the upstream tracking: `branch.set_upstream(Some(&remote_branch))`
       e. Checkout the new local branch: `repo.set_head(...)` + `repo.checkout_head(...)`
     - Handle the `DirtyWorkingDirectory` error the same way as `checkout_branch`
  </action>
  <verify>
  Run `cd /Users/phmatray/Repositories/github-phm/FlowForge && cargo build --manifest-path src-tauri/Cargo.toml 2>&1` and confirm it compiles without errors.
  </verify>
  <done>
  - BranchInfo has `is_remote` and `remote_name` fields
  - `list_all_branches(true)` returns both local and remote branches
  - `list_all_branches(false)` returns only local branches (equivalent to list_branches)
  - `checkout_remote_branch` creates local tracking branch from remote reference
  - Existing `list_branches` still works unchanged (backward compatible)
  </done>
</task>

<task type="auto">
  <name>Task 2: Register new commands and regenerate bindings</name>
  <files>src-tauri/src/lib.rs, src/bindings.ts</files>
  <action>
  1. In `src-tauri/src/lib.rs`:
     - Add `list_all_branches` and `checkout_remote_branch` to the import from `git::branch`
     - Add both commands to the `collect_commands!` macro under the "Branch commands" section, right after the existing `delete_branch`

  2. Regenerate TypeScript bindings by running the dev build:
     ```bash
     cd /Users/phmatray/Repositories/github-phm/FlowForge
     cargo build --manifest-path src-tauri/Cargo.toml
     ```
     This triggers the `#[cfg(debug_assertions)]` block in `run()` that calls `builder.export(Typescript::default(), "../src/bindings.ts")`.

  3. Verify the generated `src/bindings.ts` contains:
     - `listAllBranches(includeRemote: boolean)` command
     - `checkoutRemoteBranch(remoteBranch: string)` command
     - Updated `BranchInfo` type with `isRemote: boolean` and `remoteName: string | null` fields
  </action>
  <verify>
  Run `grep -E "listAllBranches|checkoutRemoteBranch|isRemote|remoteName" /Users/phmatray/Repositories/github-phm/FlowForge/src/bindings.ts` and confirm all four patterns appear.
  </verify>
  <done>
  - `lib.rs` registers both new commands
  - `bindings.ts` is regenerated with new command functions and updated BranchInfo type
  - Project compiles cleanly with `cargo build`
  </done>
</task>

</tasks>

<verification>
1. `cargo build --manifest-path src-tauri/Cargo.toml` compiles without errors
2. `src/bindings.ts` contains `listAllBranches` and `checkoutRemoteBranch` commands
3. `BranchInfo` type in `bindings.ts` includes `isRemote` and `remoteName` fields
4. Existing `listBranches` command still present and unchanged in bindings
</verification>

<success_criteria>
- Rust backend compiles with two new commands: `list_all_branches` and `checkout_remote_branch`
- TypeScript bindings are regenerated and contain the new commands and extended types
- No regressions in existing branch commands
</success_criteria>

<output>
After completion, create `.planning/phases/13-navigation/13-01-SUMMARY.md`
</output>
