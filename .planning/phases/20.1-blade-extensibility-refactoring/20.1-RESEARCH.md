# Phase 20.1: Blade Extensibility Refactoring — Research

**Researched:** 2026-02-07
**Domain:** Blade system architecture, type safety, React rendering patterns, extensibility
**Confidence:** HIGH
**Method:** Three-perspective parallel analysis (UX, Architecture, Expert Developer)

## Summary

Phase 20 delivered a functional blade system with 12 blade types, push/pop navigation, and modal-to-blade migrations. However, the implementation has extensibility bottlenecks that will compound as Phases 21-24 add more blade types. Three independent analyses converged on the same critical issues:

1. **Untyped props** (`Record<string, unknown>`) create runtime fragility
2. **Monolithic renderBlade switch** requires 4-7 file changes per new blade type
3. **Re-render cascade** from unstable function references defeats memoization
4. **Inconsistent UX patterns** (loading states, error handling, Suspense, BladePanel wrapping)

## Critical Issues (All Three Perspectives Agree)

### Issue 1: `props: Record<string, unknown>` Is the Central Type Hole

**UX Impact:** `String(undefined)` silently becomes `"undefined"`, causing confusing API errors far from the actual mistake.

**Architecture Impact:** No compile-time guarantee that props match what renderBlade expects. The `as` cast on DiffBlade props (line 135 of RepositoryView.tsx) is particularly dangerous.

**Developer Impact:** Every prop access requires manual `String()` coercion. TypeScript provides zero protection.

**Solution:** Introduce a `BladePropsMap` interface mapping each blade type to its required props, then derive `BladeType` and `TypedBlade` from it. The `pushBlade` function becomes generic and compiler-enforced.

### Issue 2: renderBlade Switch Statement Monolith

**UX Impact:** Inconsistent wrapping (some blades in BladePanel, some not), inconsistent title computation (4 different strategies), inconsistent Suspense usage.

**Architecture Impact:** At 12 types, the switch is 160+ lines. At 30+ types it becomes unmaintainable. Adding a blade requires changes in 4-7 files.

**Developer Impact:** The callback depends on `goBack` (unstable) and `diffInline` (irrelevant to most blades), causing re-renders of ALL blades.

**Solution:** Blade registry pattern where each blade type is self-describing. BladeContainer or a BladeRenderer looks up the registration and renders accordingly. The switch collapses to ~25 lines of generic code.

### Issue 3: Render Performance — Unstable Function References

**Expert Developer Finding:** `goBack` in `useBladeNavigation` is a fresh closure on every render. It's a dependency of the `renderBlade` useCallback, which means the callback changes identity on every render, defeating memoization. `BladeContainer` and all blade subtrees re-render unnecessarily.

**Solution:** Use Zustand store methods directly (they're stable references) instead of creating closures. Move `diffInline` state into DiffBlade.

### Issue 4: No Error Boundaries

**UX Impact:** If any blade throws (Monaco editor fails, API returns malformed data), the entire RepositoryView crashes to white screen. Users lose their entire blade stack.

**Solution:** Wrap each blade in a `BladeErrorBoundary` that shows recovery UI while keeping the sidebar and strips functional.

## High-Priority Issues

### Issue 5: AnimatePresence Misplacement

`AnimatePresence` is placed INSIDE the `.map()` iteration in BladeContainer with a hard-coded key. Exit animations may not fire correctly. Should be outside the map, with the blade `id` as the motion.div key.

### Issue 6: Navigation Helper Proliferation

`useBladeNavigation` has 9 named helper functions, each following the same `pushBlade` pattern. Every new blade type adds another. Solution: Replace with a generic `openBlade<K extends BladeType>(type: K, props: BladePropsMap[K])` function.

### Issue 7: Duplicate pushBlade Call Sites

Three locations bypass the navigation hook:
- `useKeyboardShortcuts.ts` (lines 110, 214)
- `commands/settings.ts` (line 14)
- `commands/repository.ts` (line 57)

These duplicate blade construction logic. All should use a centralized opener.

### Issue 8: Lazy Blades in Barrel Export

`src/components/blades/index.ts` eagerly re-exports the four lazy-loaded blade components. While Vite tree-shakes unused exports in production, this is a footgun — any consumer importing from the barrel could accidentally pull in the lazy components eagerly.

### Issue 9: No Singleton Guard

Nothing prevents pushing duplicate settings/changelog blades. Opening settings twice pushes two identical blades onto the stack.

## Medium-Priority Issues

### Issue 10: Inconsistent Loading States

| Pattern | Used By |
|---------|---------|
| `Loader2` spinner on dark bg | DiffBlade, CommitDetailsBlade, ViewerImageBlade |
| Store-managed `isGenerating` | ChangelogBlade |
| Plain text "Loading..." | Lazy-loaded blades (Suspense fallback) |
| No loading UI | SettingsBlade |

Solution: Shared `BladeLoadingFallback` component.

### Issue 11: No Keyboard Navigation at Blade Level

No Escape key to go back, no focus management on push/pop, no Tab trapping in active blade.

### Issue 12: Redundant Chrome in ViewerImageBlade

`ViewerImageBlade` renders its own internal toolbar showing the file path and icon, while the parent `BladePanel` already shows the filename as its title. Doubled-up chrome.

### Issue 13: Zustand devtools Missing

Blade store does not use `devtools()` middleware. Stack changes are invisible in debugging tools.

## Recommended Registry Architecture

### Core Pattern (mirrors existing commandRegistry.ts)

```typescript
// src/lib/bladeRegistry.ts
interface BladeRegistration<TProps = Record<string, never>> {
  type: string;
  defaultTitle: string | ((props: TProps) => string);
  component: ComponentType<TProps> | LazyExoticComponent<ComponentType<TProps>>;
  lazy?: boolean;
  showBack?: boolean;
  wrapInPanel?: boolean;
  suspenseFallback?: ReactNode;
  renderTitleContent?: (props: TProps) => ReactNode;
  renderTrailing?: (props: TProps, ctx: BladeRenderContext) => ReactNode;
}
```

### Self-Registration

Each blade file exports a registration alongside its component:

```typescript
// CommitDetailsBlade.registration.ts
registerBlade<{ oid: string }>({
  type: "commit-details",
  defaultTitle: "Commit",
  component: CommitDetailsBlade,
  showBack: true,
  wrapInPanel: true,
});
```

### Generic renderBlade (replaces the switch)

```typescript
export function renderBlade(blade: TypedBlade, goBack: () => void) {
  const reg = getBladeRegistration(blade.type);
  if (!reg) return <div>Unknown blade type</div>;
  let content = <reg.component {...blade.props} />;
  if (reg.lazy) content = <Suspense fallback={...}>{content}</Suspense>;
  if (reg.wrapInPanel) content = <BladePanel ...>{content}</BladePanel>;
  return content;
}
```

## Type-Safe Props Architecture

### BladePropsMap (Option A — Recommended)

```typescript
export interface BladePropsMap {
  "staging-changes": Record<string, never>;
  "topology-graph": Record<string, never>;
  "commit-details": { oid: string };
  "diff": { source: DiffSource; inline?: boolean };
  "viewer-nupkg": { filePath: string };
  "viewer-image": { filePath: string; oid?: string };
  "viewer-markdown": { filePath: string };
  "viewer-3d": { filePath: string };
  "repo-browser": { path?: string };
  "settings": Record<string, never>;
  "changelog": Record<string, never>;
  "gitflow-cheatsheet": Record<string, never>;
}

type BladeType = keyof BladePropsMap;
```

### Type-Safe pushBlade

```typescript
pushBlade: <K extends BladeType>(type: K, title: string, props: BladePropsMap[K]) => void;
```

## Migration Strategy (Incremental, Non-Breaking)

1. **Phase A:** Introduce BladePropsMap and TypedBlade types (additive, no runtime changes)
2. **Phase B:** Create blade registry infrastructure and registration files (parallel to existing switch)
3. **Phase C:** Extract renderBlade from RepositoryView to use registry (replace switch)
4. **Phase D:** Refactor useBladeNavigation to generic openBlade (replace per-type helpers)
5. **Phase E:** Tighten store types and consolidate all pushBlade call sites
6. **Phase F:** Add error boundary, fix AnimatePresence, add Suspense boundary

## Files to Modify

| File | Changes |
|------|---------|
| `src/stores/blades.ts` | New BladePropsMap, typed pushBlade, devtools middleware |
| `src/lib/bladeRegistry.ts` | NEW — registry infrastructure |
| `src/components/blades/renderBlade.tsx` | NEW — generic render function |
| `src/components/blades/BladeErrorBoundary.tsx` | NEW — error boundary component |
| `src/components/blades/BladeLoadingFallback.tsx` | NEW — shared loading component |
| `src/components/blades/*.registration.ts` | NEW — 12 registration files |
| `src/components/blades/registrations.ts` | NEW — registration barrel |
| `src/components/blades/BladeContainer.tsx` | Fix AnimatePresence, add Suspense + ErrorBoundary |
| `src/components/RepositoryView.tsx` | Remove switch, lazy imports, diffInline state |
| `src/hooks/useBladeNavigation.ts` | Generic openBlade, remove per-type helpers |
| `src/hooks/useKeyboardShortcuts.ts` | Use centralized blade opening |
| `src/commands/settings.ts` | Use centralized blade opening |
| `src/commands/repository.ts` | Use centralized blade opening |
| `src/components/blades/index.ts` | Remove lazy blade exports |

## Anti-Patterns to Avoid

- Do NOT keep the switch statement alongside the registry — fully replace it
- Do NOT add runtime validation (Zod) when compile-time types are sufficient
- Do NOT move per-blade state into the registry — keep ephemeral state in React
- Do NOT over-abstract the BladePanel — it is intentionally simple
- Do NOT lazy-load all blades — only those with heavy dependencies (Monaco, react-markdown, model-viewer)

## Sources

All findings based on direct codebase analysis of 25+ files in the blade system, hooks, stores, and command infrastructure.

**Research date:** 2026-02-07
**Valid until:** 2026-03-07
