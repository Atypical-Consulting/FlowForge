---
phase: 31-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/monacoTheme.ts
  - vite.config.ts
  - package.json
  - src-tauri/src/git/nuget.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/lib.rs
  - src/components/viewers/NugetPackageViewer.tsx
  - src/bindings.ts
autonomous: true

must_haves:
  truths:
    - "Monaco editor loads without any CDN requests to cdn.jsdelivr.net"
    - "NuGet package info fetches go through a Rust backend command, not direct browser fetch"
    - "No frontend code makes direct external HTTP requests (all proxied through Tauri IPC)"
  artifacts:
    - path: "src/lib/monacoTheme.ts"
      provides: "Local Monaco bundling configuration"
      contains: "import * as monaco from 'monaco-editor'"
    - path: "src-tauri/src/git/nuget.rs"
      provides: "Rust NuGet proxy command"
      exports: ["fetch_nuget_info"]
    - path: "src/components/viewers/NugetPackageViewer.tsx"
      provides: "NuGet viewer using Tauri IPC instead of direct fetch"
      contains: "commands.fetchNugetInfo"
    - path: "vite.config.ts"
      provides: "Monaco worker bundling configuration"
  key_links:
    - from: "src/lib/monacoTheme.ts"
      to: "monaco-editor"
      via: "direct import instead of CDN loader"
      pattern: "import \\* as monaco from 'monaco-editor'"
    - from: "src/components/viewers/NugetPackageViewer.tsx"
      to: "src-tauri/src/git/nuget.rs"
      via: "Tauri IPC command"
      pattern: "commands\\.fetchNugetInfo"
---

<objective>
Eliminate all external network dependencies from the frontend by bundling Monaco Editor locally and proxying NuGet API calls through the Rust backend.

Purpose: Before CSP can be applied in Plan 02, all external CDN and API calls must be removed from the frontend. Monaco currently loads from cdn.jsdelivr.net (would be blocked by script-src 'self') and NuGet viewer fetches directly from nuget.org APIs (would be blocked by connect-src). Moving both to local/IPC eliminates the need for any external domain allowlisting in CSP.

Output: Monaco loads from bundled assets, NuGet info fetched via Rust command, zero external frontend requests.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/monacoTheme.ts
@src/lib/monacoConfig.ts
@src/components/viewers/NugetPackageViewer.tsx
@src-tauri/src/git/gitignore.rs
@src-tauri/src/git/mod.rs
@src-tauri/src/lib.rs
@vite.config.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bundle Monaco Editor locally instead of loading from CDN</name>
  <files>
    src/lib/monacoTheme.ts
    vite.config.ts
    package.json
  </files>
  <action>
    **Goal:** Make Monaco load from the app bundle, not from cdn.jsdelivr.net.

    **Step 1 - Add `monaco-editor` as a direct dependency:**
    It is already installed as a transitive dep of `@monaco-editor/react@4.7.0` but add it explicitly to package.json devDependencies to pin the version. Run `npm install monaco-editor --save-dev` (or add to devDependencies and npm install).

    **Step 2 - Rewrite `src/lib/monacoTheme.ts`:**
    Replace the CDN loader configuration with direct local import:

    ```typescript
    import * as monaco from "monaco-editor";
    import { loader } from "@monaco-editor/react";

    // Tell @monaco-editor/react to use locally bundled Monaco
    loader.config({ monaco });

    // Custom theme matching Catppuccin Mocha color scheme
    const FLOWFORGE_THEME = {
      // ... keep existing theme definition exactly as-is ...
    };

    // Register theme immediately (Monaco is available synchronously)
    monaco.editor.defineTheme("flowforge-dark", FLOWFORGE_THEME);
    ```

    Key changes:
    - Remove `loader.config({ paths: { vs: "https://cdn.jsdelivr.net/..." } })`
    - Import `monaco-editor` directly
    - Use `loader.config({ monaco })` to tell `@monaco-editor/react` to use the local bundle
    - Call `monaco.editor.defineTheme()` synchronously instead of through `loader.init().then()`

    **Step 3 - Configure Vite for Monaco workers:**
    Monaco needs web workers for syntax highlighting. Add to `vite.config.ts`:

    ```typescript
    import tailwindcss from "@tailwindcss/vite";
    import react from "@vitejs/plugin-react";
    import { defineConfig } from "vite";
    import svgr from "vite-plugin-svgr";

    export default defineConfig({
      plugins: [svgr(), react(), tailwindcss()],
      clearScreen: false,
      server: {
        port: 1420,
        strictPort: true,
        watch: {
          ignored: ["**/src-tauri/**"],
        },
      },
      envPrefix: ["VITE_", "TAURI_"],
      build: {
        target: process.env.TAURI_PLATFORM === "windows" ? "chrome105" : "safari13",
        minify: !process.env.TAURI_DEBUG ? "esbuild" : false,
        sourcemap: !!process.env.TAURI_DEBUG,
      },
      optimizeDeps: {
        include: ["dagre-d3-es", "monaco-editor"],
      },
      resolve: {
        alias: {
          "@": "/src",
        },
      },
      worker: {
        format: "es",
      },
    });
    ```

    Also, create or add a Monaco worker entry point. The standard approach with Vite is to use `monaco-editor/esm/vs/editor/editor.worker` imports. Add a file `src/lib/monacoWorkers.ts`:

    ```typescript
    import editorWorker from "monaco-editor/esm/vs/editor/editor.worker?worker";

    // Configure Monaco environment for worker loading
    self.MonacoEnvironment = {
      getWorker() {
        return new editorWorker();
      },
    };
    ```

    Import this file in `monacoTheme.ts` BEFORE the monaco import:
    ```typescript
    import "./monacoWorkers";
    import * as monaco from "monaco-editor";
    ```

    **Important:** Do NOT install any vite-plugin-monaco-editor. The native ESM import approach with `?worker` suffix is simpler and works with Vite out of the box.
  </action>
  <verify>
    1. Run `npm run build` — build succeeds without errors (ignore pre-existing TS2440 in bindings.ts)
    2. Run `grep -r "cdn.jsdelivr" src/` — returns zero matches (no CDN references remain)
    3. Run `npm run dev` and open the app — Monaco editor loads in DiffBlade or ViewerCodeBlade with the Catppuccin theme applied
  </verify>
  <done>
    Monaco editor renders with the flowforge-dark theme using locally bundled assets. No network requests to cdn.jsdelivr.net. All three Monaco usage sites (DiffBlade, ViewerCodeBlade, InlineDiffViewer) work correctly because they all import monacoTheme.ts as a side effect.
  </done>
</task>

<task type="auto">
  <name>Task 2: Proxy NuGet API calls through Rust backend command</name>
  <files>
    src-tauri/src/git/nuget.rs
    src-tauri/src/git/mod.rs
    src-tauri/src/lib.rs
    src/components/viewers/NugetPackageViewer.tsx
    src/bindings.ts
  </files>
  <action>
    **Goal:** Move NuGet API fetching from the frontend (browser `fetch()`) to a Rust Tauri command, following the same pattern as `gitignore.rs`.

    **Step 1 - Create `src-tauri/src/git/nuget.rs`:**

    Follow the `gitignore.rs` pattern exactly. Create a new module with:

    ```rust
    //! NuGet package info proxy for the NuGet Package Viewer blade.
    //!
    //! Proxies NuGet API calls through the Rust backend so the frontend
    //! never makes direct external HTTP requests (required for strict CSP).

    use serde::{Deserialize, Serialize};
    use specta::Type;
    use std::time::Duration;
    use crate::git::error::GitError;

    // ── Types ──────────────────────────────────────────────────────────

    #[derive(Debug, Clone, Serialize, Deserialize, Type)]
    #[serde(rename_all = "camelCase")]
    pub struct NugetPackageInfo {
        pub id: String,
        pub version: String,
        pub description: String,
        pub authors: String,
        pub total_downloads: u64,
        pub published: String,
        pub project_url: Option<String>,
        pub license_url: Option<String>,
        pub tags: Vec<String>,
        pub nuget_url: String,
    }

    // ── Internal API response types ────────────────────────────────────

    #[derive(Debug, Deserialize)]
    struct SearchResponse {
        data: Vec<SearchResult>,
    }

    #[derive(Debug, Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct SearchResult {
        id: Option<String>,
        version: Option<String>,
        description: Option<String>,
        authors: Option<serde_json::Value>,  // Can be string or array
        total_downloads: Option<u64>,
        project_url: Option<String>,
        license_url: Option<String>,
        tags: Option<Vec<String>>,
    }

    #[derive(Debug, Deserialize)]
    struct RegistrationIndex {
        items: Option<Vec<RegistrationPage>>,
    }

    #[derive(Debug, Deserialize)]
    struct RegistrationPage {
        items: Option<Vec<RegistrationLeaf>>,
    }

    #[derive(Debug, Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct RegistrationLeaf {
        catalog_entry: Option<CatalogEntry>,
    }

    #[derive(Debug, Deserialize)]
    struct CatalogEntry {
        published: Option<String>,
    }

    // ── Commands ───────────────────────────────────────────────────────

    /// Fetch NuGet package information by package ID.
    ///
    /// Queries the NuGet Search API and Registration API, returning
    /// combined package metadata. Returns None-equivalent error if
    /// package not found.
    #[tauri::command]
    #[specta::specta]
    pub async fn fetch_nuget_info(package_id: String) -> Result<NugetPackageInfo, GitError> {
        let client = reqwest::Client::new();

        // 1. Search API for package metadata
        let search_url = format!(
            "https://azuresearch-usnc.nuget.org/query?q=packageid:{}&prerelease=true&take=1",
            urlencoding::encode(&package_id)
        );

        let search_resp = client
            .get(&search_url)
            .timeout(Duration::from_secs(10))
            .send()
            .await
            .map_err(|e| GitError::OperationFailed(format!("NuGet search failed: {}", e)))?;

        if !search_resp.status().is_success() {
            return Err(GitError::OperationFailed(format!(
                "NuGet search returned {}",
                search_resp.status()
            )));
        }

        let search_data: SearchResponse = search_resp
            .json()
            .await
            .map_err(|e| GitError::OperationFailed(format!("NuGet search parse failed: {}", e)))?;

        let pkg = search_data
            .data
            .into_iter()
            .next()
            .ok_or_else(|| GitError::NotFound(format!("NuGet package not found: {}", package_id)))?;

        let id = pkg.id.unwrap_or_else(|| package_id.clone());

        // 2. Registration API for published date
        let lower_id = package_id.to_lowercase();
        let reg_url = format!(
            "https://api.nuget.org/v3/registration5-gz-semver2/{}/index.json",
            lower_id
        );

        let mut published = String::new();
        if let Ok(reg_resp) = client
            .get(&reg_url)
            .timeout(Duration::from_secs(5))
            .send()
            .await
        {
            if reg_resp.status().is_success() {
                if let Ok(reg_data) = reg_resp.json::<RegistrationIndex>().await {
                    if let Some(pages) = reg_data.items {
                        if let Some(page) = pages.first() {
                            if let Some(items) = &page.items {
                                if let Some(leaf) = items.last() {
                                    if let Some(entry) = &leaf.catalog_entry {
                                        published = entry.published.clone().unwrap_or_default();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Parse authors (can be string or array in NuGet API)
        let authors = match pkg.authors {
            Some(serde_json::Value::Array(arr)) => arr
                .iter()
                .filter_map(|v| v.as_str())
                .collect::<Vec<_>>()
                .join(", "),
            Some(serde_json::Value::String(s)) => s,
            _ => "Unknown".to_string(),
        };

        Ok(NugetPackageInfo {
            id: id.clone(),
            version: pkg.version.unwrap_or_default(),
            description: pkg.description.unwrap_or_else(|| "No description available".to_string()),
            authors,
            total_downloads: pkg.total_downloads.unwrap_or(0),
            published,
            project_url: pkg.project_url,
            license_url: pkg.license_url,
            tags: pkg.tags.unwrap_or_default(),
            nuget_url: format!("https://www.nuget.org/packages/{}", id),
        })
    }
    ```

    Note: Add `urlencoding` crate to Cargo.toml dependencies: `urlencoding = "2"`. Alternatively, use `percent_encoding` which is already in the dependency tree, or just use a simple manual encode for the package ID (it's alphanumeric + dots). Actually, simplest: just use `reqwest::Url::parse` or format the URL directly since NuGet package IDs are safe ASCII. Skip urlencoding dep — just format directly (package IDs are alphanumeric + dots/hyphens).

    Replace `urlencoding::encode(&package_id)` with just `&package_id` since NuGet package IDs are safe ASCII identifiers.

    **Step 2 - Register the module in `src-tauri/src/git/mod.rs`:**
    Add `pub mod nuget;` alongside the existing `pub mod gitignore;`

    **Step 3 - Register the command in `src-tauri/src/lib.rs`:**
    Find the `invoke_handler` builder and add `git::nuget::fetch_nuget_info` to the command list. Also add it to the specta `ts::builder()` collect call to generate TypeScript bindings.

    **Step 4 - Regenerate TypeScript bindings:**
    Run `cargo build` from `src-tauri/` to trigger specta binding generation (bindings.ts auto-updates).

    **Step 5 - Rewrite `src/components/viewers/NugetPackageViewer.tsx`:**
    Replace the direct `fetch()` calls with the Tauri command:

    ```typescript
    import { useQuery } from "@tanstack/react-query";
    import { commands } from "../../bindings";
    // ... keep existing imports ...

    // Remove: fetchNugetInfo function (entire function)
    // Remove: NugetPackageInfo interface (comes from bindings now)

    export function NugetPackageViewer({ file }: ViewerProps) {
      const parsed = parseNupkgFilename(file.path);

      const {
        data: packageInfo,
        isLoading,
        error,
      } = useQuery({
        queryKey: ["nuget-package", parsed?.id],
        queryFn: async () => {
          if (!parsed) return null;
          const result = await commands.fetchNugetInfo(parsed.id);
          if (result.status === "error") throw new Error(result.error);
          return result.data;
        },
        enabled: !!parsed,
        staleTime: 5 * 60 * 1000,
      });

      // ... rest of component stays the same, but update field access:
      // packageInfo.totalDownloads → already camelCase from specta
      // Keep the exact same JSX rendering
    }
    ```

    The field names from specta will be camelCase (serde rename_all = "camelCase"), so `totalDownloads`, `projectUrl`, `licenseUrl`, `nugetUrl` stay the same as before.
  </action>
  <verify>
    1. Run `cd src-tauri && cargo build` — Rust compiles without errors
    2. Run `grep -r "azuresearch\|api\.nuget\.org" src/` — returns zero matches in src/ (only in src-tauri/)
    3. Run `npm run build` — frontend build succeeds (ignore pre-existing TS2440)
    4. Open the app, navigate to a .nupkg file — NuGet package info loads correctly via Tauri IPC
  </verify>
  <done>
    NugetPackageViewer fetches package info via Tauri IPC command (`commands.fetchNugetInfo`) instead of direct browser `fetch()`. The frontend makes zero direct external HTTP requests. The Rust backend handles NuGet API calls with proper error handling and timeout.
  </done>
</task>

</tasks>

<verification>
1. `grep -r "cdn.jsdelivr\|azuresearch\|api\.nuget\.org" src/` returns zero matches — no external URLs in frontend code
2. `npm run build` succeeds
3. `cd src-tauri && cargo build` succeeds
4. Monaco editor renders with Catppuccin theme in ViewerCodeBlade
5. NuGet package info loads in ViewerNupkgBlade
</verification>

<success_criteria>
- Zero external CDN or API URLs remain in frontend source code (src/)
- Monaco editor works with locally bundled assets
- NuGet package info works through Rust IPC proxy
- Build succeeds for both frontend and Rust backend
</success_criteria>

<output>
After completion, create `.planning/phases/31-security-hardening/31-01-SUMMARY.md`
</output>
