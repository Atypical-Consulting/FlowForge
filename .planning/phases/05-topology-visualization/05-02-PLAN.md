# Plan: IPC Command Registration

## Frontmatter

```yaml
phase: 05
plan: 02
type: backend
wave: 2
depends_on: [05-01]
files_modified:
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/graph.rs
  - src-tauri/src/lib.rs
autonomous: true
must_haves:
  - get_commit_graph IPC command registered
  - Command callable from frontend via invoke
  - Type bindings generated via tauri-specta
  - Error handling follows existing patterns
```

## Objective

Register the get_commit_graph function as a Tauri IPC command so the frontend can request commit graph data. Generate TypeScript type bindings via tauri-specta.

## Tasks

<task id="1">
<title>Create graph commands module</title>
<instructions>
Create `src-tauri/src/commands/graph.rs` following the existing command patterns.

Define the IPC command:

```rust
use crate::git::graph::{get_commit_graph as git_get_commit_graph, CommitGraph};
use crate::state::AppState;
use std::path::PathBuf;
use tauri::State;

#[tauri::command]
#[specta::specta]
pub async fn get_commit_graph(
    state: State<'_, AppState>,
    path: PathBuf,
    limit: Option<usize>,
    offset: Option<usize>,
) -> Result<CommitGraph, String> {
    git_get_commit_graph(path, limit, offset)
        .await
        .map_err(|e| e.to_string())
}
```

Follow existing error handling patterns in the codebase - check how other commands handle GitError conversion.
</instructions>
</task>

<task id="2">
<title>Register module in commands/mod.rs</title>
<instructions>
Update `src-tauri/src/commands/mod.rs`:

1. Add `pub mod graph;` to module declarations
2. Re-export the command: `pub use graph::get_commit_graph;`

Look at how existing command modules are structured (e.g., staging, branches, history) and follow the same pattern.
</instructions>
</task>

<task id="3">
<title>Add command to invoke handler</title>
<instructions>
Update `src-tauri/src/lib.rs` to register the new command:

1. Find the `tauri::generate_handler![]` macro call
2. Add `commands::get_commit_graph` to the list of commands
3. Ensure the command is also included in the specta type export if using `collect_commands!` or similar

Look at how existing commands are registered and follow the exact same pattern.
</instructions>
</task>

<task id="4">
<title>Generate TypeScript bindings</title>
<instructions>
Run the type generation to create TypeScript bindings:

```bash
cd src-tauri
cargo build
```

The tauri-specta setup should automatically generate bindings. Verify the generated types include:

- BranchType enum
- GraphNode interface
- GraphEdge interface  
- CommitGraph interface
- getCommitGraph function

Check the generated bindings location (likely `src/bindings.ts` or similar) and verify the types are present.
</instructions>
</task>

## Verification

```bash
# Check backend compiles with new command
cd src-tauri && cargo check 2>&1 | head -20

# Verify command registration
grep -n "get_commit_graph" src-tauri/src/lib.rs
grep -n "get_commit_graph" src-tauri/src/commands/mod.rs

# Check TypeScript bindings generated
grep -n "CommitGraph\|getCommitGraph" src/bindings.ts 2>/dev/null || echo "Check bindings location"
```

## Success Criteria

- [ ] graph.rs command module exists
- [ ] Command registered in invoke handler
- [ ] Cargo check passes
- [ ] TypeScript bindings include CommitGraph types
- [ ] getCommitGraph function available in bindings
