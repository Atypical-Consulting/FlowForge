# Plan: Rust Graph Module

## Frontmatter

```yaml
phase: 05
plan: 01
type: backend
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/graph.rs
  - src-tauri/src/git/mod.rs
autonomous: true
must_haves:
  - Commit graph data structures defined with specta types
  - get_commit_graph function returns nodes and edges
  - Branch type classification for Gitflow coloring
  - Lane assignment algorithm positions commits in columns
  - Pagination support with limit and offset
```

## Objective

Create the Rust backend module that walks the commit graph, classifies branches by Gitflow type, assigns lane positions, and returns structured data for frontend visualization.

## Tasks

<task id="1">
<title>Create graph.rs module with data structures</title>
<instructions>
Create a new file `src-tauri/src/git/graph.rs` with the core data structures for the commit graph.

Define the following types with Serialize, Deserialize, and specta::Type derives:

1. `BranchType` enum: Main, Develop, Feature, Release, Hotfix, Other
2. `GraphNode` struct with fields:
   - oid: String (full SHA)
   - short_oid: String (7-char SHA)
   - message: String (first line only)
   - author: String
   - timestamp: i64 (Unix timestamp)
   - parents: Vec<String> (parent SHAs)
   - branch_type: BranchType
   - column: usize (lane position)
   - branch_names: Vec<String> (branches pointing to this commit)
3. `GraphEdge` struct with from/to String fields
4. `CommitGraph` struct containing nodes: Vec<GraphNode> and edges: Vec<GraphEdge>

Add helper function `classify_branch(name: &str) -> BranchType` that:
- Returns Main for "main" or "master"
- Returns Develop for "develop" or "dev"
- Returns Feature for names starting with "feature/"
- Returns Release for names starting with "release/"
- Returns Hotfix for names starting with "hotfix/"
- Returns Other for everything else
</instructions>
</task>

<task id="2">
<title>Implement get_commit_graph function</title>
<instructions>
Add the async `get_commit_graph` function to graph.rs:

```rust
pub async fn get_commit_graph(
    repo_path: PathBuf,
    limit: Option<usize>,
    offset: Option<usize>,
) -> Result<CommitGraph, GitError>
```

Implementation steps:

1. Open repository with spawn_blocking
2. Build branch-to-commit mapping:
   - Iterate all local branches
   - Map each branch tip OID to its branch name(s)
   - Store in HashMap<Oid, Vec<String>>
3. Create revwalk with topological + time sorting:
   - Push HEAD
   - Push all branch tips to get full graph
4. Walk commits with pagination:
   - Skip `offset` commits (default 0)
   - Collect up to `limit` commits (default 100, max 500)
5. For each commit:
   - Extract oid, message (first line), author, timestamp
   - Get parent OIDs
   - Determine branch_type from branch mapping
   - Assign column (lane) - initially 0, refined in task 3
6. Build edges from parent relationships
7. Return CommitGraph with nodes and edges

Use spawn_blocking for all git2 operations per project conventions.
</instructions>
</task>

<task id="3">
<title>Implement lane assignment algorithm</title>
<instructions>
Add lane assignment logic to position commits in columns for visual display.

Algorithm (process commits in topological order):
1. Maintain `active_columns: Vec<Option<String>>` tracking which branch occupies each column
2. For each commit:
   - If commit has a branch that's already in a column, use that column
   - Otherwise, find first empty column or add new column
   - If commit is a merge (multiple parents):
     - First parent stays in same column
     - Other parents may free their columns after this commit
3. Return column index for each node

Add function:
```rust
fn assign_lanes(nodes: &mut Vec<GraphNode>) {
    // Implementation
}
```

Call this function after collecting all nodes but before returning the CommitGraph.

The goal is to produce a layout where:
- Linear history stays in one column
- Branches fork to new columns on the right
- Merged branches can release their columns
</instructions>
</task>

<task id="4">
<title>Register module in mod.rs</title>
<instructions>
Update `src-tauri/src/git/mod.rs` to include the new graph module:

1. Add `pub mod graph;` to the module declarations
2. Re-export the public types in the module's public API:
   - BranchType
   - GraphNode
   - GraphEdge
   - CommitGraph
   - get_commit_graph function
</instructions>
</task>

## Verification

```bash
# Check module compiles
cd src-tauri && cargo check 2>&1 | head -20

# Verify types are exported
grep -n "pub mod graph" src-tauri/src/git/mod.rs
grep -n "BranchType\|GraphNode\|CommitGraph" src-tauri/src/git/graph.rs | head -10
```

## Success Criteria

- [ ] graph.rs exists with all data structures
- [ ] BranchType enum covers all Gitflow types
- [ ] get_commit_graph function compiles
- [ ] Lane assignment produces column values
- [ ] Module registered and exports visible
