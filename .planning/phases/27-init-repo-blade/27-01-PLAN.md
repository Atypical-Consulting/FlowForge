---
phase: 27-init-repo-blade
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/git/gitignore.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/lib.rs
  - src-tauri/resources/bundled-gitignore-templates.json
autonomous: true

must_haves:
  truths:
    - "Tauri command list_gitignore_templates returns template names from GitHub API with 5s timeout, falling back to bundled templates on failure"
    - "Tauri command get_gitignore_template returns the raw content of a single .gitignore template"
    - "Tauri command detect_project_type scans a directory for marker files and returns detected project types with recommended templates"
    - "Tauri command write_init_files writes .gitignore and/or README.md to disk at the specified path"
  artifacts:
    - path: "src-tauri/src/git/gitignore.rs"
      provides: "4 Tauri commands for gitignore template fetching, project detection, and file writing"
      exports: ["list_gitignore_templates", "get_gitignore_template", "detect_project_type", "write_init_files"]
    - path: "src-tauri/resources/bundled-gitignore-templates.json"
      provides: "Top 20 bundled .gitignore templates for offline fallback"
      contains: "Node"
    - path: "src-tauri/Cargo.toml"
      provides: "reqwest dependency for GitHub API calls"
      contains: "reqwest"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/git/gitignore.rs"
      via: "collect_commands! macro registration"
      pattern: "list_gitignore_templates.*get_gitignore_template.*detect_project_type.*write_init_files"
    - from: "src-tauri/src/git/mod.rs"
      to: "src-tauri/src/git/gitignore.rs"
      via: "pub mod gitignore"
      pattern: "pub mod gitignore"
---

<objective>
Create the Rust backend for the Init Repo Blade: 4 new Tauri commands for .gitignore template fetching (online + offline fallback), project type detection, and init file writing.

Purpose: The Init Repo Blade needs backend commands to fetch GitHub's 163 .gitignore templates, detect project types from marker files, and write generated files to disk. These commands must work offline via bundled fallback templates.

Output: `src-tauri/src/git/gitignore.rs` with 4 commands, `reqwest` dependency added, bundled templates JSON resource file, commands registered in `lib.rs`.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src-tauri/src/git/init.rs
@src-tauri/src/git/error.rs
@src-tauri/src/git/mod.rs
@src-tauri/src/lib.rs
@src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reqwest dependency and bundled templates resource</name>
  <files>src-tauri/Cargo.toml, src-tauri/resources/bundled-gitignore-templates.json</files>
  <action>
1. Add `reqwest` to `src-tauri/Cargo.toml` dependencies with features for JSON and TLS:
   ```toml
   reqwest = { version = "0.12", features = ["json", "rustls-tls"], default-features = false }
   ```
   Use `rustls-tls` (not `native-tls`) to avoid OpenSSL dependency on all platforms.

2. Create `src-tauri/resources/bundled-gitignore-templates.json` containing the top 20 .gitignore templates as a JSON object:
   ```json
   {
     "templates": [
       {
         "name": "Node",
         "content": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\nlerna-debug.log*\n.pnpm-debug.log*\n\n# Dependency directories\nnode_modules/\n\n# Build output\ndist/\nbuild/\n\n# dotenv environment variable files\n.env\n.env.development.local\n.env.test.local\n.env.production.local\n.env.local\n\n# Stores\n.yarn/\n"
       }
     ]
   }
   ```
   Include these 20 templates with their actual content (fetch from https://raw.githubusercontent.com/github/gitignore/main/{Name}.gitignore for each):
   Node, Python, Rust, Go, Java, C++, CSharp (VisualStudio), Swift, Kotlin, Ruby, Unity, Gradle, Maven, Terraform, Android, Flutter, JetBrains (Global/JetBrains.gitignore), VisualStudioCode (Global/VisualStudioCode.gitignore), macOS (Global/macOS.gitignore), Windows (Global/Windows.gitignore), Linux (Global/Linux.gitignore)

   Note: Some GitHub gitignore templates are in subdirectories (Global/). The bundled JSON should use the display name without path prefix. Keep content accurate to the actual GitHub gitignore repo.

3. Add the resources directory to the Tauri bundle configuration in `src-tauri/tauri.conf.json` if not already present — add `"resources": ["resources/*"]` to the bundle section so the file ships in production.
  </action>
  <verify>
    Run `cd /Users/phmatray/Repositories/github-phm/FlowForge/src-tauri && cargo check 2>&1 | head -20` — should compile without errors (reqwest resolves).
    Verify the JSON file exists and is valid: `python3 -c "import json; json.load(open('src-tauri/resources/bundled-gitignore-templates.json'))" && echo "Valid JSON"`.
  </verify>
  <done>
    - `reqwest` appears in Cargo.toml dependencies with `json` and `rustls-tls` features
    - `src-tauri/resources/bundled-gitignore-templates.json` exists with 20 template objects each having `name` and `content` fields
    - `cargo check` passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement 4 Tauri commands in gitignore.rs and register them</name>
  <files>src-tauri/src/git/gitignore.rs, src-tauri/src/git/mod.rs, src-tauri/src/lib.rs</files>
  <action>
1. Create `src-tauri/src/git/gitignore.rs` with these types and 4 commands:

**Types:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct GitignoreTemplateName {
    pub name: String,
    pub category: String, // "languages", "frameworks", "editors", "os", "other"
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct GitignoreTemplateList {
    pub templates: Vec<GitignoreTemplateName>,
    pub source: String, // "github" or "bundled"
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct GitignoreTemplate {
    pub name: String,
    pub content: String,
    pub source: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct ProjectDetection {
    pub detected_types: Vec<DetectedProject>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct DetectedProject {
    pub project_type: String,      // "Node.js", "Rust", "Python", etc.
    pub marker_file: String,       // "package.json", "Cargo.toml", etc.
    pub recommended_templates: Vec<String>, // ["Node"], ["Rust"], etc.
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct InitFile {
    pub filename: String,  // ".gitignore" or "README.md"
    pub content: String,
}
```

**Command 1: `list_gitignore_templates`**
- Attempt `reqwest::Client::new().get("https://api.github.com/gitignore/templates").header("User-Agent", "FlowForge").timeout(Duration::from_secs(5)).send().await`
- On success: parse JSON array of strings, map each to `GitignoreTemplateName` with category assigned via a `categorize_template(name)` helper function
- On failure (any error): load bundled templates from `include_str!("../../resources/bundled-gitignore-templates.json")`, parse JSON, return with `source: "bundled"`
- Return `GitignoreTemplateList` with `source: "github"` or `source: "bundled"`
- The `categorize_template` helper maps template names to categories using hardcoded match arms (e.g., "Node"|"Python"|"Java"... => "languages", "JetBrains"|"VisualStudio"... => "editors", "macOS"|"Windows"|"Linux" => "os")

**Command 2: `get_gitignore_template(name: String)`**
- Attempt `reqwest::Client::new().get(format!("https://api.github.com/gitignore/templates/{name}")).header("User-Agent", "FlowForge").header("Accept", "application/vnd.github.raw+json").timeout(Duration::from_secs(5)).send().await`
- On success: The GitHub API returns JSON with `{ name, source }` where `source` is the template content. Parse and return `GitignoreTemplate { name, content: parsed.source, source: "github" }`
- On failure: search bundled templates JSON for matching name, return with `source: "bundled"`
- If not found in either: return `Err(GitError::NotFound(format!("Gitignore template not found: {}", name)))`

**Command 3: `detect_project_type(path: String)`**
- Accept a directory path, validate it exists
- Check for marker files/directories using `std::path::Path::new(&path).join(marker).exists()`:
  - `package.json` -> Node.js -> ["Node"]
  - `tsconfig.json` -> TypeScript -> ["Node"]
  - `Cargo.toml` -> Rust -> ["Rust"]
  - `go.mod` -> Go -> ["Go"]
  - `pom.xml` -> Java (Maven) -> ["Java", "Maven"]
  - `build.gradle` or `build.gradle.kts` -> Java (Gradle) -> ["Java", "Gradle"]
  - `requirements.txt` or `pyproject.toml` or `setup.py` -> Python -> ["Python"]
  - `*.csproj` or `*.sln` (glob in directory) -> C# -> ["VisualStudio"]
  - `*.xcodeproj` or `Package.swift` -> Swift -> ["Swift"]
  - `pubspec.yaml` -> Flutter -> ["Flutter"]
  - `composer.json` -> PHP -> ["Composer"]
  - `.idea/` directory -> JetBrains -> ["JetBrains"]
  - `.vscode/` directory -> VS Code -> ["VisualStudioCode"]
- For glob patterns (*.csproj, *.sln, *.xcodeproj), use `std::fs::read_dir` and check extensions
- Return `ProjectDetection { detected_types }` with all matches (a project can be both Node.js and VS Code)
- Run the detection on a blocking thread via `tokio::task::spawn_blocking`

**Command 4: `write_init_files(path: String, files: Vec<InitFile>)`**
- Validate directory exists
- For each file in `files`, write `std::fs::write(Path::new(&path).join(&file.filename), &file.content)`
- Return `Ok(())` or `Err(GitError::OperationFailed(...))`
- Run on blocking thread

2. Add `pub mod gitignore;` to `src-tauri/src/git/mod.rs`

3. In `src-tauri/src/lib.rs`:
   - Add import: `gitignore::{list_gitignore_templates, get_gitignore_template, detect_project_type, write_init_files},` in the `use git::` block
   - Add to `collect_commands!` macro: the 4 new commands in an "// Init gitignore commands" section after the existing "// Init commands" section
  </action>
  <verify>
    Run `cd /Users/phmatray/Repositories/github-phm/FlowForge/src-tauri && cargo check 2>&1 | tail -5` — should pass with no errors.
    Run `cd /Users/phmatray/Repositories/github-phm/FlowForge && npm run build 2>&1 | tail -10` — TypeScript bindings auto-generate on build. Check that `src/bindings.ts` now contains the new command names (this will be verified in subsequent plans).
  </verify>
  <done>
    - `src-tauri/src/git/gitignore.rs` exists with 4 `#[tauri::command]` functions and all type definitions
    - `src-tauri/src/git/mod.rs` has `pub mod gitignore;`
    - `src-tauri/src/lib.rs` imports and registers all 4 commands
    - `cargo check` passes without errors
  </done>
</task>

</tasks>

<verification>
1. `cargo check` in `src-tauri/` passes with no errors
2. All 4 commands are registered in `collect_commands!` macro in `lib.rs`
3. `bundled-gitignore-templates.json` is valid JSON with 20 templates
4. `gitignore.rs` has proper `#[tauri::command]` and `#[specta::specta]` attributes on all commands
5. The `include_str!` path correctly references the bundled templates file relative to `gitignore.rs`
</verification>

<success_criteria>
- 4 new Tauri commands compile and are registered
- reqwest dependency with rustls-tls added
- Bundled fallback templates embedded via include_str!
- Project detection handles 13 marker file patterns
- TypeScript bindings will auto-generate on next build
</success_criteria>

<output>
After completion, create `.planning/phases/27-init-repo-blade/27-01-SUMMARY.md`
</output>
