---
phase: 27-init-repo-blade
plan: 04
type: execute
wave: 3
depends_on: ["27-03"]
files_modified:
  - src/components/init-repo/InitRepoPreview.tsx
  - src/components/init-repo/InitRepoForm.tsx
  - src/components/blades/InitRepoBlade.tsx
  - src/components/welcome/GitInitBanner.tsx
  - src/lib/bladeOpener.ts
autonomous: false

must_haves:
  truths:
    - "User can preview a .gitignore template's contents before applying it"
    - "User can preview the composed multi-template .gitignore output in the right panel"
    - "User can open the Init Repo blade from the welcome screen when a non-git folder is detected"
    - "User can initialize a repository with chosen branch name, optional .gitignore, optional README, and optional initial commit"
    - "User can select .gitignore templates while offline via bundled fallback without errors"
  artifacts:
    - path: "src/components/init-repo/InitRepoPreview.tsx"
      provides: "Context-sensitive preview panel showing .gitignore preview, README preview, or summary"
      exports: ["InitRepoPreview"]
    - path: "src/components/welcome/GitInitBanner.tsx"
      provides: "Updated banner that opens Init Repo blade instead of inline init"
      exports: ["GitInitBanner"]
  key_links:
    - from: "src/components/init-repo/InitRepoPreview.tsx"
      to: "src/lib/gitignoreComposer.ts"
      via: "composeGitignore called to generate preview"
      pattern: "composeGitignore"
    - from: "src/components/init-repo/InitRepoForm.tsx"
      to: "src/bindings.ts"
      via: "Init pipeline: git_init -> write_init_files -> open_repository -> stage_all + create_commit"
      pattern: "commands\\.gitInit|commands\\.writeInitFiles|commands\\.stageAll|commands\\.createCommit"
    - from: "src/components/welcome/GitInitBanner.tsx"
      to: "src/lib/bladeOpener.ts"
      via: "Opens init-repo blade with directoryPath"
      pattern: "openBlade.*init-repo"
---

<objective>
Complete the Init Repo feature: preview panel with context-sensitive content, init execution pipeline, welcome screen entry point integration, and end-to-end verification.

Purpose: This plan wires everything together — the preview panel shows composed .gitignore or README output, the Initialize button executes the full pipeline (git_init -> write_init_files -> open_repository -> optional commit), and entry points from WelcomeView are connected.

Output: `InitRepoPreview.tsx`, updated `GitInitBanner.tsx`, wired init pipeline in form, checkpoint for visual verification.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-init-repo-blade/27-01-SUMMARY.md
@.planning/phases/27-init-repo-blade/27-02-SUMMARY.md
@.planning/phases/27-init-repo-blade/27-03-SUMMARY.md

@src/components/blades/InitRepoBlade.tsx
@src/components/init-repo/InitRepoForm.tsx
@src/components/welcome/GitInitBanner.tsx
@src/lib/bladeOpener.ts
@src/lib/gitignoreComposer.ts
@src/stores/initRepo.ts
@src/hooks/useGitignoreTemplates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InitRepoPreview and wire init execution pipeline</name>
  <files>src/components/init-repo/InitRepoPreview.tsx, src/components/init-repo/InitRepoForm.tsx, src/components/blades/InitRepoBlade.tsx</files>
  <action>
1. **InitRepoPreview.tsx** — Context-sensitive right panel:

   The preview switches content based on `activeSection` from the store:

   **When `activeSection === "gitignore"`:**
   - If `isPickerOpen` and a template is being previewed (hovered/clicked eye icon), show single template raw content
   - Otherwise, show the composed multi-template output via `composeGitignore(selectedTemplates.map(name => ({ name, content: templateContents[name] || "" })))`
   - Header: "Preview: .gitignore" with FileText icon
   - Content: monospace `<pre>` block styled with `bg-ctp-mantle text-ctp-text font-mono text-sm p-4 rounded-lg overflow-auto whitespace-pre`
   - Show "Select templates to preview" empty state when no templates are selected

   **When `activeSection === "readme"`:**
   - Generate README content from store state:
     ```
     # {readmeName}

     {readmeDescription}
     ```
   - Header: "Preview: README.md" with FileText icon
   - Render as styled markdown preview (heading + paragraph, using Tailwind prose-like classes: `text-ctp-text` for heading, `text-ctp-subtext1` for description)
   - Show "Enable README generation to preview" when `readmeEnabled` is false

   **When `activeSection === "commit"`:**
   - Show a summary of what the commit will contain:
     - List of files to be committed: `.gitignore` (if templates selected), `README.md` (if readme enabled)
     - Commit message preview
   - Header: "Initial Commit Summary" with GitCommit icon
   - Styled as a card with file list

   **When `activeSection === "summary"` (default):**
   - Show an overview of all planned actions:
     - Directory path
     - Branch name
     - Number of .gitignore templates selected
     - README status
     - Commit status
   - Header: "Initialization Summary" with Folder icon
   - Styled as a checklist/summary card

   **Animation:** Use `AnimatePresence` with `mode="wait"` and a simple fade transition (`initial={{ opacity: 0 }}`, `animate={{ opacity: 1 }}`, `exit={{ opacity: 0 }}`) for smooth preview switching. Wrap the entire preview content in a `motion.div` keyed by `activeSection`.

   **Container:** `h-full flex flex-col` with header area and scrollable content area.

2. **Wire init execution pipeline** — Update `InitRepoForm.tsx`:

   Add the `handleInitialize` async function to the form's Initialize button:

   ```typescript
   const handleInitialize = async () => {
     const store = useInitRepoStore.getState();
     store.setIsInitializing(true);
     store.setInitError(null);

     try {
       // Step 1: git init
       const initResult = await commands.gitInit(store.directoryPath, store.defaultBranch);
       if (initResult.status === "error") {
         store.setInitError(getErrorMessage(initResult.error));
         return;
       }

       // Step 2: Write init files (.gitignore, README.md)
       const files: Array<{ filename: string; content: string }> = [];

       if (store.selectedTemplates.length > 0) {
         const composed = composeGitignore(
           store.selectedTemplates.map(name => ({
             name,
             content: store.templateContents[name] || "",
           }))
         );
         files.push({ filename: ".gitignore", content: composed });
       }

       if (store.readmeEnabled) {
         let readme = `# ${store.readmeName || "Project"}\n`;
         if (store.readmeDescription) {
           readme += `\n${store.readmeDescription}\n`;
         }
         files.push({ filename: "README.md", content: readme });
       }

       if (files.length > 0) {
         const writeResult = await commands.writeInitFiles(store.directoryPath, files);
         if (writeResult.status === "error") {
           store.setInitError(getErrorMessage(writeResult.error));
           return;
         }
       }

       // Step 3: Open repository
       await openRepository(store.directoryPath);
       await addRecentRepo(store.directoryPath);

       // Step 4: Optional initial commit
       if (store.commitEnabled && files.length > 0) {
         const stageResult = await commands.stageAll();
         if (stageResult.status === "ok") {
           await commands.createCommit(store.commitMessage || "Initial commit");
         }
       }

       // Success — store.reset() will happen on unmount
     } catch (e) {
       store.setInitError(e instanceof Error ? e.message : "Failed to initialize repository");
     } finally {
       store.setIsInitializing(false);
     }
   };
   ```

   - Import `composeGitignore` from `../../lib/gitignoreComposer`
   - Import `getErrorMessage` from `../../lib/errors`
   - Import `useRepositoryStore` for `openRepository`
   - Import `useRecentRepos` for `addRecentRepo`
   - Show error below action bar: if `initError` is not null, display `<div className="flex items-center gap-2 text-sm text-ctp-red p-4"><AlertCircle className="w-4 h-4 shrink-0" />{initError}</div>`
   - Wire Cancel button to call `goBack()` from `useBladeNavigation()`

3. **Update InitRepoBlade.tsx** — Replace the placeholder preview with `<InitRepoPreview />`:
   - Import `InitRepoPreview` and pass it as the `detail` prop of SplitPaneLayout
   - Ensure the template content is fetched for all selected templates: iterate `selectedTemplates` and for each, if `templateContents[name]` is missing, fetch via `commands.getGitignoreTemplate(name)` and store the content
   - This can use a `useEffect` that watches `selectedTemplates` and fetches missing content

4. **Wire activeSection** — In `InitRepoForm.tsx`, when the user interacts with each section:
   - Clicking/focusing within the .gitignore section: `setActiveSection("gitignore")`
   - Clicking/focusing within the README section: `setActiveSection("readme")`
   - Clicking/focusing within the Initial Commit section: `setActiveSection("commit")`
   - Default on mount: `setActiveSection("summary")`
   - Use `onFocus` handlers on section wrapper divs
  </action>
  <verify>
    Run `npx tsc --noEmit 2>&1 | grep -v "bindings.ts" | tail -15` — no errors.
    Verify preview component exists: `ls src/components/init-repo/InitRepoPreview.tsx`.
  </verify>
  <done>
    - InitRepoPreview renders 4 context-sensitive views based on activeSection
    - .gitignore preview shows composed output via composeGitignore
    - README preview shows generated markdown
    - Init pipeline executes: git_init -> write_init_files -> open_repository -> (optional) stage_all + create_commit
    - Error handling shows inline error message below action bar
    - Cancel navigates back and resets store
  </done>
</task>

<task type="auto">
  <name>Task 2: Update entry points — GitInitBanner and blade opener integration</name>
  <files>src/components/welcome/GitInitBanner.tsx, src/lib/bladeOpener.ts</files>
  <action>
1. **Update GitInitBanner.tsx** — Replace the inline init form with a button that opens the Init Repo blade:

   The current `GitInitBanner` has an inline form with branch checkbox and Initialize button. Replace the entire form body with a simplified banner that opens the blade:

   ```tsx
   export function GitInitBanner({ path, onDismiss }: GitInitBannerProps) {
     const openInitBlade = () => {
       // Open init-repo blade with the detected path
       // The blade handles all configuration
       openBlade("init-repo", { directoryPath: path });
     };

     const folderName = path.split("/").pop() || path.split("\\").pop() || path;

     return (
       <motion.div
         variants={fadeInUp}
         initial="hidden"
         animate="show"
         role="region"
         aria-label="Git repository initialization"
         className="flex flex-col gap-3 p-4 bg-ctp-surface0/50 backdrop-blur-sm border border-ctp-surface1 rounded-lg"
       >
         <div className="flex items-start gap-3">
           <GitBranch className="w-5 h-5 text-ctp-blue shrink-0 mt-0.5" />
           <div>
             <div className="text-sm font-medium text-ctp-text">
               This folder is not a Git repository
             </div>
             <div className="text-sm text-ctp-subtext0 mt-1">
               Initialize &ldquo;{folderName}&rdquo; with .gitignore templates, README, and more.
             </div>
           </div>
         </div>
         <div className="ml-8 flex gap-2">
           <Button size="sm" onClick={openInitBlade} className="gap-2">
             <FolderGit2 className="w-4 h-4" />
             Set Up Repository
           </Button>
           <Button variant="ghost" size="sm" onClick={onDismiss}>
             Dismiss
           </Button>
         </div>
       </motion.div>
     );
   }
   ```

   - Import `FolderGit2` from lucide-react
   - Import `openBlade` from bladeOpener (check existing pattern in `bladeOpener.ts`)
   - Remove the old `useMainBranch`, `isInitializing`, `initError` state and `handleInitialize` logic
   - Remove the `useRepositoryStore` and `useRecentRepos` imports (no longer needed here)

2. **bladeOpener.ts** — Verify or add `"init-repo"` support:
   - Check the existing `openBlade` function signature. It should accept any `BladeType` and corresponding props.
   - If `openBlade` already works generically with `BladeType` + `BladePropsMap[T]`, no changes needed since we added `"init-repo"` to `BladePropsMap`.
   - If the function has hardcoded blade types, add `"init-repo"` handling.

   Note: The blade opener pushes blades onto the blade stack. Since `InitRepoBlade` renders within the blade container (which requires a repo to be open), BUT the Init Repo blade is triggered from the welcome screen (no repo open), we need to handle this case:

   **IMPORTANT**: The research identified that the Init Repo blade runs BEFORE a repo is open. The blade container only renders inside `RepositoryView`. Therefore, the `GitInitBanner` should NOT use `openBlade`. Instead, it should manage a local state that renders the `InitRepoBlade` component directly within the welcome view context.

   Update the approach: Instead of using the blade system, render `InitRepoBlade` as a standalone component within the welcome flow:

   In `GitInitBanner` parent component (the file that renders `GitInitBanner` — check where it is used):
   - When the user clicks "Set Up Repository", set a `pendingInitPath` state
   - Render `InitRepoBlade` directly (not through blade stack) with `directoryPath={pendingInitPath}`
   - Wrap in a full-screen overlay or replace the welcome content entirely
   - Pass `onCancel={() => setPendingInitPath(null)}` and `onComplete={async (path) => { await openRepository(path); await addRecentRepo(path); }}`

   To support this, add `onCancel` and `onComplete` optional props to `InitRepoBlade`:
   ```typescript
   interface InitRepoBladeProps {
     directoryPath: string;
     onCancel?: () => void;    // Called when user clicks Cancel (standalone mode)
     onComplete?: (path: string) => void;  // Called after successful init (standalone mode)
   }
   ```

   When `onCancel` is provided (standalone mode), Cancel calls `onCancel` instead of `goBack()`.
   When `onComplete` is provided (standalone mode), the init pipeline calls `onComplete(path)` after success instead of navigating via blade system.

   Find where `GitInitBanner` is rendered (likely in the parent welcome component or the component that manages the `pendingInitPath` state) and add the standalone `InitRepoBlade` rendering there.
  </action>
  <verify>
    Run `npx tsc --noEmit 2>&1 | grep -v "bindings.ts" | tail -15` — no errors.
    Verify the updated GitInitBanner is simpler than the original (fewer lines, no form logic).
  </verify>
  <done>
    - GitInitBanner shows a simplified banner with "Set Up Repository" button
    - InitRepoBlade supports standalone mode via onCancel/onComplete props
    - The welcome flow renders InitRepoBlade inline when user clicks to initialize
    - No form logic in GitInitBanner — all configuration delegated to InitRepoBlade
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Visual and functional verification of Init Repo blade</name>
  <files>N/A — human verification checkpoint</files>
  <action>
    Human verifies the complete Init Repo blade feature built in Tasks 1-2 and Plans 01-03.

    What was built:
    - Full-width blade with two-column layout (form left, preview right)
    - .gitignore template browsing with search, categories, and multi-select
    - Template composition with section headers and deduplication
    - Project type detection with smart recommendations
    - README generation option
    - Initial commit option
    - Offline fallback with bundled templates
    - Entry from welcome screen / non-git folder detection
  </action>
  <verify>
    1. Start the app: `npm run tauri dev`
    2. From the welcome screen, open a non-git folder (or use a temporary empty directory)
    3. Verify the "Set Up Repository" banner appears
    4. Click "Set Up Repository" — the Init Repo view should open
    5. Verify two-column layout: form on left, preview on right
    6. Check the branch name field defaults to "main"
    7. If the folder has a `package.json`, verify "Detected: Node.js project" banner with recommended templates
    8. Click "Browse templates" — verify the template picker expands inline
    9. Search for "Python" — verify filtering works
    10. Click category tabs (Languages, Editors, OS) — verify filtering
    11. Select 2-3 templates — verify they appear as removable chips above the picker
    12. Close the picker — verify the right panel shows the composed .gitignore preview with section headers
    13. Enable "Generate README.md" — verify the right panel switches to README preview
    14. Click "Initialize Repository" — verify the repo is created and opens in FlowForge
    15. If the folder already had a `.gitignore`, verify it was overwritten with the composed content
    16. If "Create initial commit" was enabled, verify a commit exists with the generated files
  </verify>
  <done>User types "approved" confirming all 16 verification steps pass, or describes issues for a gap closure plan.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (ignoring pre-existing bindings.ts error)
2. InitRepoPreview shows context-sensitive content for all 4 sections
3. Init pipeline executes without errors: git_init -> write_init_files -> open_repository -> optional commit
4. GitInitBanner opens Init Repo view instead of inline form
5. Offline fallback shows bundled templates with info badge
6. Full keyboard navigation works in template picker
</verification>

<success_criteria>
- User can open Init Repo from welcome screen and initialize a repository with branch name, .gitignore, README, and initial commit
- User can search, filter, browse, and compose .gitignore templates
- User can preview .gitignore and README content before initializing
- Offline mode works with bundled templates
- Project detection recommends appropriate templates
</success_criteria>

<output>
After completion, create `.planning/phases/27-init-repo-blade/27-04-SUMMARY.md`
</output>
