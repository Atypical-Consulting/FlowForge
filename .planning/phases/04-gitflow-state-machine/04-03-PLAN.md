---
phase: 04-gitflow-state-machine
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src-tauri/src/gitflow/commands.rs
  - src-tauri/src/gitflow/mod.rs
autonomous: true

must_haves:
  truths:
    - "Releases can only be started from develop branch"
    - "Release finish merges to both main AND develop, creates tag"
    - "Hotfixes can only be started from main branch"
    - "Hotfix finish merges to both main AND develop, creates tag"
    - "Branch is deleted after finish"
  artifacts:
    - path: "src-tauri/src/gitflow/commands.rs"
      provides: "Release, hotfix, status, abort commands"
      exports: ["start_release", "finish_release", "start_hotfix", "finish_hotfix", "get_gitflow_status", "abort_gitflow"]
  key_links:
    - from: "src-tauri/src/gitflow/commands.rs"
      to: "src-tauri/src/git/tag.rs"
      via: "tag creation on finish"
      pattern: "create_tag|repo\\.tag"
    - from: "src-tauri/src/gitflow/commands.rs"
      to: "src-tauri/src/gitflow/merge.rs"
      via: "merge_no_ff calls"
      pattern: "merge_no_ff"
---

<objective>
Implement release, hotfix flow commands and gitflow status endpoint.

Purpose: Complete Gitflow workflows with dual-merge + tag semantics for releases and hotfixes, plus status endpoint for UI.
Output: Working release/hotfix commands and get_gitflow_status for frontend consumption.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-gitflow-state-machine/04-RESEARCH.md
@src-tauri/src/git/tag.rs
@src-tauri/src/gitflow/mod.rs
@src-tauri/src/gitflow/commands.rs
@src-tauri/src/gitflow/merge.rs
@src-tauri/src/gitflow/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement release flow commands</name>
  <files>src-tauri/src/gitflow/commands.rs</files>
  <action>
Add release commands to commands.rs (after feature commands):

```rust
/// Start a new release branch from develop.
#[tauri::command]
#[specta::specta]
pub async fn start_release(
    version: String,
    state: State<'_, RepositoryState>,
) -> Result<String, GitflowError> {
    use crate::gitflow::policy::is_valid_version;
    
    if !is_valid_version(&version) {
        return Err(GitflowError::InvalidBranchName(format!("Invalid version: {}", version)));
    }

    let repo_path = state
        .get_path()
        .await
        .ok_or(GitflowError::Git("No repository open".to_string()))?;

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;
        
        // Must be on develop
        let current = get_current_branch_name(&repo)?;
        if !is_develop_branch(&current) {
            return Err(GitflowError::InvalidContext {
                expected: "develop".to_string(),
                actual: current,
            });
        }

        // Check no active release
        for branch in repo.branches(Some(BranchType::Local))? {
            let (branch, _) = branch?;
            if let Some(name) = branch.name()? {
                if name.starts_with("release/") {
                    return Err(GitflowError::ReleaseInProgress(name.to_string()));
                }
            }
        }

        let branch_name = format!("release/{}", version);

        // Check branch doesn't exist
        if repo.find_branch(&branch_name, BranchType::Local).is_ok() {
            return Err(GitflowError::BranchExists(branch_name));
        }

        // Create and checkout
        let head_commit = repo.head()?.peel_to_commit()?;
        repo.branch(&branch_name, &head_commit, false)?;
        let refname = format!("refs/heads/{}", branch_name);
        repo.set_head(&refname)?;
        repo.checkout_head(Some(git2::build::CheckoutBuilder::new().force()))?;

        Ok(branch_name)
    })
    .await
    .map_err(|e| GitflowError::Git(format!("Task error: {}", e)))?
}

/// Finish the current release branch.
/// Merges to main AND develop, creates version tag, deletes branch.
#[tauri::command]
#[specta::specta]
pub async fn finish_release(
    tag_message: Option<String>,
    state: State<'_, RepositoryState>,
) -> Result<String, GitflowError> {
    let repo_path = state
        .get_path()
        .await
        .ok_or(GitflowError::Git("No repository open".to_string()))?;

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;
        
        // Must be on release branch
        let current = get_current_branch_name(&repo)?;
        let version = current
            .strip_prefix("release/")
            .ok_or(GitflowError::NotOnReleaseBranch)?
            .to_string();

        // 1. Merge to main with --no-ff
        let main_branch = if repo.find_branch("main", BranchType::Local).is_ok() {
            "main"
        } else {
            "master"
        };
        let main_msg = format!("Merge branch '{}' into {}", current, main_branch);
        merge_no_ff(&repo, &current, main_branch, &main_msg)?;

        // 2. Create tag on main (we're now on main after merge)
        let tag_name = format!("v{}", version);
        let msg = tag_message.unwrap_or_else(|| format!("Release {}", version));
        let head_commit = repo.head()?.peel_to_commit()?;
        let sig = repo.signature()?;
        repo.tag(&tag_name, head_commit.as_object(), &sig, &msg, false)?;

        // 3. Merge to develop with --no-ff
        let develop_msg = format!("Merge branch '{}' into develop", current);
        merge_no_ff(&repo, &current, "develop", &develop_msg)?;

        // 4. Delete release branch (we're on develop now)
        let mut branch = repo.find_branch(&current, BranchType::Local)?;
        branch.delete()?;

        Ok(tag_name)
    })
    .await
    .map_err(|e| GitflowError::Git(format!("Task error: {}", e)))?
}
```
  </action>
  <verify>
   - `cd src-tauri && cargo check` passes
   - start_release and finish_release compile
  </verify>
  <done>Release flow commands implemented with dual merge (main + develop) and auto-tag</done>
</task>

<task type="auto">
  <name>Task 2: Implement hotfix flow commands</name>
  <files>src-tauri/src/gitflow/commands.rs</files>
  <action>
Add hotfix commands to commands.rs:

```rust
/// Start a new hotfix branch from main.
#[tauri::command]
#[specta::specta]
pub async fn start_hotfix(
    name: String,
    state: State<'_, RepositoryState>,
) -> Result<String, GitflowError> {
    if !is_valid_feature_name(&name) {
        return Err(GitflowError::InvalidBranchName(name));
    }

    let repo_path = state
        .get_path()
        .await
        .ok_or(GitflowError::Git("No repository open".to_string()))?;

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;
        
        // Must be on main/master
        let current = get_current_branch_name(&repo)?;
        if !is_main_branch(&current) {
            return Err(GitflowError::InvalidContext {
                expected: "main".to_string(),
                actual: current,
            });
        }

        // Check no active hotfix
        for branch in repo.branches(Some(BranchType::Local))? {
            let (branch, _) = branch?;
            if let Some(bname) = branch.name()? {
                if bname.starts_with("hotfix/") {
                    return Err(GitflowError::HotfixInProgress(bname.to_string()));
                }
            }
        }

        let branch_name = format!("hotfix/{}", name);

        if repo.find_branch(&branch_name, BranchType::Local).is_ok() {
            return Err(GitflowError::BranchExists(branch_name));
        }

        let head_commit = repo.head()?.peel_to_commit()?;
        repo.branch(&branch_name, &head_commit, false)?;
        let refname = format!("refs/heads/{}", branch_name);
        repo.set_head(&refname)?;
        repo.checkout_head(Some(git2::build::CheckoutBuilder::new().force()))?;

        Ok(branch_name)
    })
    .await
    .map_err(|e| GitflowError::Git(format!("Task error: {}", e)))?
}

/// Finish the current hotfix branch.
/// Merges to main AND develop, creates tag, deletes branch.
#[tauri::command]
#[specta::specta]
pub async fn finish_hotfix(
    tag_message: Option<String>,
    state: State<'_, RepositoryState>,
) -> Result<String, GitflowError> {
    let repo_path = state
        .get_path()
        .await
        .ok_or(GitflowError::Git("No repository open".to_string()))?;

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;
        
        let current = get_current_branch_name(&repo)?;
        let hotfix_name = current
            .strip_prefix("hotfix/")
            .ok_or(GitflowError::NotOnHotfixBranch)?
            .to_string();

        // 1. Merge to main
        let main_branch = if repo.find_branch("main", BranchType::Local).is_ok() {
            "main"
        } else {
            "master"
        };
        let main_msg = format!("Merge branch '{}' into {}", current, main_branch);
        merge_no_ff(&repo, &current, main_branch, &main_msg)?;

        // 2. Create tag on main
        let tag_name = format!("hotfix-{}", hotfix_name);
        let msg = tag_message.unwrap_or_else(|| format!("Hotfix {}", hotfix_name));
        let head_commit = repo.head()?.peel_to_commit()?;
        let sig = repo.signature()?;
        repo.tag(&tag_name, head_commit.as_object(), &sig, &msg, false)?;

        // 3. Merge to develop
        let develop_msg = format!("Merge branch '{}' into develop", current);
        merge_no_ff(&repo, &current, "develop", &develop_msg)?;

        // 4. Delete hotfix branch
        let mut branch = repo.find_branch(&current, BranchType::Local)?;
        branch.delete()?;

        Ok(tag_name)
    })
    .await
    .map_err(|e| GitflowError::Git(format!("Task error: {}", e)))?
}
```

Also add import at top of commands.rs:
```rust
use crate::gitflow::policy::is_main_branch;
```
  </action>
  <verify>
   - `cd src-tauri && cargo check` passes
   - start_hotfix and finish_hotfix compile
  </verify>
  <done>Hotfix flow commands implemented with dual merge and auto-tag</done>
</task>

<task type="auto">
  <name>Task 3: Implement status and abort commands</name>
  <files>src-tauri/src/gitflow/commands.rs, src-tauri/src/gitflow/mod.rs</files>
  <action>
1. Add GitflowStatus DTO and commands to commands.rs:

```rust
use serde::Serialize;
use specta::Type;

/// Flow type for active workflow.
#[derive(Debug, Clone, Serialize, Type)]
#[serde(rename_all = "lowercase")]
pub enum FlowType {
    Feature,
    Release,
    Hotfix,
}

/// Information about active Gitflow workflow.
#[derive(Debug, Clone, Serialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct ActiveFlow {
    pub flow_type: FlowType,
    pub name: String,
    pub source_branch: String,
}

/// Status of Gitflow operations for UI consumption.
#[derive(Debug, Clone, Serialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct GitflowStatus {
    pub current_branch: String,
    pub is_gitflow_ready: bool,
    pub can_start_feature: bool,
    pub can_finish_feature: bool,
    pub can_start_release: bool,
    pub can_finish_release: bool,
    pub can_start_hotfix: bool,
    pub can_finish_hotfix: bool,
    pub can_abort: bool,
    pub active_flow: Option<ActiveFlow>,
}

/// Get current Gitflow status for UI.
#[tauri::command]
#[specta::specta]
pub async fn get_gitflow_status(
    state: State<'_, RepositoryState>,
) -> Result<GitflowStatus, GitflowError> {
    let repo_path = state
        .get_path()
        .await
        .ok_or(GitflowError::Git("No repository open".to_string()))?;

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;
        let ctx = GitflowContext::from_repo(&repo)?;

        let active_flow = match &ctx.state {
            GitflowState::Feature { name } => Some(ActiveFlow {
                flow_type: FlowType::Feature,
                name: name.clone(),
                source_branch: "develop".to_string(),
            }),
            GitflowState::Release { version } => Some(ActiveFlow {
                flow_type: FlowType::Release,
                name: version.clone(),
                source_branch: "develop".to_string(),
            }),
            GitflowState::Hotfix { name } => Some(ActiveFlow {
                flow_type: FlowType::Hotfix,
                name: name.clone(),
                source_branch: "main".to_string(),
            }),
            GitflowState::Idle => None,
        };

        // Check for existing release/hotfix branches (even if not on them)
        let has_active_release = repo
            .branches(Some(BranchType::Local))?
            .filter_map(|b| b.ok())
            .any(|(b, _)| b.name().ok().flatten().map(|n| n.starts_with("release/")).unwrap_or(false));
        let has_active_hotfix = repo
            .branches(Some(BranchType::Local))?
            .filter_map(|b| b.ok())
            .any(|(b, _)| b.name().ok().flatten().map(|n| n.starts_with("hotfix/")).unwrap_or(false));

        Ok(GitflowStatus {
            current_branch: ctx.current_branch.clone(),
            is_gitflow_ready: ctx.is_gitflow_ready(),
            can_start_feature: ctx.is_gitflow_ready() && ctx.on_develop(),
            can_finish_feature: matches!(ctx.state, GitflowState::Feature { .. }),
            can_start_release: ctx.is_gitflow_ready() && ctx.on_develop() && !has_active_release,
            can_finish_release: matches!(ctx.state, GitflowState::Release { .. }),
            can_start_hotfix: ctx.is_gitflow_ready() && ctx.on_main() && !has_active_hotfix,
            can_finish_hotfix: matches!(ctx.state, GitflowState::Hotfix { .. }),
            can_abort: !matches!(ctx.state, GitflowState::Idle),
            active_flow,
        })
    })
    .await
    .map_err(|e| GitflowError::Git(format!("Task error: {}", e)))?
}

/// Abort current Gitflow operation, returning to source branch.
#[tauri::command]
#[specta::specta]
pub async fn abort_gitflow(
    state: State<'_, RepositoryState>,
) -> Result<(), GitflowError> {
    let repo_path = state
        .get_path()
        .await
        .ok_or(GitflowError::Git("No repository open".to_string()))?;

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;
        let ctx = GitflowContext::from_repo(&repo)?;

        let (branch_to_delete, target_branch) = match &ctx.state {
            GitflowState::Feature { .. } => (ctx.current_branch.clone(), "develop"),
            GitflowState::Release { .. } => (ctx.current_branch.clone(), "develop"),
            GitflowState::Hotfix { .. } => {
                let main = if repo.find_branch("main", BranchType::Local).is_ok() {
                    "main"
                } else {
                    "master"
                };
                (ctx.current_branch.clone(), main)
            }
            GitflowState::Idle => return Err(GitflowError::Git("No active Gitflow operation".to_string())),
        };

        // Checkout target branch
        let refname = format!("refs/heads/{}", target_branch);
        repo.set_head(&refname)?;
        repo.checkout_head(Some(git2::build::CheckoutBuilder::new().force()))?;

        // Delete the workflow branch
        let mut branch = repo.find_branch(&branch_to_delete, BranchType::Local)?;
        branch.delete()?;

        Ok(())
    })
    .await
    .map_err(|e| GitflowError::Git(format!("Task error: {}", e)))?
}
```

2. Add import at top of commands.rs:
```rust
use crate::gitflow::state::GitflowContext;
use crate::gitflow::machine::GitflowState;
```

3. Update gitflow/mod.rs to export the new types:
```rust
pub use commands::{
    start_feature, finish_feature,
    start_release, finish_release,
    start_hotfix, finish_hotfix,
    get_gitflow_status, abort_gitflow,
    GitflowStatus, ActiveFlow, FlowType,
};
```
  </action>
  <verify>
   - `cd src-tauri && cargo check` passes
   - All 8 commands compile: start/finish feature/release/hotfix, get_gitflow_status, abort_gitflow
  </verify>
  <done>GitflowStatus DTO and get_gitflow_status/abort_gitflow commands implemented with can_* booleans for UI</done>
</task>

</tasks>

<verification>
- [ ] `cd src-tauri && cargo check` passes
- [ ] All 8 gitflow commands compile with tauri/specta decorators
- [ ] GitflowStatus includes all can_* boolean fields
- [ ] Release/hotfix finish includes dual merge and tag creation
</verification>

<success_criteria>
- start_release validates: on develop, no active release, valid version
- finish_release: merges to main (tag), merges to develop, deletes branch
- start_hotfix validates: on main, no active hotfix, valid name
- finish_hotfix: merges to main (tag), merges to develop, deletes branch
- get_gitflow_status returns can_* booleans for each operation
- abort_gitflow returns to source branch and deletes workflow branch
</success_criteria>

<output>
After completion, create `.planning/phases/04-gitflow-state-machine/04-03-SUMMARY.md`
</output>
