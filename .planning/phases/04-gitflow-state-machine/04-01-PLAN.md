---
phase: 04-gitflow-state-machine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/gitflow/mod.rs
  - src-tauri/src/gitflow/error.rs
  - src-tauri/src/gitflow/policy.rs
  - src-tauri/src/gitflow/machine.rs
  - src-tauri/src/gitflow/state.rs
autonomous: true

must_haves:
  truths:
    - "Gitflow state machine compiles with statig crate"
    - "Branch names can be validated as Gitflow-conformant"
    - "State can be derived from current branch name"
  artifacts:
    - path: "src-tauri/src/gitflow/mod.rs"
      provides: "Module exports for gitflow"
      exports: ["GitflowState", "GitflowError", "GitflowMachine"]
    - path: "src-tauri/src/gitflow/error.rs"
      provides: "Gitflow-specific error types"
      contains: "enum GitflowError"
    - path: "src-tauri/src/gitflow/policy.rs"
      provides: "Branch name parsing and validation"
      exports: ["parse_branch_type", "is_valid_feature_name"]
    - path: "src-tauri/src/gitflow/machine.rs"
      provides: "State machine definition"
      contains: "struct GitflowMachine"
    - path: "src-tauri/src/gitflow/state.rs"
      provides: "State wrapper and reconstruction"
      exports: ["reconstruct_state", "GitflowContext"]
  key_links:
    - from: "src-tauri/src/gitflow/state.rs"
      to: "src-tauri/src/gitflow/machine.rs"
      via: "GitflowState enum import"
      pattern: "use.*machine::GitflowState"
---

<objective>
Create the foundation for Gitflow state machine enforcement.

Purpose: Establish the core state machine, error types, and policy validation that all Gitflow operations will depend on.
Output: Compilable gitflow module with state machine and branch validation utilities.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-gitflow-state-machine/04-RESEARCH.md
@src-tauri/src/git/mod.rs
@src-tauri/src/git/error.rs
@src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add statig dependency and create module structure</name>
  <files>src-tauri/Cargo.toml, src-tauri/src/gitflow/mod.rs</files>
  <action>
1. Add statig dependency to Cargo.toml under [dependencies]:
   ```toml
   statig = "0.3"
   ```

2. Create `src-tauri/src/gitflow/` directory and `mod.rs` with module declarations:
   ```rust
   pub mod error;
   pub mod machine;
   pub mod policy;
   pub mod state;
   
   pub use error::GitflowError;
   pub use machine::{GitflowEvent, GitflowMachine, GitflowState};
   pub use state::{GitflowContext, reconstruct_state};
   ```

3. Create empty placeholder files for error.rs, machine.rs, policy.rs, state.rs with minimal content so module compiles (e.g., `// TODO` comment).
  </action>
  <verify>`cd src-tauri && cargo check` compiles without module errors</verify>
  <done>statig dependency added, gitflow module structure created and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement error types and policy validation</name>
  <files>src-tauri/src/gitflow/error.rs, src-tauri/src/gitflow/policy.rs</files>
  <action>
1. Create `error.rs` with GitflowError enum (derive Serialize, Type for specta):
   - InvalidContext { expected, actual } - wrong branch for operation
   - NotOnFeatureBranch, NotOnReleaseBranch, NotOnHotfixBranch - not on expected workflow branch
   - ReleaseInProgress(String), HotfixInProgress(String) - concurrent workflow errors
   - MergeConflict - conflicts during finish operations
   - UnbornHead - operating on repo with no commits
   - BranchNotFound(String), BranchExists(String) - branch errors
   - NotGitflowRepo - missing main or develop
   - InvalidBranchName(String) - validation failure
   - Git(String) - wrapped git2 errors
   
   Implement `From<git2::Error>` for GitflowError.

2. Create `policy.rs` with:
   - BranchType enum: Main, Develop, Feature(String), Release(String), Hotfix(String), Other(String)
   - `parse_branch_type(name: &str) -> BranchType` - parse branch name to type
   - `is_valid_feature_name(name: &str) -> bool` - no slashes, not empty, alphanumeric/-/_
   - `is_valid_version(version: &str) -> bool` - digits and dots, semver-ish
   - `is_main_branch(name: &str) -> bool` - "main" or "master"
   - `is_develop_branch(name: &str) -> bool` - "develop" or "development"
  </action>
  <verify>`cd src-tauri && cargo check` passes with no errors</verify>
  <done>GitflowError enum created with all variants, policy validation functions implemented</done>
</task>

<task type="auto">
  <name>Task 3: Implement state machine and state reconstruction</name>
  <files>src-tauri/src/gitflow/machine.rs, src-tauri/src/gitflow/state.rs</files>
  <action>
1. Create `machine.rs` with state machine (simple enum-based approach, statig available but not required for this complexity level):
   - GitflowState enum: Idle, Feature { name }, Release { version }, Hotfix { name }
   - GitflowEvent enum: StartFeature, FinishFeature, StartRelease, FinishRelease, StartHotfix, FinishHotfix, Abort
   - GitflowMachine struct with:
     - `new()` - create in Idle state
     - `with_state(state)` - create with specific state
     - `state()` - get current state reference
     - `handle(event)` - process event, return Result
     - `can_handle(event)` - check if transition valid without performing

   State transitions:
   - Idle -> Feature/Release/Hotfix via Start* events
   - Feature/Release/Hotfix -> Idle via Finish* or Abort events
   - Invalid transitions return error

2. Create `state.rs` with:
   - GitflowContext struct: state, current_branch, has_main, has_develop
   - `GitflowContext::from_repo(repo)` - build context from Repository
   - `is_gitflow_ready()` - check main AND develop exist
   - `on_main()`, `on_develop()` - branch checks
   - `reconstruct_state(branch_name)` - derive GitflowState from branch name string
   - `get_current_branch_name(repo)` - get HEAD branch name

3. Ensure mod.rs exports all public items correctly.
  </action>
  <verify>
   - `cd src-tauri && cargo check` passes
   - `cd src-tauri && cargo build` succeeds
  </verify>
  <done>State machine implemented with Idle/Feature/Release/Hotfix states, reconstruction from Git branch names works</done>
</task>

</tasks>

<verification>
- [ ] `cd src-tauri && cargo check` passes
- [ ] `cd src-tauri && cargo build` succeeds  
- [ ] gitflow module compiles with all submodules
- [ ] GitflowState enum derives Serialize, Type for frontend
</verification>

<success_criteria>
- Gitflow module structure created under src-tauri/src/gitflow/
- statig dependency added to Cargo.toml
- GitflowError enum covers all error cases from research
- Policy functions validate branch names correctly
- State machine transitions compile and handle events
- State reconstruction derives GitflowState from branch name
</success_criteria>

<output>
After completion, create `.planning/phases/04-gitflow-state-machine/04-01-SUMMARY.md`
</output>
