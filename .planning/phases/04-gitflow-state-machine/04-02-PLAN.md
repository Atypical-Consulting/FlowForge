---
phase: 04-gitflow-state-machine
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src-tauri/src/gitflow/merge.rs
  - src-tauri/src/gitflow/commands.rs
  - src-tauri/src/gitflow/mod.rs
autonomous: true

must_haves:
  truths:
    - "Features can only be started from develop branch"
    - "Feature finish merges to develop with no-fast-forward"
    - "Feature branch is deleted after finish"
  artifacts:
    - path: "src-tauri/src/gitflow/merge.rs"
      provides: "No-fast-forward merge implementation"
      exports: ["merge_no_ff"]
    - path: "src-tauri/src/gitflow/commands.rs"
      provides: "Feature flow Tauri commands"
      exports: ["start_feature", "finish_feature"]
  key_links:
    - from: "src-tauri/src/gitflow/commands.rs"
      to: "src-tauri/src/gitflow/merge.rs"
      via: "merge_no_ff call in finish_feature"
      pattern: "merge_no_ff"
    - from: "src-tauri/src/gitflow/commands.rs"
      to: "src-tauri/src/git/branch.rs"
      via: "branch operations"
      pattern: "create_branch|checkout_branch|delete_branch"
---

<objective>
Implement no-fast-forward merge utility and feature flow commands.

Purpose: Enable starting and finishing feature branches with proper Gitflow semantics (merge commits, branch cleanup).
Output: Working start_feature and finish_feature Tauri commands with --no-ff merge behavior.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-gitflow-state-machine/04-RESEARCH.md
@src-tauri/src/git/merge.rs
@src-tauri/src/git/branch.rs
@src-tauri/src/gitflow/mod.rs
@src-tauri/src/gitflow/error.rs
@src-tauri/src/gitflow/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement no-fast-forward merge utility</name>
  <files>src-tauri/src/gitflow/merge.rs, src-tauri/src/gitflow/mod.rs</files>
  <action>
1. Create `src-tauri/src/gitflow/merge.rs` with merge_no_ff function.

   Key insight from research: git2-rs lacks --no-ff flag. Solution: always create merge commit even when fast-forward possible.

   ```rust
   use git2::{BranchType, Oid, Repository};
   use crate::gitflow::error::GitflowError;

   /// Merge source branch into target branch, always creating a merge commit (--no-ff behavior).
   pub fn merge_no_ff(
       repo: &Repository,
       source_branch: &str,
       target_branch: &str,
       message: &str,
   ) -> Result<Oid, GitflowError> {
       // 1. Get source commit
       let source = repo
           .find_branch(source_branch, BranchType::Local)?
           .get()
           .peel_to_commit()?;

       // 2. Checkout target branch
       let target_ref = format!("refs/heads/{}", target_branch);
       repo.set_head(&target_ref)?;
       repo.checkout_head(Some(git2::build::CheckoutBuilder::new().force()))?;

       // 3. Get target commit (now HEAD)
       let target = repo.head()?.peel_to_commit()?;

       // 4. Get annotated commit for merge
       let annotated = repo.find_annotated_commit(source.id())?;

       // 5. Run merge analysis
       let (analysis, _) = repo.merge_analysis(&[&annotated])?;

       if analysis.is_up_to_date() {
           return Ok(target.id()); // Nothing to do
       }

       if analysis.is_unborn() {
           return Err(GitflowError::UnbornHead);
       }

       // 6. Perform merge (this stages changes)
       repo.merge(&[&annotated], None, None)?;

       // 7. Check for conflicts
       let index = repo.index()?;
       if index.has_conflicts() {
           return Err(GitflowError::MergeConflict);
       }

       // 8. Create merge commit with two parents (this is --no-ff behavior)
       let mut index = repo.index()?;
       let tree_oid = index.write_tree()?;
       let tree = repo.find_tree(tree_oid)?;
       let sig = repo.signature()?;

       let commit_oid = repo.commit(
           Some("HEAD"),
           &sig,
           &sig,
           message,
           &tree,
           &[&target, &source], // Two parents = merge commit
       )?;

       // 9. Clean up merge state
       repo.cleanup_state()?;

       Ok(commit_oid)
   }
   ```

2. Add `pub mod merge;` to gitflow/mod.rs and export merge_no_ff.
  </action>
  <verify>
   - `cd src-tauri && cargo check` passes
   - merge_no_ff function compiles without errors
  </verify>
  <done>merge_no_ff implemented, always creates merge commit even for fast-forward cases</done>
</task>

<task type="auto">
  <name>Task 2: Implement feature flow commands</name>
  <files>src-tauri/src/gitflow/commands.rs, src-tauri/src/gitflow/mod.rs</files>
  <action>
1. Create `src-tauri/src/gitflow/commands.rs` with feature commands:

   ```rust
   use tauri::State;
   use crate::git::repository::RepositoryState;
   use crate::gitflow::error::GitflowError;
   use crate::gitflow::merge::merge_no_ff;
   use crate::gitflow::policy::{is_develop_branch, is_valid_feature_name};
   use crate::gitflow::state::get_current_branch_name;
   use git2::BranchType;

   /// Start a new feature branch from develop.
   #[tauri::command]
   #[specta::specta]
   pub async fn start_feature(
       name: String,
       state: State<'_, RepositoryState>,
   ) -> Result<String, GitflowError> {
       // Validate name
       if !is_valid_feature_name(&name) {
           return Err(GitflowError::InvalidBranchName(name));
       }

       let repo_path = state
           .get_path()
           .await
           .ok_or(GitflowError::Git("No repository open".to_string()))?;

       tokio::task::spawn_blocking(move || {
           let repo = git2::Repository::open(&repo_path)?;
           
           // Must be on develop
           let current = get_current_branch_name(&repo)?;
           if !is_develop_branch(&current) {
               return Err(GitflowError::InvalidContext {
                   expected: "develop".to_string(),
                   actual: current,
               });
           }

           let branch_name = format!("feature/{}", name);

           // Check branch doesn't exist
           if repo.find_branch(&branch_name, BranchType::Local).is_ok() {
               return Err(GitflowError::BranchExists(branch_name));
           }

           // Create branch from HEAD
           let head_commit = repo.head()?.peel_to_commit()?;
           repo.branch(&branch_name, &head_commit, false)?;

           // Checkout new branch
           let refname = format!("refs/heads/{}", branch_name);
           repo.set_head(&refname)?;
           repo.checkout_head(Some(git2::build::CheckoutBuilder::new().force()))?;

           Ok(branch_name)
       })
       .await
       .map_err(|e| GitflowError::Git(format!("Task error: {}", e)))?
   }

   /// Finish the current feature branch, merging to develop.
   #[tauri::command]
   #[specta::specta]
   pub async fn finish_feature(
       state: State<'_, RepositoryState>,
   ) -> Result<(), GitflowError> {
       let repo_path = state
           .get_path()
           .await
           .ok_or(GitflowError::Git("No repository open".to_string()))?;

       tokio::task::spawn_blocking(move || {
           let repo = git2::Repository::open(&repo_path)?;
           
           // Must be on feature branch
           let current = get_current_branch_name(&repo)?;
           let feature_name = current
               .strip_prefix("feature/")
               .ok_or(GitflowError::NotOnFeatureBranch)?;

           // Merge to develop with --no-ff
           let message = format!("Merge branch '{}' into develop", current);
           merge_no_ff(&repo, &current, "develop", &message)?;

           // Delete feature branch (we're now on develop after merge)
           let mut branch = repo.find_branch(&current, BranchType::Local)?;
           branch.delete()?;

           Ok(())
       })
       .await
       .map_err(|e| GitflowError::Git(format!("Task error: {}", e)))?
   }
   ```

2. Add `pub mod commands;` to gitflow/mod.rs and export the commands.
  </action>
  <verify>
   - `cd src-tauri && cargo check` passes
   - start_feature and finish_feature compile with #[tauri::command] and #[specta::specta]
  </verify>
  <done>Feature flow commands implemented: start_feature validates develop context and creates branch, finish_feature merges with --no-ff and deletes branch</done>
</task>

</tasks>

<verification>
- [ ] `cd src-tauri && cargo check` passes
- [ ] merge_no_ff creates merge commit even for fast-forward case
- [ ] start_feature only works from develop branch
- [ ] finish_feature merges and deletes feature branch
</verification>

<success_criteria>
- merge_no_ff utility created in gitflow/merge.rs
- start_feature command validates: on develop, valid name, branch doesn't exist
- finish_feature command: merges to develop (--no-ff), deletes feature branch
- All commands are #[tauri::command] #[specta::specta] decorated
</success_criteria>

<output>
After completion, create `.planning/phases/04-gitflow-state-machine/04-02-SUMMARY.md`
</output>
