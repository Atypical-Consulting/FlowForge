---
phase: 04-gitflow-state-machine
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src-tauri/src/lib.rs
  - src-tauri/src/main.rs
  - src/stores/gitflow.ts
  - src/bindings.ts
autonomous: true

must_haves:
  truths:
    - "Gitflow commands are callable from frontend"
    - "TypeScript bindings are generated for gitflow types"
    - "Zustand store manages gitflow state"
  artifacts:
    - path: "src-tauri/src/lib.rs"
      provides: "IPC registration for gitflow commands"
      contains: "start_feature"
    - path: "src/stores/gitflow.ts"
      provides: "Zustand store for gitflow"
      exports: ["useGitflowStore"]
  key_links:
    - from: "src/stores/gitflow.ts"
      to: "src/bindings.ts"
      via: "commands import"
      pattern: "import.*commands.*from.*bindings"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/gitflow/commands.rs"
      via: "command registration"
      pattern: "gitflow::.*start_feature"
---

<objective>
Register gitflow IPC commands and create frontend Zustand store.

Purpose: Wire backend commands to frontend, enabling UI to call gitflow operations.
Output: TypeScript bindings generated, gitflow store with actions and status.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-gitflow-state-machine/04-RESEARCH.md
@src-tauri/src/lib.rs
@src/stores/branches.ts
@src/bindings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register gitflow commands in lib.rs</name>
  <files>src-tauri/src/lib.rs, src-tauri/src/main.rs</files>
  <action>
1. Add gitflow module declaration to lib.rs (at top, after `mod git;`):
   ```rust
   mod gitflow;
   ```

2. Add gitflow command imports (in the use block):
   ```rust
   use gitflow::{
       start_feature, finish_feature,
       start_release, finish_release,
       start_hotfix, finish_hotfix,
       get_gitflow_status, abort_gitflow,
   };
   ```

3. Add gitflow commands to the collect_commands! macro (after merge commands):
   ```rust
   // Gitflow commands
   start_feature,
   finish_feature,
   start_release,
   finish_release,
   start_hotfix,
   finish_hotfix,
   get_gitflow_status,
   abort_gitflow,
   ```

4. Run `cd src-tauri && cargo build` to regenerate TypeScript bindings.
   This will update `src/bindings.ts` with GitflowStatus, ActiveFlow, FlowType, GitflowError types.

5. Verify bindings.ts contains the new types by checking file contents.
  </action>
  <verify>
   - `cd src-tauri && cargo build` succeeds
   - `src/bindings.ts` contains `GitflowStatus`, `startFeature`, `finishFeature` etc.
   - `grep -l "GitflowStatus" src/bindings.ts` returns the file
  </verify>
  <done>Gitflow commands registered in Tauri, TypeScript bindings generated</done>
</task>

<task type="auto">
  <name>Task 2: Create gitflow Zustand store</name>
  <files>src/stores/gitflow.ts</files>
  <action>
Create `src/stores/gitflow.ts` following the pattern from branches.ts:

```typescript
import { create } from "zustand";
import type { GitflowStatus } from "../bindings";
import { commands } from "../bindings";
import { getErrorMessage } from "../lib/errors";

interface GitflowState {
  status: GitflowStatus | null;
  isLoading: boolean;
  error: string | null;

  // Actions
  refresh: () => Promise<void>;
  startFeature: (name: string) => Promise<string | null>;
  finishFeature: () => Promise<boolean>;
  startRelease: (version: string) => Promise<string | null>;
  finishRelease: (tagMessage?: string) => Promise<string | null>;
  startHotfix: (name: string) => Promise<string | null>;
  finishHotfix: (tagMessage?: string) => Promise<string | null>;
  abort: () => Promise<boolean>;
  clearError: () => void;
}

export const useGitflowStore = create<GitflowState>((set, get) => ({
  status: null,
  isLoading: false,
  error: null,

  refresh: async () => {
    set({ isLoading: true, error: null });
    const result = await commands.getGitflowStatus();
    if (result.status === "ok") {
      set({ status: result.data, isLoading: false });
    } else {
      set({ error: getErrorMessage(result.error), isLoading: false });
    }
  },

  startFeature: async (name) => {
    set({ isLoading: true, error: null });
    const result = await commands.startFeature(name);
    if (result.status === "ok") {
      await get().refresh();
      return result.data;
    }
    set({ error: getErrorMessage(result.error), isLoading: false });
    return null;
  },

  finishFeature: async () => {
    set({ isLoading: true, error: null });
    const result = await commands.finishFeature();
    if (result.status === "ok") {
      await get().refresh();
      return true;
    }
    set({ error: getErrorMessage(result.error), isLoading: false });
    return false;
  },

  startRelease: async (version) => {
    set({ isLoading: true, error: null });
    const result = await commands.startRelease(version);
    if (result.status === "ok") {
      await get().refresh();
      return result.data;
    }
    set({ error: getErrorMessage(result.error), isLoading: false });
    return null;
  },

  finishRelease: async (tagMessage) => {
    set({ isLoading: true, error: null });
    const result = await commands.finishRelease(tagMessage ?? null);
    if (result.status === "ok") {
      await get().refresh();
      return result.data;
    }
    set({ error: getErrorMessage(result.error), isLoading: false });
    return null;
  },

  startHotfix: async (name) => {
    set({ isLoading: true, error: null });
    const result = await commands.startHotfix(name);
    if (result.status === "ok") {
      await get().refresh();
      return result.data;
    }
    set({ error: getErrorMessage(result.error), isLoading: false });
    return null;
  },

  finishHotfix: async (tagMessage) => {
    set({ isLoading: true, error: null });
    const result = await commands.finishHotfix(tagMessage ?? null);
    if (result.status === "ok") {
      await get().refresh();
      return result.data;
    }
    set({ error: getErrorMessage(result.error), isLoading: false });
    return null;
  },

  abort: async () => {
    set({ isLoading: true, error: null });
    const result = await commands.abortGitflow();
    if (result.status === "ok") {
      await get().refresh();
      return true;
    }
    set({ error: getErrorMessage(result.error), isLoading: false });
    return false;
  },

  clearError: () => set({ error: null }),
}));
```
  </action>
  <verify>
   - `npm run check` or `npx tsc --noEmit` passes (no TypeScript errors)
   - Store file exists at src/stores/gitflow.ts
  </verify>
  <done>Gitflow Zustand store created with all actions and status management</done>
</task>

</tasks>

<verification>
- [ ] `cd src-tauri && cargo build` succeeds
- [ ] TypeScript bindings include GitflowStatus, startFeature, etc.
- [ ] `npm run check` passes (no TS errors)
- [ ] Store exports useGitflowStore
</verification>

<success_criteria>
- All 8 gitflow commands registered in lib.rs
- TypeScript bindings auto-generated with correct types
- Zustand store provides: status, loading, error, all actions
- Each action refreshes status after completion
- Error handling consistent with other stores
</success_criteria>

<output>
After completion, create `.planning/phases/04-gitflow-state-machine/04-04-SUMMARY.md`
</output>
