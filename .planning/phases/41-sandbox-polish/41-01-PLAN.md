---
phase: 41-sandbox-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/extensions/manifest.rs
  - src/extensions/extensionTypes.ts
  - src/extensions/ExtensionHost.ts
  - src/extensions/ExtensionAPI.ts
  - src/extensions/sandbox/sandbox-api-surface.ts
  - src/extensions/sandbox/SandboxedExtensionAPI.ts
autonomous: true

must_haves:
  truths:
    - "Extension manifest struct includes a trust_level field that defaults to sandboxed"
    - "Built-in extensions are automatically assigned trustLevel built-in on registration"
    - "ExtensionAPI methods are annotated with sandbox-safe or requires-trust classification"
    - "A SandboxedExtensionAPI proxy class throws on requires-trust methods with descriptive error messages"
  artifacts:
    - path: "src-tauri/src/extensions/manifest.rs"
      provides: "Rust trust_level field on ExtensionManifest"
      contains: "trust_level"
    - path: "src/extensions/extensionTypes.ts"
      provides: "TrustLevel type and trustLevel field on ExtensionInfo"
      contains: "TrustLevel"
    - path: "src/extensions/sandbox/sandbox-api-surface.ts"
      provides: "API classification constants"
      exports: ["SANDBOX_SAFE_METHODS", "REQUIRES_TRUST_METHODS"]
    - path: "src/extensions/sandbox/SandboxedExtensionAPI.ts"
      provides: "Restricted API proxy for sandboxed extensions"
      exports: ["SandboxedExtensionAPI"]
  key_links:
    - from: "src/extensions/ExtensionHost.ts"
      to: "src/extensions/extensionTypes.ts"
      via: "trustLevel field in registerBuiltIn synthetic manifest"
      pattern: "trustLevel.*built-in"
    - from: "src/extensions/sandbox/SandboxedExtensionAPI.ts"
      to: "src/extensions/sandbox/sandbox-api-surface.ts"
      via: "classification constants imported for enforcement"
      pattern: "REQUIRES_TRUST_METHODS"
---

<objective>
Add trust level infrastructure to extension manifests and classify ExtensionAPI methods as sandbox-safe vs requires-trust.

Purpose: Establish the type system and classification metadata that distinguish built-in (trusted) extensions from future external (sandboxed) extensions. This is the foundation for the Worker sandbox prototype (Plan 03) and future third-party extension support.

Output: Rust manifest with trust_level field, TypeScript TrustLevel type on ExtensionInfo, JSDoc annotations on all ExtensionAPI methods, classification constants module, and SandboxedExtensionAPI proxy class.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src-tauri/src/extensions/manifest.rs
@src/extensions/extensionTypes.ts
@src/extensions/ExtensionHost.ts
@src/extensions/ExtensionAPI.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add trust level to Rust manifest and TypeScript types</name>
  <files>
    src-tauri/src/extensions/manifest.rs
    src/extensions/extensionTypes.ts
    src/extensions/ExtensionHost.ts
  </files>
  <action>
1. In `src-tauri/src/extensions/manifest.rs`, add a `trust_level` field to the `ExtensionManifest` struct:
   ```rust
   /// Trust level for the extension.
   /// "built-in" for bundled extensions, "user-trusted" for user-installed,
   /// "sandboxed" for untrusted third-party (future).
   /// Defaults to "sandboxed" when not specified in the manifest JSON.
   #[serde(default = "default_trust_level")]
   pub trust_level: String,
   ```
   Add a helper function at module level:
   ```rust
   fn default_trust_level() -> String {
       "sandboxed".to_string()
   }
   ```

2. In `src/extensions/extensionTypes.ts`, add the TrustLevel type and trustLevel field:
   ```typescript
   export type TrustLevel = "built-in" | "user-trusted" | "sandboxed";
   ```
   Add `trustLevel: TrustLevel;` to the `ExtensionInfo` interface (after the `builtIn` field).

3. In `src/extensions/ExtensionHost.ts`, update `registerBuiltIn` to set `trustLevel: "built-in"` on the synthetic manifest (inside the manifest object literal, add `trustLevel: "built-in"`) AND on the ExtensionInfo object (in the `next.set()` call, add `trustLevel: "built-in" as const`).

4. In `src/extensions/ExtensionHost.ts`, update `discoverExtensions` to set `trustLevel` on discovered extensions. When creating ExtensionInfo objects for discovered extensions, read `manifest.trustLevel` if available (from the Rust-parsed JSON), otherwise default to `"sandboxed"`. The Rust side already defaults to "sandboxed" via serde, but since the manifest type on TS side comes from bindings, also set it explicitly:
   ```typescript
   trustLevel: (manifest as any).trustLevel ?? "sandboxed",
   ```
   Note: After regenerating TypeScript bindings with `cargo build`, the `trustLevel` field will be available on the manifest type. Until bindings are regenerated, use the `as any` cast.

5. Run `cd src-tauri && cargo check` to verify Rust compiles. If the edition is 2024 and the Rust toolchain supports it, this should work. The serde default function pattern is standard.
  </action>
  <verify>
    - `cargo check` in src-tauri passes (Rust compiles with new field)
    - `npx tsc --noEmit` passes (TypeScript types are consistent)
    - Grep for `trustLevel` in ExtensionHost.ts shows it set in both registerBuiltIn and discoverExtensions
  </verify>
  <done>
    ExtensionManifest has trust_level in Rust, TrustLevel type exists in TS, built-in extensions get "built-in" trust level, discovered extensions default to "sandboxed"
  </done>
</task>

<task type="auto">
  <name>Task 2: Classify ExtensionAPI methods and create SandboxedExtensionAPI proxy</name>
  <files>
    src/extensions/ExtensionAPI.ts
    src/extensions/sandbox/sandbox-api-surface.ts
    src/extensions/sandbox/SandboxedExtensionAPI.ts
  </files>
  <action>
1. In `src/extensions/ExtensionAPI.ts`, add JSDoc `@sandboxSafety` annotations to every public method:

   **requires-trust methods** (accept React ComponentType, render functions, or store closures -- not serializable):
   - `registerBlade()`: "@sandboxSafety requires-trust - Accepts React ComponentType which cannot be serialized across Worker boundary."
   - `registerCommand()`: "@sandboxSafety requires-trust - Accepts action callback with closure access to host scope."
   - `contributeToolbar()`: "@sandboxSafety requires-trust - Accepts React render functions and LucideIcon components."
   - `contributeSidebarPanel()`: "@sandboxSafety requires-trust - Accepts React ComponentType for panel rendering."
   - `contributeStatusBar()`: "@sandboxSafety requires-trust - Accepts React render function for status bar widget."
   - `contributeContextMenu()`: "@sandboxSafety requires-trust - Accepts callback functions with closure access."

   **sandbox-safe methods** (receive/return serializable data, no DOM/React access needed):
   - `onDidGit()`: "@sandboxSafety sandbox-safe - Handler receives serializable GitHookContext. No DOM access needed."
   - `onWillGit()`: "@sandboxSafety sandbox-safe - Handler receives/returns serializable data. Can validate git operations."
   - `onDispose()`: "@sandboxSafety sandbox-safe - Cleanup callback, no DOM or React access needed."

2. Create `src/extensions/sandbox/sandbox-api-surface.ts`:
   ```typescript
   /**
    * API method classification for sandbox trust boundaries.
    *
    * Methods classified as "sandbox-safe" can be proxied to Worker-based
    * sandboxed extensions via postMessage. Methods classified as
    * "requires-trust" need direct host-thread access (React components,
    * Zustand stores, closures).
    */

   /** Methods safe to call from a Worker sandbox (serializable I/O) */
   export const SANDBOX_SAFE_METHODS = [
     "onDidGit",
     "onWillGit",
     "onDispose",
   ] as const;

   /** Methods that require trust level "built-in" or "user-trusted" */
   export const REQUIRES_TRUST_METHODS = [
     "registerBlade",
     "registerCommand",
     "contributeToolbar",
     "contributeContextMenu",
     "contributeSidebarPanel",
     "contributeStatusBar",
   ] as const;

   export type SandboxSafeMethod = (typeof SANDBOX_SAFE_METHODS)[number];
   export type RequiresTrustMethod = (typeof REQUIRES_TRUST_METHODS)[number];

   /** Check if a method name is sandbox-safe */
   export function isSandboxSafe(method: string): method is SandboxSafeMethod {
     return (SANDBOX_SAFE_METHODS as readonly string[]).includes(method);
   }
   ```

3. Create `src/extensions/sandbox/SandboxedExtensionAPI.ts`:
   ```typescript
   import { REQUIRES_TRUST_METHODS } from "./sandbox-api-surface";
   import type { ExtensionAPI } from "../ExtensionAPI";
   import type { GitOperation, DidHandler, WillHandler } from "../../lib/gitHookBus";
   import type { Disposable } from "../ExtensionAPI";

   /**
    * Restricted API proxy for sandboxed (untrusted) extensions.
    *
    * Exposes only sandbox-safe methods. Calling any requires-trust method
    * throws a descriptive error explaining what trust level is needed.
    */
   export class SandboxedExtensionAPI {
     private hostApi: ExtensionAPI;

     constructor(hostApi: ExtensionAPI) {
       this.hostApi = hostApi;
     }

     // --- Sandbox-safe methods ---

     onDidGit(operation: GitOperation, handler: DidHandler): void {
       this.hostApi.onDidGit(operation, handler);
     }

     onWillGit(operation: GitOperation, handler: WillHandler): void {
       this.hostApi.onWillGit(operation, handler);
     }

     onDispose(disposable: Disposable): void {
       this.hostApi.onDispose(disposable);
     }

     // --- Blocked methods (requires-trust) ---

     registerBlade(): never {
       throw this.trustError("registerBlade");
     }

     registerCommand(): never {
       throw this.trustError("registerCommand");
     }

     contributeToolbar(): never {
       throw this.trustError("contributeToolbar");
     }

     contributeContextMenu(): never {
       throw this.trustError("contributeContextMenu");
     }

     contributeSidebarPanel(): never {
       throw this.trustError("contributeSidebarPanel");
     }

     contributeStatusBar(): never {
       throw this.trustError("contributeStatusBar");
     }

     private trustError(method: string): Error {
       return new Error(
         `${method}() requires trust level "built-in" or "user-trusted". ` +
         `Sandboxed extensions cannot call this method because it requires ` +
         `React component references or closure access that cannot be ` +
         `serialized across the Worker boundary.`
       );
     }
   }
   ```

4. Ensure the sandbox directory exists: `src/extensions/sandbox/` (create it if needed).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Grep `@sandboxSafety` in ExtensionAPI.ts returns 9 results (one per public method)
    - `sandbox-api-surface.ts` exports SANDBOX_SAFE_METHODS (3 items) and REQUIRES_TRUST_METHODS (6 items)
    - SandboxedExtensionAPI.ts exists and has 6 methods that throw trustError
  </verify>
  <done>
    All ExtensionAPI methods annotated with sandbox safety classification, classification constants exported from sandbox-api-surface.ts, SandboxedExtensionAPI proxy throws descriptive errors for requires-trust methods
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` -- Rust compiles with trust_level field
2. `npx tsc --noEmit` -- TypeScript compiles with TrustLevel type
3. Grep `trustLevel` in ExtensionHost.ts -- appears in registerBuiltIn and discoverExtensions
4. Grep `@sandboxSafety` in ExtensionAPI.ts -- 9 annotations (all public methods)
5. `src/extensions/sandbox/sandbox-api-surface.ts` exists with classification constants
6. `src/extensions/sandbox/SandboxedExtensionAPI.ts` exists with proxy class
</verification>

<success_criteria>
- ExtensionManifest has trust_level field in Rust (defaults to "sandboxed" via serde)
- TrustLevel type exists in TypeScript with three values
- Built-in extensions get trustLevel "built-in" automatically
- All 9 ExtensionAPI methods have @sandboxSafety JSDoc tags
- sandbox-api-surface.ts exports method classification constants
- SandboxedExtensionAPI proxy throws on requires-trust methods
- All existing tests still pass (npx vitest run)
</success_criteria>

<output>
After completion, create `.planning/phases/41-sandbox-polish/41-01-SUMMARY.md`
</output>
