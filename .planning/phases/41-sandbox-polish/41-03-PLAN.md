---
phase: 41-sandbox-polish
plan: 03
type: execute
wave: 2
depends_on: ["41-01"]
files_modified:
  - src/extensions/sandbox/SandboxBridge.ts
  - src/extensions/sandbox/sandbox-worker.ts
  - src/extensions/sandbox/types.ts
  - src/extensions/sandbox/__tests__/SandboxBridge.test.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "A Worker can be created and receives a ready handshake from the host"
    - "postMessage communication works bidirectionally between host and Worker"
    - "The host can send an API call and receive a response from the Worker"
    - "Worker termination cleans up pending calls and rejects them"
    - "Sandbox-unsafe methods are blocked with descriptive errors"
  artifacts:
    - path: "src/extensions/sandbox/SandboxBridge.ts"
      provides: "Host-side Worker bridge with lifecycle management"
      exports: ["SandboxBridge"]
    - path: "src/extensions/sandbox/sandbox-worker.ts"
      provides: "Worker entry point with postMessage protocol"
    - path: "src/extensions/sandbox/types.ts"
      provides: "Shared message type definitions for host-worker protocol"
      exports: ["SandboxMessage"]
    - path: "src/extensions/sandbox/__tests__/SandboxBridge.test.ts"
      provides: "Tests for sandbox communication protocol"
  key_links:
    - from: "src/extensions/sandbox/SandboxBridge.ts"
      to: "src/extensions/sandbox/types.ts"
      via: "SandboxMessage type import for message handling"
      pattern: "SandboxMessage"
    - from: "src/extensions/sandbox/SandboxBridge.ts"
      to: "src/extensions/sandbox/sandbox-api-surface.ts"
      via: "isSandboxSafe check before proxying API calls"
      pattern: "isSandboxSafe"
---

<objective>
Build a Worker-based sandbox prototype that demonstrates postMessage communication between the host thread and isolated extension code running in a Web Worker.

Purpose: Prove the communication pattern for future sandboxed third-party extensions. This is explicitly a prototype -- it demonstrates Worker creation, bidirectional postMessage RPC, API method whitelisting, error handling, and clean termination. It does NOT load real extensions or integrate with the activation pipeline.

Output: SandboxBridge class, sandbox-worker entry point, shared message types, and comprehensive tests using @vitest/web-worker.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/41-sandbox-polish/41-01-SUMMARY.md
@src/extensions/sandbox/sandbox-api-surface.ts
@src/extensions/sandbox/SandboxedExtensionAPI.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sandbox bridge and worker with postMessage protocol</name>
  <files>
    src/extensions/sandbox/types.ts
    src/extensions/sandbox/SandboxBridge.ts
    src/extensions/sandbox/sandbox-worker.ts
  </files>
  <action>
1. Create `src/extensions/sandbox/types.ts` with shared message types for the host-worker protocol:
   ```typescript
   /**
    * Message types for host <-> worker sandbox communication.
    *
    * All messages are JSON-serializable and go through structured clone
    * via postMessage. No functions, DOM nodes, or React elements allowed.
    */

   /** Messages sent FROM host TO worker */
   export type HostToWorkerMessage =
     | { type: "init"; extensionId: string; code: string }
     | { type: "api-call"; callId: string; method: string; args: unknown[] }
     | { type: "terminate" };

   /** Messages sent FROM worker TO host */
   export type WorkerToHostMessage =
     | { type: "ready" }
     | { type: "initialized"; extensionId: string }
     | { type: "api-request"; callId: string; method: string; args: unknown[] }
     | { type: "api-response"; callId: string; result?: unknown; error?: string }
     | { type: "error"; message: string };
   ```

2. Create `src/extensions/sandbox/SandboxBridge.ts`:
   ```typescript
   import { isSandboxSafe } from "./sandbox-api-surface";
   import type { HostToWorkerMessage, WorkerToHostMessage } from "./types";

   /**
    * Host-side bridge for communicating with a sandboxed extension Worker.
    *
    * This is a prototype demonstrating the communication pattern:
    * - Worker creation and lifecycle management
    * - Bidirectional postMessage RPC
    * - API method whitelisting (sandbox-safe only)
    * - Pending call tracking with timeout
    * - Clean termination with pending call rejection
    */
   export class SandboxBridge {
     private worker: Worker | null = null;
     private pendingCalls = new Map<string, {
       resolve: (value: unknown) => void;
       reject: (error: Error) => void;
       timer: ReturnType<typeof setTimeout>;
     }>();
     private _isRunning = false;
     private readonly callTimeout: number;

     constructor(options?: { callTimeout?: number }) {
       this.callTimeout = options?.callTimeout ?? 5000;
     }

     get isRunning(): boolean {
       return this._isRunning;
     }

     /**
      * Create and start the Worker from a URL.
      * Resolves when the Worker sends a "ready" message.
      */
     async start(workerUrl: string | URL): Promise<void> {
       if (this._isRunning) {
         throw new Error("SandboxBridge is already running");
       }

       return new Promise<void>((resolve, reject) => {
         const timeout = setTimeout(() => {
           this.terminate();
           reject(new Error("Worker failed to start: ready timeout"));
         }, this.callTimeout);

         this.worker = new Worker(workerUrl, { type: "module" });

         this.worker.onmessage = (event: MessageEvent<WorkerToHostMessage>) => {
           const msg = event.data;
           if (msg.type === "ready") {
             clearTimeout(timeout);
             this._isRunning = true;
             // Replace onmessage with the standard handler
             this.worker!.onmessage = this.handleMessage.bind(this);
             resolve();
           }
         };

         this.worker.onerror = (event) => {
           clearTimeout(timeout);
           console.error("[SandboxBridge] Worker error:", event.message);
           reject(new Error(`Worker error: ${event.message}`));
         };
       });
     }

     /**
      * Send an initialization message with extension code to execute.
      */
     async initialize(extensionId: string, code: string): Promise<void> {
       this.assertRunning();
       const msg: HostToWorkerMessage = { type: "init", extensionId, code };
       this.worker!.postMessage(msg);

       // Wait for "initialized" response
       return new Promise<void>((resolve, reject) => {
         const timeout = setTimeout(() => {
           reject(new Error("Extension initialization timed out"));
         }, this.callTimeout);

         const originalHandler = this.worker!.onmessage;
         this.worker!.onmessage = (event: MessageEvent<WorkerToHostMessage>) => {
           const msg = event.data;
           if (msg.type === "initialized") {
             clearTimeout(timeout);
             this.worker!.onmessage = originalHandler;
             resolve();
           } else if (msg.type === "error") {
             clearTimeout(timeout);
             this.worker!.onmessage = originalHandler;
             reject(new Error(msg.message));
           } else {
             // Forward other messages to normal handler
             originalHandler?.call(this.worker, event);
           }
         };
       });
     }

     /**
      * Call a sandbox-safe API method on the Worker side.
      * Throws if the method is not sandbox-safe.
      */
     async callApi(method: string, args: unknown[] = []): Promise<unknown> {
       this.assertRunning();

       if (!isSandboxSafe(method)) {
         throw new Error(
           `Method "${method}" is not sandbox-safe and cannot be called ` +
           `through the sandbox bridge. It requires trust level "built-in" ` +
           `or "user-trusted".`
         );
       }

       const callId = crypto.randomUUID();

       return new Promise<unknown>((resolve, reject) => {
         const timer = setTimeout(() => {
           this.pendingCalls.delete(callId);
           reject(new Error(`API call "${method}" timed out after ${this.callTimeout}ms`));
         }, this.callTimeout);

         this.pendingCalls.set(callId, { resolve, reject, timer });

         const msg: HostToWorkerMessage = {
           type: "api-call",
           callId,
           method,
           args,
         };
         this.worker!.postMessage(msg);
       });
     }

     /**
      * Terminate the Worker and reject all pending calls.
      */
     terminate(): void {
       if (this.worker) {
         this.worker.terminate();
         this.worker = null;
       }
       this._isRunning = false;

       // Reject all pending calls
       for (const [callId, pending] of this.pendingCalls) {
         clearTimeout(pending.timer);
         pending.reject(new Error("Sandbox terminated"));
         this.pendingCalls.delete(callId);
       }
     }

     private handleMessage(event: MessageEvent<WorkerToHostMessage>): void {
       const msg = event.data;

       switch (msg.type) {
         case "api-response": {
           const pending = this.pendingCalls.get(msg.callId);
           if (pending) {
             clearTimeout(pending.timer);
             this.pendingCalls.delete(msg.callId);
             if (msg.error) {
               pending.reject(new Error(msg.error));
             } else {
               pending.resolve(msg.result);
             }
           }
           break;
         }
         case "error":
           console.error("[SandboxBridge] Worker error:", msg.message);
           break;
         default:
           break;
       }
     }

     private assertRunning(): void {
       if (!this._isRunning || !this.worker) {
         throw new Error("SandboxBridge is not running. Call start() first.");
       }
     }
   }
   ```

3. Create `src/extensions/sandbox/sandbox-worker.ts` (the Worker entry point):
   ```typescript
   /**
    * Sandbox Worker entry point.
    *
    * This runs inside a Web Worker with no access to:
    * - DOM (no document, no window)
    * - Tauri IPC (no window.__TAURI_INTERNALS__)
    * - React runtime
    * - Zustand stores
    *
    * Communication with the host thread is exclusively via postMessage.
    */
   import type { HostToWorkerMessage, WorkerToHostMessage } from "./types";

   // Signal readiness to host
   const ctx = self as unknown as DedicatedWorkerGlobalScope;

   function send(msg: WorkerToHostMessage): void {
     ctx.postMessage(msg);
   }

   // Send ready signal
   send({ type: "ready" });

   ctx.onmessage = (event: MessageEvent<HostToWorkerMessage>) => {
     const msg = event.data;

     switch (msg.type) {
       case "init": {
         try {
           // In a real implementation, this would evaluate the extension code.
           // For the prototype, we just acknowledge initialization.
           // The 'code' parameter would be evaluated in a restricted scope.
           send({ type: "initialized", extensionId: msg.extensionId });
         } catch (err) {
           send({
             type: "error",
             message: err instanceof Error ? err.message : String(err),
           });
         }
         break;
       }

       case "api-call": {
         try {
           // Prototype: echo the method and args back as a successful response.
           // In a real implementation, this would dispatch to the sandboxed
           // extension's registered handlers.
           send({
             type: "api-response",
             callId: msg.callId,
             result: {
               method: msg.method,
               args: msg.args,
               handled: true,
             },
           });
         } catch (err) {
           send({
             type: "api-response",
             callId: msg.callId,
             error: err instanceof Error ? err.message : String(err),
           });
         }
         break;
       }

       case "terminate": {
         // Clean up and close
         ctx.close();
         break;
       }
     }
   };
   ```

Note: Use `self.postMessage` explicitly (not bare `postMessage`) inside the Worker to avoid jsdom scope issues in tests. The Worker uses `DedicatedWorkerGlobalScope` typing.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/extensions/sandbox/types.ts` exports HostToWorkerMessage and WorkerToHostMessage
    - `src/extensions/sandbox/SandboxBridge.ts` exports SandboxBridge class
    - `src/extensions/sandbox/sandbox-worker.ts` exists and sends "ready" on load
  </verify>
  <done>
    SandboxBridge class handles Worker lifecycle, postMessage RPC, method whitelisting, and termination. sandbox-worker.ts handles init and API call echo. Shared types define the protocol.
  </done>
</task>

<task type="auto">
  <name>Task 2: Install @vitest/web-worker and write sandbox bridge tests</name>
  <files>
    package.json
    src/extensions/sandbox/__tests__/SandboxBridge.test.ts
  </files>
  <action>
1. Install `@vitest/web-worker` as a dev dependency:
   ```bash
   npm install -D @vitest/web-worker
   ```
   Do NOT add it to vitest setup.ts globally -- import it per-test-file to avoid jsdom scope conflicts.

2. Create `src/extensions/sandbox/__tests__/SandboxBridge.test.ts` with the following test cases:

   **IMPORTANT:** Import `@vitest/web-worker` at the top of the test file (not globally). Use inline Blob URL workers for test isolation. The `SandboxBridge` class should be tested with both inline workers (for protocol testing) and the actual `sandbox-worker.ts` if possible.

   ```typescript
   import "@vitest/web-worker";
   import { describe, it, expect, beforeEach, afterEach, vi } from "vitest";
   import { SandboxBridge } from "../SandboxBridge";

   // Helper: create inline worker from code string
   function createWorkerUrl(code: string): string {
     const blob = new Blob([code], { type: "application/javascript" });
     return URL.createObjectURL(blob);
   }

   describe("SandboxBridge", () => {
     let bridge: SandboxBridge;

     beforeEach(() => {
       bridge = new SandboxBridge({ callTimeout: 2000 });
     });

     afterEach(() => {
       bridge.terminate();
     });

     it("creates worker and receives ready handshake", async () => {
       const url = createWorkerUrl(`
         self.postMessage({ type: "ready" });
         self.onmessage = () => {};
       `);
       await bridge.start(url);
       expect(bridge.isRunning).toBe(true);
       URL.revokeObjectURL(url);
     });

     it("rejects if worker does not send ready within timeout", async () => {
       const url = createWorkerUrl(`
         // Intentionally do NOT send ready
         self.onmessage = () => {};
       `);
       await expect(bridge.start(url)).rejects.toThrow("ready timeout");
       URL.revokeObjectURL(url);
     });

     it("sends api-call and receives api-response", async () => {
       const url = createWorkerUrl(`
         self.postMessage({ type: "ready" });
         self.onmessage = (e) => {
           if (e.data.type === "api-call") {
             self.postMessage({
               type: "api-response",
               callId: e.data.callId,
               result: { echo: e.data.method },
             });
           }
         };
       `);
       await bridge.start(url);
       const result = await bridge.callApi("onDidGit", ["commit"]);
       expect(result).toEqual({ echo: "onDidGit" });
       URL.revokeObjectURL(url);
     });

     it("blocks requires-trust methods", async () => {
       const url = createWorkerUrl(`
         self.postMessage({ type: "ready" });
         self.onmessage = () => {};
       `);
       await bridge.start(url);
       await expect(bridge.callApi("registerBlade", [])).rejects.toThrow("not sandbox-safe");
       await expect(bridge.callApi("contributeToolbar", [])).rejects.toThrow("not sandbox-safe");
       URL.revokeObjectURL(url);
     });

     it("terminate rejects pending calls", async () => {
       const url = createWorkerUrl(`
         self.postMessage({ type: "ready" });
         self.onmessage = () => {
           // Intentionally never respond
         };
       `);
       await bridge.start(url);
       const callPromise = bridge.callApi("onDispose", []);
       bridge.terminate();
       await expect(callPromise).rejects.toThrow("Sandbox terminated");
       expect(bridge.isRunning).toBe(false);
     });

     it("throws when calling api before start", () => {
       expect(() => bridge.callApi("onDidGit", [])).rejects.toThrow("not running");
     });

     it("throws when starting twice", async () => {
       const url = createWorkerUrl(`
         self.postMessage({ type: "ready" });
         self.onmessage = () => {};
       `);
       await bridge.start(url);
       await expect(bridge.start(url)).rejects.toThrow("already running");
       URL.revokeObjectURL(url);
     });
   });
   ```

   **Note:** If `@vitest/web-worker` does not work well with Blob URLs in the project's jsdom environment, fall back to testing with mock Worker objects using MessageChannel. The key is testing the protocol, not the Worker runtime. Adjust tests accordingly if Blob URL workers fail in the test environment -- the bridge's message handling logic can be tested by directly calling `handleMessage` with synthetic events if needed.

3. Run `npx vitest run src/extensions/sandbox/__tests__/SandboxBridge.test.ts` to verify tests pass.
  </action>
  <verify>
    - `npm ls @vitest/web-worker` shows it installed as devDependency
    - `npx vitest run src/extensions/sandbox/__tests__/SandboxBridge.test.ts` passes all tests
    - Tests cover: ready handshake, timeout, API call/response, method blocking, termination, double-start prevention
    - `npx vitest run` -- all tests pass (new + existing)
  </verify>
  <done>
    @vitest/web-worker installed. SandboxBridge tests prove bidirectional postMessage communication, API method whitelisting, and clean termination. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- TypeScript compiles with all sandbox modules
2. `npx vitest run` -- all tests pass including new sandbox bridge tests
3. `src/extensions/sandbox/` contains: types.ts, SandboxBridge.ts, sandbox-worker.ts, sandbox-api-surface.ts, SandboxedExtensionAPI.ts, __tests__/SandboxBridge.test.ts
4. SandboxBridge test file has 6+ test cases covering the core communication patterns
5. No new runtime dependencies added (only @vitest/web-worker as devDependency)
</verification>

<success_criteria>
- Worker-based sandbox prototype demonstrates postMessage communication
- SandboxBridge creates a Worker, sends messages, receives responses
- Sandbox-safe methods are allowed, requires-trust methods are blocked
- Termination cleanly rejects pending calls
- Tests prove the communication protocol works
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/41-sandbox-polish/41-03-SUMMARY.md`
</output>
