---
phase: 52-visualization-welcome-polish
plan: 03
type: execute
wave: 2
depends_on: ["52-02"]
files_modified:
  - src-tauri/src/git/commands.rs
  - src-tauri/src/lib.rs
  - src/extensions/welcome-screen/hooks/useRepoHealth.ts
  - src/extensions/welcome-screen/components/HealthDot.tsx
  - src/extensions/welcome-screen/components/RepoCard.tsx
autonomous: true

must_haves:
  truths:
    - "User sees colored status dots on welcome screen repo cards showing sync status (clean/dirty/behind/ahead)"
    - "Status dot has a tooltip explaining the health status (e.g., 'Clean — working tree is clean')"
    - "Health checks load asynchronously without blocking the welcome screen render"
    - "User can perform quick actions on repo cards: open, open in terminal, remove from recents"
    - "Quick action buttons appear on hover and include proper aria-labels"
    - "Open in terminal uses the user's configured terminal from settings"
    - "Open in terminal shows an error toast if the terminal fails to launch"
  artifacts:
    - path: "src-tauri/src/git/commands.rs"
      provides: "get_repo_health_quick and open_in_terminal Tauri commands"
      contains: "get_repo_health_quick"
    - path: "src-tauri/src/lib.rs"
      provides: "Registration of new commands in collect_commands"
      contains: "get_repo_health_quick"
    - path: "src/extensions/welcome-screen/hooks/useRepoHealth.ts"
      provides: "Hook to asynchronously fetch health status for recent repos"
      exports: ["useRepoHealth"]
    - path: "src/extensions/welcome-screen/components/HealthDot.tsx"
      provides: "Colored dot component with tooltip for repo health status"
      exports: ["HealthDot"]
    - path: "src/extensions/welcome-screen/components/RepoCard.tsx"
      provides: "Enhanced card with health dot and quick action buttons"
  key_links:
    - from: "src/extensions/welcome-screen/hooks/useRepoHealth.ts"
      to: "src-tauri/src/git/commands.rs"
      via: "calls commands.getRepoHealthQuick via bindings"
      pattern: "commands\\.getRepoHealthQuick"
    - from: "src/extensions/welcome-screen/components/RepoCard.tsx"
      to: "src/extensions/welcome-screen/components/HealthDot.tsx"
      via: "renders HealthDot with repo status"
      pattern: "<HealthDot"
    - from: "src/extensions/welcome-screen/components/RepoCard.tsx"
      to: "src-tauri/src/git/commands.rs"
      via: "calls commands.openInTerminal for terminal action"
      pattern: "commands\\.openInTerminal"
---

<objective>
Add repository health indicators and quick actions to welcome screen repo cards, with supporting Rust backend commands.

Purpose: Users see at-a-glance sync status for their repositories and can perform common actions (open, terminal, remove) directly from the welcome screen without navigating away.
Output: Two new Rust commands (get_repo_health_quick, open_in_terminal), health dot component, quick action buttons on repo cards.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-visualization-welcome-polish/52-02-PLAN.md
@src-tauri/src/git/commands.rs
@src-tauri/src/git/repository.rs (RepoStatus struct)
@src-tauri/src/git/branch.rs (AheadBehind, get_branch_ahead_behind)
@src-tauri/src/lib.rs (command registration)
@src/extensions/welcome-screen/components/RepoCard.tsx (from plan 02)
@src/core/lib/integrations-options.ts (terminal options)
@src/core/stores/domain/preferences/settings.slice.ts (terminal setting)
@src/bindings.ts (auto-generated types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Rust commands for repo health check and open-in-terminal</name>
  <files>
    src-tauri/src/git/commands.rs
    src-tauri/src/lib.rs
  </files>
  <action>
Add two new Tauri commands to `commands.rs`:

**1. `get_repo_health_quick`** — Opens a temporary git2::Repository handle (NOT through RepositoryState) to check health without disturbing the active repo:

```rust
/// Quick health check for a repository by path.
/// Opens a temporary repo handle — does NOT affect the active repository.
#[derive(Debug, Clone, Serialize, Deserialize, specta::Type)]
#[serde(rename_all = "camelCase")]
pub struct RepoHealth {
    pub status: String,       // "clean", "dirty", "ahead", "behind", "diverged", "unknown"
    pub branch_name: String,
    pub ahead: u32,
    pub behind: u32,
    pub is_dirty: bool,
}

#[tauri::command]
#[specta::specta]
pub async fn get_repo_health_quick(path: String) -> Result<RepoHealth, GitError> {
    let path = std::path::PathBuf::from(&path);
    if !path.exists() {
        return Err(GitError::PathNotFound(path.display().to_string()));
    }

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&path)?;

        // Get current branch name
        let head = match repo.head() {
            Ok(h) => h,
            Err(_) => return Ok(RepoHealth {
                status: "unknown".to_string(),
                branch_name: String::new(),
                ahead: 0, behind: 0, is_dirty: false,
            }),
        };
        let branch_name = head.shorthand().unwrap_or("HEAD").to_string();

        // Check dirty status
        let mut opts = git2::StatusOptions::new();
        opts.include_untracked(true)
            .recurse_untracked_dirs(false);
        let statuses = repo.statuses(Some(&mut opts))?;
        let is_dirty = !statuses.is_empty();

        // Check ahead/behind (if upstream exists)
        let (ahead, behind) = match repo.find_branch(&branch_name, git2::BranchType::Local) {
            Ok(local_branch) => {
                let local_oid = match local_branch.get().peel_to_commit() {
                    Ok(c) => c.id(),
                    Err(_) => return Ok(RepoHealth {
                        status: if is_dirty { "dirty" } else { "clean" }.to_string(),
                        branch_name, ahead: 0, behind: 0, is_dirty,
                    }),
                };
                match local_branch.upstream() {
                    Ok(upstream) => {
                        let upstream_oid = match upstream.get().peel_to_commit() {
                            Ok(c) => c.id(),
                            Err(_) => return Ok(RepoHealth {
                                status: if is_dirty { "dirty" } else { "clean" }.to_string(),
                                branch_name, ahead: 0, behind: 0, is_dirty,
                            }),
                        };
                        let (a, b) = repo.graph_ahead_behind(local_oid, upstream_oid)?;
                        (a as u32, b as u32)
                    }
                    Err(_) => (0, 0), // No upstream
                }
            }
            Err(_) => (0, 0),
        };

        // Determine status string
        let status = if ahead > 0 && behind > 0 {
            "diverged"
        } else if ahead > 0 {
            "ahead"
        } else if behind > 0 {
            "behind"
        } else if is_dirty {
            "dirty"
        } else {
            "clean"
        };

        Ok(RepoHealth {
            status: status.to_string(),
            branch_name,
            ahead,
            behind,
            is_dirty,
        })
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}
```

Add required derives at the top of the file if not already present: `use serde::{Deserialize, Serialize};`

**2. `open_in_terminal`** — Spawns the user's configured terminal at the given path:

```rust
#[tauri::command]
#[specta::specta]
pub async fn open_in_terminal(path: String, terminal: String) -> Result<(), GitError> {
    let path_buf = std::path::PathBuf::from(&path);
    if !path_buf.exists() {
        return Err(GitError::PathNotFound(path_buf.display().to_string()));
    }

    let path_str = path_buf.display().to_string();

    tokio::task::spawn_blocking(move || {
        #[cfg(target_os = "macos")]
        {
            let app_name = match terminal.as_str() {
                "terminal" => "Terminal",
                "iterm2" => "iTerm",
                "warp" => "Warp",
                "alacritty" => "Alacritty",
                "kitty" => "kitty",
                "hyper" => "Hyper",
                other => other,
            };
            std::process::Command::new("open")
                .args(["-a", app_name, &path_str])
                .spawn()
                .map_err(|e| GitError::OperationFailed(format!(
                    "Failed to open terminal '{}': {}", app_name, e
                )))?;
        }

        #[cfg(target_os = "windows")]
        {
            match terminal.as_str() {
                "wt" => {
                    std::process::Command::new("wt")
                        .args(["-d", &path_str])
                        .spawn()
                        .map_err(|e| GitError::OperationFailed(format!("Failed to open Windows Terminal: {}", e)))?;
                }
                "powershell" => {
                    std::process::Command::new("powershell")
                        .args(["-NoExit", "-Command", &format!("Set-Location '{}'", path_str)])
                        .spawn()
                        .map_err(|e| GitError::OperationFailed(format!("Failed to open PowerShell: {}", e)))?;
                }
                "cmd" => {
                    std::process::Command::new("cmd")
                        .args(["/k", &format!("cd /d {}", path_str)])
                        .spawn()
                        .map_err(|e| GitError::OperationFailed(format!("Failed to open cmd: {}", e)))?;
                }
                other => {
                    std::process::Command::new("cmd")
                        .args(["/c", "start", other, &path_str])
                        .spawn()
                        .map_err(|e| GitError::OperationFailed(format!("Failed to open '{}': {}", other, e)))?;
                }
            }
        }

        #[cfg(target_os = "linux")]
        {
            match terminal.as_str() {
                "gnome-terminal" => {
                    std::process::Command::new("gnome-terminal")
                        .args(["--working-directory", &path_str])
                        .spawn()
                        .map_err(|e| GitError::OperationFailed(format!("Failed to open gnome-terminal: {}", e)))?;
                }
                other => {
                    std::process::Command::new(other)
                        .current_dir(&path_str)
                        .spawn()
                        .map_err(|e| GitError::OperationFailed(format!("Failed to open '{}': {}", other, e)))?;
                }
            }
        }

        Ok(())
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}
```

**Register in `lib.rs`:**
- Add imports in the `commands::` block: `get_repo_health_quick, open_in_terminal`
- Add both to the `collect_commands!` macro under a new comment section `// Welcome screen commands`
- Run `cargo build` to regenerate `bindings.ts` with the new command types. If in dev mode, the bindings are auto-exported. If not, ensure the build succeeds.
  </action>
  <verify>
Run `cd src-tauri && cargo check` — no compilation errors.
Confirm `get_repo_health_quick` and `open_in_terminal` are registered in `collect_commands!`.
Confirm `RepoHealth` struct is defined with `specta::Type` derive.
  </verify>
  <done>
Two new Rust Tauri commands: `get_repo_health_quick` opens a temporary repo handle to check dirty/ahead/behind status without affecting the active repo; `open_in_terminal` spawns the configured terminal at a path with platform-specific handling. Both registered in lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HealthDot, useRepoHealth hook, and enhance RepoCard with health + quick actions</name>
  <files>
    src/extensions/welcome-screen/hooks/useRepoHealth.ts
    src/extensions/welcome-screen/components/HealthDot.tsx
    src/extensions/welcome-screen/components/RepoCard.tsx
  </files>
  <action>
**Create `useRepoHealth.ts`:**
- Takes `repos: RecentRepo[]` (the array of recent repos)
- Returns `healthMap: Map<string, RepoHealthStatus>` where key is repo path
- Type: `type RepoHealthStatus = { status: "clean" | "dirty" | "ahead" | "behind" | "diverged" | "unknown" | "loading"; branchName: string; ahead: number; behind: number; isDirty: boolean; }`
- On mount and when `repos` changes, check health for all repos in parallel using `Promise.allSettled`:
  ```typescript
  const results = await Promise.allSettled(
    repos.map(async (repo) => {
      const result = await commands.getRepoHealthQuick(repo.path);
      if (result.status === "ok") return { path: repo.path, health: result.data };
      return { path: repo.path, health: null };
    })
  );
  ```
- Initialize all repos with `status: "loading"` immediately so cards render instantly (Pitfall 3: don't block render)
- Update `healthMap` as results come in using `useState` with a `Map`
- Debounce re-checks: if `repos` reference changes within 500ms, cancel pending checks (use an abort flag pattern with `useRef`)

**Create `HealthDot.tsx`:**
- Props: `{ status: RepoHealthStatus }`
- Render a small dot (8x8px) with color based on `status.status`:
  - `"clean"` → `bg-ctp-green` (tooltip: "Clean — working tree is clean")
  - `"dirty"` → `bg-ctp-yellow` (tooltip: "Dirty — uncommitted changes")
  - `"ahead"` → `bg-ctp-blue` (tooltip: "Ahead — {N} commits ahead of remote")
  - `"behind"` → `bg-ctp-peach` (tooltip: "Behind — {N} commits behind remote")
  - `"diverged"` → `bg-ctp-red` (tooltip: "Diverged — {ahead} ahead, {behind} behind remote")
  - `"unknown"` → `bg-ctp-overlay0` (tooltip: "Unknown — could not determine status")
  - `"loading"` → `bg-ctp-overlay0 motion-safe:animate-pulse` (tooltip: "Checking...")
- Dot styling: `w-2 h-2 rounded-full shrink-0` with a ring on hover: `ring-2 ring-offset-1 ring-offset-ctp-base ring-{same-color}/50`
- Use a simple hover tooltip (not ShortcutTooltip — just a title attribute or a tiny custom tooltip):
  ```tsx
  <div className="relative group">
    <div className={`w-2 h-2 rounded-full ${colorClass}`} />
    <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1 px-2 py-1 bg-ctp-mantle/95 text-xs text-ctp-subtext1 rounded shadow-md border border-ctp-surface0/30 whitespace-nowrap opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity">
      {tooltipText}
    </div>
  </div>
  ```
- Also show the branch name next to the dot in `text-[10px] text-ctp-overlay0 font-mono` if available

**Enhance `RepoCard.tsx` (from plan 02):**
1. Add new props:
   ```typescript
   health?: RepoHealthStatus;
   onOpenInTerminal?: (path: string) => void;
   ```
2. Add `HealthDot` rendering: Place the `<HealthDot>` between the folder icon and the repo name area. This gives a left-side status indicator.
3. Add quick action buttons that appear on hover (alongside existing pin and remove buttons):
   - "Open" button: `FolderOpen` icon from lucide-react, calls `onOpen(repo)`, aria-label="Open repository"
   - "Open in Terminal" button: `Terminal` icon from lucide-react, calls `onOpenInTerminal?.(repo.path)` with `e.stopPropagation()`, aria-label="Open in terminal"
   - "Remove" button: already exists (X icon), keep as-is
   - Button order left-to-right: Pin | Open | Terminal | Remove
   - All action buttons: `opacity-0 group-hover:opacity-100 transition-opacity h-7 w-7` (ghost variant)
4. Update the card to be slightly taller to accommodate the health dot and branch info: add `min-h-[52px]`

**Wire in `RecentRepos.tsx`:**
- Import `useRepoHealth` and pass repos to it
- Import `commands` from bindings for `openInTerminal`
- Import the user's terminal preference from settings store: `usePreferencesStore(s => s.settings.terminal)` or equivalent
- Create `handleOpenInTerminal` callback:
  ```typescript
  const handleOpenInTerminal = useCallback(async (path: string) => {
    const terminalApp = terminal || "terminal"; // default to system Terminal
    const result = await commands.openInTerminal(path, terminalApp);
    if (result.status === "error") {
      // Show error toast — use console.error for now if no toast system
      console.error("Failed to open terminal:", result.error);
    }
  }, [terminal]);
  ```
- Pass `health={healthMap.get(repo.path)}` and `onOpenInTerminal={handleOpenInTerminal}` to each `<RepoCard>`
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | grep -v "TS2440"` — no new type errors (after bindings regeneration from Task 1's cargo build).
Visual check: Health dots appear on repo cards with correct colors. Hovering shows tooltip. Quick action buttons (open, terminal, remove) appear on hover. Terminal button opens configured terminal.
  </verify>
  <done>
Health dots show on each repo card with status-appropriate colors and tooltips. Quick action buttons (open, open in terminal, remove) appear on hover. Health checks run asynchronously without blocking render. Terminal opening uses the user's configured terminal from settings.
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` succeeds with no errors
2. `npx tsc --noEmit 2>&1 | grep -v "TS2440"` passes with no new errors
3. get_repo_health_quick returns correct status for clean, dirty, ahead, behind repos
4. open_in_terminal spawns the configured terminal on macOS
5. HealthDot renders colored dots with correct tooltips for each status
6. Health checks load asynchronously — cards render immediately with loading dots, then update
7. Quick action buttons (open, terminal, remove) appear on hover with proper aria-labels
8. Open in terminal uses the user's terminal setting from preferences
9. Terminal spawn failure shows an error message (not silent failure)
</verification>

<success_criteria>
- Health status dots visible on repo cards with color-coded status
- Tooltips explain each health status
- Health checks are non-blocking (cards render immediately)
- Quick action buttons appear on hover: open, terminal, remove
- Open in terminal spawns the configured terminal application
- Terminal failures surface an error to the user
- No TypeScript or Rust compilation errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/52-visualization-welcome-polish/52-03-SUMMARY.md`
</output>
