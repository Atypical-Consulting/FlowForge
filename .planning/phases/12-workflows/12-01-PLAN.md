---
phase: 12-workflows
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/clone.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Clone command accepts URL, destination path, and progress channel"
    - "Progress events fire for receiving objects, resolving deltas, and checkout"
    - "Clone errors return descriptive GitError variants"
  artifacts:
    - path: "src-tauri/src/git/clone.rs"
      provides: "Clone repository with progress callbacks"
      exports: ["clone_repository", "CloneProgress"]
  key_links:
    - from: "src-tauri/src/git/clone.rs"
      to: "git2::build::RepoBuilder"
      via: "Remote callbacks for progress"
      pattern: "RepoBuilder.*clone"
---

<objective>
Implement backend clone functionality with progress tracking.

Purpose: Enable users to clone repositories by URL with real-time progress feedback.
Output: `clone_repository` command that clones with progress events via Tauri Channel.
</objective>

<execution_context>
@C:\Users\matrayp\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\matrayp\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-workflows/12-CONTEXT.md
@.planning/phases/12-workflows/12-RESEARCH.md
@src-tauri/src/git/remote.rs
@src-tauri/src/git/mod.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CloneProgress enum and clone_repository command</name>
  <files>src-tauri/src/git/clone.rs, src-tauri/src/git/mod.rs, src-tauri/src/lib.rs</files>
  <action>
Create `src-tauri/src/git/clone.rs`:

1. Define `CloneProgress` enum (tagged union like SyncProgress in remote.rs):
   - `Started { url: String }`
   - `Receiving { received: u32, total: u32, bytes: u64 }`
   - `Resolving { current: u32, total: u32 }`
   - `Checkout { current: usize, total: usize, path: String }`
   - `Finished { path: String }`

2. Implement `clone_repository` command:
   - Parameters: `url: String`, `destination: String`, `on_progress: Channel<CloneProgress>`
   - Use `tokio::task::spawn_blocking` for git2 operations (pattern from remote.rs)
   - Configure `git2::build::RepoBuilder::new()`:
     - Create `RemoteCallbacks` with `transfer_progress()` callback for Receiving/Resolving phases
     - Create `CheckoutBuilder` with `progress()` callback for Checkout phase
   - Execute clone: `builder.clone(&url, Path::new(&destination))`
   - Send progress events through channel at each phase (use `.ok()` to ignore send errors)
   - Return the cloned repository path on success

3. Add error handling:
   - Invalid URL pattern: Return `GitError::InvalidUrl(url)`
   - Destination exists non-empty: Return `GitError::PathExists(path)`
   - Git clone failure: Return `GitError::CloneFailed(message)`

4. Add new error variants to `src-tauri/src/git/error.rs`:
   - `InvalidUrl(String)`
   - `PathExists(String)`
   - `CloneFailed(String)`

5. Register module in `src-tauri/src/git/mod.rs`: Add `pub mod clone;` and re-export `clone_repository`, `CloneProgress`

6. Register command in `src-tauri/src/lib.rs`: Import from git::clone and add to `generate_handler![]` macro
  </action>
  <verify>
Run `cargo check` in src-tauri directory - no compilation errors.
Run `npm run tauri:gen` - verify CloneProgress type appears in src/bindings.ts with correct variant structure.
  </verify>
  <done>
`clone_repository` command compiles and CloneProgress type exports to TypeScript bindings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add destination validation and URL parsing</name>
  <files>src-tauri/src/git/clone.rs</files>
  <action>
Enhance clone_repository with robust path and URL handling:

1. URL parsing (extract repo name):
   - Parse URL to extract repository name (last path segment)
   - Strip `.git` suffix if present
   - Support both HTTPS (`https://github.com/user/repo.git`) and SSH (`git@github.com:user/repo.git`) formats
   - Create helper function `extract_repo_name(url: &str) -> Option<String>`

2. Destination path logic:
   - If destination is empty string, return error
   - If destination exists and is non-empty directory, return `GitError::PathExists`
   - If destination exists and is empty directory, allow clone into it
   - If destination doesn't exist, create parent directories with `std::fs::create_dir_all()`
   - Use `std::path::PathBuf` for cross-platform path handling

3. Before clone validation:
   - Send `CloneProgress::Started { url }` immediately
   - Validate URL has extractable repo name
   - Validate destination path is writable

4. After clone:
   - Send `CloneProgress::Finished { path: destination }` with actual path
   - Return `Ok(destination_path_string)`
  </action>
  <verify>
Run `cargo check` - compiles without errors.
Code review: URL parsing handles `https://github.com/user/repo.git`, `git@github.com:user/repo.git`, `https://github.com/user/repo`.
  </verify>
  <done>
Clone handles: URL parsing for repo name, path validation, cross-platform paths, clear error messages.
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes in src-tauri
- `npm run tauri:gen` regenerates bindings
- `commands.cloneRepository` exists in bindings.ts
- `CloneProgress` type has all 5 variants
</verification>

<success_criteria>
- Backend clone command exists with progress channel support
- Progress events cover all phases: started, receiving, resolving, checkout, finished
- Path validation prevents overwriting existing repositories
- URL parsing extracts repo name from HTTPS and SSH URLs
- Follows existing codebase patterns (SyncProgress, spawn_blocking, Channel)
</success_criteria>

<output>
After completion, create `.planning/phases/12-workflows/12-01-SUMMARY.md`
</output>
