---
phase: 12-workflows
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/gitflow/init.rs
  - src-tauri/src/gitflow/mod.rs
  - src-tauri/src/gitflow/state.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "init_gitflow command creates develop branch if not exists"
    - "Branch names are configurable (main, develop, feature/, release/, hotfix/)"
    - "Configuration stored in .git/config for git-flow CLI compatibility"
    - "Command returns error if develop branch exists with different name"
  artifacts:
    - path: "src-tauri/src/gitflow/init.rs"
      provides: "Gitflow initialization logic"
      exports: ["init_gitflow", "GitflowConfig"]
  key_links:
    - from: "src-tauri/src/gitflow/init.rs"
      to: "git2::Repository"
      via: "branch creation and config"
      pattern: "repo\\.branch|repo\\.config"
---

<objective>
Implement backend Gitflow initialization command.

Purpose: Enable users to initialize Gitflow on repositories that don't have it configured.
Output: `init_gitflow` command that creates develop branch and stores configuration.
</objective>

<execution_context>
@C:\Users\matrayp\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\matrayp\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-workflows/12-CONTEXT.md
@.planning/phases/12-workflows/12-RESEARCH.md
@src-tauri/src/gitflow/state.rs
@src-tauri/src/gitflow/commands.rs
@src-tauri/src/gitflow/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitflowConfig struct and init_gitflow command</name>
  <files>src-tauri/src/gitflow/init.rs, src-tauri/src/gitflow/mod.rs, src-tauri/src/lib.rs</files>
  <action>
Create `src-tauri/src/gitflow/init.rs`:

1. Define `GitflowConfig` struct (input for initialization):
   ```rust
   #[derive(Debug, Clone, Serialize, Deserialize, Type)]
   #[serde(rename_all = "camelCase")]
   pub struct GitflowConfig {
       pub main_branch: String,      // e.g., "main" or "master"
       pub develop_branch: String,   // e.g., "develop"
       pub feature_prefix: String,   // e.g., "feature/"
       pub release_prefix: String,   // e.g., "release/"
       pub hotfix_prefix: String,    // e.g., "hotfix/"
   }
   ```

2. Define `GitflowInitResult` struct (return value):
   ```rust
   #[derive(Debug, Clone, Serialize, Deserialize, Type)]
   #[serde(rename_all = "camelCase")]
   pub struct GitflowInitResult {
       pub develop_created: bool,
       pub switched_to_develop: bool,
   }
   ```

3. Implement `init_gitflow` command:
   - Parameters: `config: GitflowConfig`, `push_develop: bool`, `state: State<RepositoryState>`
   - Use `tokio::task::spawn_blocking` for git2 operations
   - Steps:
     a. Verify main branch exists (error if not)
     b. Check if develop branch exists:
        - If exists with same name as config.develop_branch: OK, proceed
        - If exists with different name: return error asking user to resolve
     c. If develop doesn't exist: create it from main branch HEAD
     d. Store config in .git/config (see Task 2)
     e. Checkout develop branch
     f. If push_develop: push develop to origin (optional, can fail silently)
   - Return `GitflowInitResult`

4. Add to `src-tauri/src/gitflow/mod.rs`: `pub mod init;` and re-export

5. Add to `src-tauri/src/lib.rs`: import and register in `generate_handler![]`
  </action>
  <verify>
Run `cargo check` - no compilation errors.
Run `npm run tauri:gen` - GitflowConfig and init_gitflow appear in bindings.ts.
  </verify>
  <done>
init_gitflow command compiles, creates develop branch, returns result struct.
  </done>
</task>

<task type="auto">
  <name>Task 2: Store Gitflow config in .git/config</name>
  <files>src-tauri/src/gitflow/init.rs</files>
  <action>
Add config storage to init_gitflow for git-flow CLI compatibility:

1. After successful initialization, write to .git/config:
   ```ini
   [gitflow "branch"]
       main = main
       develop = develop
   [gitflow "prefix"]
       feature = feature/
       release = release/
       hotfix = hotfix/
       support = support/
       versiontag = 
   ```

2. Use git2's config API:
   ```rust
   let mut config = repo.config()?;
   config.set_str("gitflow.branch.main", &cfg.main_branch)?;
   config.set_str("gitflow.branch.develop", &cfg.develop_branch)?;
   config.set_str("gitflow.prefix.feature", &cfg.feature_prefix)?;
   config.set_str("gitflow.prefix.release", &cfg.release_prefix)?;
   config.set_str("gitflow.prefix.hotfix", &cfg.hotfix_prefix)?;
   ```

3. Add helper function `get_gitflow_config(repo: &Repository) -> Option<GitflowConfig>`:
   - Read from .git/config
   - Return None if not configured
   - This enables detecting if Gitflow is already initialized

4. Update `GitflowContext` in state.rs:
   - Add field `is_initialized: bool` based on config presence
   - Update `from_repo()` to check for gitflow config
   - This allows UI to know if "Initialize Gitflow" should be shown

5. Validate branch names before storing:
   - Use `git2::Reference::is_valid_name()` for validation
   - Return error if any name is invalid
  </action>
  <verify>
Run `cargo check` - compiles.
Manual test: Initialize gitflow, then check `.git/config` contains `[gitflow "branch"]` section.
  </verify>
  <done>
Gitflow config stored in .git/config, compatible with git-flow CLI, GitflowContext includes is_initialized.
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes
- `npm run tauri:gen` updates bindings
- `commands.initGitflow` exists in bindings.ts
- GitflowConfig type exported with all branch/prefix fields
</verification>

<success_criteria>
- init_gitflow command creates develop branch from main
- Branch names fully configurable
- Config stored in .git/config (git-flow compatible)
- Handles existing develop branch gracefully
- GitflowContext.is_initialized reflects initialization state
</success_criteria>

<output>
After completion, create `.planning/phases/12-workflows/12-03-SUMMARY.md`
</output>
