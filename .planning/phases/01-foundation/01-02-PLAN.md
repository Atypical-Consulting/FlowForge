---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/repository.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/git/commands.rs
  - src-tauri/src/lib.rs
  - src-tauri/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Git operations run without blocking UI"
    - "Repository state is thread-safe"
    - "Errors are serializable to frontend"
    - "Repository can be opened and status retrieved"
  artifacts:
    - path: "src-tauri/src/git/mod.rs"
      provides: "Git module exports"
      contains: "pub mod"
    - path: "src-tauri/src/git/repository.rs"
      provides: "Repository wrapper with Arc Mutex"
      contains: "Arc<Mutex"
    - path: "src-tauri/src/git/error.rs"
      provides: "Serializable error type"
      contains: "thiserror"
    - path: "src-tauri/src/git/commands.rs"
      provides: "Tauri commands with spawn_blocking"
      contains: "spawn_blocking"
  key_links:
    - from: "src-tauri/src/git/commands.rs"
      to: "tokio::task::spawn_blocking"
      via: "async wrapper"
      pattern: "spawn_blocking"
    - from: "src-tauri/src/git/repository.rs"
      to: "git2::Repository"
      via: "wrapper struct"
      pattern: "git2::Repository"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/git/commands.rs"
      via: "command registration"
      pattern: "open_repository"
---

<objective>
Create the Git service layer with thread-safe repository management and non-blocking operations.

Purpose: Implements the critical patterns from PITFALLS.md (spawn_blocking, storing path not Repository) that prevent UI freezes and thread safety issues. This layer is the foundation for all Git operations in the application.

Output: A Rust git module with repository management, typed error handling, and Tauri commands for opening repositories and getting status.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Git Error Types</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/git/mod.rs
    src-tauri/src/git/error.rs
  </files>
  <action>
    Add git2 dependency to src-tauri/Cargo.toml (add to existing dependencies):
    
    ```toml
    git2 = "0.20"
    ```
    
    Create directory src-tauri/src/git/ if it doesn't exist.
    
    Create src-tauri/src/git/mod.rs:
    
    ```rust
    pub mod commands;
    pub mod error;
    pub mod repository;
    
    pub use error::GitError;
    pub use repository::{RepoStatus, RepositoryState};
    ```
    
    Create src-tauri/src/git/error.rs with serializable errors:
    
    ```rust
    use serde::{Deserialize, Serialize};
    use specta::Type;
    use thiserror::Error;
    
    /// Git operation errors that serialize across the IPC boundary.
    /// 
    /// These errors are sent to the frontend as typed objects,
    /// allowing proper error handling in TypeScript.
    #[derive(Debug, Error, Serialize, Deserialize, Type, Clone)]
    #[serde(tag = "type", content = "message")]
    pub enum GitError {
        #[error("Repository not found: {0}")]
        NotFound(String),
    
        #[error("Not a Git repository: {0}")]
        NotARepository(String),
    
        #[error("Repository has no commits yet")]
        EmptyRepository,
    
        #[error("Failed to get repository status: {0}")]
        StatusError(String),
    
        #[error("Git operation failed: {0}")]
        OperationFailed(String),
    
        #[error("Path does not exist: {0}")]
        PathNotFound(String),
    
        #[error("Internal error: {0}")]
        Internal(String),
    }
    
    impl From<git2::Error> for GitError {
        fn from(err: git2::Error) -> Self {
            match err.code() {
                git2::ErrorCode::NotFound => GitError::NotFound(err.message().to_string()),
                git2::ErrorCode::InvalidSpec => GitError::NotARepository(err.message().to_string()),
                _ => GitError::OperationFailed(err.message().to_string()),
            }
        }
    }
    ```
    
    The error type provides:
    - Typed errors that serialize across IPC boundary with discriminated union
    - Automatic conversion from git2::Error
    - specta Type derive for TypeScript generation
    - Clone derive for use across async boundaries
  </action>
  <verify>
    `cargo check` in src-tauri/ passes with git2 dependency and error module.
  </verify>
  <done>
    - GitError enum with thiserror + serde + specta derives
    - Errors serialize to frontend as discriminated union
    - Conversion from git2::Error implemented
    - git2 crate added to dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Repository State Management</name>
  <files>
    src-tauri/src/git/repository.rs
  </files>
  <action>
    Create src-tauri/src/git/repository.rs with thread-safe repository management.
    
    IMPORTANT: Follow PITFALLS.md guidance:
    - Store PATH, not Repository object (thread safety)
    - Open fresh Repository for each operation
    - Wrap ALL git2 calls in spawn_blocking
    
    ```rust
    use serde::{Deserialize, Serialize};
    use specta::Type;
    use std::path::PathBuf;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    
    use crate::git::error::GitError;
    
    /// Repository status information sent to frontend.
    /// 
    /// This is a lightweight summary - we don't send raw git2 objects
    /// across the IPC boundary.
    #[derive(Debug, Clone, Serialize, Deserialize, Type)]
    #[serde(rename_all = "camelCase")]
    pub struct RepoStatus {
        /// Current branch name (or short commit hash if detached)
        pub branch_name: String,
        /// Whether the working directory has uncommitted changes
        pub is_dirty: bool,
        /// Absolute path to the repository root
        pub repo_path: String,
        /// Repository display name (folder name)
        pub repo_name: String,
    }
    
    /// Application state holding the current repository path.
    /// 
    /// CRITICAL: We store the PATH, not the Repository object.
    /// git2::Repository cannot be safely shared across threads.
    /// Instead, we open a fresh Repository handle for each operation
    /// inside spawn_blocking. See PITFALLS.md #3.
    pub struct RepositoryState {
        current_path: Arc<Mutex<Option<PathBuf>>>,
    }
    
    impl RepositoryState {
        pub fn new() -> Self {
            Self {
                current_path: Arc::new(Mutex::new(None)),
            }
        }
    
        /// Open repository at path and validate it's a git repo.
        /// 
        /// This validates the path, stores it, and returns initial status.
        pub async fn open(&self, path: PathBuf) -> Result<RepoStatus, GitError> {
            // First validate it's a git repository (in blocking task)
            let path_for_validation = path.clone();
            tokio::task::spawn_blocking(move || {
                git2::Repository::open(&path_for_validation).map_err(|e| {
                    if e.code() == git2::ErrorCode::NotFound {
                        GitError::NotARepository(path_for_validation.display().to_string())
                    } else {
                        GitError::from(e)
                    }
                })
            })
            .await
            .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))??;
    
            // Store the validated path
            {
                let mut current = self.current_path.lock().await;
                *current = Some(path.clone());
            }
    
            // Return initial status
            self.get_status_internal(&path).await
        }
    
        /// Get status of current repository.
        pub async fn get_status(&self) -> Result<RepoStatus, GitError> {
            let path = {
                let current = self.current_path.lock().await;
                current
                    .clone()
                    .ok_or_else(|| GitError::NotFound("No repository open".to_string()))?
            };
    
            self.get_status_internal(&path).await
        }
    
        /// Internal status fetch - always runs in spawn_blocking.
        async fn get_status_internal(&self, path: &PathBuf) -> Result<RepoStatus, GitError> {
            let path = path.clone();
    
            tokio::task::spawn_blocking(move || {
                let repo = git2::Repository::open(&path)?;
    
                // Get current branch name
                let branch_name = match repo.head() {
                    Ok(head) => {
                        if head.is_branch() {
                            head.shorthand().unwrap_or("HEAD").to_string()
                        } else {
                            // Detached HEAD - show short commit hash
                            head.peel_to_commit()
                                .map(|c| format!("{:.7}", c.id()))
                                .unwrap_or_else(|_| "HEAD".to_string())
                        }
                    }
                    Err(e) if e.code() == git2::ErrorCode::UnbornBranch => {
                        // Fresh repo with no commits - get default branch name
                        "main".to_string()
                    }
                    Err(e) => return Err(GitError::from(e)),
                };
    
                // Check if working directory is dirty
                // Use fast options - don't recurse into untracked directories deeply
                let mut opts = git2::StatusOptions::new();
                opts.include_untracked(true)
                    .recurse_untracked_dirs(false)
                    .exclude_submodules(true);
    
                let statuses = repo.statuses(Some(&mut opts))?;
                let is_dirty = !statuses.is_empty();
    
                // Extract repo name from path
                let repo_name = path
                    .file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("unknown")
                    .to_string();
    
                Ok(RepoStatus {
                    branch_name,
                    is_dirty,
                    repo_path: path.display().to_string(),
                    repo_name,
                })
            })
            .await
            .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
        }
    
        /// Check if a repository is currently open.
        pub async fn is_open(&self) -> bool {
            self.current_path.lock().await.is_some()
        }
    
        /// Get the current repository path.
        pub async fn get_path(&self) -> Option<PathBuf> {
            self.current_path.lock().await.clone()
        }
    
        /// Close the current repository.
        pub async fn close(&self) {
            let mut current = self.current_path.lock().await;
            *current = None;
        }
    }
    
    impl Default for RepositoryState {
        fn default() -> Self {
            Self::new()
        }
    }
    ```
    
    Key patterns implemented:
    - Store PATH not Repository (thread safety per PITFALLS.md #3)
    - ALL git2 calls wrapped in spawn_blocking (non-blocking per PITFALLS.md #2)
    - Mutex only held briefly for path access, never during git operations
    - Fresh Repository opened per operation
    - camelCase serialization for TypeScript compatibility
  </action>
  <verify>
    `cargo check` in src-tauri/ passes.
    Grep for "spawn_blocking" shows all git2 operations are wrapped.
    No direct git2::Repository stored in Arc<Mutex>.
  </verify>
  <done>
    - RepositoryState with thread-safe path storage
    - RepoStatus struct for frontend consumption (camelCase fields)
    - spawn_blocking wraps ALL git2 calls
    - Branch name detection handles: normal branch, detached HEAD, unborn branch
    - Dirty status uses fast status options
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Tauri Commands for Git Operations</name>
  <files>
    src-tauri/src/git/commands.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    Create src-tauri/src/git/commands.rs with Tauri commands:
    
    ```rust
    use std::path::PathBuf;
    use tauri::State;
    
    use crate::git::error::GitError;
    use crate::git::repository::{RepoStatus, RepositoryState};
    
    /// Open a Git repository at the specified path.
    /// 
    /// Validates the path exists and is a git repository,
    /// then stores it as the current active repository.
    #[tauri::command]
    #[specta::specta]
    pub async fn open_repository(
        path: String,
        state: State<'_, RepositoryState>,
    ) -> Result<RepoStatus, GitError> {
        let path = PathBuf::from(&path);
    
        // Validate path exists
        if !path.exists() {
            return Err(GitError::PathNotFound(path.display().to_string()));
        }
    
        // Open and validate the repository
        state.open(path).await
    }
    
    /// Get the current repository status.
    /// 
    /// Returns branch name and dirty status for the currently open repository.
    #[tauri::command]
    #[specta::specta]
    pub async fn get_repository_status(
        state: State<'_, RepositoryState>,
    ) -> Result<RepoStatus, GitError> {
        state.get_status().await
    }
    
    /// Check if a path is a valid Git repository.
    /// 
    /// Used for drag-drop validation before attempting to open.
    #[tauri::command]
    #[specta::specta]
    pub async fn is_git_repository(path: String) -> Result<bool, GitError> {
        let path = PathBuf::from(path);
    
        if !path.exists() {
            return Ok(false);
        }
    
        tokio::task::spawn_blocking(move || match git2::Repository::open(&path) {
            Ok(_) => Ok(true),
            Err(e) if e.code() == git2::ErrorCode::NotFound => Ok(false),
            Err(_) => Ok(false), // Any other error means it's not a valid repo
        })
        .await
        .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
    }
    
    /// Close the current repository.
    /// 
    /// Clears the stored repository path.
    #[tauri::command]
    #[specta::specta]
    pub async fn close_repository(state: State<'_, RepositoryState>) -> Result<(), GitError> {
        state.close().await;
        Ok(())
    }
    ```
    
    Update src-tauri/src/lib.rs to include git module and register commands:
    
    ```rust
    mod git;
    
    use git::{
        commands::{close_repository, get_repository_status, is_git_repository, open_repository},
        RepositoryState,
    };
    use specta_typescript::Typescript;
    use tauri_specta::{collect_commands, Builder};
    
    #[tauri::command]
    #[specta::specta]
    async fn greet(name: String) -> String {
        format!("Hello, {}! Welcome to FlowForge.", name)
    }
    
    #[cfg_attr(mobile, tauri::mobile_entry_point)]
    pub fn run() {
        let builder = Builder::<tauri::Wry>::new().commands(collect_commands![
            greet,
            open_repository,
            get_repository_status,
            is_git_repository,
            close_repository,
        ]);
    
        #[cfg(debug_assertions)]
        builder
            .export(Typescript::default(), "../src/bindings.ts")
            .expect("Failed to export TypeScript bindings");
    
        tauri::Builder::default()
            .plugin(tauri_plugin_opener::init())
            .plugin(tauri_plugin_dialog::init())
            .plugin(tauri_plugin_store::Builder::new().build())
            .plugin(tauri_plugin_window_state::Builder::new().build())
            .manage(RepositoryState::new())
            .invoke_handler(builder.invoke_handler())
            .setup(move |app| {
                builder.mount_events(app);
    
                // Show window after setup to prevent flash
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.show();
                }
    
                Ok(())
            })
            .run(tauri::generate_context!())
            .expect("error while running tauri application");
    }
    ```
    
    Build to regenerate bindings:
    ```bash
    cd src-tauri && cargo build
    ```
    
    Verify src/bindings.ts contains:
    - `openRepository(path: string): Promise<RepoStatus>`
    - `getRepositoryStatus(): Promise<RepoStatus>`
    - `isGitRepository(path: string): Promise<boolean>`
    - `closeRepository(): Promise<void>`
    - `RepoStatus` interface with camelCase fields
    - `GitError` type
  </action>
  <verify>
    `cargo build` in src-tauri/ succeeds.
    src/bindings.ts contains all four git command functions.
    src/bindings.ts contains RepoStatus type with branchName, isDirty, repoPath, repoName.
    src/bindings.ts contains GitError discriminated union type.
  </verify>
  <done>
    - Four git commands exposed via Tauri IPC
    - TypeScript bindings generated with full types
    - RepositoryState managed as Tauri state
    - Commands ready for frontend integration
    - All commands use async/spawn_blocking pattern
  </done>
</task>

</tasks>

<verification>
1. `cargo check` in src-tauri/ passes without warnings
2. `cargo build` in src-tauri/ succeeds
3. src/bindings.ts contains:
   - `openRepository` function
   - `getRepositoryStatus` function
   - `isGitRepository` function
   - `closeRepository` function
   - `RepoStatus` type with camelCase fields
   - `GitError` discriminated union type
4. Grep for "spawn_blocking" in src-tauri/src/git/ shows all git2 calls wrapped
5. No git2::Repository stored directly in shared state (only PathBuf)
6. `cargo clippy` passes without warnings
</verification>

<success_criteria>
- Git module compiles with git2 integration
- All git2 operations use spawn_blocking (UI never blocks)
- Repository state uses path storage pattern (thread-safe)
- Errors serialize correctly to frontend as discriminated union
- TypeScript bindings include all types with correct casing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
