---
phase: 50-hunk-line-staging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/diff.rs
  - src-tauri/src/git/staging.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/lib.rs
  - src/bindings.ts
autonomous: true

must_haves:
  truths:
    - "Rust backend can return per-line diff detail for a file via get_file_diff_hunks command"
    - "Rust backend can stage specific hunks of a file via stage_hunks command"
    - "Rust backend can unstage specific hunks of a file via unstage_hunks command"
    - "Rust backend can stage specific lines of a file via stage_lines command"
    - "Rust backend can unstage specific lines of a file via unstage_lines command"
    - "All five new commands are registered in lib.rs and bindings are generated"
  artifacts:
    - path: "src-tauri/src/git/diff.rs"
      provides: "DiffLine, DiffLineOrigin, DiffHunkDetail types and get_file_diff_hunks command"
      contains: "get_file_diff_hunks"
    - path: "src-tauri/src/git/staging.rs"
      provides: "stage_hunks, unstage_hunks, stage_lines, unstage_lines commands and LineRange type"
      contains: "stage_hunks"
    - path: "src-tauri/src/git/error.rs"
      provides: "HunkIndexOutOfRange, LineRangeInvalid, BinaryPartialStaging error variants"
      contains: "HunkIndexOutOfRange"
    - path: "src-tauri/src/lib.rs"
      provides: "All 5 new commands registered in collect_commands!"
      contains: "stage_hunks"
  key_links:
    - from: "src-tauri/src/git/staging.rs"
      to: "src-tauri/src/git/diff.rs"
      via: "staging commands use diff types (DiffHunkDetail, DiffLine)"
      pattern: "use crate::git::diff"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/git/staging.rs"
      via: "command registration imports"
      pattern: "stage_hunks.*unstage_hunks.*stage_lines.*unstage_lines"
---

<objective>
Implement all Rust backend commands for hunk and line staging, including enhanced diff types with per-line detail, partial staging operations via git2 index manipulation, and comprehensive error handling.

Purpose: Provide the complete backend API that the frontend will consume for interactive hunk and line staging in the diff viewer.
Output: Five new Tauri commands (get_file_diff_hunks, stage_hunks, unstage_hunks, stage_lines, unstage_lines), new diff types (DiffHunkDetail, DiffLine, DiffLineOrigin, LineRange), new error variants, and updated bindings.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-hunk-line-staging/50-RESEARCH.md
@.planning/phases/50-hunk-line-staging/50-DEV-RESEARCH.md

# Key source files
@src-tauri/src/git/diff.rs
@src-tauri/src/git/staging.rs
@src-tauri/src/git/error.rs
@src-tauri/src/lib.rs
@src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add enhanced diff types and get_file_diff_hunks command</name>
  <files>
    src-tauri/src/git/diff.rs
    src-tauri/src/git/error.rs
  </files>
  <action>
In `diff.rs`, add the following new types ABOVE the existing `DiffHunk` struct:

```rust
/// Origin type of a diff line.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub enum DiffLineOrigin {
    Context,
    Addition,
    Deletion,
}

/// A single line in a diff hunk with origin and line numbers.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct DiffLine {
    pub origin: DiffLineOrigin,
    pub old_lineno: Option<u32>,
    pub new_lineno: Option<u32>,
    pub content: String,
}

/// Enhanced diff hunk with per-line detail for interactive staging.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct DiffHunkDetail {
    pub index: u32,
    pub old_start: u32,
    pub old_lines: u32,
    pub new_start: u32,
    pub new_lines: u32,
    pub header: String,
    pub lines: Vec<DiffLine>,
}
```

Extract a shared helper function `extract_hunks_from_diff` that consolidates the duplicated `diff.foreach()` hunk-extraction logic from `get_staged_diff` and `get_unstaged_diff`. The helper should accept `&git2::Diff` and `include_lines: bool` and return `Result<(Vec<DiffHunk>, Vec<DiffHunkDetail>, bool), GitError>`. When `include_lines` is false, return empty DiffHunkDetail vec (backward compat). When true, populate DiffHunkDetail with per-line data using the line callback of `diff.foreach()`. Map line origins: `'+'` -> Addition, `'-'` -> Deletion, `' '` and others -> Context.

Refactor `get_staged_diff` and `get_unstaged_diff` to use this helper with `include_lines: false` (no change to existing behavior).

Add a new Tauri command `get_file_diff_hunks`:
```rust
#[tauri::command]
#[specta::specta]
pub async fn get_file_diff_hunks(
    path: String,
    staged: bool,
    state: State<'_, RepositoryState>,
) -> Result<Vec<DiffHunkDetail>, GitError>
```
This command generates the diff for the specified file (staged or unstaged) and uses `extract_hunks_from_diff` with `include_lines: true` to return per-line detail. Use the same `get_path/spawn_blocking/Repository::open` pattern as `get_file_diff`. For binary files, return an empty vec.

In `error.rs`, add three new error variants to `GitError`:
```rust
#[error("Hunk index {0} out of range")]
HunkIndexOutOfRange(u32),

#[error("Line range invalid: {0}")]
LineRangeInvalid(String),

#[error("Cannot partially stage a binary file")]
BinaryPartialStaging,
```
  </action>
  <verify>
Run `cargo check --manifest-path src-tauri/Cargo.toml` to verify compilation. Run `cargo test --manifest-path src-tauri/Cargo.toml` to verify existing tests still pass.
  </verify>
  <done>
New types DiffLineOrigin, DiffLine, DiffHunkDetail exist in diff.rs. The get_file_diff_hunks command compiles and returns Vec&lt;DiffHunkDetail&gt;. The extract_hunks_from_diff helper is used by both existing diff functions and the new command. Three new error variants exist in error.rs. Existing get_file_diff behavior is unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement hunk and line staging commands with tests</name>
  <files>
    src-tauri/src/git/staging.rs
    src-tauri/src/lib.rs
    src/bindings.ts
  </files>
  <action>
In `staging.rs`, add the `LineRange` type:
```rust
/// A contiguous range of lines for partial staging operations.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct LineRange {
    pub start: u32,  // 1-based line number in the modified/new side
    pub end: u32,    // inclusive
}
```

Implement four new Tauri commands following the existing `stage_file`/`unstage_file` pattern (State access, get_path, spawn_blocking, Repository::open):

**1. `stage_hunks(path: String, hunk_indices: Vec<u32>, state: State<RepositoryState>) -> Result<(), GitError>`**
- Validate: if `hunk_indices` is empty, return Ok(()) immediately (no-op).
- Generate diff: `repo.diff_index_to_workdir(None, Some(&mut diff_opts))` with pathspec for the file.
- Check binary: if binary, return `GitError::BinaryPartialStaging`.
- Use `Repository::apply()` with `ApplyLocation::Index` and `ApplyOptions` with `hunk_callback` that returns true only for hunks whose 0-based index is in `hunk_indices`. Track the current hunk index with a counter incremented in the callback. Validate that no index in `hunk_indices` exceeds the total hunk count; if so, return `GitError::HunkIndexOutOfRange`.

**2. `unstage_hunks(path: String, hunk_indices: Vec<u32>, state: State<RepositoryState>) -> Result<(), GitError>`**
- Validate: empty indices -> no-op.
- For unstaging, we need to reverse-apply the staged hunks. Strategy:
  - Get HEAD tree (handle UnbornBranch: if unborn, the "HEAD content" is empty).
  - Read the current index content for the file via `index.get_path(path)` -> `repo.find_blob()`.
  - Read the HEAD content for the file via tree entry -> blob (empty if unborn or file doesn't exist in HEAD).
  - Generate diff HEAD -> index: `repo.diff_tree_to_index(Some(&head_tree), None, Some(&mut diff_opts))`.
  - Iterate hunks via `diff.foreach()`. For each hunk NOT in `hunk_indices`, apply it (keep it staged). For each hunk IN `hunk_indices`, revert it (use HEAD content for that region).
  - Build the resulting content manually by starting with HEAD content and applying only the hunks that should remain staged.
  - Write result via `index.add_frombuffer(&entry, result_content.as_bytes())` and `index.write()`.
  - If ALL hunks are being unstaged and the file existed in HEAD, use `repo.reset_default(None, &[&path])` instead for simplicity.
  - If ALL hunks are being unstaged and the file is NEW (not in HEAD), use `index.remove_path()` and `index.write()`.

**3. `stage_lines(path: String, hunk_index: u32, line_ranges: Vec<LineRange>, state: State<RepositoryState>) -> Result<(), GitError>`**
- Line staging operates within a single hunk. Uses `Index::add_frombuffer()` approach:
  - Read current index content for the file (base).
  - Read workdir content for the file.
  - Generate the diff (index->workdir) and extract all hunks with lines.
  - Validate `hunk_index` is in range.
  - Build new content: start with index content lines. For the target hunk, selectively apply lines:
    - Context lines: always keep
    - Addition lines: include only if their new_lineno falls within any `line_ranges`
    - Deletion lines: remove from output only if their old_lineno falls within any `line_ranges`
  - Write result with `index.add_frombuffer()` and `index.write()`.

**4. `unstage_lines(path: String, hunk_index: u32, line_ranges: Vec<LineRange>, state: State<RepositoryState>) -> Result<(), GitError>`**
- Reverse of stage_lines: reads HEAD content as base, reads index content as source.
  - Generate diff HEAD -> index.
  - For the target hunk, selectively revert lines in the `line_ranges` back to HEAD state.
  - Write result with `index.add_frombuffer()` and `index.write()`.

In `lib.rs`:
- Add imports: `use git::staging::{stage_hunks, unstage_hunks, stage_lines, unstage_lines, LineRange};` and `use git::diff::get_file_diff_hunks;`
- Add all 5 new commands to `collect_commands![]`:
  ```
  // Hunk/line staging commands
  stage_hunks,
  unstage_hunks,
  stage_lines,
  unstage_lines,
  // Detailed diff command
  get_file_diff_hunks,
  ```

After `lib.rs` changes, run `cargo build --manifest-path src-tauri/Cargo.toml` in dev mode to auto-generate updated `src/bindings.ts` via tauri-specta. The generated bindings will include TypeScript types for LineRange, DiffLineOrigin, DiffLine, DiffHunkDetail, and function wrappers for all 5 new commands. NOTE: The pre-existing TS2440 error in bindings.ts is a known issue -- ignore it.

Add unit tests in `staging.rs` using `tempfile::TempDir` and `git2::Repository::init()`:
- `test_stage_single_hunk`: Create a file with 2+ hunks of changes, stage only hunk 0, verify hunk 0's changes appear in the index while hunk 1's do not.
- `test_stage_hunk_empty_indices_noop`: Pass empty vec, verify no index changes.
- `test_stage_hunk_out_of_range`: Pass an out-of-range hunk index, verify HunkIndexOutOfRange error.
- `test_unstage_hunk_reverts`: Stage a file fully, then unstage one hunk, verify that hunk's changes are removed from the index.
- `test_binary_file_returns_error`: Create a binary file change, attempt stage_hunks, verify BinaryPartialStaging error.

Use `tempfile` crate (already in Cargo.toml as a dev-dependency, or add it if missing) for test repos. Each test creates a fresh repo, makes an initial commit, modifies the file to create hunks, then tests the staging commands synchronously (call the inner blocking logic directly, not the async wrapper).
  </action>
  <verify>
Run `cargo check --manifest-path src-tauri/Cargo.toml` to verify compilation. Run `cargo test --manifest-path src-tauri/Cargo.toml` to verify all tests pass (both existing and new). Run `npx tsc --noEmit` from the project root to verify TypeScript bindings compile (ignore the pre-existing TS2440 error).
  </verify>
  <done>
Four new staging commands (stage_hunks, unstage_hunks, stage_lines, unstage_lines) and LineRange type exist in staging.rs. All 5 new commands are registered in lib.rs. TypeScript bindings are auto-generated. At least 5 Rust unit tests pass covering hunk staging, edge cases, and error conditions. The staging commands correctly manipulate the git index for partial file staging.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --manifest-path src-tauri/Cargo.toml` passes
2. `cargo test --manifest-path src-tauri/Cargo.toml` passes (all existing + new tests)
3. `npx tsc --noEmit` passes (ignoring pre-existing TS2440)
4. bindings.ts contains: stageHunks, unstageHunks, stageLines, unstageLines, getFileDiffHunks functions
5. bindings.ts contains: LineRange, DiffLineOrigin, DiffLine, DiffHunkDetail types
</verification>

<success_criteria>
- Five new Tauri commands compile and are registered
- Hunk staging correctly applies selected hunks to the git index
- Hunk unstaging correctly reverts selected hunks from the git index
- Line staging correctly applies selected lines within a hunk to the git index
- Line unstaging correctly reverts selected lines within a hunk from the git index
- Binary files are rejected with appropriate error
- Out-of-range indices are rejected with appropriate error
- Empty indices/ranges are no-ops
- TypeScript bindings are auto-generated with correct types
- At least 5 Rust unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/50-hunk-line-staging/50-01-SUMMARY.md`
</output>
