---
phase: 50-hunk-line-staging
plan: 03
type: execute
wave: 2
depends_on: ["50-01"]
files_modified:
  - src/core/blades/diff/components/StagingDiffEditor.tsx
  - src/core/blades/diff/hooks/useHunkStaging.ts
  - src/core/blades/diff/hooks/useLineStaging.ts
  - src/core/blades/staging-changes/components/FileItem.tsx
  - src/core/blades/staging-changes/components/StagingPanel.tsx
  - src/index.css
autonomous: true

must_haves:
  truths:
    - "User can select individual lines in the diff viewer via glyph margin click"
    - "User can select a range of lines via Shift+click on glyph margin"
    - "User can stage or unstage selected lines via keyboard shortcut Ctrl+Shift+S / Ctrl+Shift+U"
    - "Line selection is cleared after a successful staging operation"
    - "Partially staged files show a yellow half-filled indicator in the staging panel"
    - "Keyboard shortcuts ] and [ navigate between hunks in the diff viewer"
  artifacts:
    - path: "src/core/blades/diff/hooks/useLineStaging.ts"
      provides: "Hook for line selection state and line staging mutations"
      exports: ["useLineStaging"]
    - path: "src/core/blades/staging-changes/components/FileItem.tsx"
      provides: "Partial staging tri-state indicator on file items"
      contains: "CircleDot"
  key_links:
    - from: "src/core/blades/diff/components/StagingDiffEditor.tsx"
      to: "src/core/blades/diff/hooks/useLineStaging.ts"
      via: "line selection state and staging mutations"
      pattern: "useLineStaging"
    - from: "src/core/blades/diff/hooks/useLineStaging.ts"
      to: "src/bindings.ts"
      via: "calls stageLines/unstageLines Tauri commands"
      pattern: "commands\\.stageLines|commands\\.unstageLines"
    - from: "src/core/blades/staging-changes/components/FileItem.tsx"
      to: "src/core/blades/staging-changes/components/StagingPanel.tsx"
      via: "partial staging state passed from panel to file items"
      pattern: "isPartiallyStaged"
---

<objective>
Implement line-level staging UI with glyph margin selection, keyboard shortcuts for hunk navigation and line staging, partial-stage indicator in the file list, and visual polish.

Purpose: Complete the DIFF-03 requirement for line-level staging controls with keyboard shortcut support, and provide at-a-glance partial staging visibility in the staging panel.
Output: useLineStaging hook, line selection decorations, keyboard shortcuts, partial-stage file indicator, and CSS for line selection states.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-hunk-line-staging/50-RESEARCH.md
@.planning/phases/50-hunk-line-staging/50-UX-RESEARCH.md
@.planning/phases/50-hunk-line-staging/50-02-SUMMARY.md

# Key source files (read fresh, may have been modified by Plan 02)
@src/core/blades/diff/components/StagingDiffEditor.tsx
@src/core/blades/diff/hooks/useHunkStaging.ts
@src/core/blades/diff/DiffBlade.tsx
@src/core/blades/diff/lib/diffUtils.ts
@src/core/blades/staging-changes/components/FileItem.tsx
@src/core/blades/staging-changes/components/StagingPanel.tsx
@src/core/blades/staging-changes/StagingChangesBlade.tsx
@src/index.css
@src/bindings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add line selection and staging to StagingDiffEditor</name>
  <files>
    src/core/blades/diff/hooks/useLineStaging.ts
    src/core/blades/diff/components/StagingDiffEditor.tsx
    src/core/blades/diff/DiffBlade.tsx
    src/index.css
  </files>
  <action>
**Create `src/core/blades/diff/hooks/useLineStaging.ts`:**

A hook managing line selection state and line staging mutations:

```typescript
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useState, useCallback, useRef } from "react";
import { commands } from "../../../../bindings";
import type { DiffHunkDetail } from "../../../../bindings";
import { findHunkForLine, linesToRanges } from "../lib/diffUtils";

interface UseLineStagingOptions {
  filePath: string;
  staged: boolean;
  hunks: DiffHunkDetail[];
}

export function useLineStaging({ filePath, staged, hunks }: UseLineStagingOptions) {
  const queryClient = useQueryClient();
  const [selectedLines, setSelectedLines] = useState<Set<number>>(new Set());
  const lastClickedLine = useRef<number | null>(null);

  const invalidateAll = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: ["stagingStatus"] });
    queryClient.invalidateQueries({ queryKey: ["fileDiff", filePath] });
    queryClient.invalidateQueries({ queryKey: ["fileDiffHunks", filePath] });
  }, [queryClient, filePath]);

  // Toggle a single line
  const toggleLine = useCallback((lineNumber: number) => {
    setSelectedLines(prev => {
      const next = new Set(prev);
      if (next.has(lineNumber)) next.delete(lineNumber);
      else next.add(lineNumber);
      return next;
    });
    lastClickedLine.current = lineNumber;
  }, []);

  // Select a range of lines (for shift-click)
  const selectRange = useCallback((toLine: number) => {
    const fromLine = lastClickedLine.current ?? toLine;
    const start = Math.min(fromLine, toLine);
    const end = Math.max(fromLine, toLine);
    setSelectedLines(prev => {
      const next = new Set(prev);
      for (let i = start; i <= end; i++) next.add(i);
      return next;
    });
    lastClickedLine.current = toLine;
  }, []);

  const clearSelection = useCallback(() => {
    setSelectedLines(new Set());
    lastClickedLine.current = null;
  }, []);

  // Stage selected lines mutation
  const stageLinesMutation = useMutation({
    mutationFn: () => {
      // Group selected lines by hunk
      const hunkIndex = findHunkForLineFromSelection(selectedLines, hunks);
      if (hunkIndex < 0) return Promise.reject(new Error("No hunk found for selection"));
      const ranges = linesToRanges(selectedLines);
      return commands.stageLines(filePath, hunkIndex, ranges);
    },
    onSuccess: () => {
      clearSelection();
      invalidateAll();
    },
  });

  // Unstage selected lines mutation
  const unstageLinesMutation = useMutation({
    mutationFn: () => {
      const hunkIndex = findHunkForLineFromSelection(selectedLines, hunks);
      if (hunkIndex < 0) return Promise.reject(new Error("No hunk found for selection"));
      const ranges = linesToRanges(selectedLines);
      return commands.unstageLines(filePath, hunkIndex, ranges);
    },
    onSuccess: () => {
      clearSelection();
      invalidateAll();
    },
  });

  const stageSelectedLines = useCallback(() => {
    if (selectedLines.size === 0) return;
    if (staged) unstageLinesMutation.mutate();
    else stageLinesMutation.mutate();
  }, [selectedLines, staged, stageLinesMutation, unstageLinesMutation]);

  const isLineStagingPending =
    stageLinesMutation.isPending || unstageLinesMutation.isPending;

  return {
    selectedLines,
    toggleLine,
    selectRange,
    clearSelection,
    stageSelectedLines,
    isLineStagingPending,
    hasSelection: selectedLines.size > 0,
  };
}

// Helper to find the hunk containing the majority of selected lines
function findHunkForLineFromSelection(
  selectedLines: Set<number>,
  hunks: DiffHunkDetail[]
): number {
  if (selectedLines.size === 0) return -1;
  const firstLine = Math.min(...selectedLines);
  return hunks.findIndex(h =>
    firstLine >= h.newStart && firstLine < h.newStart + h.newLines
  );
}
```

**Enhance `StagingDiffEditor.tsx`:**

Add line selection functionality on top of the existing hunk staging:

1. Accept new props from useLineStaging:
   ```typescript
   lineSelection?: {
     selectedLines: Set<number>;
     toggleLine: (lineNumber: number) => void;
     selectRange: (toLine: number) => void;
     clearSelection: () => void;
     stageSelectedLines: () => void;
     isLineStagingPending: boolean;
     hasSelection: boolean;
   };
   ```

2. Add line selection decorations: when `lineSelection.selectedLines` has entries, create decorations using `createDecorationsCollection()`:
   ```typescript
   const lineDecorations = Array.from(selectedLines).map(line => ({
     range: new monaco.Range(line, 1, line, 1),
     options: {
       isWholeLine: true,
       className: 'line-selected-for-staging',
       glyphMarginClassName: 'line-stage-selected',
     },
   }));
   ```

3. Add glyph margin decorations for all changed lines (additions/deletions) showing them as selectable:
   - For each hunk in the detailed hunk data, for each line that is an addition or deletion, add a glyph decoration with class `line-stage-checkbox`.
   - When a line is in `selectedLines`, use class `line-stage-checkbox-checked` instead.

4. Enhance the existing `mousedown` handler:
   - If click is on glyph margin AND the clicked line has a `line-stage-checkbox` decoration:
     - If Shift key is held: call `selectRange(lineNumber)` for range selection
     - Otherwise: call `toggleLine(lineNumber)` for toggle selection
   - If click is on glyph margin AND the clicked line has a `hunk-stage-glyph` decoration (hunk first line): existing hunk toggle behavior

5. Add keyboard event listeners on the modified editor:
   - `[` key: navigate to previous hunk (scroll to `hunks[currentIdx - 1].newStart`)
   - `]` key: navigate to next hunk (scroll to `hunks[currentIdx + 1].newStart`)
   - `Ctrl+Shift+S` / `Cmd+Shift+S`: stage selected lines (or stage hunk at cursor if no lines selected)
   - `Ctrl+Shift+U` / `Cmd+Shift+U`: unstage selected lines (or unstage hunk at cursor)
   - `Escape`: clear line selection

   Use the editor's `addCommand` or `onKeyDown` API for keyboard handling. Be careful not to conflict with Monaco's built-in shortcuts. Register via `editor.addAction()` for actions that should appear in the command palette context menu.

6. When `lineSelection.hasSelection` is true, update the ViewZone action bar for the hunk containing the selection to change its button label from "Stage Hunk" to "Stage N Lines" (where N is the count of selected lines in that hunk). This is the Tower/Sublime Merge dynamic label pattern.

7. When lines are selected, show a floating line count indicator near the selection: render a small DOM element via `editor.addContentWidget()` or a ViewZone showing "N lines selected - Stage (Ctrl+Shift+S)".

**Enhance `DiffBlade.tsx`:**

When in staging mode, also call `useLineStaging` alongside `useHunkStaging`. Pass the lineSelection props to StagingDiffEditor via DiffContent's `stagingSource`. Update the `stagingSource` type to include the line selection props.

**Add CSS to `src/index.css`:**

```css
/* Line selection indicators */
.line-stage-checkbox {
  cursor: pointer;
}
.line-stage-checkbox::before {
  content: '';
  display: block;
  width: 12px;
  height: 12px;
  border: 1.5px solid var(--ctp-overlay1, #7f849c);
  border-radius: 2px;
  margin: 2px;
}
.line-stage-checkbox:hover::before {
  border-color: var(--ctp-blue, #89b4fa);
  background: rgb(137 180 250 / 0.1);
}

.line-stage-checkbox-checked::before {
  content: '';
  display: block;
  width: 12px;
  height: 12px;
  border: 1.5px solid var(--ctp-blue, #89b4fa);
  border-radius: 2px;
  margin: 2px;
  background: var(--ctp-blue, #89b4fa);
}

.line-stage-selected {
  cursor: pointer;
}
.line-stage-selected::before {
  content: '';
  display: block;
  width: 12px;
  height: 12px;
  border: 1.5px solid var(--ctp-blue, #89b4fa);
  border-radius: 2px;
  margin: 2px;
  background: var(--ctp-blue, #89b4fa);
}

/* Selected line highlight */
.line-selected-for-staging {
  background: rgb(137 180 250 / 0.1) !important;
}
```

Verify the CSS variable names match the project's Catppuccin CSS variable convention.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation. Run `npx vitest run --reporter=verbose` to verify existing tests still pass.
  </verify>
  <done>
useLineStaging hook manages line selection state with toggle, range select, and clear. StagingDiffEditor renders glyph margin checkboxes for changed lines, highlights selected lines, and supports shift-click range selection. Keyboard shortcuts ]/[ navigate hunks, Ctrl+Shift+S stages, Ctrl+Shift+U unstages, Escape clears selection. Line selection clears after successful staging. Dynamic hunk button label changes to "Stage N Lines" when lines are selected. CSS classes provide visual feedback for line selection states.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add partial-stage indicator and tests</name>
  <files>
    src/core/blades/staging-changes/components/FileItem.tsx
    src/core/blades/staging-changes/components/StagingPanel.tsx
  </files>
  <action>
**Enhance `src/core/blades/staging-changes/components/FileItem.tsx`:**

Add a tri-state partial staging indicator. A file is "partially staged" when it appears in BOTH the staged and unstaged sections of the StagingStatus. The StagingPanel already has access to the full StagingStatus -- it needs to pass a `isPartiallyStaged` prop to FileItem.

1. Add a new optional prop to FileItem:
   ```typescript
   isPartiallyStaged?: boolean;
   ```

2. When `isPartiallyStaged` is true, render a yellow half-filled circle indicator next to the file icon (in addition to the existing status dot). Use the `CircleDot` icon from lucide-react (which looks like a circle with a dot inside -- a reasonable approximation of half-filled) or create a custom SVG:
   ```tsx
   {isPartiallyStaged && (
     <span
       className="absolute -top-0.5 -left-0.5 w-2.5 h-2.5"
       title="Partially staged"
     >
       <svg viewBox="0 0 10 10" className="w-full h-full">
         <circle cx="5" cy="5" r="4" fill="none" stroke="currentColor" strokeWidth="1.5" className="text-ctp-yellow" />
         <path d="M5 1 A4 4 0 0 1 5 9" fill="currentColor" className="text-ctp-yellow" />
       </svg>
     </span>
   )}
   ```
   The SVG creates a half-filled circle: left half filled (yellow), right half empty outline (yellow). This matches the Fork/Tower pattern from the UX research.

3. Add `aria-label` to the indicator: "File is partially staged".

**Enhance `src/core/blades/staging-changes/components/StagingPanel.tsx`:**

1. Compute the set of partially staged file paths by finding files that appear in BOTH `staged` and `unstaged` arrays of the StagingStatus:
   ```typescript
   const partiallyStaged = useMemo(() => {
     if (!stagingData) return new Set<string>();
     const stagedPaths = new Set(stagingData.staged.map(f => f.path));
     const unstagedPaths = new Set(stagingData.unstaged.map(f => f.path));
     return new Set([...stagedPaths].filter(p => unstagedPaths.has(p)));
   }, [stagingData]);
   ```

2. Pass `isPartiallyStaged={partiallyStaged.has(file.path)}` to each `FileItem` component rendered in both the staged and unstaged sections.

3. This requires reading the current file list rendering pattern -- check whether StagingPanel renders FileItem directly or via FileList/FileTreeView. Pass `partiallyStaged` set through to wherever FileItem is rendered.

**Accessibility and screen reader:**

Ensure the aria-live region in StagingDiffEditor (from Plan 02) announces line staging actions: "Staged 3 lines from hunk 2" or "Unstaged hunk 1, lines 10 through 25".

**Tests (optional if time permits within context budget):**

Add a test in `StagingChangesBlade.test.tsx` or create `FileItem.test.tsx`:
- When `isPartiallyStaged` is true, the partial indicator SVG/icon renders
- When `isPartiallyStaged` is false, no partial indicator renders
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation. Run `npx vitest run --reporter=verbose` to verify all tests pass.
  </verify>
  <done>
FileItem shows a yellow half-filled circle indicator for partially staged files. StagingPanel computes partially staged file paths and passes the flag to FileItem. The indicator has appropriate aria-label for accessibility. The indicator appears in both the Staged and Unstaged sections when a file is partially staged.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (ignoring pre-existing TS2440)
2. `npx vitest run` passes (all existing + any new tests)
3. Line selection works via glyph margin click and shift-click range
4. Keyboard shortcuts: `]`/`[` navigate hunks, `Ctrl+Shift+S` stages, `Ctrl+Shift+U` unstages, `Escape` clears
5. Line selection clears after successful staging
6. Partially staged files show yellow indicator in staging panel
7. Dynamic button label changes from "Stage Hunk" to "Stage N Lines" when lines selected
</verification>

<success_criteria>
- User can click individual changed lines in the glyph margin to select them
- User can Shift-click to select a range of lines
- User can stage/unstage selected lines via Ctrl+Shift+S / Ctrl+Shift+U
- Keyboard navigation between hunks works with ] and [ keys
- Line selection clears after staging completes
- Partially staged files have a visible tri-state indicator in the file list
- All staging operations immediately reflect in the staging panel
- All keyboard shortcuts are discoverable and do not conflict with existing shortcuts
</success_criteria>

<output>
After completion, create `.planning/phases/50-hunk-line-staging/50-03-SUMMARY.md`
</output>
