---
phase: 03-core-git-branches
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/tag.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Backend can list all tags with their target commit info"
    - "Backend can create an annotated tag with message"
    - "Backend can create a lightweight tag"
    - "Backend can delete a tag"
  artifacts:
    - path: "src-tauri/src/git/tag.rs"
      provides: "Tag operations"
      exports: ["TagInfo", "list_tags", "create_tag", "delete_tag"]
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "tag commands"
      via: "invoke_handler registration"
      pattern: "list_tags|create_tag|delete_tag"
---

<objective>
Create the Rust tag module with operations for listing, creating (annotated and lightweight), and deleting tags.

Purpose: Enable users to create version markers and release points in the repository.

Output: New tag.rs module with 3 Tauri commands exported via tauri-specta.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-git-branches/03-RESEARCH.md

# Existing code to extend
@src-tauri/src/git/mod.rs
@src-tauri/src/git/error.rs
@src-tauri/src/git/repository.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tag.rs with TagInfo struct and list_tags command</name>
  <files>src-tauri/src/git/tag.rs, src-tauri/src/git/mod.rs</files>
  <action>
Create new `src-tauri/src/git/tag.rs` with:

1. **TagInfo struct** (derive Serialize, specta::Type):
   - `name: String` - tag name (e.g., "v1.0.0")
   - `oid: String` - OID of the tag object (for annotated) or target commit (for lightweight)
   - `target_oid: String` - OID of the commit the tag points to
   - `message: Option<String>` - tag message (None for lightweight tags)
   - `tagger: Option<String>` - tagger name (None for lightweight tags)
   - `is_annotated: bool` - true for annotated tags, false for lightweight

2. **list_tags command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn list_tags(state: State<'_, RepositoryState>) -> Result<Vec<TagInfo>, GitError>
```
- Use `repo.tag_names(None)?` to get all tag names (None = no filter pattern)
- For each tag name:
  - Find reference with `repo.find_reference(&format!("refs/tags/{}", name))?`
  - Try to peel to tag object (annotated) or directly to commit (lightweight)
  - If peels to Tag: extract message, tagger, set is_annotated=true
  - If peels directly to Commit: lightweight, message=None, is_annotated=false
  - Get target_oid by peeling to commit
- Wrap in spawn_blocking

3. **Update mod.rs**:
- Add `pub mod tag;`
- Add `pub use tag::TagInfo;`
  </action>
  <verify>
`cargo check -p git-ai` compiles without errors.
  </verify>
  <done>
list_tags returns all tags with full metadata distinguishing annotated from lightweight tags.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add create_tag and delete_tag commands</name>
  <files>src-tauri/src/git/tag.rs, src-tauri/src/git/error.rs</files>
  <action>
1. **Extend GitError** in error.rs:
   - Add `TagAlreadyExists(String)` - tag name already exists
   - Add `TagNotFound(String)` - tag doesn't exist
   - Add `InvalidTagName(String)` - tag name validation failed

2. **create_tag command** in tag.rs:
```rust
#[tauri::command]
#[specta::specta]
pub async fn create_tag(
    name: String,
    message: Option<String>,
    target_oid: Option<String>,  // None = tag HEAD
    state: State<'_, RepositoryState>,
) -> Result<TagInfo, GitError>
```
- Determine target: if target_oid provided, find that commit; else use HEAD
- Get target object: `repo.find_object(oid, None)?` or `repo.head()?.peel(ObjectType::Commit)?`
- If message is Some (annotated tag):
  - Get signature with `repo.signature()?`
  - Call `repo.tag(&name, &target, &signature, &message, false)?`
- If message is None (lightweight tag):
  - Call `repo.tag_lightweight(&name, &target, false)?`
- Return TagInfo for the new tag
- Wrap in spawn_blocking

3. **delete_tag command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn delete_tag(
    name: String,
    state: State<'_, RepositoryState>,
) -> Result<(), GitError>
```
- Find tag reference: `repo.find_reference(&format!("refs/tags/{}", name))?`
- Delete with `reference.delete()?`
- Wrap in spawn_blocking
  </action>
  <verify>
`cargo check -p git-ai` compiles without errors.
  </verify>
  <done>
create_tag creates annotated (with message) or lightweight (without message) tags. delete_tag removes tags by name.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register tag commands in lib.rs</name>
  <files>src-tauri/src/lib.rs</files>
  <action>
Register all 3 tag commands in lib.rs:

1. **Add to specta builder**:
```rust
.commands(tauri_specta::collect_commands![
    // ... existing commands ...
    git::tag::list_tags,
    git::tag::create_tag,
    git::tag::delete_tag,
])
```

2. **Add to invoke_handler**:
```rust
.invoke_handler(tauri::generate_handler![
    // ... existing commands ...
    git::tag::list_tags,
    git::tag::create_tag,
    git::tag::delete_tag,
])
```

Follow the exact pattern used for other git module commands.
  </action>
  <verify>
`cargo check -p git-ai` compiles. `npm run tauri dev` starts and tag commands appear in bindings.ts.
  </verify>
  <done>
All 3 tag commands registered and available via IPC. bindings.ts includes listTags, createTag, deleteTag functions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p git-ai` - no compilation errors
2. `npm run tauri dev` - app starts successfully
3. Check `src/bindings.ts` includes: `listTags`, `createTag`, `deleteTag`
4. Check types include: `TagInfo` with all expected fields
</verification>

<success_criteria>
- 3 new Tauri commands available: listTags, createTag, deleteTag
- TagInfo type includes name, oid, target_oid, message (optional), tagger (optional), is_annotated
- create_tag creates annotated tag when message provided, lightweight when not
- create_tag can target specific commit or defaults to HEAD
- delete_tag removes tag by name
- list_tags correctly distinguishes annotated vs lightweight tags
- All git2 calls wrapped in spawn_blocking
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-git-branches/03-03-SUMMARY.md`
</output>
