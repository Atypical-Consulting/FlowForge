---
phase: 03-core-git-branches
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/stash.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Backend can save current changes to stash with optional message"
    - "Backend can list all stash entries with index, message, and OID"
    - "Backend can apply or pop a stash by index"
    - "Backend can drop a stash by index"
  artifacts:
    - path: "src-tauri/src/git/stash.rs"
      provides: "Stash operations"
      exports: ["StashEntry", "stash_save", "list_stashes", "stash_apply", "stash_pop", "stash_drop"]
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "stash commands"
      via: "invoke_handler registration"
      pattern: "stash_save|list_stashes|stash_apply|stash_pop|stash_drop"
---

<objective>
Create the Rust stash module with operations for saving, listing, applying, popping, and dropping stashes.

Purpose: Enable users to temporarily store changes when switching branches or before risky operations.

Output: New stash.rs module with 5 Tauri commands exported via tauri-specta.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-git-branches/03-RESEARCH.md

# Existing code to extend
@src-tauri/src/git/mod.rs
@src-tauri/src/git/error.rs
@src-tauri/src/git/repository.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stash.rs with StashEntry struct and list/save commands</name>
  <files>src-tauri/src/git/stash.rs, src-tauri/src/git/mod.rs, src-tauri/src/git/error.rs</files>
  <action>
Create new `src-tauri/src/git/stash.rs` with:

1. **StashEntry struct** (derive Serialize, specta::Type):
   - `index: usize` - 0-based index for stash operations (CRITICAL: UI must track this)
   - `message: String` - stash message (e.g., "WIP on main: abc1234 last commit msg")
   - `oid: String` - commit OID of the stash

2. **list_stashes command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn list_stashes(state: State<'_, RepositoryState>) -> Result<Vec<StashEntry>, GitError>
```
- Use `repo.stash_foreach(|index, message, oid| { ... true })?`
- Collect into Vec<StashEntry>
- IMPORTANT: Stash indices are 0-based and used for all stash operations
- Wrap in spawn_blocking

3. **stash_save command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn stash_save(
    message: Option<String>,
    include_untracked: bool,
    state: State<'_, RepositoryState>,
) -> Result<String, GitError>  // Returns OID of stash commit
```
- Get signature with `repo.signature()?`
- Build flags: if `include_untracked`, use `StashFlags::INCLUDE_UNTRACKED`, else `StashFlags::DEFAULT`
- Call `repo.stash_save(&signature, message.as_deref().unwrap_or("WIP"), Some(flags))?`
- Return the OID as string
- Wrap in spawn_blocking

4. **Update mod.rs**:
- Add `pub mod stash;`
- Add `pub use stash::StashEntry;`

5. **Extend GitError** in error.rs:
- Add `StashNotFound(usize)` - stash index doesn't exist
- Add `NothingToStash` - no changes to stash
  </action>
  <verify>
`cargo check -p git-ai` compiles without errors.
  </verify>
  <done>
list_stashes returns all stash entries with indices. stash_save creates a new stash with optional message and untracked file inclusion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add stash_apply, stash_pop, and stash_drop commands</name>
  <files>src-tauri/src/git/stash.rs</files>
  <action>
Add three commands to stash.rs:

1. **stash_apply command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn stash_apply(
    index: usize,
    state: State<'_, RepositoryState>,
) -> Result<(), GitError>
```
- Call `repo.stash_apply(index, None)?` (None = default options)
- Does NOT remove the stash from the list
- Wrap in spawn_blocking

2. **stash_pop command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn stash_pop(
    index: usize,
    state: State<'_, RepositoryState>,
) -> Result<(), GitError>
```
- Call `repo.stash_pop(index, None)?`
- Applies AND removes the stash
- Wrap in spawn_blocking

3. **stash_drop command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn stash_drop(
    index: usize,
    state: State<'_, RepositoryState>,
) -> Result<(), GitError>
```
- Call `repo.stash_drop(index)?`
- Removes stash WITHOUT applying
- Wrap in spawn_blocking

NOTE: All stash operations use 0-based index. After any modification (pop/drop), indices shift - the UI must refresh the stash list after operations.
  </action>
  <verify>
`cargo check -p git-ai` compiles without errors.
  </verify>
  <done>
stash_apply restores changes without removing stash. stash_pop restores and removes. stash_drop removes without applying. All use index-based addressing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register stash commands in lib.rs</name>
  <files>src-tauri/src/lib.rs</files>
  <action>
Register all 5 stash commands in lib.rs:

1. **Add to specta builder**:
```rust
.commands(tauri_specta::collect_commands![
    // ... existing commands ...
    git::stash::list_stashes,
    git::stash::stash_save,
    git::stash::stash_apply,
    git::stash::stash_pop,
    git::stash::stash_drop,
])
```

2. **Add to invoke_handler**:
```rust
.invoke_handler(tauri::generate_handler![
    // ... existing commands ...
    git::stash::list_stashes,
    git::stash::stash_save,
    git::stash::stash_apply,
    git::stash::stash_pop,
    git::stash::stash_drop,
])
```

Follow the exact pattern used for staging and commit commands.
  </action>
  <verify>
`cargo check -p git-ai` compiles. `npm run tauri dev` starts and stash commands appear in bindings.ts.
  </verify>
  <done>
All 5 stash commands registered and available via IPC. bindings.ts includes listStashes, stashSave, stashApply, stashPop, stashDrop functions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p git-ai` - no compilation errors
2. `npm run tauri dev` - app starts successfully
3. Check `src/bindings.ts` includes: `listStashes`, `stashSave`, `stashApply`, `stashPop`, `stashDrop`
4. Check types include: `StashEntry` with index, message, oid fields
</verification>

<success_criteria>
- 5 new Tauri commands available: listStashes, stashSave, stashApply, stashPop, stashDrop
- StashEntry type includes index (usize), message (string), oid (string)
- stash_save supports optional message and include_untracked flag
- stash_apply restores without removing
- stash_pop restores and removes
- stash_drop removes without applying
- All operations use index-based addressing (UI tracks indices from list)
- All git2 calls wrapped in spawn_blocking
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-git-branches/03-02-SUMMARY.md`
</output>
