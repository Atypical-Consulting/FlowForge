---
phase: 03-core-git-branches
plan: 06
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - src/stores/stash.ts
  - src/components/stash/StashList.tsx
  - src/components/stash/StashItem.tsx
  - src/components/stash/StashDialog.tsx
  - src/components/tags/TagList.tsx
  - src/components/tags/TagItem.tsx
  - src/components/tags/CreateTagDialog.tsx
  - src/components/RepositoryView.tsx
autonomous: true

must_haves:
  truths:
    - "User can view list of stashes with message and index"
    - "User can stash current changes with optional message"
    - "User can apply, pop, or drop a stash"
    - "User can view list of tags"
    - "User can create annotated or lightweight tags"
    - "User can delete tags"
  artifacts:
    - path: "src/stores/stash.ts"
      provides: "Stash state management"
      exports: ["useStashStore"]
    - path: "src/components/stash/StashList.tsx"
      provides: "Stash list UI"
    - path: "src/components/tags/TagList.tsx"
      provides: "Tag list UI"
  key_links:
    - from: "src/components/stash/StashList.tsx"
      to: "commands.listStashes"
      via: "store action"
      pattern: "commands\\.listStashes"
    - from: "src/components/RepositoryView.tsx"
      to: "StashList|TagList"
      via: "sidebar integration"
      pattern: "StashList|TagList"
---

<objective>
Create the stash and tag UI components with zustand stores and integrate them into the repository view.

Purpose: Complete the Phase 3 feature set with stash management and tag operations.

Output: Stash store, stash components, tag components, and RepositoryView integration.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-git-branches/03-RESEARCH.md
@.planning/phases/03-core-git-branches/03-02-SUMMARY.md
@.planning/phases/03-core-git-branches/03-03-SUMMARY.md

# Existing patterns to follow
@src/stores/branches.ts
@src/components/branches/BranchList.tsx
@src/components/RepositoryView.tsx
@src/bindings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stash.ts store and StashList/StashItem components</name>
  <files>src/stores/stash.ts, src/components/stash/StashList.tsx, src/components/stash/StashItem.tsx</files>
  <action>
**src/stores/stash.ts**:
```typescript
import { create } from "zustand";
import type { StashEntry } from "../bindings";
import { commands } from "../bindings";

interface StashState {
  stashes: StashEntry[];
  isLoading: boolean;
  error: string | null;

  loadStashes: () => Promise<void>;
  saveStash: (message: string | null, includeUntracked: boolean) => Promise<boolean>;
  applyStash: (index: number) => Promise<boolean>;
  popStash: (index: number) => Promise<boolean>;
  dropStash: (index: number) => Promise<boolean>;
  clearError: () => void;
}

export const useStashStore = create<StashState>((set, get) => ({
  stashes: [],
  isLoading: false,
  error: null,

  loadStashes: async () => {
    set({ isLoading: true, error: null });
    const result = await commands.listStashes();
    if (result.status === "ok") {
      set({ stashes: result.data, isLoading: false });
    } else {
      const errorMsg = "message" in result.error ? result.error.message : result.error.type;
      set({ error: errorMsg, isLoading: false });
    }
  },

  saveStash: async (message, includeUntracked) => {
    set({ isLoading: true, error: null });
    const result = await commands.stashSave(message, includeUntracked);
    if (result.status === "ok") {
      await get().loadStashes();
      return true;
    } else {
      const errorMsg = "message" in result.error ? result.error.message : result.error.type;
      set({ error: errorMsg, isLoading: false });
      return false;
    }
  },

  applyStash: async (index) => {
    set({ isLoading: true, error: null });
    const result = await commands.stashApply(index);
    if (result.status === "ok") {
      set({ isLoading: false });
      return true;
    } else {
      const errorMsg = "message" in result.error ? result.error.message : result.error.type;
      set({ error: errorMsg, isLoading: false });
      return false;
    }
  },

  popStash: async (index) => {
    set({ isLoading: true, error: null });
    const result = await commands.stashPop(index);
    if (result.status === "ok") {
      await get().loadStashes();
      return true;
    } else {
      const errorMsg = "message" in result.error ? result.error.message : result.error.type;
      set({ error: errorMsg, isLoading: false });
      return false;
    }
  },

  dropStash: async (index) => {
    set({ isLoading: true, error: null });
    const result = await commands.stashDrop(index);
    if (result.status === "ok") {
      await get().loadStashes();
      return true;
    } else {
      const errorMsg = "message" in result.error ? result.error.message : result.error.type;
      set({ error: errorMsg, isLoading: false });
      return false;
    }
  },

  clearError: () => set({ error: null }),
}));
```

**src/components/stash/StashItem.tsx**:
```tsx
import { Archive, Play, Trash2, Download } from "lucide-react";
import type { StashEntry } from "../../bindings";

interface StashItemProps {
  stash: StashEntry;
  onApply: () => void;
  onPop: () => void;
  onDrop: () => void;
  disabled?: boolean;
}

export function StashItem({ stash, onApply, onPop, onDrop, disabled }: StashItemProps) {
  return (
    <div className="flex items-center justify-between px-3 py-2 rounded-md hover:bg-gray-800">
      <div className="flex items-center gap-2 min-w-0 flex-1">
        <Archive className="w-4 h-4 shrink-0 text-gray-400" />
        <div className="min-w-0">
          <span className="text-xs text-gray-500">stash@{stash.index}</span>
          <p className="truncate text-sm">{stash.message}</p>
        </div>
      </div>
      <div className="flex items-center gap-1">
        <button
          onClick={onApply}
          disabled={disabled}
          className="p-1.5 hover:bg-gray-700 rounded text-gray-400 hover:text-white"
          title="Apply (keep stash)"
        >
          <Download className="w-4 h-4" />
        </button>
        <button
          onClick={onPop}
          disabled={disabled}
          className="p-1.5 hover:bg-gray-700 rounded text-gray-400 hover:text-green-400"
          title="Pop (apply and remove)"
        >
          <Play className="w-4 h-4" />
        </button>
        <button
          onClick={onDrop}
          disabled={disabled}
          className="p-1.5 hover:bg-gray-700 rounded text-gray-400 hover:text-red-400"
          title="Drop (discard)"
        >
          <Trash2 className="w-4 h-4" />
        </button>
      </div>
    </div>
  );
}
```

**src/components/stash/StashList.tsx**:
```tsx
import { useEffect, useState } from "react";
import { Plus, RefreshCw } from "lucide-react";
import { useStashStore } from "../../stores/stash";
import { StashItem } from "./StashItem";
import { StashDialog } from "./StashDialog";
import { cn } from "../../lib/utils";

export function StashList() {
  const { stashes, isLoading, error, loadStashes, applyStash, popStash, dropStash, clearError } = useStashStore();
  const [showSaveDialog, setShowSaveDialog] = useState(false);

  useEffect(() => {
    loadStashes();
  }, [loadStashes]);

  const handleDrop = async (index: number) => {
    if (window.confirm("Drop this stash? This cannot be undone.")) {
      await dropStash(index);
    }
  };

  return (
    <div className="flex flex-col">
      <div className="flex items-center justify-between p-3 border-b border-gray-800">
        <h2 className="text-sm font-semibold text-gray-300">Stashes</h2>
        <div className="flex gap-1">
          <button
            onClick={() => loadStashes()}
            disabled={isLoading}
            className="p-1.5 hover:bg-gray-800 rounded text-gray-400 hover:text-white"
          >
            <RefreshCw className={cn("w-4 h-4", isLoading && "animate-spin")} />
          </button>
          <button
            onClick={() => setShowSaveDialog(true)}
            className="p-1.5 hover:bg-gray-800 rounded text-gray-400 hover:text-white"
          >
            <Plus className="w-4 h-4" />
          </button>
        </div>
      </div>

      {error && (
        <div className="p-3 bg-red-900/30 text-red-300 text-sm">
          {error}
          <button onClick={clearError} className="ml-2 underline">dismiss</button>
        </div>
      )}

      <div className="p-2 space-y-1">
        {stashes.length === 0 ? (
          <p className="text-gray-500 text-sm p-2">No stashes</p>
        ) : (
          stashes.map((stash) => (
            <StashItem
              key={stash.oid}
              stash={stash}
              onApply={() => applyStash(stash.index)}
              onPop={() => popStash(stash.index)}
              onDrop={() => handleDrop(stash.index)}
              disabled={isLoading}
            />
          ))
        )}
      </div>

      {showSaveDialog && (
        <StashDialog onClose={() => setShowSaveDialog(false)} />
      )}
    </div>
  );
}
```

Import cn from utils.
  </action>
  <verify>
TypeScript compiles without errors.
  </verify>
  <done>
useStashStore manages stash state. StashList shows all stashes. StashItem provides apply/pop/drop actions with appropriate icons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create StashDialog and Tag components</name>
  <files>src/components/stash/StashDialog.tsx, src/components/tags/TagList.tsx, src/components/tags/CreateTagDialog.tsx, src/components/tags/TagItem.tsx</files>
  <action>
**src/components/stash/StashDialog.tsx**:
```tsx
import { useState } from "react";
import { X } from "lucide-react";
import { useStashStore } from "../../stores/stash";

interface StashDialogProps {
  onClose: () => void;
}

export function StashDialog({ onClose }: StashDialogProps) {
  const { saveStash, isLoading, error } = useStashStore();
  const [message, setMessage] = useState("");
  const [includeUntracked, setIncludeUntracked] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const success = await saveStash(message || null, includeUntracked);
    if (success) onClose();
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 border border-gray-700 rounded-lg p-6 w-96">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold">Stash Changes</h3>
          <button onClick={onClose} className="p-1 hover:bg-gray-800 rounded">
            <X className="w-5 h-5" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm text-gray-400 mb-1">Message (optional)</label>
            <input
              type="text"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="WIP: description"
              className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded focus:outline-none focus:border-blue-500"
            />
          </div>

          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={includeUntracked}
              onChange={(e) => setIncludeUntracked(e.target.checked)}
              className="rounded"
            />
            <span>Include untracked files</span>
          </label>

          {error && <p className="text-red-400 text-sm">{error}</p>}

          <div className="flex justify-end gap-2">
            <button type="button" onClick={onClose} className="px-4 py-2 text-sm text-gray-400 hover:text-white">
              Cancel
            </button>
            <button
              type="submit"
              disabled={isLoading}
              className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-700 rounded disabled:opacity-50"
            >
              {isLoading ? "Stashing..." : "Stash"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
```

**src/components/tags/TagItem.tsx**:
```tsx
import { Tag, Trash2 } from "lucide-react";
import type { TagInfo } from "../../bindings";

interface TagItemProps {
  tag: TagInfo;
  onDelete: () => void;
  disabled?: boolean;
}

export function TagItem({ tag, onDelete, disabled }: TagItemProps) {
  return (
    <div className="flex items-center justify-between px-3 py-2 rounded-md hover:bg-gray-800">
      <div className="flex items-center gap-2 min-w-0 flex-1">
        <Tag className="w-4 h-4 shrink-0 text-yellow-400" />
        <div className="min-w-0">
          <p className="truncate font-medium">{tag.name}</p>
          {tag.message && (
            <p className="text-xs text-gray-500 truncate">{tag.message}</p>
          )}
        </div>
        {tag.isAnnotated && (
          <span className="text-xs text-gray-500 px-1.5 py-0.5 bg-gray-800 rounded">annotated</span>
        )}
      </div>
      <button
        onClick={onDelete}
        disabled={disabled}
        className="p-1.5 hover:bg-gray-700 rounded text-gray-400 hover:text-red-400"
        title="Delete tag"
      >
        <Trash2 className="w-4 h-4" />
      </button>
    </div>
  );
}
```

**src/components/tags/TagList.tsx**:
```tsx
import { useEffect, useState, useCallback } from "react";
import { Plus, RefreshCw } from "lucide-react";
import type { TagInfo } from "../../bindings";
import { commands } from "../../bindings";
import { TagItem } from "./TagItem";
import { CreateTagDialog } from "./CreateTagDialog";
import { cn } from "../../lib/utils";

export function TagList() {
  const [tags, setTags] = useState<TagInfo[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateDialog, setShowCreateDialog] = useState(false);

  const loadTags = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    const result = await commands.listTags();
    if (result.status === "ok") {
      setTags(result.data);
    } else {
      const errorMsg = "message" in result.error ? result.error.message : result.error.type;
      setError(errorMsg);
    }
    setIsLoading(false);
  }, []);

  useEffect(() => {
    loadTags();
  }, [loadTags]);

  const handleDelete = async (name: string) => {
    if (!window.confirm(`Delete tag "${name}"?`)) return;
    const result = await commands.deleteTag(name);
    if (result.status === "ok") {
      await loadTags();
    }
  };

  return (
    <div className="flex flex-col">
      <div className="flex items-center justify-between p-3 border-b border-gray-800">
        <h2 className="text-sm font-semibold text-gray-300">Tags</h2>
        <div className="flex gap-1">
          <button
            onClick={() => loadTags()}
            disabled={isLoading}
            className="p-1.5 hover:bg-gray-800 rounded text-gray-400 hover:text-white"
          >
            <RefreshCw className={cn("w-4 h-4", isLoading && "animate-spin")} />
          </button>
          <button
            onClick={() => setShowCreateDialog(true)}
            className="p-1.5 hover:bg-gray-800 rounded text-gray-400 hover:text-white"
          >
            <Plus className="w-4 h-4" />
          </button>
        </div>
      </div>

      {error && (
        <div className="p-3 bg-red-900/30 text-red-300 text-sm">
          {error}
          <button onClick={() => setError(null)} className="ml-2 underline">dismiss</button>
        </div>
      )}

      <div className="p-2 space-y-1">
        {tags.length === 0 ? (
          <p className="text-gray-500 text-sm p-2">No tags</p>
        ) : (
          tags.map((tag) => (
            <TagItem
              key={tag.name}
              tag={tag}
              onDelete={() => handleDelete(tag.name)}
              disabled={isLoading}
            />
          ))
        )}
      </div>

      {showCreateDialog && (
        <CreateTagDialog onClose={() => setShowCreateDialog(false)} onCreated={loadTags} />
      )}
    </div>
  );
}
```

**src/components/tags/CreateTagDialog.tsx**:
```tsx
import { useState } from "react";
import { X } from "lucide-react";
import { commands } from "../../bindings";

interface CreateTagDialogProps {
  onClose: () => void;
  onCreated: () => void;
}

export function CreateTagDialog({ onClose, onCreated }: CreateTagDialogProps) {
  const [name, setName] = useState("");
  const [message, setMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) return;

    setIsLoading(true);
    setError(null);

    // If message is empty, create lightweight tag (pass null)
    const result = await commands.createTag(
      name.trim(),
      message.trim() || null,
      null // null = tag HEAD
    );

    if (result.status === "ok") {
      onCreated();
      onClose();
    } else {
      const errorMsg = "message" in result.error ? result.error.message : result.error.type;
      setError(errorMsg);
    }
    setIsLoading(false);
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 border border-gray-700 rounded-lg p-6 w-96">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold">Create Tag</h3>
          <button onClick={onClose} className="p-1 hover:bg-gray-800 rounded">
            <X className="w-5 h-5" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm text-gray-400 mb-1">Tag name</label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="v1.0.0"
              className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded focus:outline-none focus:border-blue-500"
              autoFocus
            />
          </div>

          <div>
            <label className="block text-sm text-gray-400 mb-1">
              Message (optional - leave empty for lightweight tag)
            </label>
            <textarea
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="Release v1.0.0"
              rows={3}
              className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded focus:outline-none focus:border-blue-500 resize-none"
            />
          </div>

          {error && <p className="text-red-400 text-sm">{error}</p>}

          <div className="flex justify-end gap-2">
            <button type="button" onClick={onClose} className="px-4 py-2 text-sm text-gray-400 hover:text-white">
              Cancel
            </button>
            <button
              type="submit"
              disabled={!name.trim() || isLoading}
              className="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-700 rounded disabled:opacity-50"
            >
              {isLoading ? "Creating..." : "Create"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
```
  </action>
  <verify>
TypeScript compiles without errors.
  </verify>
  <done>
StashDialog allows saving stash with message and untracked option. TagList shows all tags. TagItem displays tag info with delete. CreateTagDialog creates annotated (with message) or lightweight (without) tags.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate stash and tag panels into RepositoryView</name>
  <files>src/components/RepositoryView.tsx</files>
  <action>
Update RepositoryView.tsx to include stash and tag panels:

1. **Add imports**:
```tsx
import { BranchList } from "./branches/BranchList";
import { StashList } from "./stash/StashList";
import { TagList } from "./tags/TagList";
import { GitBranch, Archive, Tag } from "lucide-react";
```

2. **Add collapsible sections** for branches, stash, and tags in the sidebar.
   - Use existing sidebar pattern if one exists, or create collapsible panels
   - Each section should be independently collapsible with a header
   - Consider using Lucide icons: GitBranch for branches, Archive for stash, Tag for tags

3. **Layout pattern** (adjust to match existing layout):
```tsx
// In sidebar area
<div className="w-64 border-r border-gray-800 flex flex-col overflow-hidden">
  {/* Branch section */}
  <details open className="border-b border-gray-800">
    <summary className="p-3 cursor-pointer hover:bg-gray-800/50 flex items-center gap-2">
      <GitBranch className="w-4 h-4" />
      <span className="font-semibold text-sm">Branches</span>
    </summary>
    <div className="max-h-64 overflow-y-auto">
      <BranchList />
    </div>
  </details>

  {/* Stash section */}
  <details className="border-b border-gray-800">
    <summary className="p-3 cursor-pointer hover:bg-gray-800/50 flex items-center gap-2">
      <Archive className="w-4 h-4" />
      <span className="font-semibold text-sm">Stashes</span>
    </summary>
    <div className="max-h-48 overflow-y-auto">
      <StashList />
    </div>
  </details>

  {/* Tag section */}
  <details className="border-b border-gray-800">
    <summary className="p-3 cursor-pointer hover:bg-gray-800/50 flex items-center gap-2">
      <Tag className="w-4 h-4" />
      <span className="font-semibold text-sm">Tags</span>
    </summary>
    <div className="max-h-48 overflow-y-auto">
      <TagList />
    </div>
  </details>

  {/* Existing staging panel or other content */}
</div>
```

4. **Refresh on branch change**: When user switches branches, trigger stash and staging refresh (stash list doesn't change, but staging does). Add effect or callback coordination.

5. **Ensure proper overflow handling**: Each section should scroll independently if content exceeds max-height.

Adapt the exact implementation to match the existing RepositoryView structure - the key is integrating the three new panels (Branches, Stash, Tags) in a discoverable location.
  </action>
  <verify>
`npm run tauri dev` - app shows branches, stash, and tags panels. All three panels populate with data. User can interact with all controls.
  </verify>
  <done>
RepositoryView integrates BranchList, StashList, and TagList in collapsible sidebar sections. All Phase 3 features are accessible from the main UI.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run typecheck` - TypeScript compiles without errors
2. `npm run tauri dev` - app starts successfully
3. Stash panel visible with save/apply/pop/drop functionality
4. Tag panel visible with create/delete functionality
5. All three panels (Branches, Stash, Tags) integrated into main view
6. End-to-end flow works:
   - Create branch, switch to it
   - Make changes, stash them
   - Switch branch, pop stash
   - Create tag for commit
   - Merge branch back
</verification>

<success_criteria>
- useStashStore provides complete stash state management
- StashList shows all stashes with index and message
- StashDialog allows saving with optional message and untracked flag
- StashItem provides apply/pop/drop with clear icons
- TagList shows all tags distinguishing annotated vs lightweight
- CreateTagDialog creates both tag types based on message presence
- TagItem shows tag info with delete action
- RepositoryView integrates all three panels in sidebar
- All components follow existing Tailwind/Lucide patterns
- Loading and error states handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-git-branches/03-06-SUMMARY.md`
</output>
