---
phase: 03-core-git-branches
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/branch.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Backend can list all local branches with current HEAD indicator"
    - "Backend can create a new branch from HEAD"
    - "Backend can checkout/switch to an existing branch"
    - "Backend can delete a branch with merge safety check"
  artifacts:
    - path: "src-tauri/src/git/branch.rs"
      provides: "Branch CRUD operations"
      exports: ["BranchInfo", "list_branches", "create_branch", "checkout_branch", "delete_branch"]
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "branch commands"
      via: "invoke_handler registration"
      pattern: "list_branches|create_branch|checkout_branch|delete_branch"
---

<objective>
Create the Rust branch module with operations for listing, creating, checking out, and deleting local branches.

Purpose: Enable the frontend to display all branches and allow users to manage them. This is the foundation for branch management UI.

Output: New branch.rs module with 4 Tauri commands exported via tauri-specta.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-git-branches/03-RESEARCH.md

# Existing code to extend
@src-tauri/src/git/mod.rs
@src-tauri/src/git/error.rs
@src-tauri/src/git/repository.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create branch.rs module with BranchInfo struct and list_branches command</name>
  <files>src-tauri/src/git/branch.rs, src-tauri/src/git/mod.rs</files>
  <action>
Create new `src-tauri/src/git/branch.rs` with:

1. **BranchInfo struct** (derive Serialize, specta::Type):
   - `name: String` - branch name (e.g., "main", "feature/login")
   - `is_head: bool` - true if this is the currently checked out branch
   - `last_commit_oid: String` - short OID of the branch tip commit
   - `last_commit_message: String` - summary line of the tip commit
   - `is_merged: Option<bool>` - whether branch is merged into HEAD (None if IS head)

2. **list_branches command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn list_branches(state: State<'_, RepositoryState>) -> Result<Vec<BranchInfo>, GitError>
```
- Get repo path from state, return error if no repo open
- Use `repo.branches(Some(BranchType::Local))` to iterate local branches
- For each branch: extract name, check `is_head()`, peel to commit for OID/message
- For merge check: use `repo.merge_base()` between HEAD and branch commit - if merge_base equals branch commit, it's merged
- Wrap all git2 calls in `spawn_blocking`

3. Update `src-tauri/src/git/mod.rs`:
- Add `pub mod branch;`
- Add `pub use branch::BranchInfo;`
  </action>
  <verify>
`cargo check -p git-ai` compiles without errors. Run `cargo test -p git-ai` if tests exist.
  </verify>
  <done>
list_branches command exists, returns Vec<BranchInfo> with all local branches including is_head and is_merged flags.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add create_branch and checkout_branch commands</name>
  <files>src-tauri/src/git/branch.rs</files>
  <action>
Add two commands to branch.rs:

1. **create_branch command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn create_branch(
    name: String,
    checkout: bool,
    state: State<'_, RepositoryState>,
) -> Result<BranchInfo, GitError>
```
- Validate branch name with `Branch::name_is_valid(&name)?` - return error if invalid
- Get HEAD commit via `repo.head()?.peel_to_commit()?`
- Create branch with `repo.branch(&name, &head_commit, false)?` (false = don't force)
- If `checkout` is true, call the two-step checkout process:
  - `repo.set_head(&format!("refs/heads/{}", name))?`
  - `repo.checkout_head(Some(&mut CheckoutBuilder::new().safe()))?`
- Return BranchInfo for the new branch

2. **checkout_branch command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn checkout_branch(
    branch_name: String,
    state: State<'_, RepositoryState>,
) -> Result<(), GitError>
```
- CRITICAL: git2 checkout is TWO steps (see research Pattern 1)
- Step 1: `repo.set_head(&format!("refs/heads/{}", branch_name))?`
- Step 2: `repo.checkout_head(Some(&mut CheckoutBuilder::new().safe()))?`
- Use `.safe()` to prevent overwriting local changes - if dirty, return error suggesting stash
- Check if branch exists first with `repo.find_branch(&branch_name, BranchType::Local)?`

Both commands must be wrapped in `spawn_blocking`.
  </action>
  <verify>
`cargo check -p git-ai` compiles. Manually test in a git repo:
- create_branch should create a new branch
- checkout_branch should switch HEAD and update working directory
  </verify>
  <done>
create_branch creates a branch from HEAD and optionally checks it out. checkout_branch switches to an existing branch using two-step process.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add delete_branch command and register all commands in lib.rs</name>
  <files>src-tauri/src/git/branch.rs, src-tauri/src/git/error.rs, src-tauri/src/lib.rs</files>
  <action>
1. **Extend GitError** in error.rs:
   Add variants for branch operations:
   - `BranchNotFound(String)` - branch doesn't exist
   - `CannotDeleteCurrentBranch` - trying to delete HEAD
   - `BranchNotMerged(String)` - branch has unmerged commits (for non-force delete)
   - `InvalidBranchName(String)` - branch name validation failed
   - `BranchAlreadyExists(String)` - branch already exists
   - `DirtyWorkingDirectory` - cannot checkout with uncommitted changes

2. **delete_branch command** in branch.rs:
```rust
#[tauri::command]
#[specta::specta]
pub async fn delete_branch(
    branch_name: String,
    force: bool,
    state: State<'_, RepositoryState>,
) -> Result<(), GitError>
```
- Find branch with `repo.find_branch(&branch_name, BranchType::Local)?`
- Check `branch.is_head()` - return `CannotDeleteCurrentBranch` error if true
- If not force: check if branch is merged into HEAD
  - Get HEAD commit and branch commit
  - Use `repo.merge_base(head_commit.id(), branch_commit.id())?`
  - If merge_base != branch_commit.id(), branch has unmerged work - return error
- Call `branch.delete()?` to remove the branch
- Wrap in `spawn_blocking`

3. **Register commands** in lib.rs:
- Add to specta builder: `list_branches, create_branch, checkout_branch, delete_branch`
- Add to invoke_handler: same 4 commands
- Follow existing pattern from staging/commit/history commands
  </action>
  <verify>
`cargo check -p git-ai` compiles. `npm run tauri dev` starts and new commands appear in bindings.ts after regeneration.
  </verify>
  <done>
delete_branch removes branches with safety checks (cannot delete HEAD, warns on unmerged). All 4 branch commands registered in lib.rs and available via IPC.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p git-ai` - no compilation errors
2. `npm run tauri dev` - app starts successfully
3. Check `src/bindings.ts` includes: `listBranches`, `createBranch`, `checkoutBranch`, `deleteBranch`
4. Check types include: `BranchInfo` with expected fields
</verification>

<success_criteria>
- 4 new Tauri commands available: listBranches, createBranch, checkoutBranch, deleteBranch
- BranchInfo type includes name, is_head, last_commit_oid, last_commit_message, is_merged
- create_branch validates name and optionally checks out
- checkout_branch uses two-step process (set_head + checkout_head) with safe mode
- delete_branch prevents deleting current branch and warns on unmerged branches
- All git2 calls wrapped in spawn_blocking
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-git-branches/03-01-SUMMARY.md`
</output>
