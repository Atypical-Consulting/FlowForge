---
phase: 03-core-git-branches
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src-tauri/src/git/merge.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Backend can analyze merge to determine if fast-forward is possible"
    - "Backend can perform a merge with automatic commit on success"
    - "Backend can detect merge conflicts and report them"
    - "Backend can abort a merge in progress"
  artifacts:
    - path: "src-tauri/src/git/merge.rs"
      provides: "Merge operations"
      exports: ["MergeResult", "MergeAnalysisResult", "merge_branch", "abort_merge", "get_merge_status"]
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "merge commands"
      via: "invoke_handler registration"
      pattern: "merge_branch|abort_merge|get_merge_status"
---

<objective>
Create the Rust merge module with operations for analyzing, executing, and aborting merges.

Purpose: Enable users to merge branches together, handling both fast-forward and three-way merges with conflict detection.

Output: New merge.rs module with 3 Tauri commands exported via tauri-specta.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-git-branches/03-RESEARCH.md
@.planning/phases/03-core-git-branches/03-01-SUMMARY.md

# Existing code to extend
@src-tauri/src/git/mod.rs
@src-tauri/src/git/error.rs
@src-tauri/src/git/branch.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create merge.rs with result types and merge_branch command</name>
  <files>src-tauri/src/git/merge.rs, src-tauri/src/git/mod.rs, src-tauri/src/git/error.rs</files>
  <action>
Create new `src-tauri/src/git/merge.rs` with:

1. **MergeAnalysisResult enum** (derive Serialize, specta::Type):
```rust
pub enum MergeAnalysisResult {
    UpToDate,           // Already merged, nothing to do
    FastForward,        // Can fast-forward without merge commit
    Normal,             // Requires merge commit
    Unborn,             // HEAD doesn't exist yet
}
```

2. **MergeResult struct** (derive Serialize, specta::Type):
```rust
pub struct MergeResult {
    pub success: bool,
    pub analysis: MergeAnalysisResult,
    pub commit_oid: Option<String>,    // OID of merge commit (if created)
    pub fast_forwarded: bool,          // True if fast-forward was used
    pub has_conflicts: bool,           // True if conflicts remain
    pub conflicted_files: Vec<String>, // List of conflicted file paths
}
```

3. **merge_branch command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn merge_branch(
    source_branch: String,
    state: State<'_, RepositoryState>,
) -> Result<MergeResult, GitError>
```
Implementation (CRITICAL - follow research Pattern 2):
- Find source branch: `repo.find_branch(&source_branch, BranchType::Local)?`
- Get annotated commit: `repo.find_annotated_commit(source_commit.id())?`
- Run analysis: `repo.merge_analysis(&[&annotated])?`

If `analysis.is_up_to_date()`:
- Return MergeResult with success=true, analysis=UpToDate

If `analysis.is_fast_forward()`:
- Get current branch name from HEAD
- Update reference: `repo.reference(&refname, source_commit.id(), true, "merge: fast-forward")?`
- Checkout: `repo.checkout_head(Some(&mut CheckoutBuilder::new().safe()))?`
- Return MergeResult with success=true, fast_forwarded=true

If normal merge:
- Call `repo.merge(&[&annotated], None, None)?`
- Check `repo.index()?.has_conflicts()`
- If conflicts: collect conflicted paths, return has_conflicts=true
- If no conflicts: create merge commit
  - Get HEAD commit and source commit as parents
  - Write index to tree
  - Create merge commit with both parents
  - Return commit_oid

Wrap all in spawn_blocking.

4. **Extend GitError** in error.rs:
   - Add `MergeConflict(Vec<String>)` - merge resulted in conflicts
   - Add `NoMergeInProgress` - tried to abort but no merge active

5. **Update mod.rs**:
- Add `pub mod merge;`
- Add `pub use merge::{MergeResult, MergeAnalysisResult};`
  </action>
  <verify>
`cargo check -p git-ai` compiles without errors.
  </verify>
  <done>
merge_branch performs analysis-first merge, handles fast-forward and normal merge cases, detects conflicts and reports conflicted files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add abort_merge and get_merge_status commands</name>
  <files>src-tauri/src/git/merge.rs</files>
  <action>
Add two commands to merge.rs:

1. **MergeStatus struct** (derive Serialize, specta::Type):
```rust
pub struct MergeStatus {
    pub in_progress: bool,
    pub conflicted_files: Vec<String>,
}
```

2. **get_merge_status command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn get_merge_status(state: State<'_, RepositoryState>) -> Result<MergeStatus, GitError>
```
- Check `repo.state()` for `RepositoryState::Merge`
- If in merge state, get index and collect conflicted files via `index.conflicts()?`
- Return MergeStatus with in_progress and conflicted_files
- Wrap in spawn_blocking

3. **abort_merge command**:
```rust
#[tauri::command]
#[specta::specta]
pub async fn abort_merge(state: State<'_, RepositoryState>) -> Result<(), GitError>
```
- Check `repo.state()` - if not in merge state, return `NoMergeInProgress` error
- Call `repo.cleanup_state()?` to clear merge state
- Reset to HEAD: `repo.checkout_head(Some(&mut CheckoutBuilder::new().force()))?`
- Note: `.force()` is appropriate here because we want to discard merge changes
- Wrap in spawn_blocking

This allows UI to show merge state and provide "Abort Merge" button when conflicts occur.
  </action>
  <verify>
`cargo check -p git-ai` compiles without errors.
  </verify>
  <done>
get_merge_status reports if merge is in progress and lists conflicted files. abort_merge cancels in-progress merge and restores HEAD state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register merge commands in lib.rs</name>
  <files>src-tauri/src/lib.rs</files>
  <action>
Register all 3 merge commands in lib.rs:

1. **Add to specta builder**:
```rust
.commands(tauri_specta::collect_commands![
    // ... existing commands ...
    git::merge::merge_branch,
    git::merge::abort_merge,
    git::merge::get_merge_status,
])
```

2. **Add to invoke_handler**:
```rust
.invoke_handler(tauri::generate_handler![
    // ... existing commands ...
    git::merge::merge_branch,
    git::merge::abort_merge,
    git::merge::get_merge_status,
])
```

Follow the exact pattern used for other git module commands.
  </action>
  <verify>
`cargo check -p git-ai` compiles. `npm run tauri dev` starts and merge commands appear in bindings.ts.
  </verify>
  <done>
All 3 merge commands registered and available via IPC. bindings.ts includes mergeBranch, abortMerge, getMergeStatus functions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p git-ai` - no compilation errors
2. `npm run tauri dev` - app starts successfully
3. Check `src/bindings.ts` includes: `mergeBranch`, `abortMerge`, `getMergeStatus`
4. Check types include: `MergeResult`, `MergeAnalysisResult`, `MergeStatus`
</verification>

<success_criteria>
- 3 new Tauri commands available: mergeBranch, abortMerge, getMergeStatus
- MergeResult includes success, analysis type, commit_oid (if created), fast_forwarded flag, has_conflicts, conflicted_files
- MergeAnalysisResult enum covers UpToDate, FastForward, Normal, Unborn cases
- merge_branch runs analysis FIRST to determine strategy (Pattern 2 from research)
- Fast-forward merges update ref without creating merge commit
- Normal merges detect conflicts and return conflicted file list
- abort_merge cleans up merge state and resets to HEAD
- get_merge_status reports in-progress merge and conflicts
- All git2 calls wrapped in spawn_blocking
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-git-branches/03-04-SUMMARY.md`
</output>
