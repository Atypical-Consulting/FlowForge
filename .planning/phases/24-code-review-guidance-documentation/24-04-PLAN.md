---
phase: 24-code-review-guidance-documentation
plan: 04
type: execute
wave: 3
depends_on: ["24-01"]
files_modified:
  - src-tauri/src/gitflow/commands.rs
  - src-tauri/src/gitflow/merge.rs
  - src-tauri/src/gitflow/error.rs
  - src/stores/gitflow.ts
autonomous: true

must_haves:
  truths:
    - "All gitflow start/finish commands check for uncommitted changes before proceeding"
    - "merge_no_ff cleans up merge state on conflict errors"
    - "Gitflow store calls refresh() on error path so UI reflects actual repo state"
    - "Start Feature creates branch and checks it out when on develop with clean working tree"
    - "Finish Feature merges to develop, deletes feature branch when on feature/* with clean working tree"
  artifacts:
    - path: "src-tauri/src/gitflow/commands.rs"
      provides: "Dirty working directory check before all gitflow operations"
    - path: "src-tauri/src/gitflow/merge.rs"
      provides: "Merge state cleanup on conflict, proper no-ff always-merge-commit behavior"
    - path: "src-tauri/src/gitflow/error.rs"
      provides: "DirtyWorkingTree error variant"
    - path: "src/stores/gitflow.ts"
      provides: "refresh() called on error path for all actions"
---

<objective>
Fix Gitflow robustness issues identified in UAT: dirty working directory checks, merge state cleanup, and UI state refresh on errors.

Purpose: Gitflow start/finish operations work reliably even with uncommitted changes or edge-case repo states. Users get clear error messages and the UI always reflects the actual repo state.

Output: Hardened gitflow commands with pre-flight checks and proper error cleanup.
</objective>

<tasks>

<task type="auto">
  <name>Task 1: Add DirtyWorkingTree error and dirty check helper</name>
  <files>
    src-tauri/src/gitflow/error.rs
    src-tauri/src/gitflow/commands.rs
  </files>
  <action>
    **Modify `src-tauri/src/gitflow/error.rs`:**

    Add a new error variant after `MergeConflict`:
    ```rust
    /// Working directory has uncommitted changes
    #[error("Working directory has uncommitted changes — commit or stash before proceeding")]
    DirtyWorkingTree,
    ```

    **Modify `src-tauri/src/gitflow/commands.rs`:**

    Add a helper function at the top of the file (after the use statements):
    ```rust
    /// Check if the working directory is clean (no uncommitted changes).
    /// Returns Ok(()) if clean, Err(DirtyWorkingTree) if dirty.
    fn ensure_clean_working_tree(repo: &git2::Repository) -> Result<(), GitflowError> {
        let statuses = repo.statuses(Some(
            git2::StatusOptions::new()
                .include_untracked(false)
                .include_ignored(false),
        ))?;
        if !statuses.is_empty() {
            return Err(GitflowError::DirtyWorkingTree);
        }
        Ok(())
    }
    ```

    Add `ensure_clean_working_tree(&repo)?;` as the first check inside the `spawn_blocking` closure for ALL 6 gitflow commands:
    - `start_feature` — after `let repo = git2::Repository::open(&repo_path)?;` (line 38)
    - `finish_feature` — after `let repo = git2::Repository::open(&repo_path)?;` (line 83)
    - `start_release` — after `let repo = git2::Repository::open(&repo_path)?;` (line 131)
    - `finish_release` — after `let repo = git2::Repository::open(&repo_path)?;` (line 188)
    - `start_hotfix` — after `let repo = git2::Repository::open(&repo_path)?;` (line 250)
    - `finish_hotfix` — after `let repo = git2::Repository::open(&repo_path)?;` (line 305)
  </action>
  <verify>
    - `cargo check` passes
    - DirtyWorkingTree variant exists in GitflowError
    - All 6 commands call ensure_clean_working_tree
  </verify>
</task>

<task type="auto">
  <name>Task 2: Fix merge_no_ff conflict cleanup and up-to-date handling</name>
  <files>
    src-tauri/src/gitflow/merge.rs
  </files>
  <action>
    **Modify `src-tauri/src/gitflow/merge.rs`:**

    1. **Fix conflict cleanup** (line 50-52): When a merge conflict is detected, clean up the merge state before returning error:
    ```rust
    // 7. Check for conflicts
    let index = repo.index()?;
    if index.has_conflicts() {
        // Clean up merge state so repo isn't left in MERGING state
        repo.cleanup_state()?;
        // Reset to target branch state (undo partial merge)
        repo.checkout_head(Some(git2::build::CheckoutBuilder::new().force()))?;
        return Err(GitflowError::MergeConflict);
    }
    ```

    2. **Fix up-to-date case** (line 37-39): When analysis shows up-to-date, still create a merge commit for proper --no-ff behavior. Replace the early return with a tree-based merge commit:
    ```rust
    if analysis.is_up_to_date() {
        // Even when up-to-date, create a merge commit (true --no-ff behavior)
        let tree_oid = repo.index()?.write_tree()?;
        let tree = repo.find_tree(tree_oid)?;
        let sig = repo.signature()?;
        let commit_oid = repo.commit(
            Some("HEAD"),
            &sig,
            &sig,
            message,
            &tree,
            &[&target, &source],
        )?;
        return Ok(commit_oid);
    }
    ```
  </action>
  <verify>
    - `cargo check` passes
    - Conflict path calls cleanup_state() and checkout_head()
    - Up-to-date path creates a merge commit instead of returning early
  </verify>
</task>

<task type="auto">
  <name>Task 3: Add refresh() on error path in gitflow store</name>
  <files>
    src/stores/gitflow.ts
  </files>
  <action>
    **Modify `src/stores/gitflow.ts`:**

    For all 6 action functions (startFeature, finishFeature, startRelease, finishRelease, startHotfix, finishHotfix), add `await get().refresh();` on the error path BEFORE setting the error state. This ensures the UI always reflects the actual repo state even after a failed operation.

    Pattern for each action:
    ```typescript
    // Before (error path):
    set({ error: getErrorMessage(result.error), isLoading: false });

    // After (error path):
    await get().refresh(); // Ensure UI reflects actual repo state
    set({ error: getErrorMessage(result.error) });
    // Note: refresh() already sets isLoading: false
    ```

    Apply this to all 6 actions:
    - `startFeature` (line 62)
    - `finishFeature` (line 73)
    - `startRelease` (line 84)
    - `finishRelease` (line 95)
    - `startHotfix` (line 106)
    - `finishHotfix` (line 117)

    IMPORTANT: After `refresh()`, only set `error` — don't set `isLoading: false` since `refresh()` already handles that. But we need to set the error AFTER refresh since refresh clears it. Use:
    ```typescript
    await get().refresh();
    set({ error: getErrorMessage(result.error) });
    ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes (ignoring pre-existing bindings.ts error)
    - All 6 error paths call refresh() before setting error
  </verify>
</task>

</tasks>

<verification>
1. Open a repo with Gitflow initialized, make a change but don't commit
2. Try "Start Feature" — should show "Working directory has uncommitted changes" error
3. Commit or stash the change, then "Start Feature" — should create and checkout the feature branch
4. Make a commit on the feature branch
5. "Finish Feature" — should merge to develop with a merge commit and delete the feature branch
6. Verify the UI shows the correct branch (develop) after finish
</verification>

<success_criteria>
- All gitflow commands reject dirty working trees with a clear error message
- merge_no_ff cleans up merge state on conflict (no stuck MERGING state)
- merge_no_ff creates merge commit even when up-to-date (true --no-ff)
- UI always refreshes after errors so it reflects the real repo state
- Existing happy-path behavior is preserved
</success_criteria>
