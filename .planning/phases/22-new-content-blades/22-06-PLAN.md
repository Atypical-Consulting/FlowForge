---
phase: 22
plan: 22-06
title: Repo Browser Blade — File Tree at HEAD with Breadcrumbs, Smart File Dispatch, Keyboard Navigation
wave: 2
depends_on: [22-01, 22-02]
files_modified:
  - src/components/blades/RepoBrowserBlade.tsx
  - src/components/blades/registrations/repo-browser.ts
autonomous: true
---

# Repo Browser Blade — File Tree at HEAD with Breadcrumbs, Smart File Dispatch, Keyboard Navigation

## Goal

Replace the placeholder RepoBrowserBlade with a fully functional repository file browser that shows files and directories at HEAD, supports breadcrumb navigation, dispatches file clicks to the appropriate viewer blade, and provides keyboard navigation (arrow keys, Enter, Home/End). This fulfills requirement CONTENT-04.

## must_haves

- Displays a flat list of files and directories for the current path, sorted folders-first then alphabetical
- Clicking a folder replaces the current blade with the same type at the new path (in-place navigation)
- Clicking a file pushes the appropriate viewer blade using the declarative file dispatch map
- Breadcrumbs show the full path with clickable ancestor segments and a home icon for root
- Breadcrumbs use `<nav aria-label="Repository path">` with `<ol>` and `aria-current="page"` on the current segment
- Arrow Up/Down moves focus between file list items, Enter activates, Home/End jumps to first/last
- Empty directories show the `BladeContentEmpty` component
- File list rows use `FileTypeIcon` for appropriate file/folder icons
- File sizes are displayed in dimmed text on the right side of each row
- Loading and error states use `BladeContentLoading` / `BladeContentError`

## Tasks

<task id="1" title="Replace RepoBrowserBlade with full implementation">

**File**: `src/components/blades/RepoBrowserBlade.tsx`

Replace the entire file:

```tsx
import { useQuery } from "@tanstack/react-query";
import { FolderOpen, Home } from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { commands } from "../../bindings";
import type { RepoFileEntry } from "../../bindings";
import { bladeTypeForFile } from "../../lib/fileDispatch";
import { useBladeStore } from "../../stores/blades";
import { FileTypeIcon } from "../icons/FileTypeIcon";
import { BladeContentLoading } from "./BladeContentLoading";
import { BladeContentError } from "./BladeContentError";
import { BladeContentEmpty } from "./BladeContentEmpty";
import { BladeToolbar } from "./BladeToolbar";

interface RepoBrowserBladeProps {
  path?: string;
}

export function RepoBrowserBlade({ path = "" }: RepoBrowserBladeProps) {
  const store = useBladeStore();
  const [focusedIndex, setFocusedIndex] = useState(0);
  const listRef = useRef<HTMLDivElement>(null);
  const itemRefs = useRef<(HTMLButtonElement | null)[]>([]);

  const {
    data: entries,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["repoFiles", path],
    queryFn: async () => {
      const result = await commands.listRepoFiles(path);
      if (result.status === "ok") {
        return result.data;
      }
      throw new Error("Failed to load directory contents");
    },
    staleTime: 30_000,
  });

  // Reset focus when path changes
  useEffect(() => {
    setFocusedIndex(0);
  }, [path]);

  // Focus the item when focusedIndex changes
  useEffect(() => {
    itemRefs.current[focusedIndex]?.focus();
  }, [focusedIndex]);

  const navigateToDirectory = useCallback(
    (dirPath: string) => {
      store.replaceBlade({
        type: "repo-browser",
        title: dirPath.split("/").pop() || "Repository Browser",
        props: { path: dirPath },
      });
    },
    [store],
  );

  const openFile = useCallback(
    (entry: RepoFileEntry) => {
      if (entry.isDir) {
        navigateToDirectory(entry.path);
        return;
      }

      const bladeType = bladeTypeForFile(entry.path, "browse");
      const title = entry.name;

      if (bladeType === "viewer-image") {
        store.pushBlade({
          type: "viewer-image",
          title,
          props: { filePath: entry.path },
        });
      } else if (bladeType === "viewer-markdown") {
        store.pushBlade({
          type: "viewer-markdown",
          title,
          props: { filePath: entry.path },
        });
      } else if (bladeType === "viewer-3d") {
        store.pushBlade({
          type: "viewer-3d",
          title,
          props: { filePath: entry.path },
        });
      } else if (bladeType === "viewer-nupkg") {
        store.pushBlade({
          type: "viewer-nupkg",
          title,
          props: { filePath: entry.path },
        });
      } else if (bladeType === "viewer-code") {
        store.pushBlade({
          type: "viewer-code",
          title,
          props: { filePath: entry.path },
        });
      } else {
        // Fallback: viewer-code for unrecognized text files
        store.pushBlade({
          type: "viewer-code",
          title,
          props: { filePath: entry.path },
        });
      }
    },
    [store, navigateToDirectory],
  );

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (!entries || entries.length === 0) return;

      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          setFocusedIndex((i) => Math.min(i + 1, entries.length - 1));
          break;
        case "ArrowUp":
          e.preventDefault();
          setFocusedIndex((i) => Math.max(i - 1, 0));
          break;
        case "Home":
          e.preventDefault();
          setFocusedIndex(0);
          break;
        case "End":
          e.preventDefault();
          setFocusedIndex(entries.length - 1);
          break;
        case "Enter":
        case " ":
          e.preventDefault();
          if (entries[focusedIndex]) {
            openFile(entries[focusedIndex]);
          }
          break;
        case "Backspace":
          e.preventDefault();
          if (path) {
            // Navigate to parent directory
            const parentPath = path.includes("/")
              ? path.substring(0, path.lastIndexOf("/"))
              : "";
            navigateToDirectory(parentPath);
          }
          break;
      }
    },
    [entries, focusedIndex, openFile, path, navigateToDirectory],
  );

  if (isLoading) {
    return <BladeContentLoading />;
  }

  if (error) {
    return (
      <BladeContentError
        message="Could not load repository contents"
        detail={error instanceof Error ? error.message : String(error)}
        onRetry={() => refetch()}
      />
    );
  }

  return (
    <div className="flex-1 flex flex-col overflow-hidden h-full">
      {/* Breadcrumbs toolbar */}
      <BladeToolbar>
        <Breadcrumbs path={path} onNavigate={navigateToDirectory} />
      </BladeToolbar>

      {/* File list */}
      {!entries || entries.length === 0 ? (
        <BladeContentEmpty
          icon={FolderOpen}
          message="This directory is empty"
        />
      ) : (
        <div
          ref={listRef}
          role="listbox"
          aria-label={`Files in ${path || "repository root"}`}
          className="flex-1 overflow-y-auto"
          onKeyDown={handleKeyDown}
        >
          {entries.map((entry, index) => (
            <FileRow
              key={entry.path}
              entry={entry}
              isFocused={index === focusedIndex}
              onClick={() => openFile(entry)}
              onFocus={() => setFocusedIndex(index)}
              ref={(el) => {
                itemRefs.current[index] = el;
              }}
            />
          ))}
        </div>
      )}
    </div>
  );
}

// --- Breadcrumbs component ---

interface BreadcrumbsProps {
  path: string;
  onNavigate: (path: string) => void;
}

function Breadcrumbs({ path, onNavigate }: BreadcrumbsProps) {
  const segments = path ? path.split("/").filter(Boolean) : [];

  return (
    <nav aria-label="Repository path" className="flex-1 min-w-0">
      <ol className="flex items-center gap-1 text-sm overflow-x-auto scrollbar-none">
        {/* Root segment */}
        <li>
          {segments.length === 0 ? (
            <span
              className="flex items-center gap-1 font-medium text-ctp-text"
              aria-current="page"
            >
              <Home className="w-3.5 h-3.5" />
              <span className="sr-only">Repository root</span>
            </span>
          ) : (
            <button
              type="button"
              onClick={() => onNavigate("")}
              className="flex items-center gap-1 text-ctp-overlay1 hover:text-ctp-text hover:underline"
              aria-label="Repository root"
            >
              <Home className="w-3.5 h-3.5" />
            </button>
          )}
        </li>

        {/* Path segments */}
        {segments.map((segment, index) => {
          const segmentPath = segments.slice(0, index + 1).join("/");
          const isLast = index === segments.length - 1;

          return (
            <li key={segmentPath} className="flex items-center gap-1">
              <span aria-hidden="true" className="text-ctp-overlay0">
                /
              </span>
              {isLast ? (
                <span
                  className="font-medium text-ctp-text truncate"
                  aria-current="page"
                >
                  {segment}
                </span>
              ) : (
                <button
                  type="button"
                  onClick={() => onNavigate(segmentPath)}
                  className="text-ctp-overlay1 hover:text-ctp-text hover:underline truncate"
                >
                  {segment}
                </button>
              )}
            </li>
          );
        })}
      </ol>
    </nav>
  );
}

// --- FileRow component ---

import { forwardRef } from "react";

interface FileRowProps {
  entry: RepoFileEntry;
  isFocused: boolean;
  onClick: () => void;
  onFocus: () => void;
}

const FileRow = forwardRef<HTMLButtonElement, FileRowProps>(
  function FileRow({ entry, isFocused, onClick, onFocus }, ref) {
    return (
      <button
        ref={ref}
        type="button"
        role="option"
        aria-selected={false}
        onClick={onClick}
        onFocus={onFocus}
        tabIndex={isFocused ? 0 : -1}
        className={`
          w-full flex items-center gap-2.5 px-3 py-1.5 text-left text-sm
          hover:bg-ctp-surface0/50 transition-colors
          focus:bg-ctp-surface0/50 focus:outline-none focus:ring-1 focus:ring-ctp-blue/50 focus:ring-inset
          ${isFocused ? "bg-ctp-surface0/30" : ""}
        `}
      >
        <FileTypeIcon
          path={entry.name}
          isDirectory={entry.isDir}
        />
        <span className="flex-1 truncate text-ctp-text">
          {entry.name}
          {entry.isDir && (
            <span className="text-ctp-overlay0">/</span>
          )}
        </span>
        {!entry.isDir && entry.size > 0 && (
          <span className="text-xs text-ctp-overlay0 tabular-nums shrink-0">
            {formatFileSize(entry.size)}
          </span>
        )}
      </button>
    );
  },
);

function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
```

</task>

<task id="2" title="Update repo-browser registration" depends_on="1">

**File**: `src/components/blades/registrations/repo-browser.ts`

Update the registration to show a dynamic title based on the current directory:

```ts
import { lazy } from "react";
import { registerBlade } from "../../../lib/bladeRegistry";

const RepoBrowserBlade = lazy(() =>
  import("../RepoBrowserBlade").then((m) => ({
    default: m.RepoBrowserBlade,
  })),
);

registerBlade<{ path?: string }>({
  type: "repo-browser",
  defaultTitle: (props) => {
    if (!props.path) return "Repository Browser";
    return props.path.split("/").pop() || "Repository Browser";
  },
  component: RepoBrowserBlade,
  lazy: true,
  renderTitleContent: (props) => {
    if (!props.path) return null; // Use default title
    const path = props.path;
    const lastSlash = path.lastIndexOf("/");
    if (lastSlash === -1) {
      return (
        <span className="text-sm font-semibold text-ctp-text truncate">
          {path}
        </span>
      );
    }
    return (
      <span className="text-sm truncate">
        <span className="text-ctp-overlay1">
          {path.slice(0, lastSlash + 1)}
        </span>
        <span className="font-semibold text-ctp-text">
          {path.slice(lastSlash + 1)}
        </span>
      </span>
    );
  },
});
```

</task>

## Verification

- [ ] Opening the repo browser shows files and folders at the repository root
- [ ] Folders appear before files, both sorted alphabetically (case-insensitive)
- [ ] Each row shows the appropriate file/folder icon via `FileTypeIcon`
- [ ] File sizes appear in dimmed text on the right side of each row
- [ ] Clicking a folder replaces the blade (stays in repo browser) at the new path
- [ ] Clicking a `.md` file pushes a viewer-markdown blade
- [ ] Clicking a `.png` file pushes a viewer-image blade
- [ ] Clicking a `.tsx` file pushes a viewer-code blade
- [ ] Clicking a `.glb` file pushes a viewer-3d blade
- [ ] Breadcrumbs show the full path with clickable ancestor segments
- [ ] Clicking the Home icon in breadcrumbs navigates to repository root
- [ ] Clicking a middle breadcrumb segment navigates to that directory
- [ ] The current breadcrumb segment has `aria-current="page"` and is non-interactive
- [ ] Arrow Up/Down moves focus between file list items
- [ ] Enter key activates the focused item (opens file or enters directory)
- [ ] Home/End keys jump to first/last item
- [ ] Backspace navigates to the parent directory
- [ ] Empty directories show "This directory is empty" with the FolderOpen icon
- [ ] Loading state shows centered spinner; error state shows error with retry
- [ ] `npx tsc --noEmit` completes with no new errors
