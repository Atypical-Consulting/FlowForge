---
phase: 22
plan: 22-08
title: Viewer-3D Blade — model-viewer Integration with Orbit Controls, Progress Bar, WebGL Fallback
wave: 3
depends_on: [22-02, 22-03]
files_modified:
  - src/components/blades/Viewer3dBlade.tsx
  - src/components/blades/registrations/viewer-3d.ts
autonomous: true
---

# Viewer-3D Blade — model-viewer Integration with Orbit Controls, Progress Bar, WebGL Fallback

## Goal

Replace the placeholder Viewer3dBlade with a fully functional 3D model viewer using `@google/model-viewer`. The blade loads `.glb` and `.gltf` files from git HEAD, converts them to blob URLs, and renders them with orbit controls, auto-rotation, gradient background, progress bar loading, collapsible metadata panel, and WebGL context loss recovery. This fulfills requirement CONTENT-03.

## must_haves

- `.glb` and `.gltf` files load from git HEAD via `readRepoFile`, decode base64 to blob URL
- `<model-viewer>` renders with `camera-controls` and `auto-rotate`
- Background is a gradient from `--ctp-base` to `--ctp-mantle`
- Loading shows a progress bar (not just a spinner) using model-viewer progress events
- WebGL context loss shows a retry UI (static placeholder + "Reload 3D View" button)
- Collapsible metadata panel shows format, size; toggle via `Info` icon in blade header trailing slot
- Blob URL is cleaned up on unmount
- `alt` attribute is set on the model-viewer element
- `aria-busy` during loading, `role="alert"` on failure
- First-time interaction hint overlay (drag/scroll/shift-drag) fades after 4s or first interaction

## Tasks

<task id="1" title="Replace Viewer3dBlade with full implementation">

**File**: `src/components/blades/Viewer3dBlade.tsx`

Replace the entire file:

```tsx
import "@google/model-viewer";
import { Box, Info, RotateCcw } from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { commands } from "../../bindings";
import { getErrorMessage } from "../../lib/errors";
import { BladeContentLoading } from "./BladeContentLoading";
import { BladeContentError } from "./BladeContentError";
import { BladeContentEmpty } from "./BladeContentEmpty";

interface Viewer3dBladeProps {
  filePath: string;
}

export function Viewer3dBlade({ filePath }: Viewer3dBladeProps) {
  const [blobUrl, setBlobUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [fetchError, setFetchError] = useState<string | null>(null);
  const [progress, setProgress] = useState(0);
  const [modelReady, setModelReady] = useState(false);
  const [contextLost, setContextLost] = useState(false);
  const [showMetadata, setShowMetadata] = useState(false);
  const [showHint, setShowHint] = useState(false);
  const [fileSize, setFileSize] = useState(0);
  const viewerRef = useRef<HTMLElement>(null);
  const retryCount = useRef(0);

  // Load model from git HEAD
  const loadModel = useCallback(async () => {
    setLoading(true);
    setFetchError(null);
    setProgress(0);
    setModelReady(false);
    setContextLost(false);

    try {
      const result = await commands.readRepoFile(filePath);
      if (result.status !== "ok") {
        setFetchError(getErrorMessage(result.error));
        setLoading(false);
        return;
      }

      const { content, isBinary, size } = result.data;
      setFileSize(size);

      if (!isBinary) {
        // .gltf files are JSON text — handle as text blob
        const ext = filePath.split(".").pop()?.toLowerCase();
        const mime = ext === "gltf" ? "model/gltf+json" : "model/gltf-binary";
        const blob = new Blob([content], { type: mime });
        const url = URL.createObjectURL(blob);
        setBlobUrl(url);
      } else {
        // Binary (.glb) — decode base64 to ArrayBuffer
        const binaryString = atob(content);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }

        const ext = filePath.split(".").pop()?.toLowerCase();
        const mime = ext === "gltf" ? "model/gltf+json" : "model/gltf-binary";
        const blob = new Blob([bytes.buffer], { type: mime });
        const url = URL.createObjectURL(blob);
        setBlobUrl(url);
      }

      setLoading(false);
    } catch (err) {
      setFetchError(err instanceof Error ? err.message : "Failed to load model");
      setLoading(false);
    }
  }, [filePath]);

  // Initial load
  useEffect(() => {
    loadModel();
    return () => {
      // Cleanup blob URL on unmount
      setBlobUrl((prev) => {
        if (prev) URL.revokeObjectURL(prev);
        return null;
      });
    };
  }, [loadModel]);

  // model-viewer event listeners
  useEffect(() => {
    const viewer = viewerRef.current;
    if (!viewer || !blobUrl) return;

    const onProgress = (e: Event) => {
      const detail = (e as CustomEvent).detail;
      if (detail && typeof detail.totalProgress === "number") {
        setProgress(detail.totalProgress);
      }
    };

    const onLoad = () => {
      setModelReady(true);
      // Show interaction hint on first ever load
      const hintKey = "flowforge-3d-hint-seen";
      if (!localStorage.getItem(hintKey)) {
        setShowHint(true);
        localStorage.setItem(hintKey, "true");
      }
    };

    const onError = () => {
      setFetchError("Failed to render 3D model");
    };

    viewer.addEventListener("progress", onProgress);
    viewer.addEventListener("load", onLoad);
    viewer.addEventListener("error", onError);

    return () => {
      viewer.removeEventListener("progress", onProgress);
      viewer.removeEventListener("load", onLoad);
      viewer.removeEventListener("error", onError);
    };
  }, [blobUrl]);

  // WebGL context loss detection
  useEffect(() => {
    const viewer = viewerRef.current;
    if (!viewer) return;

    // model-viewer uses Shadow DOM — access canvas via shadowRoot
    const checkCanvas = () => {
      const canvas = viewer.shadowRoot?.querySelector("canvas");
      if (!canvas) return;

      const handleContextLost = (e: Event) => {
        e.preventDefault();
        setContextLost(true);
      };

      const handleContextRestored = () => {
        setContextLost(false);
      };

      canvas.addEventListener("webglcontextlost", handleContextLost);
      canvas.addEventListener("webglcontextrestored", handleContextRestored);

      return () => {
        canvas.removeEventListener("webglcontextlost", handleContextLost);
        canvas.removeEventListener("webglcontextrestored", handleContextRestored);
      };
    };

    // Canvas may not be immediately available — observe
    const interval = setInterval(() => {
      const cleanup = checkCanvas();
      if (cleanup) {
        clearInterval(interval);
        // Store cleanup for unmount
        return cleanup;
      }
    }, 200);

    return () => clearInterval(interval);
  }, [blobUrl]);

  // Auto-hide interaction hint
  useEffect(() => {
    if (!showHint) return;
    const timer = setTimeout(() => setShowHint(false), 4000);
    return () => clearTimeout(timer);
  }, [showHint]);

  // Hide hint on first interaction
  const handleInteraction = useCallback(() => {
    if (showHint) setShowHint(false);
  }, [showHint]);

  // Retry handler
  const handleRetry = useCallback(() => {
    retryCount.current += 1;
    // Revoke old blob URL
    if (blobUrl) URL.revokeObjectURL(blobUrl);
    setBlobUrl(null);
    loadModel();
  }, [blobUrl, loadModel]);

  // Export metadata toggle for registration's renderTrailing
  // Store it on the component for the registration to access
  Viewer3dBlade.showMetadata = showMetadata;
  Viewer3dBlade.setShowMetadata = setShowMetadata;

  if (loading) {
    return <BladeContentLoading />;
  }

  if (fetchError) {
    return (
      <BladeContentError
        message="Failed to load 3D model"
        detail={fetchError}
        onRetry={handleRetry}
      />
    );
  }

  if (!blobUrl) {
    return (
      <BladeContentEmpty
        icon={Box}
        message="3D model not found at HEAD"
        detail={filePath}
      />
    );
  }

  // WebGL context lost state
  if (contextLost) {
    return (
      <div className="flex-1 flex flex-col items-center justify-center bg-ctp-mantle gap-4" role="alert">
        <Box className="w-12 h-12 text-ctp-overlay0" />
        <p className="text-sm text-ctp-subtext0">3D rendering context lost</p>
        <p className="text-xs text-ctp-overlay0">WebGL context was lost</p>
        {retryCount.current > 0 && (
          <p className="text-xs text-ctp-overlay0">
            If this keeps happening, your GPU may not support WebGL
          </p>
        )}
        <button
          type="button"
          onClick={handleRetry}
          className="flex items-center gap-1.5 px-3 py-1.5 text-xs text-ctp-subtext1 bg-ctp-surface0 hover:bg-ctp-surface1 rounded transition-colors"
        >
          <RotateCcw className="w-3.5 h-3.5" />
          Reload 3D View
        </button>
      </div>
    );
  }

  const fileName = filePath.split("/").pop() || "3D Model";
  const ext = filePath.split(".").pop()?.toLowerCase();
  const formatLabel = ext === "gltf" ? "GLTF (JSON)" : "GLTF Binary (.glb)";

  return (
    <div
      className="flex-1 flex flex-col overflow-hidden h-full relative"
      onPointerDown={handleInteraction}
      onWheel={handleInteraction}
      aria-busy={!modelReady}
    >
      {/* Collapsible metadata panel */}
      {showMetadata && (
        <div className="bg-ctp-crust/90 backdrop-blur-sm border-b border-ctp-surface0 px-4 py-2 shrink-0">
          <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-xs max-w-md">
            <div>
              <span className="text-ctp-overlay0">Format: </span>
              <span className="text-ctp-subtext1">{formatLabel}</span>
            </div>
            <div>
              <span className="text-ctp-overlay0">Size: </span>
              <span className="text-ctp-subtext1">{formatFileSize(fileSize)}</span>
            </div>
          </div>
        </div>
      )}

      {/* Loading progress overlay */}
      {!modelReady && (
        <div className="absolute inset-0 flex flex-col items-center justify-center gap-3 bg-ctp-mantle z-10">
          <Box className="w-8 h-8 text-ctp-overlay0" />
          <div className="w-48 h-1.5 bg-ctp-surface0 rounded-full overflow-hidden">
            <div
              className="h-full bg-ctp-blue rounded-full transition-[width] duration-150"
              style={{ width: `${Math.round(progress * 100)}%` }}
            />
          </div>
          <p className="text-xs text-ctp-overlay0">Loading model...</p>
        </div>
      )}

      {/* model-viewer element */}
      <model-viewer
        ref={viewerRef as any}
        src={blobUrl}
        alt={fileName}
        camera-controls
        auto-rotate
        shadow-intensity="1"
        environment-image="neutral"
        style={{
          width: "100%",
          height: "100%",
          flex: 1,
          background: `linear-gradient(to bottom, var(--ctp-base), var(--ctp-mantle))`,
          opacity: modelReady ? 1 : 0,
          transition: "opacity 200ms ease-out",
        }}
      />

      {/* First-time interaction hint */}
      {showHint && modelReady && (
        <div className="absolute bottom-4 left-1/2 -translate-x-1/2 z-20 motion-safe:animate-[fadeOut_0.3s_ease-out_3.5s_forwards]">
          <div className="text-xs text-ctp-text/80 bg-ctp-base/60 backdrop-blur-sm rounded-lg px-4 py-2 flex items-center gap-3">
            <span>Drag to orbit</span>
            <span className="text-ctp-overlay0">|</span>
            <span>Scroll to zoom</span>
            <span className="text-ctp-overlay0">|</span>
            <span>Shift+drag to pan</span>
          </div>
        </div>
      )}
    </div>
  );
}

// Static properties for metadata toggle (used by registration renderTrailing)
Viewer3dBlade.showMetadata = false;
Viewer3dBlade.setShowMetadata = (() => {}) as React.Dispatch<React.SetStateAction<boolean>>;

function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
```

**Important notes**:

1. The `import "@google/model-viewer"` is a side-effect import that registers the `<model-viewer>` custom element. It MUST be inside this lazy-loaded file (not at the top level) so the 500KB+ Three.js bundle is only loaded when a user opens a 3D model.

2. The metadata toggle state (`showMetadata`, `setShowMetadata`) needs to be accessible from the registration's `renderTrailing` callback. Since the registration callback receives props (not component state), we use a simpler approach: the metadata toggle button is rendered inside the component itself rather than in `renderTrailing`. This avoids the complexity of bridging component state to the registration.

**Revised approach**: Instead of the static property hack above, move the metadata toggle button INSIDE the component. Remove the static properties and update the implementation to include the toggle in the blade's own UI.

Replace the metadata toggle approach: Add the Info toggle button inside the component's metadata panel area, OR place it as a fixed button inside the component rather than in the registration's `renderTrailing`. The simpler approach:

Add a small toggle button in the top-right corner of the 3D viewport:

```tsx
{/* Metadata toggle button (positioned inside the viewport) */}
{modelReady && (
  <button
    type="button"
    onClick={() => setShowMetadata((v) => !v)}
    className="absolute top-2 right-2 z-20 p-1.5 rounded bg-ctp-surface0/60 hover:bg-ctp-surface0 text-ctp-overlay1 hover:text-ctp-text transition-colors backdrop-blur-sm"
    aria-label={showMetadata ? "Hide metadata" : "Show metadata"}
  >
    <Info className="w-4 h-4" />
  </button>
)}
```

Place this inside the relative container div, after the model-viewer element.

Remove the static property hack (`Viewer3dBlade.showMetadata = ...`) entirely.

</task>

<task id="2" title="Update viewer-3d registration with renderTitleContent" depends_on="1">

**File**: `src/components/blades/registrations/viewer-3d.ts`

Update the registration to use `renderPathTitle`:

```ts
import { lazy } from "react";
import { registerBlade } from "../../../lib/bladeRegistry";
import { renderPathTitle } from "../../../lib/bladeUtils";

const Viewer3dBlade = lazy(() =>
  import("../Viewer3dBlade").then((m) => ({
    default: m.Viewer3dBlade,
  })),
);

registerBlade<{ filePath: string }>({
  type: "viewer-3d",
  defaultTitle: (props) => props.filePath.split("/").pop() || "3D Model",
  component: Viewer3dBlade,
  lazy: true,
  renderTitleContent: (props) => renderPathTitle(props.filePath),
});
```

Note: The metadata toggle is handled inside the component (not via `renderTrailing`), keeping the registration simple.

</task>

<task id="3" title="Add fadeOut keyframe for hint overlay" depends_on="1">

**File**: `src/index.css`

Add a `fadeOut` keyframe if not already present (used by the interaction hint overlay):

```css
@keyframes fadeOut {
    from {
        opacity: 1;
    }
    to {
        opacity: 0;
    }
}
```

Place this after the existing `gentle-pulse` keyframes. This is used as `animate-[fadeOut_0.3s_ease-out_3.5s_forwards]` — Tailwind's arbitrary animation syntax with a 3.5s delay.

</task>

## Verification

- [ ] Opening a `.glb` file shows a 3D model with orbit controls (drag to rotate)
- [ ] The model auto-rotates on initial load (stops when user interacts)
- [ ] Background is a gradient from `--ctp-base` to `--ctp-mantle`
- [ ] Loading shows a progress bar that fills from 0% to 100%
- [ ] After loading, the model fades in smoothly (opacity transition)
- [ ] The Info button toggles a metadata panel showing format and file size
- [ ] The metadata panel has a semi-transparent blurred background
- [ ] First-time load shows an interaction hint ("Drag to orbit | Scroll to zoom | Shift+drag to pan")
- [ ] The hint fades out after ~4 seconds or immediately on first interaction
- [ ] The hint only shows once (subsequent visits skip it via localStorage flag)
- [ ] If WebGL context is lost, a retry UI appears with "Reload 3D View" button
- [ ] Clicking retry re-fetches the model and re-renders it
- [ ] If retry fails again, additional text warns about GPU support
- [ ] The `model-viewer` element has `alt={filename}` for accessibility
- [ ] The loading container has `aria-busy="true"`, the error state has `role="alert"`
- [ ] Blob URL is cleaned up on unmount (no memory leaks)
- [ ] The blade header shows the path/filename split
- [ ] `npx tsc --noEmit` completes with no new errors
