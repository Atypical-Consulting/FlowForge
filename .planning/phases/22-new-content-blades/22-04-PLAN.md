---
phase: 22
plan: 22-04
title: Viewer-Markdown Blade — Full Markdown Rendering with GFM, Syntax Highlighting, Copy Code, Link/Image Handling
wave: 2
depends_on: [22-01, 22-02, 22-03]
files_modified:
  - src/components/blades/ViewerMarkdownBlade.tsx
  - src/components/markdown/MarkdownRenderer.tsx (new)
  - src/components/markdown/MarkdownLink.tsx (new)
  - src/components/markdown/MarkdownImage.tsx (new)
  - src/components/markdown/CopyCodeButton.tsx (new)
  - src/components/markdown/markdownComponents.tsx (new)
  - src/components/blades/registrations/viewer-markdown.ts
autonomous: true
---

# Viewer-Markdown Blade — Full Markdown Rendering with GFM, Syntax Highlighting, Copy Code, Link/Image Handling

## Goal

Replace the placeholder ViewerMarkdownBlade with a fully functional markdown renderer that supports GitHub Flavored Markdown (tables, task lists, syntax-highlighted code blocks), Catppuccin-themed syntax highlighting, a copy-code button on code blocks, custom link handling (external -> system browser, relative .md -> replaceBlade, other -> pushBlade repo-browser), and inline image rendering from git HEAD. This fulfills requirement CONTENT-01.

## must_haves

- Markdown files render with GFM support: tables, task lists, strikethrough, autolinks
- Code blocks have syntax highlighting using Catppuccin Mocha theme colors
- Every `<pre>` code block has a visible "Copy code" button that copies to clipboard
- External links (https://) open in the system browser via Tauri opener plugin
- Relative `.md` links replace the current blade with a new markdown viewer
- Other relative links push a repo-browser blade
- Images with relative paths load from git HEAD via `readRepoFile` and display as base64 data URLs
- XSS protection via `rehype-sanitize` with GitHub schema, allowing `hljs-*` classes
- Content is styled with Catppuccin color tokens (not @tailwindcss/typography)
- Loading state shows `BladeContentLoading`, error state shows `BladeContentError`
- Focus management: after relative link navigation, focus moves to content start
- The `MarkdownRenderer` component is reusable (also used by DiffBlade in Plan 22-07)

## Tasks

<task id="1" title="Create CopyCodeButton component">

**File**: Create `src/components/markdown/CopyCodeButton.tsx`

```tsx
import { Check, Copy } from "lucide-react";
import { useCallback, useState } from "react";

interface CopyCodeButtonProps {
  code: string;
}

/**
 * Copy-to-clipboard button for code blocks.
 * Shows a checkmark confirmation for 2 seconds after copying.
 */
export function CopyCodeButton({ code }: CopyCodeButtonProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = useCallback(async () => {
    try {
      await navigator.clipboard.writeText(code);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch {
      // Clipboard API may fail in some contexts — fail silently
    }
  }, [code]);

  return (
    <button
      type="button"
      onClick={handleCopy}
      className="absolute top-2 right-2 p-1.5 rounded bg-ctp-surface0/80 hover:bg-ctp-surface1 text-ctp-overlay1 hover:text-ctp-text transition-colors"
      aria-label={copied ? "Copied" : "Copy code"}
    >
      {copied ? (
        <Check className="w-3.5 h-3.5 text-ctp-green" />
      ) : (
        <Copy className="w-3.5 h-3.5" />
      )}
    </button>
  );
}
```

</task>

<task id="2" title="Create MarkdownLink component">

**File**: Create `src/components/markdown/MarkdownLink.tsx`

This component handles the three link behaviors: external, relative .md, and other relative.

```tsx
import { openUrl } from "@tauri-apps/plugin-opener";
import type { AnchorHTMLAttributes } from "react";
import { useBladeStore } from "../../stores/blades";
import { resolveRelativePath } from "../../lib/resolveRelativePath";

interface MarkdownLinkProps extends AnchorHTMLAttributes<HTMLAnchorElement> {
  /** Current file path for resolving relative links */
  currentFilePath: string;
}

export function MarkdownLink({
  href,
  children,
  currentFilePath,
  ...props
}: MarkdownLinkProps) {
  const store = useBladeStore();

  const handleClick = async (e: React.MouseEvent) => {
    e.preventDefault();
    if (!href) return;

    // Anchor links (same page)
    if (href.startsWith("#")) {
      // Scroll to heading — not implemented for v1, just ignore
      return;
    }

    // External links
    if (href.startsWith("http://") || href.startsWith("https://")) {
      await openUrl(href);
      return;
    }

    // Relative links
    const resolvedPath = resolveRelativePath(currentFilePath, href);

    if (href.endsWith(".md") || href.endsWith(".mdx")) {
      // Markdown link → replace current blade
      store.replaceBlade({
        type: "viewer-markdown",
        title: resolvedPath.split("/").pop() || "Markdown",
        props: { filePath: resolvedPath },
      });
    } else {
      // Other file/directory → push repo browser
      store.pushBlade({
        type: "repo-browser",
        title: resolvedPath.split("/").pop() || "Browser",
        props: { path: resolvedPath },
      });
    }
  };

  return (
    <a
      href={href}
      onClick={handleClick}
      className="text-ctp-blue hover:text-ctp-sapphire underline underline-offset-2 cursor-pointer"
      {...props}
    >
      {children}
    </a>
  );
}
```

</task>

<task id="3" title="Create MarkdownImage component">

**File**: Create `src/components/markdown/MarkdownImage.tsx`

This component loads relative images from git HEAD via `readRepoFile`.

```tsx
import { useEffect, useState } from "react";
import { commands } from "../../bindings";
import { resolveRelativePath } from "../../lib/resolveRelativePath";

interface MarkdownImageProps {
  src?: string;
  alt?: string;
  currentFilePath: string;
}

/**
 * Custom image component for markdown rendering.
 * External/data URLs are used directly.
 * Relative paths are fetched from git HEAD via readRepoFile.
 */
export function MarkdownImage({ src, alt, currentFilePath }: MarkdownImageProps) {
  const [imageSrc, setImageSrc] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(false);

  useEffect(() => {
    if (!src) {
      setLoading(false);
      setError(true);
      return;
    }

    // External or data URL — use directly
    if (
      src.startsWith("http://") ||
      src.startsWith("https://") ||
      src.startsWith("data:")
    ) {
      setImageSrc(src);
      setLoading(false);
      return;
    }

    // Relative path — fetch from git HEAD
    let cancelled = false;
    const load = async () => {
      try {
        const resolvedPath = resolveRelativePath(currentFilePath, src);
        const result = await commands.readRepoFile(resolvedPath);
        if (cancelled) return;

        if (result.status === "ok") {
          const { content, isBinary } = result.data;
          const ext = resolvedPath.split(".").pop()?.toLowerCase() || "png";

          if (isBinary) {
            // Binary image: content is base64
            const mime =
              ext === "svg"
                ? "image/svg+xml"
                : `image/${ext === "jpg" ? "jpeg" : ext}`;
            setImageSrc(`data:${mime};base64,${content}`);
          } else if (ext === "svg") {
            // SVG is text, not binary — encode as data URI
            const encoded = btoa(unescape(encodeURIComponent(content)));
            setImageSrc(`data:image/svg+xml;base64,${encoded}`);
          } else {
            // Unexpected text content for an image
            setError(true);
          }
        } else {
          setError(true);
        }
      } catch {
        if (!cancelled) setError(true);
      }
      if (!cancelled) setLoading(false);
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [src, currentFilePath]);

  if (loading) {
    return (
      <span className="inline-block w-5 h-5 animate-spin rounded-full border-2 border-ctp-overlay0 border-t-transparent align-middle" />
    );
  }

  if (error || !imageSrc) {
    return (
      <span className="text-ctp-overlay0 text-xs italic">
        [image: {alt || "unavailable"}]
      </span>
    );
  }

  return (
    <img
      src={imageSrc}
      alt={alt || ""}
      className="max-w-full rounded my-2"
    />
  );
}
```

</task>

<task id="4" title="Create markdownComponents with Catppuccin styling" depends_on="1">

**File**: Create `src/components/markdown/markdownComponents.tsx`

This module exports a factory function that creates the `components` prop for react-markdown, parameterized by the current file path (needed for link and image resolution).

```tsx
import type { Components } from "react-markdown";
import { cn } from "../../lib/utils";
import { CopyCodeButton } from "./CopyCodeButton";
import { MarkdownLink } from "./MarkdownLink";
import { MarkdownImage } from "./MarkdownImage";

/**
 * Create Catppuccin-styled component overrides for react-markdown.
 *
 * @param currentFilePath - The file being rendered (for resolving relative links/images)
 */
export function createMarkdownComponents(
  currentFilePath: string,
): Components {
  return {
    // Headings
    h1: ({ children, ...props }) => (
      <h1
        className="text-2xl font-bold text-ctp-text mt-6 mb-3 pb-2 border-b border-ctp-surface1"
        {...props}
      >
        {children}
      </h1>
    ),
    h2: ({ children, ...props }) => (
      <h2
        className="text-xl font-semibold text-ctp-text mt-5 mb-2 pb-1 border-b border-ctp-surface0"
        {...props}
      >
        {children}
      </h2>
    ),
    h3: ({ children, ...props }) => (
      <h3
        className="text-lg font-semibold text-ctp-subtext1 mt-4 mb-2"
        {...props}
      >
        {children}
      </h3>
    ),
    h4: ({ children, ...props }) => (
      <h4 className="text-base font-semibold text-ctp-subtext1 mt-3 mb-1" {...props}>
        {children}
      </h4>
    ),
    h5: ({ children, ...props }) => (
      <h5 className="text-sm font-semibold text-ctp-subtext0 mt-3 mb-1" {...props}>
        {children}
      </h5>
    ),
    h6: ({ children, ...props }) => (
      <h6 className="text-sm font-medium text-ctp-overlay1 mt-2 mb-1" {...props}>
        {children}
      </h6>
    ),

    // Paragraphs
    p: ({ children, ...props }) => (
      <p className="text-sm text-ctp-text leading-relaxed mb-3" {...props}>
        {children}
      </p>
    ),

    // Tables
    table: ({ children, ...props }) => (
      <div className="overflow-x-auto my-4">
        <table className="w-full text-sm border-collapse" {...props}>
          {children}
        </table>
      </div>
    ),
    thead: ({ children, ...props }) => (
      <thead className="bg-ctp-surface0 text-ctp-subtext1" {...props}>
        {children}
      </thead>
    ),
    th: ({ children, ...props }) => (
      <th
        className="px-3 py-2 text-left font-medium border border-ctp-surface1"
        {...props}
      >
        {children}
      </th>
    ),
    td: ({ children, ...props }) => (
      <td
        className="px-3 py-2 border border-ctp-surface0 text-ctp-subtext0"
        {...props}
      >
        {children}
      </td>
    ),
    tr: ({ children, ...props }) => (
      <tr className="even:bg-ctp-surface0/30" {...props}>
        {children}
      </tr>
    ),

    // Code blocks with copy button
    pre: ({ children, ...props }) => {
      // Extract text content from children for the copy button
      const codeText = extractTextContent(children);
      return (
        <div className="relative group my-3">
          <pre
            className="bg-ctp-crust rounded-md p-4 overflow-x-auto text-sm"
            tabIndex={0}
            {...props}
          >
            {children}
          </pre>
          <CopyCodeButton code={codeText} />
        </div>
      );
    },

    // Inline and block code
    code: ({ children, className, ...props }) => {
      const isBlock =
        className?.includes("hljs") || className?.includes("language-");
      if (isBlock) {
        return (
          <code className={cn("font-mono", className)} {...props}>
            {children}
          </code>
        );
      }
      return (
        <code
          className="bg-ctp-surface0 text-ctp-peach px-1.5 py-0.5 rounded text-xs font-mono"
          {...props}
        >
          {children}
        </code>
      );
    },

    // Blockquote
    blockquote: ({ children, ...props }) => (
      <blockquote
        className="border-l-4 border-ctp-blue pl-4 my-3 text-ctp-subtext0 italic"
        {...props}
      >
        {children}
      </blockquote>
    ),

    // Lists
    ul: ({ children, ...props }) => (
      <ul
        className="list-disc pl-6 mb-3 space-y-1 text-sm text-ctp-text"
        {...props}
      >
        {children}
      </ul>
    ),
    ol: ({ children, ...props }) => (
      <ol
        className="list-decimal pl-6 mb-3 space-y-1 text-sm text-ctp-text"
        {...props}
      >
        {children}
      </ol>
    ),
    li: ({ children, ...props }) => (
      <li className="text-ctp-subtext1" {...props}>
        {children}
      </li>
    ),

    // Task list items (GFM)
    input: ({ type, checked, ...props }) => {
      if (type === "checkbox") {
        return (
          <input
            type="checkbox"
            checked={checked}
            readOnly
            className="mr-2 accent-ctp-blue align-middle"
            {...props}
          />
        );
      }
      return <input type={type} {...props} />;
    },

    // Horizontal rule
    hr: (props) => <hr className="my-6 border-ctp-surface1" {...props} />,

    // Strong/em
    strong: ({ children, ...props }) => (
      <strong className="font-semibold text-ctp-text" {...props}>
        {children}
      </strong>
    ),
    em: ({ children, ...props }) => (
      <em className="italic text-ctp-subtext1" {...props}>
        {children}
      </em>
    ),

    // Links — custom handler
    a: ({ href, children, ...props }) => (
      <MarkdownLink
        href={href}
        currentFilePath={currentFilePath}
        {...props}
      >
        {children}
      </MarkdownLink>
    ),

    // Images — custom handler
    img: ({ src, alt, ...props }) => (
      <MarkdownImage
        src={src}
        alt={alt}
        currentFilePath={currentFilePath}
        {...(props as any)}
      />
    ),
  };
}

/**
 * Extract text content from React children (for code block copy button).
 * Recursively extracts text from nested elements.
 */
function extractTextContent(children: React.ReactNode): string {
  if (typeof children === "string") return children;
  if (typeof children === "number") return String(children);
  if (Array.isArray(children)) return children.map(extractTextContent).join("");
  if (children && typeof children === "object" && "props" in children) {
    return extractTextContent((children as any).props?.children);
  }
  return "";
}
```

</task>

<task id="5" title="Create MarkdownRenderer component" depends_on="4">

**File**: Create `src/components/markdown/MarkdownRenderer.tsx`

This is the reusable component that wires up react-markdown with all plugins and custom components.

```tsx
import Markdown from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeHighlight from "rehype-highlight";
import rehypeSanitize, { defaultSchema } from "rehype-sanitize";
import "@catppuccin/highlightjs/css/catppuccin-mocha.css";
import { useMemo } from "react";
import { createMarkdownComponents } from "./markdownComponents";

/**
 * Sanitize schema that allows highlight.js class names.
 * Based on GitHub's default schema with hljs-* and language-* classes allowed.
 */
const sanitizeSchema = {
  ...defaultSchema,
  attributes: {
    ...defaultSchema.attributes,
    code: [
      ...(defaultSchema.attributes?.code || []),
      ["className", /^hljs-/, /^language-/],
    ],
    span: [
      ...(defaultSchema.attributes?.span || []),
      ["className", /^hljs-/],
    ],
  },
};

interface MarkdownRendererProps {
  /** Markdown content string */
  content: string;
  /** Current file path for resolving relative links/images. Empty string if not file-based. */
  currentFilePath?: string;
  /** Additional CSS class for the wrapper */
  className?: string;
}

/**
 * Reusable markdown renderer with GFM support, syntax highlighting,
 * XSS sanitization, and Catppuccin-themed styling.
 *
 * Used by:
 * - ViewerMarkdownBlade (standalone markdown file preview)
 * - DiffBlade (markdown toggle preview)
 */
export function MarkdownRenderer({
  content,
  currentFilePath = "",
  className,
}: MarkdownRendererProps) {
  const components = useMemo(
    () => createMarkdownComponents(currentFilePath),
    [currentFilePath],
  );

  return (
    <div className={className}>
      <Markdown
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[
          rehypeHighlight,
          [rehypeSanitize, sanitizeSchema],
        ]}
        components={components}
      >
        {content}
      </Markdown>
    </div>
  );
}
```

**Important**: Plugin order matters. `rehypeHighlight` must come BEFORE `rehypeSanitize` so that highlight.js class names (`hljs-*`) are already applied before sanitization runs. The sanitize schema then allows those classes through.

</task>

<task id="6" title="Replace ViewerMarkdownBlade placeholder" depends_on="5">

**File**: `src/components/blades/ViewerMarkdownBlade.tsx`

Replace the entire file with the full implementation:

```tsx
import { FileText } from "lucide-react";
import { useEffect, useRef } from "react";
import { useRepoFile } from "../../hooks/useRepoFile";
import { BladeContentLoading } from "./BladeContentLoading";
import { BladeContentError } from "./BladeContentError";
import { BladeContentEmpty } from "./BladeContentEmpty";
import { MarkdownRenderer } from "../markdown/MarkdownRenderer";

interface ViewerMarkdownBladeProps {
  filePath: string;
}

export function ViewerMarkdownBlade({ filePath }: ViewerMarkdownBladeProps) {
  const { data, isLoading, error, refetch } = useRepoFile(filePath);
  const containerRef = useRef<HTMLDivElement>(null);

  // Focus management: after mounting (including after replaceBlade navigation),
  // move focus to the content container for keyboard users.
  useEffect(() => {
    containerRef.current?.focus();
  }, [filePath]);

  if (isLoading) {
    return <BladeContentLoading />;
  }

  if (error) {
    return (
      <BladeContentError
        message="Failed to load markdown"
        detail={error.message}
        onRetry={() => refetch()}
      />
    );
  }

  if (!data || data.isBinary) {
    return (
      <BladeContentEmpty
        icon={FileText}
        message="File not found at HEAD"
        detail={filePath}
      />
    );
  }

  return (
    <div
      ref={containerRef}
      tabIndex={-1}
      className="flex-1 overflow-y-auto h-full bg-ctp-base outline-none"
    >
      <div className="p-6 max-w-3xl mx-auto">
        <MarkdownRenderer
          content={data.content}
          currentFilePath={filePath}
        />
      </div>
    </div>
  );
}
```

</task>

<task id="7" title="Update viewer-markdown registration with renderTitleContent" depends_on="6">

**File**: `src/components/blades/registrations/viewer-markdown.ts`

Update the registration to use the shared `renderPathTitle` utility for the title display:

```ts
import { lazy } from "react";
import { registerBlade } from "../../../lib/bladeRegistry";
import { renderPathTitle } from "../../../lib/bladeUtils";

const ViewerMarkdownBlade = lazy(() =>
  import("../ViewerMarkdownBlade").then((m) => ({
    default: m.ViewerMarkdownBlade,
  })),
);

registerBlade<{ filePath: string }>({
  type: "viewer-markdown",
  defaultTitle: (props) => props.filePath.split("/").pop() || "Markdown",
  component: ViewerMarkdownBlade,
  lazy: true,
  renderTitleContent: (props) => renderPathTitle(props.filePath),
});
```

</task>

## Verification

- [ ] Opening a `.md` file from the repo browser or staging view shows rendered markdown with proper heading hierarchy
- [ ] GFM tables render with styled borders and alternating row backgrounds
- [ ] GFM task lists render with checkboxes (read-only)
- [ ] Code blocks have syntax highlighting in Catppuccin Mocha colors
- [ ] Each code block has a visible "Copy" button that copies code to clipboard and shows a checkmark
- [ ] Clicking an external link (https://...) opens the system browser
- [ ] Clicking a relative `.md` link replaces the current blade (not push)
- [ ] Clicking any other relative link pushes a repo-browser blade
- [ ] Relative images load and display inline from git HEAD
- [ ] The blade header shows the path/filename split (e.g., dimmed `docs/` bold `README.md`)
- [ ] Loading state shows a centered spinner; error state shows error with retry button
- [ ] HTML injection in markdown content is sanitized (test with `<script>alert('xss')</script>` in .md)
- [ ] Focus moves to content start after navigating a relative .md link
- [ ] `npx tsc --noEmit` completes with no new errors
