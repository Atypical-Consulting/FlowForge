---
phase: 22-new-content-blades
plan: 21
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/blades/Viewer3dBlade.tsx
  - package.json
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "3D model (.glb) loads and renders with orbit controls from the repo browser"
    - "User can orbit, zoom, and pan the 3D model"
    - "Loading progress indicator shows while model loads"
    - "WebGL-not-supported error is shown clearly if WebGL is unavailable"
  artifacts:
    - path: "src/components/blades/Viewer3dBlade.tsx"
      provides: "Three.js-based 3D model viewer"
      contains: "GLTFLoader"
    - path: "package.json"
      provides: "three dependency"
      contains: "three"
  key_links:
    - from: "src/components/blades/Viewer3dBlade.tsx"
      to: "three"
      via: "import { Scene, WebGLRenderer, PerspectiveCamera } from 'three'"
      pattern: "from ['\"]three['\"]"
    - from: "src/components/blades/Viewer3dBlade.tsx"
      to: "three/addons"
      via: "GLTFLoader and OrbitControls imports"
      pattern: "GLTFLoader|OrbitControls"
    - from: "src/components/blades/Viewer3dBlade.tsx"
      to: "commands.readRepoFile"
      via: "Tauri command for file content"
      pattern: "commands\\.readRepoFile"
---

<objective>
Replace @google/model-viewer with direct Three.js + GLTFLoader to fix the 3D model viewer blocker in Tauri's WKWebView.

Purpose: Close gap 1 (blocker) from 22-wave7-UAT.md. @google/model-viewer detects Tauri's WKWebView as iOS WKWebView (window.webkit.messageHandlers is truthy), entering unsupported code paths that crash during module evaluation. model-viewer is officially unsupported in webviews. Direct Three.js eliminates the WKWebView misdetection, Lit Element shadow DOM, web component registration, and the 48K-line bundle overhead.
Output: Working 3D model viewer that loads .glb/.gltf files with orbit controls.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/3d-model-wave7.md
@src/components/blades/Viewer3dBlade.tsx
@src/components/blades/registrations/viewer-3d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install three.js and remove model-viewer</name>
  <files>package.json</files>
  <action>
    Run: `npm install three @types/three && npm uninstall @google/model-viewer`

    This adds Three.js (which includes GLTFLoader and OrbitControls in `three/addons/`) and removes the problematic model-viewer package.

    After installing, verify the three package version is recent (r160+) and that `three/addons/loaders/GLTFLoader.js` exists in node_modules.

    Also remove any model-viewer type declarations if they exist (check for `src/types/model-viewer.d.ts` or similar -- delete if found).
  </action>
  <verify>
    `npm ls three` shows three installed.
    `npm ls @google/model-viewer` shows it is NOT installed (error/empty).
    `ls node_modules/three/examples/jsm/loaders/GLTFLoader.js` exists OR `ls node_modules/three/src/loaders/` confirms loader availability.
  </verify>
  <done>three.js is installed, @google/model-viewer is removed from package.json and node_modules.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite Viewer3dBlade with Three.js + GLTFLoader</name>
  <files>src/components/blades/Viewer3dBlade.tsx</files>
  <action>
    Completely rewrite Viewer3dBlade.tsx to use Three.js directly instead of `<model-viewer>` web component.

    **Imports:**
    ```
    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    ```
    If the `three/addons/` path doesn't work (depends on three.js version), use `three/examples/jsm/loaders/GLTFLoader` and `three/examples/jsm/controls/OrbitControls` instead.

    **Core architecture:**
    1. Use a `<canvas>` element with a ref. The canvas wrapper div should have `className="h-full overflow-hidden relative"` (matching the pattern from gap 3 fix -- parent is NOT a flex container, use h-full).
    2. In a `useEffect`, create:
       - `WebGLRenderer` with `{ canvas, antialias: true, alpha: true }` and set pixelRatio to `window.devicePixelRatio`
       - `PerspectiveCamera` (fov 45, near 0.1, far 1000)
       - `Scene` with a subtle gradient background matching Catppuccin theme: use `scene.background = new THREE.Color("#1e1e2e")` (ctp-base) or a gradient via renderer.setClearColor
       - `OrbitControls` attached to camera + canvas, with `enableDamping: true`
       - Lighting: `AmbientLight(0xffffff, 0.6)` + `DirectionalLight(0xffffff, 0.8)` positioned at (5, 10, 7.5) + a softer fill light from opposite side `DirectionalLight(0xffffff, 0.3)` at (-5, 5, -5)
    3. Animation loop via `requestAnimationFrame` -- update controls, render scene. Store the animation frame ID for cleanup.
    4. Resize handling: use `ResizeObserver` on the canvas container div. On resize, update camera aspect ratio, camera.updateProjectionMatrix(), renderer.setSize(width, height).
    5. Cleanup on unmount: dispose renderer, controls, scene geometries/materials, cancel animation frame, disconnect ResizeObserver.

    **Model loading pipeline (preserve existing logic):**
    1. Keep the existing `loadModel` flow that calls `commands.readRepoFile(filePath)` and decodes base64 via atob for binary files.
    2. Instead of creating a blob URL for model-viewer, pass the binary data directly to GLTFLoader:
       ```typescript
       const loader = new GLTFLoader();
       const arrayBuffer = bytes.buffer; // from the existing Uint8Array
       loader.parse(arrayBuffer, "", (gltf) => {
         // Center and scale the model
         const box = new THREE.Box3().setFromObject(gltf.scene);
         const center = box.getCenter(new THREE.Vector3());
         const size = box.getSize(new THREE.Vector3());
         const maxDim = Math.max(size.x, size.y, size.z);
         const scale = 2 / maxDim; // normalize to fit in view
         gltf.scene.scale.multiplyScalar(scale);
         gltf.scene.position.sub(center.multiplyScalar(scale));
         scene.add(gltf.scene);
         // Position camera
         camera.position.set(0, 1, 3);
         controls.target.set(0, 0, 0);
         controls.update();
         setModelReady(true);
       }, (error) => {
         setFetchError(error.message || "Failed to parse 3D model");
       });
       ```
    3. For .gltf (JSON text) files: convert the text content string to ArrayBuffer via `new TextEncoder().encode(content).buffer` before passing to `loader.parse()`.

    **State management (preserve existing UX patterns):**
    - `loading` / `BladeContentLoading` while fetching from git
    - `fetchError` / `BladeContentError` with retry button
    - `modelReady` for hiding loading overlay and showing metadata button
    - `progress` -- Three.js GLTFLoader doesn't provide granular progress for in-memory parsing, so show an indeterminate loading state (use the existing pulsing animation or a spinner instead of progress bar)
    - `contextLost` -- attach `webglcontextlost` and `webglcontextrestored` events directly to the canvas element (no Shadow DOM polling needed!)
    - `showMetadata` / `showHint` -- keep the existing overlay UI for metadata and interaction hint
    - `retryCount` / `handleRetry` -- keep existing retry logic

    **Preserve all existing UI elements:**
    - Metadata panel (format, file size)
    - Loading overlay with progress/spinner
    - WebGL context lost state with retry button
    - First-time interaction hint (drag to orbit, scroll to zoom, shift+drag to pan)
    - Metadata toggle button (Info icon, top-right)

    **Do NOT change:**
    - `src/components/blades/registrations/viewer-3d.ts` -- the lazy import and registration are fine
    - The overall component interface (`Viewer3dBladeProps` with `filePath: string`)
    - The existing error handling patterns (BladeContentError, BladeContentLoading, BladeContentEmpty)

    **Key difference from model-viewer approach:**
    - No web component, no Shadow DOM, no Lit Element
    - Direct canvas access -- WebGL context loss is detected natively via canvas events
    - No IntersectionObserver-based lazy loading issues
    - No WKWebView misdetection
    - Smaller bundle: only Three.js core + GLTFLoader + OrbitControls
  </action>
  <verify>
    1. `npx tsc --noEmit 2>&1 | grep -v "bindings.ts"` -- no new TypeScript errors
    2. `npm run build` completes without errors (Vite bundles Three.js correctly)
    3. Open a .glb file from the repo browser -- 3D model renders with orbit controls
    4. Drag to orbit, scroll to zoom, shift+drag to pan -- all work
    5. Metadata button (Info icon) shows format and file size
    6. Loading state shows while model loads
    7. If no .glb test file is available, at minimum verify: build succeeds, component mounts without crash, WebGL check runs
  </verify>
  <done>3D model viewer renders .glb/.gltf files using Three.js directly. Orbit controls work. No WKWebView misdetection. model-viewer dependency fully removed.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit 2>&1 | grep -v "bindings.ts"` -- no new errors
2. `npm run build` succeeds
3. `npm ls @google/model-viewer` shows NOT installed
4. `npm ls three` shows installed
5. Open .glb file from repo browser -- model renders with orbit/zoom/pan
6. Loading overlay shows during model fetch
7. Retry button works on error state
8. No console errors related to model-viewer, WKWebView, or customElements
</verification>

<success_criteria>
- 3D model (.glb) loads and renders in Tauri WKWebView without errors
- User can orbit, zoom, and pan the model
- @google/model-viewer is fully removed from the project
- Three.js is the only 3D dependency
- All existing UX (metadata, loading, error, retry, hint) preserved
</success_criteria>

<output>
After completion, create `.planning/phases/22-new-content-blades/22-21-SUMMARY.md`
</output>
