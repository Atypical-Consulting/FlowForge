---
phase: 22
plan: 22-01
title: Extensibility Refactoring — Type Safety, Auto-Registration, File Dispatch
wave: 1
depends_on: []
files_modified:
  - src/lib/bladeRegistry.ts
  - src/stores/bladeTypes.ts
  - src/components/blades/registrations/index.ts
  - src/lib/fileTypeUtils.ts
  - src/lib/fileDispatch.ts (new)
autonomous: true
---

# Extensibility Refactoring — Type Safety, Auto-Registration, File Dispatch

## Goal

Close the type-safety gaps in the blade registry system and establish declarative file dispatch so that future blade types can be added with minimal friction and maximum compile-time safety. This plan addresses the four extensibility gaps identified in the architecture research: `BladeRegistration.type` is `string` not `BladeType`, manual barrel file updates, hard-coded if/else file dispatch, and no dev-mode exhaustiveness check.

## must_haves

- `BladeRegistration.type` is constrained to `BladeType` — registering a non-existent type is a compile error
- `registrations/index.ts` uses `import.meta.glob` to auto-discover registration files — no manual import list
- `bladeTypeForFile()` uses a declarative `Map<string, BladeType>` instead of an if/else chain
- `bladeTypeForFile()` accepts a `context` parameter (`"diff" | "browse"`) with context-aware fallback
- A dev-mode exhaustiveness check warns when a `BladePropsMap` entry lacks a runtime registration
- `viewer-code` is added to `BladePropsMap` (type entry only; component in a later plan)
- `BladePropsMap` has a documentation comment explaining how to add a new blade type
- All existing blade registrations compile without changes (zero runtime impact)
- `getAllBladeTypes()` returns `BladeType[]` instead of `string[]`

## Tasks

<task id="1" title="Constrain BladeRegistration.type to BladeType">

**File**: `src/lib/bladeRegistry.ts`

1. Add the import at the top:
   ```ts
   import type { BladeType } from "../stores/bladeTypes";
   ```

2. Change the `BladeRegistration` interface `type` field from `string` to `BladeType`:
   ```ts
   export interface BladeRegistration<TProps = Record<string, never>> {
     type: BladeType;  // was: string
     defaultTitle: string | ((props: TProps) => string);
     component: ComponentType<TProps> | LazyExoticComponent<ComponentType<TProps>>;
     lazy?: boolean;
     wrapInPanel?: boolean;
     showBack?: boolean;
     renderTitleContent?: (props: TProps) => ReactNode;
     renderTrailing?: (props: TProps, ctx: BladeRenderContext) => ReactNode;
   }
   ```

3. Change the internal registry Map from `Map<string, ...>` to `Map<BladeType, ...>`:
   ```ts
   const registry = new Map<BladeType, BladeRegistration<any>>();
   ```

4. Update `registerBlade` signature — the `config.type` is already `BladeType` via the interface, so no change needed to the function body.

5. Update `getBladeRegistration` parameter from `string` to `BladeType`:
   ```ts
   export function getBladeRegistration(
     type: BladeType,
   ): BladeRegistration | undefined {
     return registry.get(type);
   }
   ```

6. Update `getAllBladeTypes` return type from `string[]` to `BladeType[]`:
   ```ts
   export function getAllBladeTypes(): BladeType[] {
     return Array.from(registry.keys());
   }
   ```

7. Verify there are no TypeScript errors. All existing registration files already use valid type strings that are members of `BladeType`, so they should compile without changes.

</task>

<task id="2" title="Add viewer-code to BladePropsMap with documentation comment" depends_on="1">

**File**: `src/stores/bladeTypes.ts`

1. Add the `viewer-code` entry to the `BladePropsMap` interface:
   ```ts
   "viewer-code": { filePath: string };
   ```
   Place it after the `"viewer-3d"` entry to keep viewer types grouped.

2. Add a documentation comment above the interface:
   ```ts
   /**
    * Central map: blade type -> required props.
    *
    * TO ADD A NEW BLADE TYPE:
    * 1. Add an entry to this interface
    * 2. Create the component in src/components/blades/YourBlade.tsx
    * 3. Create src/components/blades/registrations/your-type.ts with registerBlade()
    * 4. If file-type-based: add mapping in src/lib/fileDispatch.ts
    *
    * The dev-mode exhaustiveness check will warn if step 3 is forgotten.
    */
   export interface BladePropsMap {
   ```

The resulting `BladeType` union will automatically include `"viewer-code"` since it derives from `keyof BladePropsMap`.

</task>

<task id="3" title="Switch registrations barrel to import.meta.glob" depends_on="1">

**File**: `src/components/blades/registrations/index.ts`

Replace the entire file contents with:

```ts
// Auto-import all blade registration modules in this directory.
// Each .ts file's top-level registerBlade() call executes on import.
// Adding a new registration file is automatically discovered — no manual imports needed.
const modules = import.meta.glob("./*.ts", { eager: true });

// Ensure the glob matched something (guard against misconfigured paths)
if (import.meta.env.DEV && Object.keys(modules).length === 0) {
  console.error("[BladeRegistry] No registration modules found — check registrations directory");
}
```

**Important**: The glob `"./*.ts"` will match every `.ts` file in the `registrations/` directory, including this `index.ts` file itself. However, since `index.ts` does not call `registerBlade()`, importing it is a harmless no-op. Alternatively, use the pattern `"./*.ts"` and exclude index explicitly:

```ts
const modules = import.meta.glob(["./*.ts", "!./index.ts"], { eager: true });
```

Use the exclusion pattern to be safe and avoid any circular import concern.

**Verification**: After this change, remove a registration file import that previously existed and verify the glob still picks it up. Run the app in dev mode and check the browser console — the exhaustiveness check (added in Task 5) should report 0 missing registrations.

</task>

<task id="4" title="Create declarative file dispatch module" depends_on="2">

**File**: Create `src/lib/fileDispatch.ts` (new file)

```ts
import type { BladeType } from "../stores/bladeTypes";

/**
 * Declarative mapping from file extension to blade type.
 *
 * Adding a new file type mapping = adding one line here.
 * The BladeType constraint ensures the target blade type exists in BladePropsMap.
 */
const FILE_DISPATCH_MAP: ReadonlyMap<string, BladeType> = new Map([
  // Images
  ["png", "viewer-image"],
  ["jpg", "viewer-image"],
  ["jpeg", "viewer-image"],
  ["gif", "viewer-image"],
  ["webp", "viewer-image"],
  ["svg", "viewer-image"],
  ["ico", "viewer-image"],
  ["bmp", "viewer-image"],

  // Markdown
  ["md", "viewer-markdown"],
  ["mdx", "viewer-markdown"],

  // 3D models
  ["glb", "viewer-3d"],
  ["gltf", "viewer-3d"],

  // Packages
  ["nupkg", "viewer-nupkg"],
]);

/**
 * Extensions known to be binary (no text preview fallback).
 * Files with these extensions that are not in FILE_DISPATCH_MAP
 * will still open viewer-code but show "binary file" info.
 */
const BINARY_EXTENSIONS: ReadonlySet<string> = new Set([
  "exe", "dll", "so", "dylib", "bin", "dat", "wasm",
  "zip", "tar", "gz", "7z", "rar",
  "pdf", "doc", "docx", "xls", "xlsx",
  "mp3", "wav", "ogg", "mp4", "avi", "mov",
  "woff", "woff2", "ttf", "otf", "eot",
  "obj", "fbx", "stl",
]);

function getExtension(filePath: string): string {
  return filePath.split(".").pop()?.toLowerCase() ?? "";
}

/**
 * Determine the blade type for a file, with context-aware fallback.
 *
 * @param filePath - file path (relative or absolute)
 * @param context  - "diff" for staging/commit context, "browse" for repo browser
 * @returns the blade type to open
 */
export function bladeTypeForFile(
  filePath: string,
  context: "diff" | "browse" = "diff",
): BladeType {
  const ext = getExtension(filePath);
  const mapped = FILE_DISPATCH_MAP.get(ext);
  if (mapped) return mapped;

  // Context-aware fallback
  if (context === "browse") {
    return "viewer-code";
  }

  return "diff"; // Staging/commit context defaults to diff view
}

/**
 * Check if a file has a specialized viewer (not a diff or generic code fallback).
 */
export function hasSpecializedViewer(filePath: string): boolean {
  const ext = getExtension(filePath);
  return FILE_DISPATCH_MAP.has(ext);
}

/**
 * Check if a file extension is known to be binary.
 */
export function isBinaryExtension(filePath: string): boolean {
  const ext = getExtension(filePath);
  return BINARY_EXTENSIONS.has(ext);
}
```

</task>

<task id="5" title="Migrate fileTypeUtils.ts to use fileDispatch.ts" depends_on="4">

**File**: `src/lib/fileTypeUtils.ts`

Replace the entire file contents to re-export from the new module. This preserves backward compatibility for all existing import sites:

```ts
/**
 * File type utilities — re-exports from fileDispatch.ts
 *
 * This module is kept for backward compatibility. New code should import
 * directly from fileDispatch.ts.
 */
export { bladeTypeForFile, isBinaryExtension as isBinaryFile } from "./fileDispatch";

/** Returns true when the file gets a text diff (not a specialized viewer) */
export function isTextDiffable(filePath: string): boolean {
  // Import inline to avoid circular deps
  const { bladeTypeForFile: dispatch } = require("./fileDispatch");
  return dispatch(filePath, "diff") === "diff";
}
```

Wait — `require` won't work in ESM. Instead, write it as:

```ts
import { bladeTypeForFile, isBinaryExtension } from "./fileDispatch";

/** Re-export for backward compatibility */
export { bladeTypeForFile, isBinaryExtension as isBinaryFile };

/** Returns true when the file gets a text diff (not a specialized viewer) */
export function isTextDiffable(filePath: string): boolean {
  return bladeTypeForFile(filePath, "diff") === "diff";
}
```

Now verify that all files importing from `fileTypeUtils.ts` still work. Run a search for imports of this module:
- `src/hooks/useBladeNavigation.ts` — imports `bladeTypeForFile` (still exported, unchanged signature for 1-arg calls)
- `src/components/staging/*` — may import `isBinaryFile` or `isTextDiffable`

The 1-argument call `bladeTypeForFile(filePath)` still works because the `context` parameter defaults to `"diff"`. No call-site changes needed.

Remove the old `BINARY_EXTENSIONS` set and `bladeTypeForFile` function from this file since they are now in `fileDispatch.ts`.

</task>

<task id="6" title="Add dev-mode exhaustiveness check" depends_on="3">

**File**: `src/components/blades/registrations/index.ts`

Add the exhaustiveness check after the glob import:

```ts
// Auto-import all blade registration modules in this directory.
const modules = import.meta.glob(["./*.ts", "!./index.ts"], { eager: true });

// Dev-mode exhaustiveness check: verify all BladePropsMap types have registrations
if (import.meta.env.DEV) {
  // Use dynamic import to avoid pulling bladeRegistry into the module graph statically
  Promise.all([
    import("../../../lib/bladeRegistry"),
    import("../../../stores/bladeTypes"),
  ]).then(([{ getAllBladeTypes }]) => {
    const registered = new Set(getAllBladeTypes());
    // The full list of expected types is derived from BladePropsMap at build time.
    // We list them explicitly here for the runtime check.
    const EXPECTED_TYPES: string[] = [
      "staging-changes", "topology-graph", "commit-details", "diff",
      "viewer-nupkg", "viewer-image", "viewer-markdown", "viewer-3d",
      "viewer-code", "repo-browser", "settings", "changelog", "gitflow-cheatsheet",
    ];
    const missing = EXPECTED_TYPES.filter(t => !registered.has(t as any));
    if (missing.length > 0) {
      console.warn(
        `[BladeRegistry] Missing registrations for: ${missing.join(", ")}. ` +
        `Create a registration file in src/components/blades/registrations/ for each.`
      );
    } else {
      console.debug(`[BladeRegistry] All ${registered.size} blade types registered.`);
    }
  });
}
```

Note: `viewer-code` is included in the expected list. It will warn until the viewer-code registration file is created in Plan 22-04. This is intentional — the warning guides the developer to create the missing registration.

</task>

<task id="7" title="Fix getBladeRegistration call site in BladeRenderer" depends_on="1">

**File**: `src/components/blades/BladeRenderer.tsx`

The `BladeRenderer` calls `getBladeRegistration(blade.type)` where `blade.type` comes from `TypedBlade.type` which is already `BladeType`. Verify this compiles cleanly.

Also check `src/hooks/useBladeNavigation.ts` — the `getBladeRegistration(type)` call passes a `BladeType` value, so it should be fine.

If there are any other call sites passing a plain `string` to `getBladeRegistration`, they need to be cast or typed correctly. Search for `getBladeRegistration(` across the codebase and fix any issues.

</task>

## Verification

- [ ] `npx tsc --noEmit` completes with no new errors (the pre-existing TS2440 in bindings.ts is expected)
- [ ] Attempting `registerBlade({ type: "nonexistent", ... })` produces a TypeScript compile error
- [ ] Adding a new `.ts` file in `registrations/` with a `registerBlade()` call is auto-discovered without editing `index.ts`
- [ ] `bladeTypeForFile("README.md")` returns `"viewer-markdown"`
- [ ] `bladeTypeForFile("README.md", "diff")` returns `"viewer-markdown"`
- [ ] `bladeTypeForFile("app.tsx", "browse")` returns `"viewer-code"`
- [ ] `bladeTypeForFile("app.tsx", "diff")` returns `"diff"`
- [ ] `bladeTypeForFile("model.glb", "browse")` returns `"viewer-3d"`
- [ ] Dev console shows `[BladeRegistry] Missing registrations for: viewer-code` (until Plan 22-04 creates the registration)
- [ ] App launches and all existing blades render correctly (no regressions)
