---
phase: 22-new-content-blades
plan: 25
type: execute
wave: 10
depends_on: []
files_modified:
  - src/components/blades/Viewer3dBlade.tsx
  - public/debug/viewer3d-test.html
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Every setFetchError path in Viewer3dBlade logs to console.error before setting state"
    - "Key pipeline stages (readRepoFile success, base64 decode, buffer ready, Three.js setup, model parsed) log telemetry to console"
    - "A standalone HTML test page exists at public/debug/viewer3d-test.html for isolated WebGL/Three.js debugging"
  artifacts:
    - path: "src/components/blades/Viewer3dBlade.tsx"
      provides: "Diagnostic console.error on all error paths + telemetry logging on success path"
    - path: "public/debug/viewer3d-test.html"
      provides: "Standalone Three.js debug page for Playwright testing"
  key_links:
    - from: "Viewer3dBlade.tsx line 52-53"
      to: "console.error"
      via: "WebGL detection failure now logs before setFetchError"
    - from: "Viewer3dBlade.tsx line 65-66"
      to: "console.error"
      via: "readRepoFile failure now logs before setFetchError"
---

<objective>
Add diagnostic logging to Viewer3dBlade's silent error paths and deploy a standalone HTML test page for isolated debugging with Playwright MCP.

Purpose: The 3D model viewer shows "Failed to load 3D model" with zero console output, making it impossible to identify whether the failure is WebGL unavailability, readRepoFile error, or something else. This plan makes every failure path visible and provides an isolated test environment.

Output: Viewer3dBlade.tsx with full diagnostic logging, standalone HTML test page at public/debug/viewer3d-test.html
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/viewer3d-round5.md
@.planning/debug/viewer3d-standalone.html
@src/components/blades/Viewer3dBlade.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add console.error to silent failure paths and telemetry logging to success path</name>
  <files>src/components/blades/Viewer3dBlade.tsx</files>
  <action>
    Add diagnostic logging to Viewer3dBlade.tsx at two levels:

    **1. Silent error paths — add console.error BEFORE each setFetchError call that currently lacks it:**

    A) WebGL detection failure (around line 52-53):
    ```typescript
    if (!gl) {
      console.error("[Viewer3dBlade] WebGL not supported — neither webgl2 nor webgl context available");
      setFetchError("WebGL is not supported by your browser or GPU");
      setLoading(false);
      return;
    }
    ```

    B) readRepoFile error status (around line 65-66):
    ```typescript
    if (result.status !== "ok") {
      console.error("[Viewer3dBlade] readRepoFile failed:", result.error);
      setFetchError(getErrorMessage(result.error));
      setLoading(false);
      return;
    }
    ```

    **2. Success path telemetry — add console.log at each pipeline stage:**

    A) After readRepoFile succeeds (after getting content, isBinary, size):
    ```typescript
    console.log("[Viewer3dBlade] readRepoFile OK:", { isBinary, size, contentLength: content.length });
    ```

    B) After base64 decode completes (after creating arrayBuffer from binary path):
    ```typescript
    console.log("[Viewer3dBlade] Base64 decode OK, arrayBuffer byteLength:", arrayBuffer.byteLength);
    ```

    C) After bufferRef is set (just before setLoading(false)):
    ```typescript
    console.log("[Viewer3dBlade] Buffer ready, setting loading=false");
    ```

    D) In the Three.js setup effect, right after the guard checks pass (after `const arrayBuffer = bufferRef.current;`):
    ```typescript
    console.log("[Viewer3dBlade] Three.js setup starting, buffer byteLength:", arrayBuffer.byteLength);
    ```

    E) In the GLTFLoader.parse success callback (before `setModelReady(true)`):
    ```typescript
    console.log("[Viewer3dBlade] Model parsed successfully, adding to scene");
    ```

    **3. Make fetchError detail more prominent in the error UI:**

    In the `fetchError` render guard (around line 356-364), update the BladeContentError call to show the actual error as the main message instead of hiding it in detail:
    ```tsx
    <BladeContentError
      message={fetchError}
      detail="Failed to load 3D model — check browser console for details"
      onRetry={handleRetry}
    />
    ```
    This swaps message and detail so the ACTUAL error (e.g., "WebGL is not supported...") is the prominent text, and the generic text becomes the detail.

    Do NOT change any logic, control flow, or other behavior. Only add console.error/console.log calls and swap the message/detail props.
  </action>
  <verify>
    Run `npx tsc --noEmit 2>&1 | grep -v 'bindings.ts'` — should have zero errors.
    Grep for "setFetchError" in Viewer3dBlade.tsx — every occurrence should have a console.error within 1-3 lines above it (no silent paths remain).
  </verify>
  <done>
    Every setFetchError call in Viewer3dBlade.tsx is preceded by a console.error call. Success path has 5 console.log telemetry points. Error UI shows actual error text as primary message.
  </done>
</task>

<task type="auto">
  <name>Task 2: Deploy standalone HTML test page for Playwright debugging</name>
  <files>public/debug/viewer3d-test.html</files>
  <action>
    Copy the standalone HTML page from `.planning/debug/viewer3d-standalone.html` to `public/debug/viewer3d-test.html`.

    This makes it accessible via the Vite dev server at `http://localhost:1420/debug/viewer3d-test.html` for Playwright MCP testing.

    The page already:
    1. Tests WebGL 1 and 2 availability
    2. Allows loading .glb files via file input
    3. Runs the exact same pipeline as Viewer3dBlade (atob -> Uint8Array -> ArrayBuffer -> GLTFLoader.parse)
    4. Tests base64 round-trip encoding/decoding
    5. Has a procedural cube test (no file needed)
    6. Can fetch BoxAnimated.glb from GitHub for testing
    7. Logs every step to an on-screen console
    8. Uses Three.js r182 from CDN (same version as the app)

    The file should be copied as-is. It's a self-contained HTML page with no dependencies on the app's build system. Vite serves files from `public/` as static assets.

    Create the `public/debug/` directory if it doesn't exist.
  </action>
  <verify>
    File exists at `public/debug/viewer3d-test.html`.
    File content matches the debug source (same line count, same Three.js version).
    Run `ls -la public/debug/viewer3d-test.html` to confirm.
  </verify>
  <done>
    Standalone HTML test page is deployed to `public/debug/viewer3d-test.html` and accessible via the Vite dev server for Playwright MCP debugging. User can open it in any browser to isolate whether the 3D model failure is environmental (WebGL/WKWebView) or data-related.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (ignoring pre-existing bindings.ts error)
2. `grep -c "console.error" src/components/blades/Viewer3dBlade.tsx` shows at least 5 (was 3, adding 2 new)
3. `grep -c "console.log" src/components/blades/Viewer3dBlade.tsx` shows at least 5 new telemetry lines
4. `test -f public/debug/viewer3d-test.html && echo "exists"` returns "exists"
5. No behavioral changes to Viewer3dBlade — only logging additions and message/detail swap
</verification>

<success_criteria>
- Zero silent error paths in Viewer3dBlade.tsx — every setFetchError preceded by console.error
- 5 telemetry console.log calls trace the full success pipeline
- Error UI shows actual error message prominently (not hidden in detail)
- Standalone test page deployed at public/debug/viewer3d-test.html
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/22-new-content-blades/22-25-SUMMARY.md`
</output>
