---
phase: 38-content-viewer-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/extensions/ExtensionAPI.ts
  - src/blades/viewer-plaintext/ViewerPlaintextBlade.tsx
  - src/blades/viewer-plaintext/registration.ts
  - src/blades/viewer-plaintext/index.ts
  - src/blades/viewer-plaintext/ViewerPlaintextBlade.test.tsx
  - src/stores/bladeTypes.ts
  - src/lib/fileDispatch.ts
  - src/blades/_discovery.ts
autonomous: true

must_haves:
  truths:
    - "ExtensionAPI.registerBlade() supports coreOverride flag that skips ext: namespacing"
    - "A viewer-plaintext core blade renders file content as plain monospaced text"
    - "bladeTypeForFile() returns viewer-plaintext (not viewer-code) as browse fallback when no extension overlay matches"
    - "Binary files show a 'Binary file' placeholder in viewer-plaintext instead of gibberish"
  artifacts:
    - path: "src/extensions/ExtensionAPI.ts"
      provides: "coreOverride option in ExtensionBladeConfig"
      contains: "coreOverride"
    - path: "src/blades/viewer-plaintext/ViewerPlaintextBlade.tsx"
      provides: "Plain text fallback viewer component"
      exports: ["ViewerPlaintextBlade"]
    - path: "src/blades/viewer-plaintext/registration.ts"
      provides: "Core blade registration for viewer-plaintext"
    - path: "src/lib/fileDispatch.ts"
      provides: "Browse fallback returns viewer-plaintext"
      contains: "viewer-plaintext"
    - path: "src/stores/bladeTypes.ts"
      provides: "viewer-plaintext in BladePropsMap"
      contains: "viewer-plaintext"
  key_links:
    - from: "src/extensions/ExtensionAPI.ts"
      to: "src/lib/bladeRegistry.ts"
      via: "registerBlade call with coreOverride skipping namespacing"
      pattern: "coreOverride.*config\\.type"
    - from: "src/blades/viewer-plaintext/ViewerPlaintextBlade.tsx"
      to: "src/hooks/useRepoFile.ts"
      via: "useRepoFile hook for file content loading"
      pattern: "useRepoFile"
    - from: "src/lib/fileDispatch.ts"
      to: "src/stores/bladeTypes.ts"
      via: "browse fallback type must exist in BladePropsMap"
      pattern: "viewer-plaintext"
---

<objective>
Add coreOverride support to ExtensionAPI and create the viewer-plaintext core fallback blade.

Purpose: The coreOverride flag enables the content-viewers extension (Plan 02) to register blade types under their original core names (viewer-markdown, viewer-code, viewer-3d) without ext: namespacing, avoiding cascading changes to fileDispatch, useBladeNavigation, and BladePropsMap. The viewer-plaintext blade provides a lightweight always-available fallback for file browsing when the content-viewers extension is disabled.

Output: ExtensionAPI with coreOverride, viewer-plaintext blade registered in core, fileDispatch browse fallback updated.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-content-viewer-extraction/38-RESEARCH.md

@src/extensions/ExtensionAPI.ts
@src/lib/bladeRegistry.ts
@src/lib/fileDispatch.ts
@src/stores/bladeTypes.ts
@src/blades/_discovery.ts
@src/blades/viewer-code/registration.ts
@src/blades/viewer-code/ViewerCodeBlade.tsx
@src/hooks/useRepoFile.ts
@src/blades/_shared/BladeContentLoading.tsx
@src/blades/_shared/BladeContentError.tsx
@src/blades/_shared/BladeContentEmpty.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add coreOverride to ExtensionAPI and create viewer-plaintext blade</name>
  <files>
    src/extensions/ExtensionAPI.ts
    src/blades/viewer-plaintext/ViewerPlaintextBlade.tsx
    src/blades/viewer-plaintext/registration.ts
    src/blades/viewer-plaintext/index.ts
    src/stores/bladeTypes.ts
    src/lib/fileDispatch.ts
    src/blades/_discovery.ts
  </files>
  <action>
    **1. Add `coreOverride` to ExtensionBladeConfig in `src/extensions/ExtensionAPI.ts`:**

    Add `coreOverride?: boolean` to the `ExtensionBladeConfig` interface (after `showBack`). Then modify the `registerBlade` method so that when `config.coreOverride` is `true`, the blade type is registered using `config.type` directly (no `ext:{extensionId}:` prefix). The source tag must still be `ext:${this.extensionId}` for cleanup tracking. The `this.registeredBlades` array must still track the actual registered type for cleanup.

    ```typescript
    registerBlade(config: ExtensionBladeConfig): void {
      const namespacedType = config.coreOverride
        ? config.type
        : `ext:${this.extensionId}:${config.type}`;
      registerBlade({
        ...config,
        type: namespacedType,
        defaultTitle: config.title,
        source: `ext:${this.extensionId}`,
      });
      this.registeredBlades.push(namespacedType);
    }
    ```

    Add a JSDoc comment on `coreOverride`: "If true, blade type is registered without ext:{extensionId}: prefix. Use for built-in extensions that replace core blade types."

    **2. Create `src/blades/viewer-plaintext/ViewerPlaintextBlade.tsx`:**

    A minimal fallback blade with NO heavy dependencies. It accepts `{ filePath: string }`, uses `useRepoFile(filePath)` to load content, and renders:
    - Loading state: `<BladeContentLoading />`
    - Error state: `<BladeContentError message="Failed to load file" detail={error.message} onRetry={() => refetch()} />`
    - Binary/missing: `<BladeContentEmpty icon={FileText} message={data?.isBinary ? "Binary file" : "File not found"} detail={filePath} />`
    - Text content: A `<pre>` element with classes `flex-1 overflow-auto p-4 bg-ctp-base text-ctp-text text-sm font-mono whitespace-pre-wrap break-words leading-relaxed`. Use `whitespace-pre-wrap` and `break-words` so long lines wrap rather than overflow.

    Import `FileText` from `lucide-react`. Import `useRepoFile` from `../../hooks/useRepoFile`. Import `BladeContentLoading`, `BladeContentError`, `BladeContentEmpty` from `../_shared/`.

    **3. Create `src/blades/viewer-plaintext/registration.ts`:**

    Follow the same pattern as existing core blade registrations. Use `React.lazy()` for the component import. Call `registerBlade<{ filePath: string }>()` with:
    - `type: "viewer-plaintext"`
    - `defaultTitle: (props) => props.filePath.split("/").pop() || "Plain Text"`
    - `component: ViewerPlaintextBlade` (the lazy version)
    - `lazy: true`
    - `renderTitleContent: (props) => renderPathBreadcrumb(props.filePath)`

    Import `registerBlade` from `../../lib/bladeRegistry` and `renderPathBreadcrumb` from `../../lib/bladeUtils`.

    **4. Create `src/blades/viewer-plaintext/index.ts`:**

    Barrel export: `export { ViewerPlaintextBlade } from "./ViewerPlaintextBlade";`

    **5. Add `viewer-plaintext` to `BladePropsMap` in `src/stores/bladeTypes.ts`:**

    Add entry: `"viewer-plaintext": { filePath: string };` after the `viewer-code` entry.

    **6. Update browse fallback in `src/lib/fileDispatch.ts`:**

    Change line 65 from `return "viewer-code";` to `return "viewer-plaintext";` so the browse context fallback uses the always-available core blade.

    **7. Add `viewer-plaintext` to `EXPECTED_TYPES` in `src/blades/_discovery.ts`:**

    Add `"viewer-plaintext"` to the EXPECTED_TYPES array (after "viewer-code").
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no new TypeScript errors (the pre-existing TS2440 in bindings.ts is expected).
    Run `npx vitest run` -- all existing tests pass.
  </verify>
  <done>
    ExtensionBladeConfig has `coreOverride?: boolean`. ExtensionAPI.registerBlade() conditionally skips namespacing when coreOverride is true. viewer-plaintext blade exists and is registered as a core blade. bladeTypeForFile("test.ts", "browse") returns "viewer-plaintext". BladePropsMap includes "viewer-plaintext".
  </done>
</task>

<task type="auto">
  <name>Task 2: Add coreOverride and viewer-plaintext tests</name>
  <files>
    src/extensions/__tests__/ExtensionAPI.test.ts
    src/blades/viewer-plaintext/ViewerPlaintextBlade.test.tsx
  </files>
  <action>
    **1. Add coreOverride test to `src/extensions/__tests__/ExtensionAPI.test.ts`:**

    Add a new test case in the existing ExtensionAPI describe block:

    ```typescript
    it("registers blade with original type when coreOverride is true", () => {
      const api = new ExtensionAPI("content-viewers");
      api.registerBlade({
        type: "viewer-markdown",
        title: "Markdown Preview",
        component: () => null,
        coreOverride: true,
      });
      expect(getBladeRegistration("viewer-markdown")).toBeDefined();
      expect(getBladeRegistration("ext:content-viewers:viewer-markdown")).toBeUndefined();
    });
    ```

    Add another test verifying cleanup still works with coreOverride:

    ```typescript
    it("cleanup removes coreOverride blades correctly", () => {
      const api = new ExtensionAPI("content-viewers");
      api.registerBlade({
        type: "viewer-markdown",
        title: "Markdown Preview",
        component: () => null,
        coreOverride: true,
      });
      expect(getBladeRegistration("viewer-markdown")).toBeDefined();
      api.cleanup();
      expect(getBladeRegistration("viewer-markdown")).toBeUndefined();
    });
    ```

    Import `getBladeRegistration` from `../../lib/bladeRegistry` at the top of the file if not already imported.

    **2. Create `src/blades/viewer-plaintext/ViewerPlaintextBlade.test.tsx`:**

    Follow the same pattern as `src/blades/viewer-code/ViewerCodeBlade.test.tsx` and `src/blades/viewer-markdown/ViewerMarkdownBlade.test.tsx`:

    - Mock `../../hooks/useRepoFile` via `vi.mock()` returning `{ useRepoFile: vi.fn() }`
    - Use `vi.hoisted()` to create the mock reference
    - Test 1: "renders text content" -- mock useRepoFile returning `{ data: { content: "hello world", isBinary: false }, isLoading: false, error: null, refetch: vi.fn() }`. Render `<ViewerPlaintextBlade filePath="test.txt" />`. Assert `screen.getByText("hello world")` is present.
    - Test 2: "shows loading state" -- mock useRepoFile returning `{ data: undefined, isLoading: true, error: null, refetch: vi.fn() }`. Render and verify the container is not empty (loading fallback renders).
    - Test 3: "shows binary placeholder" -- mock useRepoFile returning `{ data: { content: "", isBinary: true }, isLoading: false, error: null, refetch: vi.fn() }`. Render and assert `screen.getByText(/binary file/i)` is present.

    Import `render` from the project's test-utils: `import { render, screen } from "../../test-utils/render";` (or `@testing-library/react` -- check existing test patterns). Import `describe, it, expect, vi` from `vitest`.
  </action>
  <verify>
    Run `npx vitest run src/extensions/__tests__/ExtensionAPI.test.ts` -- all tests pass including new coreOverride tests.
    Run `npx vitest run src/blades/viewer-plaintext/` -- all viewer-plaintext tests pass.
    Run `npx vitest run` -- full suite passes.
  </verify>
  <done>
    coreOverride registration and cleanup are tested. ViewerPlaintextBlade renders text content, shows loading state, and handles binary files correctly in tests.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (ignore pre-existing TS2440 in bindings.ts)
2. `npx vitest run` -- full test suite passes
3. `grep -r "coreOverride" src/extensions/ExtensionAPI.ts` shows the new flag
4. `grep "viewer-plaintext" src/stores/bladeTypes.ts` confirms BladePropsMap entry
5. `grep "viewer-plaintext" src/lib/fileDispatch.ts` confirms browse fallback change
6. `grep "viewer-plaintext" src/blades/_discovery.ts` confirms EXPECTED_TYPES entry
</verification>

<success_criteria>
- ExtensionBladeConfig interface includes coreOverride?: boolean
- ExtensionAPI.registerBlade() conditionally skips ext: namespacing when coreOverride is true
- Cleanup still removes coreOverride blades via tracked type
- viewer-plaintext blade renders file content as monospaced text without heavy dependencies
- viewer-plaintext shows binary file placeholder for non-text files
- fileDispatch browse fallback is "viewer-plaintext" (not "viewer-code")
- All existing tests pass, new tests added for coreOverride and viewer-plaintext
</success_criteria>

<output>
After completion, create `.planning/phases/38-content-viewer-extraction/38-01-SUMMARY.md`
</output>
