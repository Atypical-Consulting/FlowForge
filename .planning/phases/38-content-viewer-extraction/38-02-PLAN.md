---
phase: 38-content-viewer-extraction
plan: 02
type: execute
wave: 2
depends_on: ["38-01"]
files_modified:
  - src/extensions/content-viewers/index.ts
  - src/App.tsx
  - src/blades/viewer-markdown/registration.ts
  - src/blades/viewer-code/registration.ts
  - src/blades/viewer-3d/registration.ts
  - src/blades/_discovery.ts
  - src/blades/_shared/BladeRenderer.tsx
  - src/extensions/__tests__/content-viewers.test.ts
autonomous: true

must_haves:
  truths:
    - "Opening a .md file in the repo browser launches the markdown preview blade provided by the content-viewers extension"
    - "Opening a source file in the repo browser launches the Monaco code viewer blade provided by the content-viewers extension"
    - "Opening a .gltf/.glb file in the repo browser launches the 3D model viewer blade provided by the content-viewers extension"
    - "Disabling the content-viewers extension causes file previews to fall back to viewer-plaintext (plain text display)"
    - "Re-enabling the content-viewers extension restores all three rich viewers"
    - "Already-open viewer blades show a helpful fallback message (not red error text) when the extension is disabled"
  artifacts:
    - path: "src/extensions/content-viewers/index.ts"
      provides: "Content viewers built-in extension entry point"
      exports: ["onActivate", "onDeactivate"]
    - path: "src/blades/_shared/BladeRenderer.tsx"
      provides: "Graceful fallback for unregistered extension blades"
      contains: "extension that is currently disabled"
  key_links:
    - from: "src/extensions/content-viewers/index.ts"
      to: "src/blades/viewer-markdown/ViewerMarkdownBlade.tsx"
      via: "React.lazy dynamic import"
      pattern: "import.*ViewerMarkdownBlade"
    - from: "src/extensions/content-viewers/index.ts"
      to: "src/blades/viewer-code/ViewerCodeBlade.tsx"
      via: "React.lazy dynamic import"
      pattern: "import.*ViewerCodeBlade"
    - from: "src/extensions/content-viewers/index.ts"
      to: "src/blades/viewer-3d/Viewer3dBlade.tsx"
      via: "React.lazy dynamic import"
      pattern: "import.*Viewer3dBlade"
    - from: "src/App.tsx"
      to: "src/extensions/content-viewers/index.ts"
      via: "registerBuiltIn call in useEffect"
      pattern: "registerBuiltIn.*content-viewers"
    - from: "src/extensions/content-viewers/index.ts"
      to: "src/extensions/ExtensionAPI.ts"
      via: "api.registerBlade with coreOverride: true"
      pattern: "coreOverride.*true"
---

<objective>
Create the content-viewers built-in extension and wire graceful degradation.

Purpose: This plan moves the three content viewer blade registrations (markdown, code, 3D) from core side-effect files into a single toggleable built-in extension. When the extension is enabled, all three viewers function exactly as before. When disabled, file previews fall back to the viewer-plaintext blade (from Plan 01). This satisfies requirements VIEW-01, VIEW-02, VIEW-03, VIEW-04, and DEGR-04.

Output: Working content-viewers extension registered via registerBuiltIn(), old registration.ts files deleted, graceful BladeRenderer fallback, extension lifecycle tests.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-content-viewer-extraction/38-RESEARCH.md
@.planning/phases/38-content-viewer-extraction/38-01-SUMMARY.md

@src/extensions/ExtensionAPI.ts
@src/extensions/ExtensionHost.ts
@src/extensions/github/index.ts
@src/App.tsx
@src/lib/bladeRegistry.ts
@src/lib/bladeUtils.tsx
@src/blades/viewer-markdown/registration.ts
@src/blades/viewer-markdown/ViewerMarkdownBlade.tsx
@src/blades/viewer-code/registration.ts
@src/blades/viewer-code/ViewerCodeBlade.tsx
@src/blades/viewer-3d/registration.ts
@src/blades/viewer-3d/Viewer3dBlade.tsx
@src/blades/_discovery.ts
@src/blades/_shared/BladeRenderer.tsx
@src/stores/bladeTypes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content-viewers extension and wire into App.tsx</name>
  <files>
    src/extensions/content-viewers/index.ts
    src/App.tsx
    src/blades/viewer-markdown/registration.ts
    src/blades/viewer-code/registration.ts
    src/blades/viewer-3d/registration.ts
    src/blades/_discovery.ts
  </files>
  <action>
    **1. Create `src/extensions/content-viewers/index.ts`:**

    This is the extension entry point. It must use `React.lazy()` (NOT `ensureComponents()` / eager import) to preserve lazy loading of Monaco (~3MB) and Three.js (~600KB). The components are only loaded when a user actually opens a file of that type.

    ```typescript
    import { lazy } from "react";
    import type { ExtensionAPI } from "../ExtensionAPI";
    import { renderPathBreadcrumb } from "../../lib/bladeUtils";

    export async function onActivate(api: ExtensionAPI): Promise<void> {
      // Lazy component imports -- loaded on first blade render, not during activation
      const ViewerMarkdownBlade = lazy(() =>
        import("../../blades/viewer-markdown/ViewerMarkdownBlade").then((m) => ({
          default: m.ViewerMarkdownBlade,
        }))
      );
      const ViewerCodeBlade = lazy(() =>
        import("../../blades/viewer-code/ViewerCodeBlade").then((m) => ({
          default: m.ViewerCodeBlade,
        }))
      );
      const Viewer3dBlade = lazy(() =>
        import("../../blades/viewer-3d/Viewer3dBlade").then((m) => ({
          default: m.Viewer3dBlade,
        }))
      );

      // Register blade types with coreOverride to preserve existing blade type names
      api.registerBlade({
        type: "viewer-markdown",
        title: "Markdown Preview",
        component: ViewerMarkdownBlade,
        lazy: true,
        coreOverride: true,
        renderTitleContent: (props: any) => renderPathBreadcrumb(props.filePath),
      });

      api.registerBlade({
        type: "viewer-code",
        title: "Code Viewer",
        component: ViewerCodeBlade,
        lazy: true,
        coreOverride: true,
        renderTitleContent: (props: any) => renderPathBreadcrumb(props.filePath),
      });

      api.registerBlade({
        type: "viewer-3d",
        title: "3D Model Viewer",
        component: Viewer3dBlade,
        lazy: true,
        coreOverride: true,
        renderTitleContent: (props: any) => renderPathBreadcrumb(props.filePath),
      });
    }

    export function onDeactivate(): void {
      // No custom cleanup needed -- api.cleanup() handles all blade unregistrations
    }
    ```

    Notes:
    - Use `coreOverride: true` on ALL three blades so types remain `viewer-markdown`, `viewer-code`, `viewer-3d` (no ext: prefix). This prevents cascading changes to `useBladeNavigation.ts`, `RepoBrowserBlade.tsx`, `fileDispatch.ts`, and `BladePropsMap`.
    - Use `lazy: true` to tell BladeRenderer to wrap in Suspense for loading fallback.
    - Import `renderPathBreadcrumb` from `../../lib/bladeUtils` -- same function used by the old registration files.
    - The `title` field sets `defaultTitle` via ExtensionAPI (it maps config.title to BladeRegistration.defaultTitle). Use the dynamic title function from existing registrations by passing a string and letting the original component handle filename display. Wait -- the old registrations use `defaultTitle: (props) => props.filePath.split("/").pop() || "Markdown"` which is a function. But ExtensionBladeConfig.title is `string`. Looking at the current ExtensionAPI, `registerBlade` passes `config.title` as `defaultTitle`. The old registrations passed a function as defaultTitle. We need ExtensionAPI to support function titles too.

    **Check:** Read `src/extensions/ExtensionAPI.ts` registerBlade method. It maps `config.title` to `defaultTitle`. The `BladeRegistration.defaultTitle` supports `string | ((props: TProps) => string)`. The `ExtensionBladeConfig.title` is typed as `string`. We need to widen it to `string | ((props: any) => string)`. Modify `ExtensionBladeConfig.title` in `src/extensions/ExtensionAPI.ts` from `title: string;` to `title: string | ((props: any) => string);`.

    Then in the extension:
    ```typescript
    api.registerBlade({
      type: "viewer-markdown",
      title: (props: any) => props.filePath?.split("/").pop() || "Markdown",
      component: ViewerMarkdownBlade,
      lazy: true,
      coreOverride: true,
      renderTitleContent: (props: any) => renderPathBreadcrumb(props.filePath),
    });
    ```

    Do the same for viewer-code (title fallback "Code") and viewer-3d (title fallback "3D Model").

    **2. Register in `src/App.tsx`:**

    Add import at top (near the GitHub import):
    ```typescript
    import { onActivate as contentViewersActivate, onDeactivate as contentViewersDeactivate } from "./extensions/content-viewers";
    ```

    In the `useEffect` that registers built-in extensions (the one containing `registerBuiltIn` for GitHub), add the content-viewers registration BEFORE the GitHub registration. This ensures content-viewer blades are available before any GitHub blade that might reference file viewers:

    ```typescript
    // Register built-in extensions
    registerBuiltIn({
      id: "content-viewers",
      name: "Content Viewers",
      version: "1.0.0",
      activate: contentViewersActivate,
      deactivate: contentViewersDeactivate,
    });

    registerBuiltIn({
      id: "github",
      name: "GitHub Integration",
      version: "1.0.0",
      activate: githubActivate,
      deactivate: githubDeactivate,
    });
    ```

    **3. Delete the old registration.ts files:**

    Delete the following files (they are now replaced by the extension's onActivate):
    - `src/blades/viewer-markdown/registration.ts`
    - `src/blades/viewer-code/registration.ts`
    - `src/blades/viewer-3d/registration.ts`

    Keep the blade component files (ViewerMarkdownBlade.tsx, ViewerCodeBlade.tsx, Viewer3dBlade.tsx) and their index.ts barrels in place. The extension dynamically imports them.

    **4. Update `src/blades/_discovery.ts` EXPECTED_TYPES:**

    Remove `"viewer-markdown"`, `"viewer-3d"`, `"viewer-code"` from the EXPECTED_TYPES array. These blade types are now registered by the extension (during activation), not by the eager import.meta.glob scan. Keep `"viewer-plaintext"` (added in Plan 01), `"viewer-nupkg"`, and `"viewer-image"` which remain as core blades.

    **5. Widen ExtensionBladeConfig.title type:**

    In `src/extensions/ExtensionAPI.ts`, change the `title` field in `ExtensionBladeConfig` from:
    ```typescript
    title: string;
    ```
    to:
    ```typescript
    title: string | ((props: any) => string);
    ```

    This allows extensions to pass dynamic title functions (like the content-viewers extension needs for filename-based titles).
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no new TypeScript errors (pre-existing TS2440 in bindings.ts is expected).
    Verify the three old registration.ts files are deleted: `ls src/blades/viewer-{markdown,code,3d}/registration.ts` should fail.
    Verify `grep "viewer-markdown" src/blades/_discovery.ts` returns no results (removed from EXPECTED_TYPES).
    Verify `grep "content-viewers" src/App.tsx` shows the registerBuiltIn call.
  </verify>
  <done>
    Content-viewers extension exists at `src/extensions/content-viewers/index.ts`. It registers viewer-markdown, viewer-code, and viewer-3d with coreOverride. Old registration.ts files are deleted. Extension is registered in App.tsx before GitHub. _discovery.ts no longer expects the three extracted viewer types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Improve BladeRenderer fallback and add extension lifecycle tests</name>
  <files>
    src/blades/_shared/BladeRenderer.tsx
    src/extensions/__tests__/content-viewers.test.ts
  </files>
  <action>
    **1. Improve BladeRenderer fallback in `src/blades/_shared/BladeRenderer.tsx`:**

    Replace the current "Unknown blade" red text with a graceful fallback that distinguishes between extension blades (disabled extension) and truly unknown blades (code bugs). When a blade type has a source that starts with `ext:` OR when the type is a known core override type that no longer has a registration (because its extension was disabled), show a helpful message instead of an error.

    Since we use `coreOverride`, the blade type will be `viewer-markdown` (no ext: prefix). We cannot easily detect if it was an extension blade from the type alone. Instead, simply improve the fallback for ALL unknown blade types to be user-friendly:

    ```tsx
    import { Puzzle } from "lucide-react";
    import { openBlade } from "../../lib/bladeOpener";

    // In BladeRenderer, replace the unknown blade fallback:
    if (!reg) {
      return (
        <div className="flex-1 flex flex-col items-center justify-center gap-4 p-8">
          <Puzzle className="w-10 h-10 text-ctp-overlay0 opacity-50" />
          <p className="text-sm text-ctp-subtext0 text-center">
            This content requires an extension that is currently disabled.
          </p>
          <button
            type="button"
            onClick={() => openBlade("extension-manager", {})}
            className="text-xs text-ctp-blue hover:underline cursor-pointer"
          >
            Open Extension Manager
          </button>
        </div>
      );
    }
    ```

    Import `Puzzle` from `lucide-react` and `openBlade` from `../../lib/bladeOpener`.

    Note: The fallback wraps in a BladePanel so it has a header with back button. Do NOT wrap the fallback in BladePanel since it is returned before the BladePanel wrapping logic. Instead, wrap the entire fallback in a div that fills the blade area. The BladeContainer (parent) handles the outer chrome. Actually, looking at the code more carefully, the BladeRenderer returns the component, and the parent wraps as needed. The fallback should look good as a standalone flex container.

    **2. Create `src/extensions/__tests__/content-viewers.test.ts`:**

    Test the content-viewers extension lifecycle following the pattern from `src/extensions/__tests__/ExtensionAPI.test.ts`:

    ```typescript
    import { describe, it, expect, beforeEach } from "vitest";
    import { ExtensionAPI } from "../ExtensionAPI";
    import { getBladeRegistration } from "../../lib/bladeRegistry";
    import { onActivate, onDeactivate } from "../content-viewers";

    describe("content-viewers extension", () => {
      let api: ExtensionAPI;

      beforeEach(() => {
        api = new ExtensionAPI("content-viewers");
      });

      it("registers three viewer blade types on activation", async () => {
        await onActivate(api);

        expect(getBladeRegistration("viewer-markdown")).toBeDefined();
        expect(getBladeRegistration("viewer-code")).toBeDefined();
        expect(getBladeRegistration("viewer-3d")).toBeDefined();
      });

      it("registers blade types without ext: namespace (coreOverride)", async () => {
        await onActivate(api);

        // Should NOT be namespaced
        expect(getBladeRegistration("ext:content-viewers:viewer-markdown")).toBeUndefined();
        expect(getBladeRegistration("ext:content-viewers:viewer-code")).toBeUndefined();
        expect(getBladeRegistration("ext:content-viewers:viewer-3d")).toBeUndefined();
      });

      it("marks all blades as lazy for Suspense wrapping", async () => {
        await onActivate(api);

        const md = getBladeRegistration("viewer-markdown");
        const code = getBladeRegistration("viewer-code");
        const v3d = getBladeRegistration("viewer-3d");

        expect(md?.lazy).toBe(true);
        expect(code?.lazy).toBe(true);
        expect(v3d?.lazy).toBe(true);
      });

      it("tracks source as ext:content-viewers for cleanup", async () => {
        await onActivate(api);

        const md = getBladeRegistration("viewer-markdown");
        expect(md?.source).toBe("ext:content-viewers");
      });

      it("unregisters all blade types on cleanup", async () => {
        await onActivate(api);
        api.cleanup();

        expect(getBladeRegistration("viewer-markdown")).toBeUndefined();
        expect(getBladeRegistration("viewer-code")).toBeUndefined();
        expect(getBladeRegistration("viewer-3d")).toBeUndefined();
      });

      it("onDeactivate is a no-op (cleanup handled by ExtensionAPI)", () => {
        // Should not throw
        expect(() => onDeactivate()).not.toThrow();
      });
    });
    ```

    Note: The `React.lazy()` calls in onActivate create lazy components. The tests don't need to render them -- just verify registration metadata (type, lazy, source).
  </action>
  <verify>
    Run `npx vitest run src/extensions/__tests__/content-viewers.test.ts` -- all 6 tests pass.
    Run `npx vitest run` -- full test suite passes.
    Run `npx tsc --noEmit` -- no new TypeScript errors.
  </verify>
  <done>
    BladeRenderer shows a user-friendly fallback with Puzzle icon and "Open Extension Manager" link when a blade type is unregistered. Content-viewers extension lifecycle is tested: registration, coreOverride namespacing, lazy flag, source tracking, cleanup, and onDeactivate.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (ignore pre-existing TS2440 in bindings.ts)
2. `npx vitest run` -- full test suite passes
3. `ls src/blades/viewer-markdown/registration.ts` -- file does NOT exist (deleted)
4. `ls src/blades/viewer-code/registration.ts` -- file does NOT exist (deleted)
5. `ls src/blades/viewer-3d/registration.ts` -- file does NOT exist (deleted)
6. `grep "content-viewers" src/App.tsx` -- shows registerBuiltIn call
7. `grep "coreOverride" src/extensions/content-viewers/index.ts` -- shows true on all three registrations
8. `grep "viewer-markdown" src/blades/_discovery.ts` -- returns nothing (removed from EXPECTED_TYPES)
9. `grep "Puzzle" src/blades/_shared/BladeRenderer.tsx` -- shows graceful fallback icon
10. Content-viewers extension lifecycle tests all pass
</verification>

<success_criteria>
- content-viewers extension at src/extensions/content-viewers/index.ts registers viewer-markdown, viewer-code, viewer-3d
- All three registrations use coreOverride: true to preserve original blade type names
- All three registrations use React.lazy() and lazy: true for on-demand loading
- Old registration.ts files deleted from src/blades/viewer-{markdown,code,3d}/
- Blade component files (.tsx) remain in their original locations (dynamic import)
- Extension registered in App.tsx BEFORE GitHub extension
- _discovery.ts EXPECTED_TYPES no longer includes the three extracted types
- BladeRenderer shows graceful fallback (not red "Unknown blade" text) for unregistered blade types
- Extension lifecycle tests cover: activation, coreOverride, lazy flag, source tracking, cleanup
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/38-content-viewer-extraction/38-02-SUMMARY.md`
</output>
