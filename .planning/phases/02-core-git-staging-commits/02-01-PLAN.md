---
phase: 02-core-git-staging-commits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/staging.rs
  - src-tauri/src/git/diff.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/git/commands.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Backend can return list of changed files grouped by status"
    - "Backend can stage/unstage individual files"
    - "Backend can stage/unstage all files at once"
    - "Backend can generate unified diff for any changed file"
  artifacts:
    - path: "src-tauri/src/git/staging.rs"
      provides: "File status types and staging operations"
      exports: ["FileChange", "FileStatus", "StagingStatus"]
    - path: "src-tauri/src/git/diff.rs"
      provides: "Diff generation with configurable context"
      exports: ["FileDiff", "DiffHunk", "get_file_diff"]
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "staging commands"
      via: "collect_commands! macro"
      pattern: "get_staging_status|stage_file|unstage_file"
    - from: "src-tauri/src/git/staging.rs"
      to: "git2::Index"
      via: "spawn_blocking"
      pattern: "index\\.add_path|index\\.write"
---

<objective>
Create the Rust staging and diff modules that provide file status enumeration, staging/unstaging operations, and diff generation.

Purpose: Enable the frontend to display changed files and allow users to stage/unstage them. This is the foundation for the staging UI.

Output: New staging.rs and diff.rs modules with Tauri commands exported via tauri-specta.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-git-staging-commits/02-CONTEXT.md
@.planning/phases/02-core-git-staging-commits/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Existing code to extend
@src-tauri/src/git/mod.rs
@src-tauri/src/git/error.rs
@src-tauri/src/git/commands.rs
@src-tauri/src/git/repository.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create staging.rs with file status types and staging commands</name>
  <files>
    src-tauri/src/git/staging.rs
    src-tauri/src/git/mod.rs
    src-tauri/src/git/error.rs
  </files>
  <action>
Create `src-tauri/src/git/staging.rs` with:

**Types (all with `#[derive(Debug, Clone, Serialize, Deserialize, Type)]` and `#[serde(rename_all = "camelCase")]`):**

```rust
pub enum FileStatus {
    Modified,
    Added,
    Deleted,
    Renamed { old_path: String },
    Untracked,
    Conflicted,
}

pub struct FileChange {
    pub path: String,
    pub status: FileStatus,
    pub additions: Option<i32>,
    pub deletions: Option<i32>,
}

pub struct StagingStatus {
    pub staged: Vec<FileChange>,
    pub unstaged: Vec<FileChange>,
    pub untracked: Vec<FileChange>,
}
```

**Commands (all wrapped in `tokio::task::spawn_blocking`):**

1. `get_staging_status(state: State<'_, RepositoryState>) -> Result<StagingStatus, GitError>`
   - Use `repo.statuses(Some(&mut opts))` with proper options
   - Parse StatusEntry flags to categorize: INDEX_* for staged, WT_* for unstaged, WT_NEW for untracked
   - Return grouped StagingStatus

2. `stage_file(path: String, state: ...) -> Result<(), GitError>`
   - Get index via `repo.index()?`
   - Call `index.add_path(Path::new(&path))?` (path must be relative to repo root)
   - Call `index.write()?` to persist (CRITICAL - do not forget this)

3. `unstage_file(path: String, state: ...) -> Result<(), GitError>`
   - Get HEAD commit via `repo.head()?.peel_to_commit()?`
   - Handle ErrorCode::UnbornBranch for fresh repos (just remove from index instead)
   - Call `repo.reset_default(Some(&head.into_object()), [&path])?`

4. `stage_all(state: ...) -> Result<(), GitError>`
   - Call `index.add_all(["*"].iter(), git2::IndexAddOption::DEFAULT, None)?`
   - Call `index.write()?`

5. `unstage_all(state: ...) -> Result<(), GitError>`
   - Reset entire index to HEAD state

**Update mod.rs:** Add `pub mod staging;` and re-export types.

**Update error.rs:** Add new error variants if needed (e.g., `StagingError(String)`, `IndexError(String)`).
  </action>
  <verify>
    - `cargo check` passes
    - `cargo build` succeeds
    - `src/bindings.ts` contains `getStagingStatus`, `stageFile`, `unstageFile`, `stageAll`, `unstageAll` functions
    - `src/bindings.ts` contains `StagingStatus`, `FileChange`, `FileStatus` types
  </verify>
  <done>
    - All 5 staging commands are callable from TypeScript
    - Types serialize with camelCase field names
    - index.write() is called after every staging mutation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create diff.rs with diff generation commands</name>
  <files>
    src-tauri/src/git/diff.rs
    src-tauri/src/git/mod.rs
    src-tauri/src/git/commands.rs
    src-tauri/src/lib.rs
  </files>
  <action>
Create `src-tauri/src/git/diff.rs` with:

**Types:**

```rust
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct DiffHunk {
    pub old_start: u32,
    pub old_lines: u32,
    pub new_start: u32,
    pub new_lines: u32,
    pub header: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct FileDiff {
    pub path: String,
    pub old_content: String,  // For Monaco DiffEditor original
    pub new_content: String,  // For Monaco DiffEditor modified
    pub hunks: Vec<DiffHunk>,
    pub is_binary: bool,
    pub language: String,     // Detected from file extension
}
```

**Commands:**

1. `get_file_diff(path: String, staged: bool, context_lines: u32, state: ...) -> Result<FileDiff, GitError>`
   - If `staged`: diff index vs HEAD (`repo.diff_tree_to_index`)
   - If not `staged`: diff workdir vs index (`repo.diff_index_to_workdir`)
   - Use `DiffOptions::new().context_lines(context_lines).pathspec(&path)`
   - Extract old/new blob content for Monaco DiffEditor:
     - For unstaged: old = index version, new = workdir version
     - For staged: old = HEAD version, new = index version
   - Detect language from file extension (map common extensions: .rs -> rust, .ts -> typescript, .tsx -> typescriptreact, .js -> javascript, .json -> json, .md -> markdown, etc.)
   - Handle binary files (set is_binary = true, leave content empty)

**Update mod.rs:** Add `pub mod diff;`

**Update commands.rs:** Move all command functions to commands.rs OR keep them in their respective modules but re-export. Either pattern is fine - be consistent with existing code.

**Update lib.rs:** Add new commands to `collect_commands!` macro:
```rust
collect_commands![
    greet,
    open_repository,
    get_repository_status,
    is_git_repository,
    close_repository,
    // NEW:
    get_staging_status,
    stage_file,
    unstage_file,
    stage_all,
    unstage_all,
    get_file_diff,
]
```
  </action>
  <verify>
    - `cargo check` passes
    - `cargo build` succeeds
    - `src/bindings.ts` contains `getFileDiff` function
    - `src/bindings.ts` contains `FileDiff`, `DiffHunk` types with camelCase fields
    - Test manually: open a repo with changes, call getFileDiff from dev tools console
  </verify>
  <done>
    - getFileDiff returns old/new content suitable for Monaco DiffEditor
    - Staged vs unstaged diffs work correctly
    - Language detection maps file extensions to Monaco language IDs
    - Binary files are detected and marked
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `cargo build` succeeds with no warnings
2. `npm run tauri dev` launches without errors
3. Open browser dev tools, test commands:
   ```javascript
   // Open a repo with changes first
   await __TAURI__.invoke('get_staging_status')
   // Should return { staged: [], unstaged: [...], untracked: [...] }
   
   await __TAURI__.invoke('stage_file', { path: 'some/changed/file.txt' })
   await __TAURI__.invoke('get_staging_status')
   // File should now appear in staged array
   
   await __TAURI__.invoke('get_file_diff', { path: 'some/file.txt', staged: false, contextLines: 3 })
   // Should return { oldContent: '...', newContent: '...', hunks: [...] }
   ```
4. All types visible in `src/bindings.ts` with correct TypeScript types
</verification>

<success_criteria>
- 6 new Tauri commands available: getStagingStatus, stageFile, unstageFile, stageAll, unstageAll, getFileDiff
- StagingStatus correctly categorizes files by staged/unstaged/untracked
- FileDiff provides old/new content for Monaco DiffEditor consumption
- All git2 calls wrapped in spawn_blocking
- index.write() called after every staging mutation
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-git-staging-commits/02-01-SUMMARY.md`
</output>
