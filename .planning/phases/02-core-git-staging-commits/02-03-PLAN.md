---
phase: 02-core-git-staging-commits
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/remote.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/lib.rs
  - src-tauri/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Backend can push to remote with progress streaming"
    - "Backend can pull from remote with progress streaming"
    - "Backend can fetch from remote without merging"
  artifacts:
    - path: "src-tauri/src/git/remote.rs"
      provides: "Push/pull/fetch with Tauri Channels for progress"
      exports: ["SyncProgress", "SyncResult", "push_to_remote", "pull_from_remote", "fetch_from_remote"]
  key_links:
    - from: "remote.rs"
      to: "Tauri Channel"
      via: "on_progress: Channel<SyncProgress>"
      pattern: "on_progress\\.send\\("
    - from: "remote.rs"
      to: "auth-git2"
      via: "credential callbacks"
      pattern: "auth_git2"
---

<objective>
Create the Rust remote module that enables push, pull, and fetch operations with progress streaming via Tauri Channels.

Purpose: Allow users to synchronize with remote repositories while seeing real-time progress feedback.

Output: New remote.rs module with push/pull/fetch commands using Tauri Channels for progress events.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-git-staging-commits/02-CONTEXT.md
@.planning/phases/02-core-git-staging-commits/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Existing code
@src-tauri/src/git/mod.rs
@src-tauri/src/git/error.rs
@src-tauri/src/git/repository.rs
@src-tauri/src/lib.rs
@src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth-git2 dependency and create remote.rs with progress types</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/git/remote.rs
    src-tauri/src/git/mod.rs
    src-tauri/src/git/error.rs
  </files>
  <action>
**Add dependency to Cargo.toml:**
```toml
[dependencies]
auth-git2 = "0.5"
```

**Create `src-tauri/src/git/remote.rs` with types:**

```rust
use serde::{Deserialize, Serialize};
use specta::Type;
use tauri::ipc::Channel;

#[derive(Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase", tag = "event", content = "data")]
pub enum SyncProgress {
    Started { operation: String },
    Counting { current: usize, total: usize },
    Compressing { current: usize, total: usize },
    Transferring { current: usize, total: usize, bytes: usize },
    Resolving { current: usize, total: usize },
    Finished { operation: String },
    Error { message: String },
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct SyncResult {
    pub success: bool,
    pub message: String,
    pub commits_transferred: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct RemoteInfo {
    pub name: String,
    pub url: String,
}
```

**Add helper function for creating callbacks:**

```rust
fn create_remote_callbacks<'a>(
    on_progress: &'a Channel<SyncProgress>,
) -> git2::RemoteCallbacks<'a> {
    let mut callbacks = git2::RemoteCallbacks::new();
    
    // Transfer progress
    callbacks.transfer_progress(|stats| {
        let _ = on_progress.send(SyncProgress::Transferring {
            current: stats.received_objects(),
            total: stats.total_objects(),
            bytes: stats.received_bytes(),
        });
        true
    });
    
    // Sideband progress (textual messages from server)
    callbacks.sideband_progress(|msg| {
        // Parse common messages, or ignore
        true
    });
    
    // Pack progress
    callbacks.pack_progress(|stage, current, total| {
        match stage {
            git2::PackBuilderStage::AddingObjects => {
                let _ = on_progress.send(SyncProgress::Counting { current, total });
            }
            git2::PackBuilderStage::Deltafication => {
                let _ = on_progress.send(SyncProgress::Compressing { current, total });
            }
        }
    });
    
    // Credentials - use auth-git2 for SSH agent support
    callbacks.credentials(|url, username_from_url, allowed_types| {
        auth_git2::GitAuthenticator::new()
            .username(username_from_url)
            .try_build()
            .map(|cred| cred)
    });
    
    callbacks
}
```

**Add error variants to error.rs:**
```rust
#[error("Remote not found: {0}")]
RemoteNotFound(String),

#[error("Authentication failed: {0}")]
AuthenticationFailed(String),

#[error("Push rejected: {0}")]
PushRejected(String),

#[error("Network error: {0}")]
NetworkError(String),
```

**Update mod.rs:** Add `pub mod remote;`
  </action>
  <verify>
    - `cargo check` passes (auth-git2 compiles)
    - `cargo build` succeeds
    - SyncProgress type visible in bindings.ts
  </verify>
  <done>
    - auth-git2 dependency added
    - Progress types defined with Tauri Channel-compatible serde tags
    - Remote callbacks helper created with credential support
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement push, pull, and fetch commands</name>
  <files>
    src-tauri/src/git/remote.rs
    src-tauri/src/lib.rs
  </files>
  <action>
**Add commands to remote.rs:**

1. `get_remotes(state: ...) -> Result<Vec<RemoteInfo>, GitError>`
   - List all configured remotes with names and URLs
   - Return empty vec if no remotes

2. `fetch_from_remote(remote: String, on_progress: Channel<SyncProgress>, state: ...) -> Result<SyncResult, GitError>`

```rust
#[tauri::command]
#[specta::specta]
pub async fn fetch_from_remote(
    remote: String,
    on_progress: Channel<SyncProgress>,
    state: State<'_, RepositoryState>,
) -> Result<SyncResult, GitError> {
    let repo_path = state.get_path().await?;
    
    on_progress.send(SyncProgress::Started { 
        operation: "fetch".to_string() 
    }).ok();
    
    let result = tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;
        let mut remote_obj = repo.find_remote(&remote)
            .map_err(|_| GitError::RemoteNotFound(remote.clone()))?;
        
        let mut opts = git2::FetchOptions::new();
        let callbacks = create_remote_callbacks(&on_progress);
        opts.remote_callbacks(callbacks);
        
        // Fetch all branches
        remote_obj.fetch(&[] as &[&str], Some(&mut opts), None)?;
        
        Ok::<_, GitError>(SyncResult {
            success: true,
            message: format!("Fetched from {}", remote),
            commits_transferred: 0, // TODO: calculate from fetch stats
        })
    }).await.map_err(|e| GitError::Internal(e.to_string()))??;
    
    on_progress.send(SyncProgress::Finished { 
        operation: "fetch".to_string() 
    }).ok();
    
    Ok(result)
}
```

3. `push_to_remote(remote: String, on_progress: Channel<SyncProgress>, state: ...) -> Result<SyncResult, GitError>`

```rust
// Get current branch name
let head = repo.head()?;
let branch_name = head.shorthand().unwrap_or("HEAD");

// Build refspec for current branch
let refspec = format!(
    "refs/heads/{}:refs/heads/{}",
    branch_name, branch_name
);

let mut opts = git2::PushOptions::new();
let callbacks = create_remote_callbacks(&on_progress);
opts.remote_callbacks(callbacks);

remote_obj.push(&[&refspec], Some(&mut opts))?;
```

4. `pull_from_remote(remote: String, on_progress: Channel<SyncProgress>, state: ...) -> Result<SyncResult, GitError>`

Pull is fetch + merge. Implementation:
```rust
// 1. Fetch first
fetch_from_remote(...)?;

// 2. Get fetch head
let fetch_head = repo.find_reference("FETCH_HEAD")?;
let fetch_commit = repo.reference_to_annotated_commit(&fetch_head)?;

// 3. Perform merge analysis
let (analysis, _) = repo.merge_analysis(&[&fetch_commit])?;

if analysis.is_fast_forward() {
    // Fast-forward: just update HEAD
    let refname = format!("refs/heads/{}", branch_name);
    let mut reference = repo.find_reference(&refname)?;
    reference.set_target(fetch_commit.id(), "pull: fast-forward")?;
    repo.set_head(&refname)?;
    repo.checkout_head(Some(git2::build::CheckoutBuilder::default().force()))?;
} else if analysis.is_normal() {
    // Normal merge required
    repo.merge(&[&fetch_commit], None, None)?;
    // Note: This may leave repo in merge state if conflicts
    // Check for conflicts and report
} else if analysis.is_up_to_date() {
    // Nothing to do
}
```

**Handle conflicts gracefully:**
- If merge has conflicts, return SyncResult with success=false and message explaining conflicts
- Do NOT auto-commit merge (user should review)

**Update lib.rs:** Add commands to collect_commands!:
```rust
get_remotes,
fetch_from_remote,
push_to_remote,
pull_from_remote,
```
  </action>
  <verify>
    - `cargo check` passes
    - `cargo build` succeeds
    - `src/bindings.ts` contains `getRemotes`, `fetchFromRemote`, `pushToRemote`, `pullFromRemote` functions
    - `src/bindings.ts` contains correct Channel parameter types
  </verify>
  <done>
    - All 4 remote commands implemented
    - Progress streaming works via Tauri Channels
    - SSH authentication via auth-git2 (uses ssh-agent)
    - Fast-forward and merge scenarios handled
    - Conflicts reported gracefully (not auto-resolved)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `cargo build` succeeds
2. Test requires a repo with a remote configured. In dev tools:
   ```javascript
   // List remotes
   const remotes = await __TAURI__.invoke('get_remotes')
   console.log(remotes) // [{ name: 'origin', url: '...' }]
   
   // Fetch with progress
   const { Channel } = await import('@tauri-apps/api/core')
   const progress = new Channel()
   progress.onmessage = (msg) => console.log('Progress:', msg)
   await __TAURI__.invoke('fetch_from_remote', { 
     remote: 'origin', 
     onProgress: progress 
   })
   ```
3. Note: Full testing of push/pull requires proper SSH keys or HTTPS credentials configured in git
</verification>

<success_criteria>
- auth-git2 handles SSH agent authentication automatically
- Progress events stream to frontend via Tauri Channels
- Fetch downloads remote refs without merging
- Push sends current branch to remote
- Pull does fetch + fast-forward/merge
- Conflict scenarios return informative error messages
- All git2 calls wrapped in spawn_blocking
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-git-staging-commits/02-03-SUMMARY.md`
</output>
