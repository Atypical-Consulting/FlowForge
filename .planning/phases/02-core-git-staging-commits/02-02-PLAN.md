---
phase: 02-core-git-staging-commits
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/commit.rs
  - src-tauri/src/git/history.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Backend can create commits from staged changes"
    - "Backend can amend the last commit"
    - "Backend can return paginated commit history"
    - "Backend can return full details of any commit"
  artifacts:
    - path: "src-tauri/src/git/commit.rs"
      provides: "Commit creation with amend support"
      exports: ["CommitInfo", "create_commit"]
    - path: "src-tauri/src/git/history.rs"
      provides: "History traversal with pagination"
      exports: ["CommitSummary", "CommitDetails", "get_commit_history", "get_commit_details"]
  key_links:
    - from: "commit.rs"
      to: "git2::Repository::commit"
      via: "spawn_blocking"
      pattern: "repo\\.commit\\("
    - from: "history.rs"
      to: "git2::Revwalk"
      via: "spawn_blocking"
      pattern: "repo\\.revwalk\\(\\)"
---

<objective>
Create the Rust commit and history modules that enable creating commits and viewing commit history with pagination.

Purpose: Enable users to commit staged changes and browse project history. This completes the core commit workflow.

Output: New commit.rs and history.rs modules with Tauri commands exported via tauri-specta.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-git-staging-commits/02-CONTEXT.md
@.planning/phases/02-core-git-staging-commits/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Existing code
@src-tauri/src/git/mod.rs
@src-tauri/src/git/error.rs
@src-tauri/src/git/repository.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create commit.rs with commit creation command</name>
  <files>
    src-tauri/src/git/commit.rs
    src-tauri/src/git/mod.rs
    src-tauri/src/git/error.rs
  </files>
  <action>
Create `src-tauri/src/git/commit.rs` with:

**Types:**

```rust
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct CommitInfo {
    pub oid: String,
    pub short_oid: String,
    pub message: String,
}
```

**Commands:**

1. `create_commit(message: String, amend: bool, state: ...) -> Result<CommitInfo, GitError>`

Implementation (wrapped in spawn_blocking):
```rust
let repo = git2::Repository::open(&repo_path)?;
let sig = repo.signature()?; // Uses git config user.name/email

let mut index = repo.index()?;
let tree_oid = index.write_tree()?;
let tree = repo.find_tree(tree_oid)?;

let oid = if amend {
    // Amend: reuse parent's parents
    let head = repo.head()?.peel_to_commit()?;
    let parents: Vec<_> = head.parents().collect();
    let parent_refs: Vec<_> = parents.iter().collect();
    
    repo.commit(
        Some("HEAD"),
        &sig,
        &sig,
        &message,
        &tree,
        &parent_refs,
    )?
} else {
    // Normal commit: HEAD is parent (if exists)
    match repo.head() {
        Ok(head) => {
            let parent = head.peel_to_commit()?;
            repo.commit(
                Some("HEAD"),
                &sig,
                &sig,
                &message,
                &tree,
                &[&parent],
            )?
        }
        Err(e) if e.code() == git2::ErrorCode::UnbornBranch => {
            // First commit - no parent
            repo.commit(
                Some("HEAD"),
                &sig,
                &sig,
                &message,
                &tree,
                &[],
            )?
        }
        Err(e) => return Err(e.into()),
    }
};

Ok(CommitInfo {
    oid: oid.to_string(),
    short_oid: format!("{:.7}", oid),
    message,
})
```

**Error handling additions to error.rs:**
- Add `NoStagedChanges` variant for when user tries to commit with empty index
- Add `SignatureError(String)` for git config issues

**Validation before commit:**
- Check that index has staged changes (compare tree_oid to HEAD tree oid)
- Return `NoStagedChanges` error if nothing staged

**Update mod.rs:** Add `pub mod commit;`
  </action>
  <verify>
    - `cargo check` passes
    - `cargo build` succeeds
    - `src/bindings.ts` contains `createCommit` function
    - `src/bindings.ts` contains `CommitInfo` type
  </verify>
  <done>
    - createCommit creates a new commit from staged changes
    - Amend mode updates the last commit instead of creating new
    - First commit on empty repo works (no parent)
    - Returns commit oid and message
  </done>
</task>

<task type="auto">
  <name>Task 2: Create history.rs with history pagination commands</name>
  <files>
    src-tauri/src/git/history.rs
    src-tauri/src/git/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
Create `src-tauri/src/git/history.rs` with:

**Types:**

```rust
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct CommitSummary {
    pub oid: String,
    pub short_oid: String,
    pub message_subject: String,  // First line only
    pub author_name: String,
    pub author_email: String,
    pub timestamp: i64,           // Unix timestamp (seconds)
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct CommitDetails {
    pub oid: String,
    pub short_oid: String,
    pub message: String,          // Full message
    pub author_name: String,
    pub author_email: String,
    pub author_timestamp: i64,
    pub committer_name: String,
    pub committer_email: String,
    pub committer_timestamp: i64,
    pub parent_oids: Vec<String>,
    pub files_changed: Vec<FileChanged>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct FileChanged {
    pub path: String,
    pub status: String,  // "added", "modified", "deleted", "renamed"
    pub additions: i32,
    pub deletions: i32,
}
```

**Commands:**

1. `get_commit_history(skip: usize, limit: usize, state: ...) -> Result<Vec<CommitSummary>, GitError>`

```rust
let repo = git2::Repository::open(&repo_path)?;

// Handle empty repo
match repo.head() {
    Err(e) if e.code() == git2::ErrorCode::UnbornBranch => {
        return Ok(vec![]);
    }
    Err(e) => return Err(e.into()),
    Ok(_) => {}
}

let mut revwalk = repo.revwalk()?;
revwalk.push_head()?;
revwalk.set_sorting(git2::Sort::TIME)?;

let commits: Vec<CommitSummary> = revwalk
    .skip(skip)
    .take(limit)
    .filter_map(|oid| oid.ok())
    .filter_map(|oid| {
        let commit = repo.find_commit(oid).ok()?;
        let author = commit.author();
        
        Some(CommitSummary {
            oid: oid.to_string(),
            short_oid: format!("{:.7}", oid),
            message_subject: commit.summary()
                .unwrap_or("")
                .to_string(),
            author_name: author.name()
                .unwrap_or("Unknown")
                .to_string(),
            author_email: author.email()
                .unwrap_or("")
                .to_string(),
            timestamp: author.when().seconds(),
        })
    })
    .collect();

Ok(commits)
```

2. `get_commit_details(oid: String, state: ...) -> Result<CommitDetails, GitError>`
   - Parse oid string to git2::Oid
   - Get commit via `repo.find_commit(oid)?`
   - Get diff to parent: `repo.diff_tree_to_tree(parent_tree, commit_tree, None)?`
   - Iterate diff deltas to build files_changed list
   - For merge commits (multiple parents), diff against first parent

**Update lib.rs:** Add commands to collect_commands!:
```rust
create_commit,
get_commit_history,
get_commit_details,
```
  </action>
  <verify>
    - `cargo check` passes
    - `cargo build` succeeds
    - `src/bindings.ts` contains `getCommitHistory`, `getCommitDetails` functions
    - `src/bindings.ts` contains `CommitSummary`, `CommitDetails`, `FileChanged` types
    - Test: `await __TAURI__.invoke('get_commit_history', { skip: 0, limit: 10 })`
  </verify>
  <done>
    - getCommitHistory returns paginated list of commits (skip/limit)
    - getCommitDetails returns full commit info including changed files
    - Empty repositories return empty array (no crash)
    - Timestamps are Unix seconds for easy frontend formatting
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `cargo build` succeeds
2. Test in dev tools console:
   ```javascript
   // Stage some files first
   await __TAURI__.invoke('stage_all')
   
   // Create commit
   const commit = await __TAURI__.invoke('create_commit', { 
     message: 'test: verify commit creation', 
     amend: false 
   })
   console.log(commit) // { oid: '...', shortOid: '...', message: '...' }
   
   // View history
   const history = await __TAURI__.invoke('get_commit_history', { skip: 0, limit: 5 })
   console.log(history) // Array of CommitSummary
   
   // View details
   const details = await __TAURI__.invoke('get_commit_details', { oid: history[0].oid })
   console.log(details) // Full CommitDetails with files changed
   ```
</verification>

<success_criteria>
- createCommit successfully creates commits with proper parent linking
- Amend mode works to update last commit
- First commit on empty repo works (handles UnbornBranch)
- getCommitHistory returns paginated results
- getCommitDetails returns full commit info with file changes
- All git2 calls wrapped in spawn_blocking
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-git-staging-commits/02-02-SUMMARY.md`
</output>
