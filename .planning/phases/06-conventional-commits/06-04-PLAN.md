---
phase: 06-conventional-commits
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/stores/conventionalStore.ts
  - src/hooks/useConventionalCommit.ts
autonomous: true

must_haves:
  truths:
    - "Frontend has state management for conventional commit form"
    - "Validation results are debounced and cached"
    - "Type and scope suggestions are fetched and stored"
  artifacts:
    - path: "src/stores/conventionalStore.ts"
      provides: "Zustand store for conventional commit state"
      exports: ["useConventionalStore"]
    - path: "src/hooks/useConventionalCommit.ts"
      provides: "Hook for conventional commit form logic"
      exports: ["useConventionalCommit"]
  key_links:
    - from: "src/stores/conventionalStore.ts"
      to: "IPC commands"
      via: "invoke calls"
      pattern: "invoke.*conventional"
---

<objective>
Create frontend state management and hooks for conventional commit features.

Purpose: Provide reactive state for the commit form with debounced validation and cached suggestions.
Output: Zustand store and custom hook for conventional commit form.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-conventional-commits/06-RESEARCH.md
@src/stores/repositoryStore.ts
@src/stores/stagingStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conventional commit Zustand store</name>
  <files>src/stores/conventionalStore.ts</files>
  <action>
1. Create `src/stores/conventionalStore.ts` with Zustand store:

```typescript
import { create } from 'zustand';
import { invoke } from '@tauri-apps/api/core';

// Types matching Rust structs
interface ValidationError {
  code: string;
  message: string;
  suggestion: string | null;
}

interface ValidationWarning {
  code: string;
  message: string;
}

interface ValidationResult {
  is_valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

interface TypeSuggestion {
  suggested_type: string;
  confidence: 'High' | 'Medium' | 'Low';
  reason: string;
}

interface ScopeSuggestion {
  scope: string;
  usage_count: number;
}

// Commit types
const COMMIT_TYPES = ['feat', 'fix', 'docs', 'style', 'refactor', 'perf', 'test', 'chore', 'ci', 'build', 'revert'] as const;
type CommitType = typeof COMMIT_TYPES[number];

interface ConventionalState {
  // Form state
  commitType: CommitType | '';
  scope: string;
  description: string;
  body: string;
  isBreaking: boolean;
  breakingDescription: string;
  
  // Suggestions
  typeSuggestion: TypeSuggestion | null;
  scopeSuggestions: ScopeSuggestion[];
  inferredScope: string | null;
  
  // Validation
  validation: ValidationResult | null;
  isValidating: boolean;
  
  // Actions
  setCommitType: (type: CommitType | '') => void;
  setScope: (scope: string) => void;
  setDescription: (desc: string) => void;
  setBody: (body: string) => void;
  setIsBreaking: (breaking: boolean) => void;
  setBreakingDescription: (desc: string) => void;
  
  // Async actions
  fetchTypeSuggestion: () => Promise<void>;
  fetchScopeSuggestions: () => Promise<void>;
  fetchInferredScope: () => Promise<void>;
  validateMessage: (message: string) => Promise<void>;
  
  // Utilities
  buildCommitMessage: () => string;
  reset: () => void;
}

export const useConventionalStore = create<ConventionalState>((set, get) => ({
  // Initial state
  commitType: '',
  scope: '',
  description: '',
  body: '',
  isBreaking: false,
  breakingDescription: '',
  typeSuggestion: null,
  scopeSuggestions: [],
  inferredScope: null,
  validation: null,
  isValidating: false,
  
  // Setters
  setCommitType: (type) => set({ commitType: type }),
  setScope: (scope) => set({ scope }),
  setDescription: (desc) => set({ description: desc }),
  setBody: (body) => set({ body }),
  setIsBreaking: (breaking) => set({ isBreaking: breaking }),
  setBreakingDescription: (desc) => set({ breakingDescription: desc }),
  
  // Async actions
  fetchTypeSuggestion: async () => {
    try {
      const suggestion = await invoke<TypeSuggestion>('suggest_commit_type');
      set({ typeSuggestion: suggestion });
      // Auto-fill if high confidence and no type selected
      if (suggestion.confidence === 'High' && !get().commitType) {
        set({ commitType: suggestion.suggested_type as CommitType });
      }
    } catch (e) {
      console.error('Failed to fetch type suggestion:', e);
    }
  },
  
  fetchScopeSuggestions: async () => {
    try {
      const suggestions = await invoke<ScopeSuggestion[]>('get_scope_suggestions', { limit: 20 });
      set({ scopeSuggestions: suggestions });
    } catch (e) {
      console.error('Failed to fetch scope suggestions:', e);
    }
  },
  
  fetchInferredScope: async () => {
    try {
      const scope = await invoke<string | null>('infer_scope_from_staged');
      set({ inferredScope: scope });
      // Auto-fill if scope is inferred and not already set
      if (scope && !get().scope) {
        set({ scope });
      }
    } catch (e) {
      console.error('Failed to infer scope:', e);
    }
  },
  
  validateMessage: async (message) => {
    set({ isValidating: true });
    try {
      const result = await invoke<ValidationResult>('validate_conventional_commit', { message });
      set({ validation: result, isValidating: false });
    } catch (e) {
      console.error('Validation failed:', e);
      set({ isValidating: false });
    }
  },
  
  buildCommitMessage: () => {
    const { commitType, scope, description, body, isBreaking, breakingDescription } = get();
    
    // Build header: type(scope)!: description
    let header = commitType;
    if (scope) header += `(${scope})`;
    if (isBreaking) header += '!';
    header += `: ${description}`;
    
    // Build full message
    let message = header;
    if (body) {
      message += `\n\n${body}`;
    }
    if (isBreaking && breakingDescription) {
      message += `\n\nBREAKING CHANGE: ${breakingDescription}`;
    }
    
    return message;
  },
  
  reset: () => set({
    commitType: '',
    scope: '',
    description: '',
    body: '',
    isBreaking: false,
    breakingDescription: '',
    typeSuggestion: null,
    inferredScope: null,
    validation: null,
    isValidating: false,
  }),
}));

export { COMMIT_TYPES };
export type { CommitType, ValidationResult, TypeSuggestion, ScopeSuggestion };
```
  </action>
  <verify>
    - TypeScript compiles without errors
    - Store exports all required types and hook
  </verify>
  <done>Zustand store created with all conventional commit state management</done>
</task>

<task type="auto">
  <name>Task 2: Create useConventionalCommit hook with debounced validation</name>
  <files>src/hooks/useConventionalCommit.ts</files>
  <action>
1. Create `src/hooks/useConventionalCommit.ts`:

```typescript
import { useEffect, useMemo, useCallback } from 'react';
import { useConventionalStore, COMMIT_TYPES, type CommitType } from '../stores/conventionalStore';
import { useStagingStore } from '../stores/stagingStore';
import { debounce } from '../utils/debounce'; // or use lodash-es

export function useConventionalCommit() {
  const store = useConventionalStore();
  const { staged, partiallyStaged } = useStagingStore();
  
  // Fetch suggestions when staged files change
  useEffect(() => {
    const hasStaged = staged.length > 0 || partiallyStaged.length > 0;
    if (hasStaged) {
      store.fetchTypeSuggestion();
      store.fetchInferredScope();
    }
  }, [staged, partiallyStaged]);
  
  // Fetch scope suggestions on mount
  useEffect(() => {
    store.fetchScopeSuggestions();
  }, []);
  
  // Build current message
  const currentMessage = store.buildCommitMessage();
  
  // Debounced validation
  const debouncedValidate = useMemo(
    () => debounce((message: string) => {
      if (message.trim()) {
        store.validateMessage(message);
      }
    }, 300),
    []
  );
  
  // Validate on message change
  useEffect(() => {
    if (store.description) {
      debouncedValidate(currentMessage);
    }
    return () => debouncedValidate.cancel?.();
  }, [currentMessage, debouncedValidate]);
  
  // Filtered scope suggestions for autocomplete
  const filteredScopes = useMemo(() => {
    const query = store.scope.toLowerCase();
    if (!query) return store.scopeSuggestions;
    return store.scopeSuggestions.filter(s => 
      s.scope.toLowerCase().includes(query)
    );
  }, [store.scope, store.scopeSuggestions]);
  
  // Is form valid for commit?
  const canCommit = useMemo(() => {
    return (
      store.commitType !== '' &&
      store.description.trim() !== '' &&
      (store.validation?.is_valid ?? false) &&
      (!store.isBreaking || store.breakingDescription.trim() !== '')
    );
  }, [store.commitType, store.description, store.validation, store.isBreaking, store.breakingDescription]);
  
  // Apply type suggestion
  const applyTypeSuggestion = useCallback(() => {
    if (store.typeSuggestion) {
      store.setCommitType(store.typeSuggestion.suggested_type as CommitType);
    }
  }, [store.typeSuggestion]);
  
  // Apply scope suggestion
  const applyScopeSuggestion = useCallback((scope: string) => {
    store.setScope(scope);
  }, []);
  
  return {
    // State
    commitType: store.commitType,
    scope: store.scope,
    description: store.description,
    body: store.body,
    isBreaking: store.isBreaking,
    breakingDescription: store.breakingDescription,
    
    // Suggestions
    typeSuggestion: store.typeSuggestion,
    scopeSuggestions: filteredScopes,
    inferredScope: store.inferredScope,
    
    // Validation
    validation: store.validation,
    isValidating: store.isValidating,
    canCommit,
    
    // Computed
    currentMessage,
    commitTypes: COMMIT_TYPES,
    
    // Actions
    setCommitType: store.setCommitType,
    setScope: store.setScope,
    setDescription: store.setDescription,
    setBody: store.setBody,
    setIsBreaking: store.setIsBreaking,
    setBreakingDescription: store.setBreakingDescription,
    applyTypeSuggestion,
    applyScopeSuggestion,
    reset: store.reset,
  };
}
```

2. Ensure debounce utility exists or create it:

```typescript
// src/utils/debounce.ts
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  ms: number
): T & { cancel: () => void } {
  let timeoutId: ReturnType<typeof setTimeout> | null = null;
  
  const debounced = (...args: Parameters<T>) => {
    if (timeoutId) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), ms);
  };
  
  debounced.cancel = () => {
    if (timeoutId) clearTimeout(timeoutId);
  };
  
  return debounced as T & { cancel: () => void };
}
```
  </action>
  <verify>
    - TypeScript compiles without errors
    - Hook exports all required values and actions
  </verify>
  <done>Custom hook created with debounced validation and suggestion management</done>
</task>

</tasks>

<verification>
```bash
# Type check
npm run typecheck || pnpm typecheck

# Check imports work
grep -r "useConventionalStore\|useConventionalCommit" src/
```
</verification>

<success_criteria>
- [ ] conventionalStore.ts created with Zustand store
- [ ] Store has all form state and async actions
- [ ] useConventionalCommit hook created
- [ ] Debounced validation working (300ms)
- [ ] Suggestions auto-fetched on staged files change
- [ ] canCommit computed correctly
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-conventional-commits/06-04-SUMMARY.md`
</output>
