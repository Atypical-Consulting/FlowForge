---
phase: 06-conventional-commits
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src-tauri/src/commands/conventional.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Frontend can validate commit messages via IPC"
    - "Frontend can get type suggestions for staged files"
    - "Frontend can get scope autocomplete from history"
    - "Frontend can generate changelog via IPC"
  artifacts:
    - path: "src-tauri/src/commands/conventional.rs"
      provides: "IPC commands for conventional commit features"
      exports: ["validate_conventional_commit", "suggest_commit_type", "get_scope_suggestions", "generate_changelog_cmd"]
  key_links:
    - from: "src-tauri/src/commands/conventional.rs"
      to: "src-tauri/src/git/conventional.rs"
      via: "function calls"
      pattern: "conventional::"
    - from: "src-tauri/src/commands/conventional.rs"
      to: "src-tauri/src/git/changelog.rs"
      via: "function calls"
      pattern: "changelog::"
---

<objective>
Register IPC commands to expose conventional commit functionality to the React frontend.

Purpose: Bridge the Rust backend modules to the frontend via tauri-specta IPC.
Output: IPC commands registered and TypeScript bindings generated.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-conventional-commits/06-01-SUMMARY.md
@.planning/phases/06-conventional-commits/06-02-SUMMARY.md
@src-tauri/src/commands/mod.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conventional commands module</name>
  <files>src-tauri/src/commands/conventional.rs, src-tauri/src/commands/mod.rs</files>
  <action>
1. Create `src-tauri/src/commands/conventional.rs` with IPC commands:

```rust
use crate::git::{conventional, changelog};
use crate::state::AppState;
use tauri::State;

#[tauri::command]
#[specta::specta]
pub async fn validate_conventional_commit(
    message: String,
) -> Result<conventional::ValidationResult, String> {
    Ok(conventional::validate_commit_message(&message))
}

#[tauri::command]
#[specta::specta]
pub async fn suggest_commit_type(
    state: State<'_, AppState>,
) -> Result<conventional::TypeSuggestion, String> {
    let repo_guard = state.repository.lock().await;
    let repo = repo_guard.as_ref().ok_or("No repository open")?;
    
    // Get staged files from staging module
    let staging_status = crate::git::staging::get_staging_status(repo)
        .map_err(|e| e.to_string())?;
    
    let staged_files: Vec<_> = staging_status.staged.into_iter()
        .chain(staging_status.partially_staged)
        .collect();
    
    Ok(conventional::infer_commit_type(&staged_files))
}

#[tauri::command]
#[specta::specta]
pub async fn get_scope_suggestions(
    state: State<'_, AppState>,
    limit: Option<usize>,
) -> Result<Vec<conventional::ScopeSuggestion>, String> {
    let repo_guard = state.repository.lock().await;
    let repo = repo_guard.as_ref().ok_or("No repository open")?;
    
    // Get recent commits
    let commits = crate::git::history::get_commits(repo, 500, 0)
        .map_err(|e| e.to_string())?;
    
    Ok(conventional::extract_scopes_from_history(&commits, limit.unwrap_or(20)))
}

#[tauri::command]
#[specta::specta]
pub async fn infer_scope_from_staged(
    state: State<'_, AppState>,
) -> Result<Option<String>, String> {
    let repo_guard = state.repository.lock().await;
    let repo = repo_guard.as_ref().ok_or("No repository open")?;
    
    let staging_status = crate::git::staging::get_staging_status(repo)
        .map_err(|e| e.to_string())?;
    
    let staged_files: Vec<_> = staging_status.staged.into_iter()
        .chain(staging_status.partially_staged)
        .collect();
    
    Ok(conventional::infer_scope_from_files(&staged_files))
}
```

2. Add `pub mod conventional;` to `src-tauri/src/commands/mod.rs`
  </action>
  <verify>
    - `cargo check` passes
    - Commands are exported
  </verify>
  <done>Conventional commit IPC commands created</done>
</task>

<task type="auto">
  <name>Task 2: Add changelog command and register all commands</name>
  <files>src-tauri/src/commands/conventional.rs, src-tauri/src/lib.rs</files>
  <action>
1. Add changelog command to conventional.rs:

```rust
#[tauri::command]
#[specta::specta]
pub async fn generate_changelog_cmd(
    state: State<'_, AppState>,
    from_ref: Option<String>,
    to_ref: Option<String>,
    version: Option<String>,
) -> Result<changelog::ChangelogOutput, String> {
    let repo_guard = state.repository.lock().await;
    let repo = repo_guard.as_ref().ok_or("No repository open")?;
    
    let options = changelog::ChangelogOptions {
        from_ref,
        to_ref,
        include_unreleased: true,
        group_by_scope: false,
        version,
        date: Some(chrono::Local::now().format("%Y-%m-%d").to_string()),
    };
    
    changelog::generate_changelog(repo, options)
        .map_err(|e| e.to_string())
}
```

2. In `src-tauri/src/lib.rs`, add the new commands to the specta builder and invoke_handler:
   - Find the existing `tauri_specta::Builder` or command registration
   - Add: `validate_conventional_commit`, `suggest_commit_type`, `get_scope_suggestions`, `infer_scope_from_staged`, `generate_changelog_cmd`
   - Follow the existing pattern for registering commands

3. Regenerate TypeScript bindings by running the app or build command (the specta builder should auto-generate on build).
  </action>
  <verify>
    - `cargo check` passes
    - Commands registered in lib.rs
    - `cargo build` succeeds (triggers binding generation)
  </verify>
  <done>All IPC commands registered, bindings will be generated on build</done>
</task>

<task type="auto">
  <name>Task 3: Verify TypeScript bindings generated</name>
  <files>src/bindings.ts or equivalent</files>
  <action>
1. Run `cargo build` to trigger specta binding generation

2. Verify the bindings file contains the new types and functions:
   - validateConventionalCommit
   - suggestCommitType
   - getScopeSuggestions
   - inferScopeFromStaged
   - generateChangelogCmd
   - ValidationResult, TypeSuggestion, ScopeSuggestion types
   - ChangelogOutput, ChangelogOptions types

3. If bindings not auto-generated, check the specta configuration in lib.rs and ensure export path is correct.

4. Test one command from frontend console:
```typescript
import { invoke } from '@tauri-apps/api/core';
await invoke('validate_conventional_commit', { message: 'feat: test' });
```
  </action>
  <verify>
    - TypeScript bindings exist with new types
    - `npm run typecheck` passes (or equivalent)
    - Manual invoke test succeeds
  </verify>
  <done>TypeScript bindings generated and verified working</done>
</task>

</tasks>

<verification>
```bash
# Build to generate bindings
cargo build

# Check bindings generated
grep -l "validateConventionalCommit\|suggestCommitType" src/bindings.ts src/lib/bindings.ts 2>/dev/null || echo "Check bindings location"

# Type check frontend
cd src && npm run typecheck || pnpm typecheck
```
</verification>

<success_criteria>
- [ ] conventional.rs commands module created
- [ ] All 5 commands implemented (validate, suggest_type, get_scopes, infer_scope, changelog)
- [ ] Commands registered in lib.rs
- [ ] TypeScript bindings generated
- [ ] Bindings include all new types
- [ ] cargo build succeeds
- [ ] Frontend typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-conventional-commits/06-03-SUMMARY.md`
</output>
