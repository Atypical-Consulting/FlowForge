---
phase: 06-conventional-commits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/git/conventional.rs
  - src-tauri/src/git/mod.rs
autonomous: true

must_haves:
  truths:
    - "Conventional commit messages can be parsed into structured components"
    - "Invalid commit messages return specific validation errors"
    - "Commit type can be inferred from staged file paths"
  artifacts:
    - path: "src-tauri/src/git/conventional.rs"
      provides: "Conventional commit parsing, validation, and type inference"
      exports: ["parse_conventional_commit", "validate_commit_message", "infer_commit_type", "extract_scopes_from_history"]
  key_links:
    - from: "src-tauri/src/git/conventional.rs"
      to: "git-conventional crate"
      via: "Commit::parse"
      pattern: "git_conventional::Commit"
---

<objective>
Implement the Rust backend module for conventional commit parsing, validation, and type inference.

Purpose: Provide the core logic for conventional commits that the frontend will consume via IPC.
Output: `conventional.rs` module with parsing, validation, type inference, and scope extraction functions.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-conventional-commits/06-RESEARCH.md
@src-tauri/src/git/staging.rs
@src-tauri/src/git/history.rs
@src-tauri/src/git/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create conventional.rs module</name>
  <files>src-tauri/Cargo.toml, src-tauri/src/git/conventional.rs, src-tauri/src/git/mod.rs</files>
  <action>
1. Add to Cargo.toml dependencies:
   - `git-conventional = "0.12"`
   
2. Create `src-tauri/src/git/conventional.rs` with:
   - CommitType enum: Feat, Fix, Docs, Style, Refactor, Perf, Test, Chore, Ci, Build, Revert
   - ParsedCommit struct with: commit_type, scope (Option), description, body (Option), breaking (bool), footers (Vec)
   - Footer struct with: token, value
   - ValidationResult struct with: is_valid, errors (Vec), warnings (Vec)
   - ValidationError struct with: code, message, suggestion (Option)
   - ValidationWarning struct with: code, message
   
3. Add `pub mod conventional;` to `src-tauri/src/git/mod.rs`

All structs must derive Serialize, Deserialize, Clone, Debug, and specta::Type for IPC compatibility.
  </action>
  <verify>
    - `cargo check` passes
    - Module is exported from git mod
  </verify>
  <done>Types defined and module structure in place</done>
</task>

<task type="auto">
  <name>Task 2: Implement parsing and validation functions</name>
  <files>src-tauri/src/git/conventional.rs</files>
  <action>
1. Implement `parse_conventional_commit(message: &str) -> Result<ParsedCommit, ValidationError>`:
   - Guard against empty input first
   - Use `git_conventional::Commit::parse(message)`
   - Map to ParsedCommit struct
   - Extract footers including BREAKING CHANGE
   - Handle both `!` suffix and BREAKING CHANGE footer for breaking detection

2. Implement `validate_commit_message(message: &str) -> ValidationResult`:
   - Try parsing with git_conventional
   - On success: check for warnings (subject > 50 chars, body > 72 chars per line)
   - On failure: convert parse error to ValidationError with specific codes:
     - "EMPTY_MESSAGE" for empty input
     - "INVALID_TYPE" for unrecognized type
     - "MISSING_COLON" for missing `: ` separator
     - "MISSING_DESCRIPTION" for empty description
   - Include suggestions in errors (e.g., "Did you mean 'feat'?" for typos)

3. Define VALID_TYPES constant: ["feat", "fix", "docs", "style", "refactor", "perf", "test", "chore", "ci", "build", "revert"]
  </action>
  <verify>
    - `cargo test` with unit tests for parsing
    - Test cases: valid commits, invalid commits, breaking changes both ways, multi-line footers
  </verify>
  <done>Parsing returns structured ParsedCommit, validation returns specific errors</done>
</task>

<task type="auto">
  <name>Task 3: Implement type inference and scope extraction</name>
  <files>src-tauri/src/git/conventional.rs</files>
  <action>
1. Implement `infer_commit_type(staged_files: &[FileChange]) -> TypeSuggestion`:
   - TypeSuggestion struct with: suggested_type (CommitType), confidence (High/Medium/Low), reason (String)
   - Priority-ordered rules:
     a. Any file path contains "test", "spec", "__tests__" → Test
     b. Any file ends with ".md" or path starts with "docs/" or contains "readme" → Docs
     c. Any file ends with ".css", ".scss", ".less" → Style
     d. All files are new (not in repo) and are source files → Feat
     e. All files are modified source files → Fix
     f. Config files only (.json, .toml, .yaml, .yml in root) → Chore
     g. Fallback → Chore with Low confidence
   - Source files: .rs, .ts, .tsx, .js, .jsx, .py, .go, etc.

2. Implement `infer_scope_from_files(staged_files: &[FileChange]) -> Option<String>`:
   - Find common directory prefix of all staged files
   - If all files in same directory, suggest that directory name as scope
   - If files span multiple directories, return None

3. Implement `extract_scopes_from_history(commits: &[CommitInfo], limit: usize) -> Vec<ScopeSuggestion>`:
   - ScopeSuggestion struct with: scope (String), usage_count (usize)
   - Parse each commit message, extract scope if present
   - Count occurrences, sort by frequency descending
   - Limit to top N scopes (default 20)
   - Filter out scopes with count < 2 (likely typos)

Use FileChange from staging.rs and CommitInfo from history.rs.
  </action>
  <verify>
    - Unit tests for type inference with various file patterns
    - Unit tests for scope extraction
  </verify>
  <done>Type inference suggests type based on files, scope extraction provides autocomplete list</done>
</task>

</tasks>

<verification>
```bash
# Build check
cargo check

# Run tests
cargo test conventional

# Verify module exports
grep -r "pub mod conventional" src-tauri/src/git/
grep -r "pub fn" src-tauri/src/git/conventional.rs
```
</verification>

<success_criteria>
- [ ] git-conventional dependency added to Cargo.toml
- [ ] conventional.rs module created with all types
- [ ] parse_conventional_commit handles valid/invalid messages
- [ ] validate_commit_message returns structured errors
- [ ] infer_commit_type suggests type from file patterns
- [ ] extract_scopes_from_history returns frequency-sorted scopes
- [ ] All functions have unit tests
- [ ] cargo check and cargo test pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-conventional-commits/06-01-SUMMARY.md`
</output>
