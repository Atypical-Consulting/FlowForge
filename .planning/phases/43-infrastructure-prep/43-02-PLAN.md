---
phase: 43-infrastructure-prep
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - src/components/command-palette/CommandPalette.tsx
  - src/blades/_shared/ProcessNavigation.tsx
  - src/components/WelcomeView.tsx
autonomous: true

must_haves:
  truths:
    - "CommandPalette reactively shows new extension commands the moment they register without reopening"
    - "Topology tab hides from process navigation when topology-graph blade is not registered"
    - "WelcomeView renders InitRepoBlade from BladeRegistry lookup, not a hardcoded import"
    - "If active process is topology and blade is unregistered, auto-switch to staging occurs"
    - "WelcomeView shows a defensive fallback if init-repo blade is not yet registered"
  artifacts:
    - path: "src/components/command-palette/CommandPalette.tsx"
      provides: "Reactive command list via useCommandRegistry Zustand selector"
      contains: "useCommandRegistry"
    - path: "src/blades/_shared/ProcessNavigation.tsx"
      provides: "Conditional topology tab visibility based on BladeRegistry state"
      contains: "useBladeRegistry"
    - path: "src/components/WelcomeView.tsx"
      provides: "BladeRegistry lookup for InitRepoBlade component"
      contains: "useBladeRegistry"
  key_links:
    - from: "src/components/command-palette/CommandPalette.tsx"
      to: "src/lib/commandRegistry.ts"
      via: "useCommandRegistry((s) => s.commands) Zustand selector"
      pattern: "useCommandRegistry"
    - from: "src/blades/_shared/ProcessNavigation.tsx"
      to: "src/lib/bladeRegistry.ts"
      via: "useBladeRegistry((s) => s.blades) selector for topology-graph check"
      pattern: "blades\\.has.*topology-graph"
    - from: "src/components/WelcomeView.tsx"
      to: "src/lib/bladeRegistry.ts"
      via: "useBladeRegistry((s) => s.blades.get('init-repo')) for component lookup"
      pattern: "blades\\.get.*init-repo"
---

<objective>
Wire the migrated registries into the three UI consumers that need reactive behavior: CommandPalette subscribes to command changes, ProcessNavigation conditionally shows the Topology tab, and WelcomeView resolves InitRepoBlade from BladeRegistry.

Purpose: These changes close the reactivity gap in CommandPalette (INFRA-03), establish the process tab visibility pattern needed for Topology extraction in Phase 46 (INFRA-04), and remove the hardcoded InitRepoBlade import in WelcomeView (INFRA-05).

Output: Three modified component files with reactive registry subscriptions replacing static snapshots and hardcoded imports.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-infrastructure-prep/43-01-SUMMARY.md

@src/components/command-palette/CommandPalette.tsx
@src/blades/_shared/ProcessNavigation.tsx
@src/components/WelcomeView.tsx
@src/lib/commandRegistry.ts
@src/lib/bladeRegistry.ts
@src/machines/navigation/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make CommandPalette reactively subscribe to command registry</name>
  <files>src/components/command-palette/CommandPalette.tsx</files>
  <action>
Replace the non-reactive `useMemo(() => getEnabledCommands(), [isOpen])` with a Zustand store subscription.

**Changes to imports:**
- Add: `import { useCommandRegistry } from "../../lib/commandRegistry";`
- Remove: `getEnabledCommands` from the existing import (keep `getOrderedCategories` and `CommandCategory`)

**Replace line 24:**

Current (non-reactive):
```typescript
const enabledCommands = useMemo(() => getEnabledCommands(), [isOpen]);
```

New (reactive):
```typescript
// Subscribe to commands Map -- re-renders on any register/unregister
const commandsMap = useCommandRegistry((s) => s.commands);

const enabledCommands = useMemo(
  () => Array.from(commandsMap.values()).filter((cmd) => (cmd.enabled ? cmd.enabled() : true)),
  [commandsMap],
);
```

**Also update `groupedResults` memo** to depend on `commandsMap` instead of just `results` and `query`:

Current:
```typescript
const groupedResults = useMemo(() => {
  if (query.trim()) return null;
  // ...uses getOrderedCategories()...
}, [results, query]);
```

New:
```typescript
const groupedResults = useMemo(() => {
  if (query.trim()) return null;
  const groups = new Map<CommandCategory, typeof results>();
  for (const item of results) {
    const cat = item.command.category;
    if (!groups.has(cat)) groups.set(cat, []);
    groups.get(cat)!.push(item);
  }
  return getOrderedCategories().filter((cat) => groups.has(cat as CommandCategory)).map((cat) => ({
    category: cat,
    items: groups.get(cat)!,
  }));
}, [results, query, commandsMap]);
```

Add `commandsMap` to the dependency array so category ordering re-derives when commands change.

**Clamp selectedIndex when results shrink (prevent out-of-bounds):**

Add after the `results` useMemo:
```typescript
// Clamp selectedIndex when results list shrinks (e.g., extension disabled while palette open)
useEffect(() => {
  if (results.length > 0 && selectedIndex >= results.length) {
    setSelectedIndex(Math.max(0, results.length - 1));
  }
}, [results.length, selectedIndex, setSelectedIndex]);
```

**Important:** The palette renders `null` when `!isOpen`, so re-renders from command registration during startup are essentially free (no DOM work). No performance optimization needed.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | grep -v "bindings.ts"` -- zero new type errors.
Run `npx vitest run --reporter=verbose 2>&1` -- all existing tests pass.
Verify that `useCommandRegistry` appears in CommandPalette.tsx imports.
Verify that `getEnabledCommands` is no longer imported (the backward-compat export still exists in commandRegistry.ts, but CommandPalette no longer uses it).
  </verify>
  <done>
CommandPalette subscribes to `useCommandRegistry((s) => s.commands)` and derives `enabledCommands` reactively. Commands appear/disappear in real-time when extensions register/unregister. selectedIndex is clamped when the list shrinks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add conditional process tab visibility and WelcomeView registry lookup</name>
  <files>src/blades/_shared/ProcessNavigation.tsx, src/components/WelcomeView.tsx</files>
  <action>
**Part A: ProcessNavigation conditional topology tab (INFRA-04)**

Modify `src/blades/_shared/ProcessNavigation.tsx` to conditionally show the Topology tab based on BladeRegistry state.

**Add imports:**
```typescript
import { useEffect, useMemo } from "react";
import { useBladeRegistry } from "../../lib/bladeRegistry";
```

**Replace the static `PROCESSES` const with a reactive derivation:**

Keep the static array as a base definition:
```typescript
const ALL_PROCESSES = [
  { id: "staging" as ProcessType, label: "Staging", icon: Files },
  { id: "topology" as ProcessType, label: "Topology", icon: Network },
];
```

Inside the component, derive visible processes reactively:
```typescript
const blades = useBladeRegistry((s) => s.blades);
const visibleProcesses = useMemo(
  () => ALL_PROCESSES.filter((p) => p.id === "staging" || blades.has("topology-graph")),
  [blades],
);
```

**Add auto-fallback effect:**
If the user is on the topology process and the blade becomes unavailable, auto-switch to staging:
```typescript
useEffect(() => {
  if (activeProcess === "topology" && !blades.has("topology-graph")) {
    actorRef.send({ type: "SWITCH_PROCESS", process: "staging" });
  }
}, [activeProcess, blades, actorRef]);
```

**Update the render to use `visibleProcesses` instead of `PROCESSES`:**
```typescript
{visibleProcesses.map(({ id, label, icon: Icon }) => (
  // ...existing button JSX unchanged...
))}
```

Keep the tab bar `div` visible even when only "Staging" remains (preserve spatial consistency per UX research).

**Part B: WelcomeView BladeRegistry lookup (INFRA-05)**

Modify `src/components/WelcomeView.tsx` to resolve InitRepoBlade from BladeRegistry instead of a hardcoded import.

**Change imports:**
- Remove: `import { InitRepoBlade } from "../blades/init-repo";`
- Add: `import { Suspense } from "react";` (add to existing react import)
- Add: `import { useBladeRegistry } from "../lib/bladeRegistry";`

**Inside the WelcomeView component, add:**
```typescript
const initRepoRegistration = useBladeRegistry((s) => s.blades.get("init-repo"));
```

**Replace the InitRepoBlade rendering block (lines 117-132):**

Current:
```tsx
if (showInitRepo && pendingInitPath) {
  return (
    <div className="h-[calc(100vh-3.5rem)] bg-ctp-base">
      <InitRepoBlade
        directoryPath={pendingInitPath}
        onCancel={() => setShowInitRepo(false)}
        onComplete={async (path) => {
          await openRepository(path);
          await addRecentRepo(path);
          setShowInitRepo(false);
          setPendingInitPath(null);
        }}
      />
    </div>
  );
}
```

New:
```tsx
if (showInitRepo && pendingInitPath) {
  if (!initRepoRegistration) {
    // Defensive fallback: blade not yet registered (race condition guard)
    return (
      <div className="h-[calc(100vh-3.5rem)] bg-ctp-base flex items-center justify-center">
        <p className="text-ctp-subtext0">Preparing repository setup...</p>
      </div>
    );
  }

  const InitComponent = initRepoRegistration.component;
  return (
    <div className="h-[calc(100vh-3.5rem)] bg-ctp-base">
      <Suspense
        fallback={
          <div className="h-full flex items-center justify-center">
            <p className="text-ctp-subtext0">Loading...</p>
          </div>
        }
      >
        <InitComponent
          directoryPath={pendingInitPath}
          onCancel={() => setShowInitRepo(false)}
          onComplete={async (path: string) => {
            await openRepository(path);
            await addRecentRepo(path);
            setShowInitRepo(false);
            setPendingInitPath(null);
          }}
        />
      </Suspense>
    </div>
  );
}
```

**Why Suspense:** The InitRepoBlade may be registered with `lazy: true` by an extension, requiring a Suspense boundary. The `_discovery.ts` eager glob guarantees the blade IS registered before WelcomeView renders in normal operation, but the Zustand subscription provides an additional safety net.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | grep -v "bindings.ts"` -- zero new type errors.
Run `npx vitest run --reporter=verbose 2>&1` -- all existing tests pass.
Verify that `ProcessNavigation.tsx` imports `useBladeRegistry` and checks `blades.has("topology-graph")`.
Verify that `WelcomeView.tsx` no longer imports `InitRepoBlade` directly and uses `useBladeRegistry` for lookup.
  </verify>
  <done>
ProcessNavigation conditionally shows Topology tab based on BladeRegistry state, with auto-fallback to staging when topology is unavailable. WelcomeView resolves InitRepoBlade from BladeRegistry lookup with Suspense boundary and defensive fallback for missing registration.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit 2>&1 | grep -v "bindings.ts"` passes with zero new errors
2. `npx vitest run` -- all existing tests pass
3. CommandPalette.tsx contains `useCommandRegistry` import and NO `getEnabledCommands` import
4. ProcessNavigation.tsx contains `useBladeRegistry` import and `topology-graph` registry check
5. WelcomeView.tsx does NOT contain `import { InitRepoBlade }` -- replaced with BladeRegistry lookup
6. WelcomeView.tsx has a `<Suspense>` boundary wrapping the dynamically resolved component
</verification>

<success_criteria>
- CommandPalette uses reactive Zustand selector for commands (not `useMemo(() => getEnabledCommands(), [isOpen])`)
- ProcessNavigation hides topology tab when `topology-graph` is not in BladeRegistry
- ProcessNavigation auto-switches to staging if active process is topology and blade is removed
- WelcomeView uses BladeRegistry lookup for InitRepoBlade with Suspense and defensive fallback
- No hardcoded `InitRepoBlade` import in WelcomeView.tsx
- All type-checks and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/43-infrastructure-prep/43-02-SUMMARY.md`
</output>
