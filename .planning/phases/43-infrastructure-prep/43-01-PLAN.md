---
phase: 43-infrastructure-prep
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/commandRegistry.ts
  - src/lib/previewRegistry.ts
  - src/blades/staging-changes/components/previewRegistrations.ts
autonomous: true

must_haves:
  truths:
    - "commandRegistry is a Zustand store with the same public API as before migration"
    - "previewRegistry is a Zustand store with source-based cleanup support"
    - "All 13 commandRegistry consumers and 2 previewRegistry consumers continue working unchanged"
    - "DevTools shows command-registry and preview-registry store names in development mode"
  artifacts:
    - path: "src/lib/commandRegistry.ts"
      provides: "Zustand store useCommandRegistry + backward-compatible function exports"
      contains: "useCommandRegistry"
    - path: "src/lib/previewRegistry.ts"
      provides: "Zustand store usePreviewRegistry + backward-compatible function exports"
      contains: "usePreviewRegistry"
    - path: "src/blades/staging-changes/components/previewRegistrations.ts"
      provides: "Core preview registrations with source: core field"
      contains: "source:"
  key_links:
    - from: "src/lib/commandRegistry.ts"
      to: "zustand"
      via: "create<CommandRegistryState>()(devtools(...))"
      pattern: "create<CommandRegistryState>"
    - from: "src/lib/previewRegistry.ts"
      to: "zustand"
      via: "create<PreviewRegistryState>()(devtools(...))"
      pattern: "create<PreviewRegistryState>"
    - from: "src/lib/commandRegistry.ts"
      to: "backward-compat exports"
      via: "useCommandRegistry.getState().method()"
      pattern: "getState\\(\\)"
---

<objective>
Migrate commandRegistry and previewRegistry from plain Map/array modules to reactive Zustand stores, following the exact pattern established by bladeRegistry in v1.6.

Purpose: Reactive stores enable real-time UI updates when extensions register/unregister commands and preview handlers. This is the foundation for INFRA-03 (reactive CommandPalette) and source-based cleanup across all registries.

Output: Two Zustand stores (`useCommandRegistry`, `usePreviewRegistry`) with full backward-compatible function exports so all 15 consumer files need zero changes.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/bladeRegistry.ts
@src/lib/commandRegistry.ts
@src/lib/previewRegistry.ts
@src/blades/staging-changes/components/previewRegistrations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate commandRegistry to Zustand store</name>
  <files>src/lib/commandRegistry.ts</files>
  <action>
Rewrite `src/lib/commandRegistry.ts` to use a Zustand store following the EXACT pattern from `src/lib/bladeRegistry.ts`.

**Keep unchanged:**
- All type exports: `CoreCommandCategory`, `CommandCategory`, `Command`
- The `Command.source?: string` field (already exists)
- The `CORE_ORDER` constant (stays module-level, not in store)

**Create the Zustand store:**

```typescript
import { create } from "zustand";
import { devtools } from "zustand/middleware";
```

Store interface `CommandRegistryState` with fields:
- `commands: Map<string, Command>`
- `register: (cmd: Command) => void` -- creates `new Map(get().commands)`, sets `cmd.source ?? "core"` as default source, sets the command, calls `set()` with action name `"command-registry/register"`
- `unregister: (id: string) => boolean` -- returns false if not found, otherwise creates new Map, deletes, sets
- `unregisterBySource: (source: string) => void` -- iterates Map, deletes matching source entries, single `set()` call (NOT multiple deletes)
- `getAll: () => Command[]` -- `Array.from(get().commands.values())`
- `getEnabled: () => Command[]` -- filter where `cmd.enabled ? cmd.enabled() : true`
- `getById: (id: string) => Command | undefined`
- `getOrderedCategories: () => CommandCategory[]` -- same logic as current `getOrderedCategories()` function, using `get().commands`

Store creation: `export const useCommandRegistry = create<CommandRegistryState>()(devtools((set, get) => ({...}), { name: "command-registry", enabled: import.meta.env.DEV }))`

**Backward-compatible function exports (at bottom of file):**
Delegate every existing exported function to `useCommandRegistry.getState().method()`:
- `registerCommand(cmd)` -> `.register(cmd)`
- `unregisterCommand(id)` -> `.unregister(id)`
- `unregisterCommandsBySource(source)` -> `.unregisterBySource(source)`
- `getCommands()` -> `.getAll()`
- `getEnabledCommands()` -> `.getEnabled()`
- `getCommandById(id)` -> `.getById(id)`
- `executeCommand(id)` -- keep same logic (check enabled, then call action)
- `getOrderedCategories()` -> `.getOrderedCategories()`

**Critical details:**
- Every Map mutation MUST create `new Map(get().commands)` to trigger Zustand re-renders
- The `register()` action MUST default `source` to `"core"` when not provided: `next.set(cmd.id, { ...cmd, source: cmd.source ?? "core" })`
- Do NOT import anything from the extension system (keeps dependency direction one-way)
- Keep the `LucideIcon` type import from lucide-react
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | grep -v "bindings.ts"` -- zero new type errors.
Run `npx vitest run --reporter=verbose 2>&1` -- all existing tests pass.
Verify backward-compat by checking that all function export signatures match the original: `registerCommand`, `unregisterCommand`, `unregisterCommandsBySource`, `getCommands`, `getEnabledCommands`, `getCommandById`, `executeCommand`, `getOrderedCategories`.
  </verify>
  <done>
commandRegistry.ts exports a `useCommandRegistry` Zustand store hook AND all original function exports. Type-checks pass. All 13 consumer files work unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate previewRegistry to Zustand store with source field</name>
  <files>src/lib/previewRegistry.ts, src/blades/staging-changes/components/previewRegistrations.ts</files>
  <action>
**Part A: Rewrite `src/lib/previewRegistry.ts`**

Follow the bladeRegistry Zustand pattern. The previewRegistry is array-based (not Map-based) because priority-sorted order matters.

**Keep unchanged:**
- All type exports: `PreviewMode`, `PreviewRegistration` (add `source` field)
- All type imports from `react`, `bindings`, `blades/diff`

**Add `source` field to `PreviewRegistration` interface:**
```typescript
export interface PreviewRegistration {
  key: string;
  matches: (filePath: string) => boolean;
  mode: PreviewMode;
  placeholder?: { icon: ComponentType<{ className?: string }>; message: string };
  component?: ComponentType<{ file: FileChange; source: DiffSource }>;
  priority?: number;
  source?: string;  // "core" for built-in, "ext:{extensionId}" for extensions
}
```

**Create the Zustand store:**

Store interface `PreviewRegistryState` with fields:
- `previews: PreviewRegistration[]`
- `register: (config: PreviewRegistration) => void` -- defaults `config.source ?? "core"`, creates new sorted array `[...get().previews, { ...config, source: config.source ?? "core" }].sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0))`, single `set()` call with action name `"preview-registry/register"`
- `unregister: (key: string) => boolean` -- filters out matching key, returns false if length unchanged
- `unregisterBySource: (source: string) => void` -- filters out matching source, single `set()` call
- `getForFile: (filePath: string) => PreviewRegistration | undefined` -- `get().previews.find(r => r.matches(filePath))` (already sorted by priority)

Store creation: `export const usePreviewRegistry = create<PreviewRegistryState>()(devtools((set, get) => ({...}), { name: "preview-registry", enabled: import.meta.env.DEV }))`

**Backward-compatible function exports:**
- `registerPreview(config)` -> `.register(config)`
- `getPreviewForFile(filePath)` -> `.getForFile(filePath)`

**Part B: Update `src/blades/staging-changes/components/previewRegistrations.ts`**

Add `source: "core"` to all 5 `registerPreview()` calls:

```typescript
registerPreview({
  key: "binary",
  priority: 10,
  mode: "placeholder",
  matches: (filePath) => binaryExts.test(filePath),
  placeholder: { icon: File, message: "Binary file -- click to expand" },
  source: "core",
});
```

Repeat for: `image`, `archive`, `3d`, `text-diff` (all 5 registrations).
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | grep -v "bindings.ts"` -- zero new type errors.
Run `npx vitest run --reporter=verbose 2>&1` -- all existing tests pass.
Verify that `PreviewRegistration` interface includes `source?: string`.
Verify that all 5 core preview registrations include `source: "core"`.
  </verify>
  <done>
previewRegistry.ts exports a `usePreviewRegistry` Zustand store hook AND original function exports. The `PreviewRegistration` interface has a `source` field. All 5 core registrations have `source: "core"`. Both consumer files work unchanged.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit 2>&1 | grep -v "bindings.ts"` passes with zero new errors
2. `npx vitest run` -- all existing tests pass (the __mocks__/zustand.ts auto-reset mock handles new stores automatically)
3. Grep for `useCommandRegistry` and `usePreviewRegistry` in respective files confirms Zustand store exists
4. Grep for `registerCommand`, `getEnabledCommands`, `registerPreview`, `getPreviewForFile` confirms backward-compat exports exist
5. No circular imports: commandRegistry.ts imports only from `lucide-react` and `zustand`; previewRegistry.ts imports only from `react`, `bindings`, `blades/diff`, and `zustand`
</verification>

<success_criteria>
- Both registries are Zustand stores with devtools middleware
- All backward-compatible function exports delegate to `useStore.getState().method()`
- Source field exists and defaults to "core" on both registries
- `unregisterBySource()` available on both stores for extension cleanup
- Zero consumer file changes needed (all 15 consumers work unchanged)
- Type-checks pass, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/43-infrastructure-prep/43-01-SUMMARY.md`
</output>
