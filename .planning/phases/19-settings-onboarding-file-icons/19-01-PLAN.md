---
phase: 19-settings-onboarding-file-icons
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/init.rs
  - src-tauri/src/git/config.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/lib.rs
  - src/bindings.ts
autonomous: true

must_haves:
  truths:
    - "git_init(path, default_branch) validates path exists, is a directory, and is not already a git repo, then creates a repository with optional initial branch name"
    - "get_git_global_config() reads user.name, user.email, init.defaultBranch from global git config and returns None for unset values"
    - "set_git_global_config(key, value) writes a single key-value pair to ~/.gitconfig using Config::open_level(Global)"
    - "All three commands follow existing patterns: #[tauri::command] #[specta::specta], spawn_blocking, Result<T, GitError>"
  artifacts:
    - path: "src-tauri/src/git/init.rs"
      provides: "git_init command with InitResult struct"
      exports: ["git_init", "InitResult"]
    - path: "src-tauri/src/git/config.rs"
      provides: "Git global config read/write commands with GitGlobalConfig struct"
      exports: ["get_git_global_config", "set_git_global_config", "GitGlobalConfig"]
    - path: "src-tauri/src/git/mod.rs"
      provides: "Module declarations for config and init"
      contains: "pub mod config"
    - path: "src-tauri/src/lib.rs"
      provides: "Command registration in collect_commands![]"
      contains: "git_init"
  key_links:
    - from: "src-tauri/src/git/init.rs"
      to: "src-tauri/src/git/error.rs"
      via: "imports GitError for error handling"
      pattern: "use crate::git::error::GitError"
    - from: "src-tauri/src/git/config.rs"
      to: "src-tauri/src/git/error.rs"
      via: "imports GitError for error handling"
      pattern: "use crate::git::error::GitError"
---

<objective>
Create three new Rust Tauri commands: git_init for initializing repositories, get_git_global_config for reading global git config, and set_git_global_config for writing global git config.

Purpose: These commands provide the backend API for the git init prompt (Plan 19-05) and git settings expansion (Plan 19-03). The git_init command uses git2::Repository::init_opts() to create repos with a configurable default branch. The config commands use git2::Config to read/write ~/.gitconfig. None of these commands require an open repository.

Output: Two new Rust modules registered in lib.rs with auto-generated TypeScript bindings. Ready for consumption by frontend plans.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src-tauri/src/git/commands.rs
@src-tauri/src/git/clone.rs
@src-tauri/src/git/error.rs
@src-tauri/src/git/mod.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create git init module</name>
  <files>src-tauri/src/git/init.rs</files>
  <action>
Create `src-tauri/src/git/init.rs` with the `git_init` Tauri command.

1. Define `InitResult` struct with derives `Debug, Clone, Serialize, Deserialize, Type` and `#[serde(rename_all = "camelCase")]`:
   - `repo_path: String` -- path to the newly initialized repository
   - `initial_branch: String` -- the branch name that was set

2. Implement `git_init` command:
   - Signature: `pub async fn git_init(path: String, default_branch: Option<String>) -> Result<InitResult, GitError>`
   - Annotated with `#[tauri::command]` and `#[specta::specta]`
   - Does NOT take `State<'_, RepositoryState>` -- standalone operation
   - Validation before spawn_blocking:
     a. Check `path_buf.exists()` -- return `GitError::PathNotFound` if not
     b. Check `path_buf.is_dir()` -- return `GitError::InvalidPath("Path is not a directory")` if not
     c. Check `git2::Repository::open(&path_buf).is_ok()` -- return `GitError::OperationFailed("Directory is already a Git repository")` if true
   - Default branch to "main" if `default_branch` is None
   - Inside `tokio::task::spawn_blocking`:
     a. Create `git2::RepositoryInitOptions::new()`
     b. Call `opts.initial_head(&branch)` to set the initial branch name
     c. Call `git2::Repository::init_opts(&path_buf, &opts)` with GitError mapping
     d. Return `InitResult { repo_path, initial_branch }`

Required imports: `std::path::PathBuf`, `serde::{Deserialize, Serialize}`, `specta::Type`, `crate::git::error::GitError`
  </action>
  <verify>
Verify the file compiles by checking `cargo check` passes. Verify the command signature matches the pattern in clone.rs and commands.rs.
  </verify>
  <done>
init.rs exports git_init command and InitResult struct. The command validates the path, creates a git repository with configurable default branch, and returns the result.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create git config module</name>
  <files>src-tauri/src/git/config.rs</files>
  <action>
Create `src-tauri/src/git/config.rs` with two Tauri commands for global git config read/write.

1. Define `GitGlobalConfig` struct with derives `Debug, Clone, Serialize, Deserialize, Type` and `#[serde(rename_all = "camelCase")]`:
   - `user_name: Option<String>` -- user.name from git config
   - `user_email: Option<String>` -- user.email from git config
   - `default_branch: Option<String>` -- init.defaultBranch from git config

2. Implement `get_git_global_config` command:
   - Signature: `pub async fn get_git_global_config() -> Result<GitGlobalConfig, GitError>`
   - Annotated with `#[tauri::command]` and `#[specta::specta]`
   - Inside `tokio::task::spawn_blocking`:
     a. Open config via `git2::Config::open_default()` -- map error to `GitError::OperationFailed`
     b. Read `user.name`, `user.email`, `init.defaultBranch` using `config.get_string(key).ok()` -- returns None if unset
     c. Return `GitGlobalConfig` with the three values

3. Implement `set_git_global_config` command:
   - Signature: `pub async fn set_git_global_config(key: String, value: String) -> Result<(), GitError>`
   - Annotated with `#[tauri::command]` and `#[specta::specta]`
   - Inside `tokio::task::spawn_blocking`:
     a. Open config via `git2::Config::open_default()`
     b. Open global level specifically via `config.open_level(git2::ConfigLevel::Global)` -- map error with helpful message "No global git config found"
     c. Write via `global.set_str(&key, &value)` -- map error to `GitError::OperationFailed`

Required imports: `serde::{Deserialize, Serialize}`, `specta::Type`, `crate::git::error::GitError`

IMPORTANT: Neither command takes `State<'_, RepositoryState>` since they operate on global config, not a specific repository.
  </action>
  <verify>
Verify the file compiles. Verify get_git_global_config returns None (not error) for unset config values.
  </verify>
  <done>
config.rs exports get_git_global_config and set_git_global_config commands plus GitGlobalConfig struct. Reads return None for unset values. Writes target ~/.gitconfig specifically.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register modules and commands</name>
  <files>src-tauri/src/git/mod.rs, src-tauri/src/lib.rs</files>
  <action>
**Step 1: Update `src-tauri/src/git/mod.rs`**

Add two new module declarations in alphabetical order among the existing modules:
- Add `pub mod config;` between `pub mod clone;` and `pub mod commands;`
- Add `pub mod init;` between `pub mod history;` and `pub mod merge;`

The full module list should be: branch, changelog, clone, **config**, commands, commit, conventional, diff, error, graph, history, **init**, merge, remote, repository, staging, stash, tag, undo, watcher, worktree.

**Step 2: Update `src-tauri/src/lib.rs` imports**

In the `use git::{...}` block, add two new import lines in alphabetical position:
- After `clone::clone_repository,` add: `commands::{close_repository, get_repository_status, is_git_repository, open_repository},` (this already exists)
- After the `commands` import, add: `config::{get_git_global_config, set_git_global_config},`
- After `history::{...},` add: `init::git_init,`

**Step 3: Register in `collect_commands![]`**

Add three new commands to the macro invocation:
- After `clone_repository,` line at the end, add a new section:
```rust
        // Init commands
        git_init,
        // Config commands
        get_git_global_config,
        set_git_global_config,
```
  </action>
  <verify>
Run `cargo build` from `src-tauri/` directory. The build should succeed and auto-generate updated TypeScript bindings in `src/bindings.ts`. Verify bindings contain `gitInit`, `getGitGlobalConfig`, `setGitGlobalConfig`, `InitResult`, and `GitGlobalConfig`.
  </verify>
  <done>
All three commands registered in mod.rs and lib.rs. cargo build succeeds. TypeScript bindings auto-generated with correct types.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` (from src-tauri/) compiles without errors
2. `src/bindings.ts` contains `gitInit`, `getGitGlobalConfig`, `setGitGlobalConfig` command wrappers
3. `InitResult` type has `repoPath: string` and `initialBranch: string`
4. `GitGlobalConfig` type has `userName: string | null`, `userEmail: string | null`, `defaultBranch: string | null`
5. `git_init` validates path existence, directory check, and not-already-a-repo check
6. `get_git_global_config` returns None for unset config values (does not error)
7. `set_git_global_config` writes to global-level config file specifically
8. All commands use `spawn_blocking` pattern consistent with existing codebase
</verification>

<success_criteria>
- Three new Tauri commands compile and are registered
- TypeScript bindings auto-generated with correct types
- git_init creates a valid repository with configurable initial branch
- Config commands read/write global git config without requiring an open repository
</success_criteria>

<output>
After completion, create `.planning/phases/19-settings-onboarding-file-icons/19-01-SUMMARY.md`
</output>
