---
phase: 07-worktree-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/worktree.rs
  - src-tauri/src/git/mod.rs
autonomous: true

must_haves:
  truths:
    - "Worktree list returns all active worktrees with names and paths"
    - "Worktree status accurately reports clean/dirty/conflicts state"
    - "Worktree creation succeeds with valid branch and path"
    - "Worktree deletion removes filesystem and git metadata"
  artifacts:
    - path: "src-tauri/src/git/worktree.rs"
      provides: "Worktree types and core operations"
      exports: ["WorktreeInfo", "WorktreeStatus", "CreateWorktreeOptions", "list_worktrees", "create_worktree", "delete_worktree"]
  key_links:
    - from: "src-tauri/src/git/worktree.rs"
      to: "git2::Repository"
      via: "worktrees() method"
      pattern: "repo\\.worktrees\\(\\)"
    - from: "src-tauri/src/git/worktree.rs"
      to: "git2::Worktree"
      via: "find_worktree and validate"
      pattern: "find_worktree|validate"
---

<objective>
Implement the Rust backend module for git worktree management using git2-rs APIs.

Purpose: Provide core worktree operations (list, create, delete, status) that the frontend will consume via Tauri IPC commands.
Output: `worktree.rs` module with types and functions for complete worktree lifecycle management.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-worktree-management/07-RESEARCH.md
@src-tauri/src/git/branch.rs
@src-tauri/src/git/repository.rs
@src-tauri/src/git/mod.rs
@src-tauri/src/git/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worktree.rs module with types</name>
  <files>src-tauri/src/git/worktree.rs, src-tauri/src/git/mod.rs</files>
  <action>
1. Create `src-tauri/src/git/worktree.rs` with the following types:

```rust
use serde::{Deserialize, Serialize};
use specta::Type;

#[derive(Debug, Clone, Serialize, Deserialize, Type, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum WorktreeStatus {
    Clean,
    Dirty,
    Conflicts,
    Invalid,
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct WorktreeInfo {
    pub name: String,
    pub path: String,
    pub branch: Option<String>,
    pub status: WorktreeStatus,
    pub is_main: bool,
    pub is_locked: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct CreateWorktreeOptions {
    pub name: String,
    pub path: String,
    pub branch: Option<String>,
    pub create_branch: bool,
}
```

2. Add `pub mod worktree;` to `src-tauri/src/git/mod.rs`

All structs derive Serialize, Deserialize, Clone, Debug, and specta::Type for IPC compatibility.
  </action>
  <verify>
    - `cargo check` passes
    - Module is exported from git mod
  </verify>
  <done>WorktreeInfo, WorktreeStatus, CreateWorktreeOptions types defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement list_worktrees and status detection</name>
  <files>src-tauri/src/git/worktree.rs</files>
  <action>
1. Implement helper function `get_worktree_status(repo: &Repository) -> WorktreeStatus`:
   - Use `repo.statuses(None)` to check for changes
   - Check for `STATUS_CONFLICTED` flag for conflicts
   - Return Clean if no statuses, Dirty if changes exist, Conflicts if any conflict

2. Implement helper function `get_worktree_info(main_repo: &Repository, worktree: &git2::Worktree) -> Result<WorktreeInfo, GitError>`:
   - Get name from `worktree.name()`
   - Get path from `worktree.path()`
   - Check validity with `worktree.validate()` - if fails, status is Invalid
   - Open worktree as repo with `Repository::open(worktree.path())` to get branch and status
   - Get branch with `repo.head()?.shorthand()`
   - Check locked status with `worktree.is_locked()`

3. Implement `list_worktrees` internal function (not Tauri command yet):
```rust
pub fn list_worktrees_internal(repo_path: &Path) -> Result<Vec<WorktreeInfo>, GitError> {
    let repo = Repository::open(repo_path)?;
    let mut worktrees = Vec::new();
    
    // Add main worktree first
    worktrees.push(get_main_worktree_info(&repo)?);
    
    // Add linked worktrees
    for name in repo.worktrees()?.iter().flatten() {
        if let Ok(wt) = repo.find_worktree(name) {
            if let Ok(info) = get_worktree_info(&repo, &wt) {
                worktrees.push(info);
            }
        }
    }
    
    Ok(worktrees)
}
```

4. Implement `get_main_worktree_info` helper:
   - Main worktree is the repo itself (is_main: true)
   - Path is repo workdir
   - Branch is current HEAD
   - Status from main repo status check
  </action>
  <verify>
    - `cargo check` passes
    - Unit test: list_worktrees returns at least the main worktree
  </verify>
  <done>list_worktrees returns main worktree plus all linked worktrees with accurate status</done>
</task>

<task type="auto">
  <name>Task 3: Implement create_worktree and delete_worktree</name>
  <files>src-tauri/src/git/worktree.rs</files>
  <action>
1. Implement `create_worktree_internal`:
```rust
pub fn create_worktree_internal(
    repo_path: &Path,
    options: CreateWorktreeOptions,
) -> Result<WorktreeInfo, GitError> {
    let repo = Repository::open(repo_path)?;
    
    // Resolve or create branch reference
    let reference = if let Some(ref branch_name) = options.branch {
        if options.create_branch {
            // Create new branch from HEAD
            let head_commit = repo.head()?.peel_to_commit()?;
            repo.branch(branch_name, &head_commit, false)?;
        }
        Some(repo.find_branch(branch_name, git2::BranchType::Local)?.into_reference())
    } else {
        None
    };
    
    // Create worktree
    let mut add_opts = git2::WorktreeAddOptions::new();
    if let Some(ref r) = reference {
        add_opts.reference(Some(r));
    }
    
    let worktree = repo.worktree_add(&options.name, Path::new(&options.path), Some(&add_opts))?;
    
    get_worktree_info(&repo, &worktree)
}
```

2. Implement `delete_worktree_internal`:
```rust
pub fn delete_worktree_internal(
    repo_path: &Path,
    name: &str,
    force: bool,
    delete_branch: bool,
) -> Result<(), GitError> {
    let repo = Repository::open(repo_path)?;
    let worktree = repo.find_worktree(name)?;
    
    // Get branch name before deletion if we need to delete it
    let branch_to_delete = if delete_branch {
        let wt_repo = Repository::open(worktree.path())?;
        wt_repo.head().ok().and_then(|h| h.shorthand().map(String::from))
    } else {
        None
    };
    
    // Prune worktree
    let mut prune_opts = git2::WorktreePruneOptions::new();
    if force {
        prune_opts.flags(
            git2::WorktreePruneFlag::VALID | 
            git2::WorktreePruneFlag::WORKING_TREE
        );
    }
    
    worktree.prune(Some(&mut prune_opts))?;
    
    // Delete branch if requested
    if let Some(branch_name) = branch_to_delete {
        if let Ok(mut branch) = repo.find_branch(&branch_name, git2::BranchType::Local) {
            // Check if fully merged before deleting
            let _ = branch.delete(); // Silent fail is OK, branch might not be merged
        }
    }
    
    Ok(())
}
```

3. Add proper error handling:
   - Return GitError::NotFound if worktree doesn't exist
   - Return GitError::OperationFailed if worktree is dirty and force=false
   - Return GitError::InvalidWorktree if worktree validation fails
  </action>
  <verify>
    - `cargo check` passes
    - Integration test: create worktree, verify it exists, delete it, verify it's gone
  </verify>
  <done>create_worktree and delete_worktree work with proper error handling</done>
</task>

</tasks>

<verification>
- `cargo check` passes with no errors
- `cargo test` passes (if tests added)
- Module exports all required types and functions
- Types are properly serializable for IPC
</verification>

<success_criteria>
- WorktreeInfo, WorktreeStatus, CreateWorktreeOptions types exist with specta::Type
- list_worktrees_internal returns main worktree + linked worktrees
- create_worktree_internal creates worktree with optional new branch
- delete_worktree_internal removes worktree with optional branch deletion
- All functions use spawn_blocking pattern for git2 calls
</success_criteria>

<output>
After completion, create `.planning/phases/07-worktree-management/07-01-SUMMARY.md`
</output>
