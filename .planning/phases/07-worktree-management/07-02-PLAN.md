---
phase: 07-worktree-management
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src-tauri/src/git/worktree.rs
  - src-tauri/src/lib.rs
  - package.json
  - src/stores/worktrees.ts
  - src-tauri/capabilities/default.json
autonomous: true

must_haves:
  truths:
    - "Tauri commands are callable from frontend via bindings"
    - "Frontend store fetches and caches worktree list"
    - "Store actions for create/delete trigger backend commands"
    - "Plugin permissions allow directory picker and file reveal"
  artifacts:
    - path: "src-tauri/src/lib.rs"
      provides: "Registered worktree Tauri commands"
      contains: "list_worktrees, create_worktree, delete_worktree"
    - path: "src/stores/worktrees.ts"
      provides: "Zustand store for worktree state management"
      exports: ["useWorktreeStore"]
    - path: "src-tauri/capabilities/default.json"
      provides: "Plugin permissions"
      contains: "dialog:allow-open, opener:allow-reveal-item-in-dir"
  key_links:
    - from: "src/stores/worktrees.ts"
      to: "src/bindings.ts"
      via: "commands import"
      pattern: "commands\\.listWorktrees"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/git/worktree.rs"
      via: "command registration"
      pattern: "list_worktrees|create_worktree|delete_worktree"
---

<objective>
Wire up Tauri IPC commands and create the frontend Zustand store for worktree management.

Purpose: Enable frontend-backend communication for worktree operations via type-safe tauri-specta bindings.
Output: Registered Tauri commands, configured plugin permissions, and a complete Zustand store.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-worktree-management/07-RESEARCH.md
@.planning/phases/07-worktree-management/07-01-SUMMARY.md
@src-tauri/src/lib.rs
@src/stores/branches.ts
@src/bindings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Tauri commands to worktree.rs and register in lib.rs</name>
  <files>src-tauri/src/git/worktree.rs, src-tauri/src/lib.rs</files>
  <action>
1. Add Tauri command wrappers to `src-tauri/src/git/worktree.rs`:

```rust
use tauri::State;
use crate::git::repository::RepositoryState;

#[tauri::command]
#[specta::specta]
pub async fn list_worktrees(state: State<'_, RepositoryState>) -> Result<Vec<WorktreeInfo>, GitError> {
    let repo_path = state.get_path().await
        .ok_or_else(|| GitError::NotFound("No repository open".to_string()))?;
    
    tokio::task::spawn_blocking(move || {
        list_worktrees_internal(&repo_path)
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}

#[tauri::command]
#[specta::specta]
pub async fn create_worktree(
    options: CreateWorktreeOptions,
    state: State<'_, RepositoryState>,
) -> Result<WorktreeInfo, GitError> {
    let repo_path = state.get_path().await
        .ok_or_else(|| GitError::NotFound("No repository open".to_string()))?;
    
    tokio::task::spawn_blocking(move || {
        create_worktree_internal(&repo_path, options)
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}

#[tauri::command]
#[specta::specta]
pub async fn delete_worktree(
    name: String,
    force: bool,
    delete_branch: bool,
    state: State<'_, RepositoryState>,
) -> Result<(), GitError> {
    let repo_path = state.get_path().await
        .ok_or_else(|| GitError::NotFound("No repository open".to_string()))?;
    
    tokio::task::spawn_blocking(move || {
        delete_worktree_internal(&repo_path, &name, force, delete_branch)
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}
```

2. Update `src-tauri/src/lib.rs`:
   - Add import: `worktree::{list_worktrees, create_worktree, delete_worktree},`
   - Add to collect_commands!: `list_worktrees, create_worktree, delete_worktree,`
  </action>
  <verify>
    - `cargo check` passes
    - Commands appear in generated bindings after `pnpm tauri dev`
  </verify>
  <done>Tauri commands registered and exported</done>
</task>

<task type="auto">
  <name>Task 2: Configure Tauri plugin permissions and add npm dependencies</name>
  <files>src-tauri/capabilities/default.json, package.json</files>
  <action>
1. Update `src-tauri/capabilities/default.json` to add permissions:
```json
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Default capability set",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default",
    "dialog:default",
    "store:default",
    "window-state:default",
    "dialog:allow-open",
    "opener:allow-reveal-item-in-dir"
  ]
}
```

2. Add npm dependencies for Tauri plugins:
```bash
pnpm add @tauri-apps/plugin-dialog @tauri-apps/plugin-opener
```

3. Verify plugins are already registered in main.rs (they should be from foundation phase):
```rust
.plugin(tauri_plugin_dialog::init())
.plugin(tauri_plugin_opener::init())
```
  </action>
  <verify>
    - `pnpm tauri dev` starts without permission errors
    - Import `{ open } from '@tauri-apps/plugin-dialog'` works
    - Import `{ revealItemInDir } from '@tauri-apps/plugin-opener'` works
  </verify>
  <done>Tauri plugins configured with proper permissions</done>
</task>

<task type="auto">
  <name>Task 3: Create worktrees.ts Zustand store</name>
  <files>src/stores/worktrees.ts</files>
  <action>
Create `src/stores/worktrees.ts`:

```typescript
import { create } from "zustand";
import type { WorktreeInfo, CreateWorktreeOptions } from "../bindings";
import { commands } from "../bindings";
import { getErrorMessage } from "../lib/errors";

interface WorktreeState {
  worktrees: WorktreeInfo[];
  isLoading: boolean;
  error: string | null;
  selectedWorktree: string | null;

  loadWorktrees: () => Promise<void>;
  createWorktree: (options: CreateWorktreeOptions) => Promise<WorktreeInfo | null>;
  deleteWorktree: (name: string, force: boolean, deleteBranch: boolean) => Promise<boolean>;
  selectWorktree: (name: string | null) => void;
  openInExplorer: (path: string) => Promise<void>;
  switchToWorktree: (path: string) => Promise<boolean>;
  clearError: () => void;
}

export const useWorktreeStore = create<WorktreeState>((set, get) => ({
  worktrees: [],
  isLoading: false,
  error: null,
  selectedWorktree: null,

  loadWorktrees: async () => {
    set({ isLoading: true, error: null });
    const result = await commands.listWorktrees();
    if (result.status === "ok") {
      set({ worktrees: result.data, isLoading: false });
    } else {
      set({ error: getErrorMessage(result.error), isLoading: false });
    }
  },

  createWorktree: async (options) => {
    set({ isLoading: true, error: null });
    const result = await commands.createWorktree(options);
    if (result.status === "ok") {
      await get().loadWorktrees();
      return result.data;
    }
    set({ error: getErrorMessage(result.error), isLoading: false });
    return null;
  },

  deleteWorktree: async (name, force, deleteBranch) => {
    set({ isLoading: true, error: null });
    const result = await commands.deleteWorktree(name, force, deleteBranch);
    if (result.status === "ok") {
      await get().loadWorktrees();
      return true;
    }
    set({ error: getErrorMessage(result.error), isLoading: false });
    return false;
  },

  selectWorktree: (name) => set({ selectedWorktree: name }),

  openInExplorer: async (path) => {
    const { revealItemInDir } = await import("@tauri-apps/plugin-opener");
    await revealItemInDir(path);
  },

  switchToWorktree: async (path) => {
    // Import repository store and switch context
    const { useRepositoryStore } = await import("./repository");
    try {
      await useRepositoryStore.getState().openRepository(path);
      return true;
    } catch {
      return false;
    }
  },

  clearError: () => set({ error: null }),
}));
```

Follow the exact pattern from branches.ts for consistency.
  </action>
  <verify>
    - TypeScript compiles without errors
    - Store exports useWorktreeStore
    - All actions match the interface
  </verify>
  <done>Zustand store ready with all worktree actions</done>
</task>

</tasks>

<verification>
- `pnpm tauri dev` starts successfully
- `src/bindings.ts` contains listWorktrees, createWorktree, deleteWorktree
- Store can be imported: `import { useWorktreeStore } from './stores/worktrees'`
- Plugin imports work without errors
</verification>

<success_criteria>
- Tauri commands callable via `commands.listWorktrees()` etc.
- Plugin permissions allow directory picker and file reveal
- Zustand store provides all worktree operations
- TypeScript types are auto-generated by tauri-specta
</success_criteria>

<output>
After completion, create `.planning/phases/07-worktree-management/07-02-SUMMARY.md`
</output>
