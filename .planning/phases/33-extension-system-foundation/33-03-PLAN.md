---
phase: 33-extension-system-foundation
plan: 03
type: execute
wave: 2
depends_on: ["33-01", "33-02"]
files_modified:
  - src/extensions/extensionManifest.ts
  - src/extensions/extensionTypes.ts
  - src/extensions/ExtensionAPI.ts
  - src/extensions/ExtensionHost.ts
  - src/extensions/index.ts
autonomous: true

must_haves:
  truths:
    - "ExtensionHost discovers manifests via the Rust discover_extensions command and stores them in reactive state"
    - "An extension with incompatible apiVersion is rejected at discovery with status 'error' and a user-visible toast"
    - "activateExtension loads the entry point via dynamic import and calls onActivate with an ExtensionAPI instance"
    - "If onActivate throws, all partial registrations are cleaned up and the extension status is set to 'error' with a toast"
    - "deactivateExtension calls onDeactivate (if exported) and removes ALL tracked blade, command, and toolbar registrations"
    - "ExtensionAPI.registerBlade namespaces the type as ext:{extId}:{bladeName}"
    - "ExtensionAPI.registerCommand namespaces the id as ext:{extId}:{commandId}"
    - "ExtensionAPI.contributeToolbar namespaces the id as ext:{extId}:{actionId}"
  artifacts:
    - path: "src/extensions/extensionManifest.ts"
      provides: "TypeScript re-export/alias of generated manifest types from bindings"
      contains: "ExtensionManifest"
    - path: "src/extensions/extensionTypes.ts"
      provides: "ExtensionStatus, ExtensionInfo, extension lifecycle types"
      exports: ["ExtensionStatus", "ExtensionInfo"]
    - path: "src/extensions/ExtensionAPI.ts"
      provides: "Per-extension API facade with namespaced registration and cleanup"
      exports: ["ExtensionAPI"]
    - path: "src/extensions/ExtensionHost.ts"
      provides: "Singleton Zustand store for extension lifecycle management"
      exports: ["useExtensionHost", "CURRENT_API_VERSION"]
    - path: "src/extensions/index.ts"
      provides: "Barrel exports for the extension system"
      contains: "export"
  key_links:
    - from: "src/extensions/ExtensionHost.ts"
      to: "src/bindings.ts"
      via: "Calls discoverExtensions Tauri command"
      pattern: "commands\\.discoverExtensions"
    - from: "src/extensions/ExtensionHost.ts"
      to: "src/extensions/ExtensionAPI.ts"
      via: "Creates ExtensionAPI instances during activation"
      pattern: "new ExtensionAPI"
    - from: "src/extensions/ExtensionAPI.ts"
      to: "src/lib/bladeRegistry.ts"
      via: "Calls registerBlade/unregisterBlade with namespaced types"
      pattern: "registerBlade|unregisterBlade"
    - from: "src/extensions/ExtensionAPI.ts"
      to: "src/lib/commandRegistry.ts"
      via: "Calls registerCommand/unregisterCommand with namespaced ids"
      pattern: "registerCommand|unregisterCommand"
    - from: "src/extensions/ExtensionAPI.ts"
      to: "src/lib/toolbarRegistry.ts"
      via: "Calls useToolbarRegistry.getState().register/unregisterBySource"
      pattern: "useToolbarRegistry"
---

<objective>
Build the ExtensionHost Zustand store and per-extension ExtensionAPI facade that manages the full extension lifecycle: discovery, apiVersion validation, activation via dynamic import, registration tracking, and clean deactivation.

Purpose: This is the core runtime of the extension system. It connects the Rust-side manifest discovery (Plan 02) to the widened registries (Plan 01), creating the complete extension lifecycle pipeline that Phases 34-36 will use to load the GitHub extension.

Output: Complete extension system runtime in `src/extensions/` -- ready for extensions to be loaded.
</objective>

<execution_context>
@C:/Users/matrayp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matrayp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-extension-system-foundation/33-RESEARCH.md
@.planning/phases/33-extension-system-foundation/33-01-SUMMARY.md
@.planning/phases/33-extension-system-foundation/33-02-SUMMARY.md

@src/extensions/ (new directory created by this plan)
@src/lib/bladeRegistry.ts
@src/lib/commandRegistry.ts
@src/lib/toolbarRegistry.ts
@src/bindings.ts
@src/stores/toast.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extension type definitions and manifest re-exports</name>
  <files>
    src/extensions/extensionManifest.ts
    src/extensions/extensionTypes.ts
  </files>
  <action>
**src/extensions/extensionManifest.ts:**
Re-export the manifest types generated by tauri-specta in bindings.ts. This creates a stable import path for the extension system (decoupled from the auto-generated bindings file).

```typescript
// Re-export generated manifest types from Rust bindings
export type {
  ExtensionManifest,
  ExtensionContributes,
  ExtensionBladeContribution,
  ExtensionCommandContribution,
  ExtensionToolbarContribution,
} from "../bindings";
```

If the generated types use slightly different names (check bindings.ts from Plan 02), adjust the re-exports to match.

**src/extensions/extensionTypes.ts:**
Define the frontend-side extension lifecycle types:

```typescript
import type { ExtensionManifest } from "./extensionManifest";

export type ExtensionStatus =
  | "discovered"   // Manifest found and parsed, not yet activated
  | "activating"   // Entry point loading in progress
  | "active"       // onActivate completed successfully
  | "error"        // Failed to activate or incompatible apiVersion
  | "deactivated"; // Was active, now cleanly deactivated

export interface ExtensionInfo {
  id: string;
  name: string;
  version: string;
  status: ExtensionStatus;
  error?: string;
  manifest: ExtensionManifest;
}
```

These types are used by ExtensionHost (state shape) and will be used by the Extension Manager UI in Phase 36.
  </action>
  <verify>
`npx tsc --noEmit` -- no errors (the types compile and the re-exports resolve correctly from bindings.ts).
  </verify>
  <done>
extensionManifest.ts re-exports all manifest types from bindings.ts. extensionTypes.ts defines ExtensionStatus and ExtensionInfo. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ExtensionAPI facade with namespaced registration and cleanup</name>
  <files>
    src/extensions/ExtensionAPI.ts
  </files>
  <action>
Create the per-extension API facade class. Each extension gets its own instance at activation time. The facade wraps the three registries with automatic namespacing and tracks all registrations for cleanup.

**Class: ExtensionAPI**

Constructor: `constructor(extensionId: string)` -- stores the extension ID for namespacing.

Private state:
- `extensionId: string`
- `registeredBlades: string[]` -- tracks namespaced blade types registered by this extension
- `registeredCommands: string[]` -- tracks namespaced command IDs
- `registeredToolbarActions: string[]` -- tracks namespaced toolbar action IDs

**Methods:**

1. `registerBlade(config)`:
   - Config type: `{ type: string; title: string; component: ComponentType<any>; singleton?: boolean; lazy?: boolean; wrapInPanel?: boolean; showBack?: boolean; renderTitleContent?: (props: any) => ReactNode; renderTrailing?: (props: any, ctx: any) => ReactNode }`
   - Namespace the type: `const namespacedType = \`ext:${this.extensionId}:${config.type}\``
   - Call `registerBlade({ ...config, type: namespacedType, source: \`ext:${this.extensionId}\` })`
   - Push `namespacedType` to `this.registeredBlades`
   - Import `registerBlade` from `../lib/bladeRegistry`

2. `registerCommand(config)`:
   - Config type: `{ id: string; title: string; category?: string; action: () => void | Promise<void>; description?: string; shortcut?: string; icon?: LucideIcon; enabled?: () => boolean; keywords?: string[] }`
   - Namespace the id: `const namespacedId = \`ext:${this.extensionId}:${config.id}\``
   - Call `registerCommand({ ...config, id: namespacedId, category: config.category ?? this.extensionId, source: \`ext:${this.extensionId}\` })`
   - If no category is provided, default to the extension ID as the category name (title-cased ideally, but the manifest category from the contributes section is preferred -- the ExtensionHost will pass the manifest category through)
   - Push `namespacedId` to `this.registeredCommands`
   - Import `registerCommand` from `../lib/commandRegistry`

3. `contributeToolbar(config)`:
   - Config type: `{ id: string; label: string; icon: LucideIcon; group: ToolbarGroup; priority: number; shortcut?: string; when?: () => boolean; execute: () => void | Promise<void>; isLoading?: () => boolean }`
   - Namespace the id: `const namespacedId = \`ext:${this.extensionId}:${config.id}\``
   - Call `useToolbarRegistry.getState().register({ ...config, id: namespacedId, source: \`ext:${this.extensionId}\` })`
   - Push `namespacedId` to `this.registeredToolbarActions`
   - Import `useToolbarRegistry` from `../lib/toolbarRegistry`

4. `cleanup()`:
   - Unregister all tracked blades: `for (const type of this.registeredBlades) unregisterBlade(type)`
   - Unregister all tracked commands: `for (const id of this.registeredCommands) unregisterCommand(id)`
   - Unregister all toolbar actions by source: `useToolbarRegistry.getState().unregisterBySource(\`ext:${this.extensionId}\`)`
   - Clear all tracking arrays
   - Import `unregisterBlade` from `../lib/bladeRegistry`
   - Import `unregisterCommand` from `../lib/commandRegistry`

Export the class as a named export. Do NOT export a default.
  </action>
  <verify>
`npx tsc --noEmit` -- the class compiles. Manually verify that the method signatures align with the registry function signatures from Plan 01 (bladeRegistry.registerBlade, commandRegistry.registerCommand, toolbarRegistry.register).
  </verify>
  <done>
ExtensionAPI class namespaces all registrations with ext:{extensionId}: prefix, tracks all registrations in arrays, and cleanup() atomically removes all tracked registrations from all three registries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ExtensionHost Zustand store with lifecycle management</name>
  <files>
    src/extensions/ExtensionHost.ts
    src/extensions/index.ts
  </files>
  <action>
**src/extensions/ExtensionHost.ts:**
Create the singleton Zustand store that manages the full extension lifecycle.

Imports:
- `create` from `zustand`, `devtools` from `zustand/middleware`
- `commands` from `../bindings` (for discoverExtensions)
- `toast` from `../stores/toast` (check actual toast API -- it might be `toast.error()` or `useToast` depending on codebase pattern; read `src/stores/toast.ts` to confirm)
- `ExtensionAPI` from `./ExtensionAPI`
- `ExtensionInfo, ExtensionStatus` from `./extensionTypes`
- `ExtensionManifest` from `./extensionManifest`

Constants:
- `CURRENT_API_VERSION = "1"` -- the current extension API version. Extensions declaring a different `apiVersion` are rejected.

Module-level Maps (NOT in the store -- these hold JS references that Zustand can't serialize):
- `const extensionApis = new Map<string, ExtensionAPI>()` -- per-extension API instances
- `const extensionModules = new Map<string, any>()` -- loaded extension modules (for calling onDeactivate)

Store interface:
```typescript
interface ExtensionHostState {
  extensions: Map<string, ExtensionInfo>;
  isDiscovering: boolean;
  discoverExtensions: () => Promise<void>;
  activateExtension: (id: string) => Promise<void>;
  deactivateExtension: (id: string) => Promise<void>;
  activateAll: () => Promise<void>;
  deactivateAll: () => Promise<void>;
}
```

**discoverExtensions:**
1. Set `isDiscovering: true`.
2. Call the Rust command: `const manifests = await commands.discoverExtensions(extensionsDir)`. The `extensionsDir` should be constructed as `.flowforge/extensions` relative to the app data directory. For now, use a hardcoded path placeholder that will be refined when the actual GitHub extension is loaded in Phase 34. Use `".flowforge/extensions"` as the argument -- the Rust side can resolve it relative to the app's working directory. Alternatively, check how the app determines its data directory (likely via the currently-opened repo path or an app config path). For v1.5, extensions live in `{repoRoot}/.flowforge/extensions/`. If no repo is open, skip discovery. Read the existing repository state pattern to determine how to get the repo root.
3. For each manifest, check `manifest.apiVersion !== CURRENT_API_VERSION`. If incompatible, set status to `"error"` with an error message, and call `toast.error(...)` with a user-visible message.
4. Compatible extensions get status `"discovered"`.
5. Update state with the new extensions Map (copy-on-write: `new Map(extensions)`).
6. Set `isDiscovering: false`.

**activateExtension:**
1. Get the extension info from state. If not found or status !== "discovered", return.
2. Set status to "activating" and update state.
3. Create `const api = new ExtensionAPI(id)`.
4. Build the entry point URL from `manifest.basePath` and `manifest.main`. For Tauri, use `convertFileSrc` from `@tauri-apps/api/core` if needed, or construct an asset protocol URL. The research notes say this needs implementation-time validation. Try: `const entryUrl = manifest.basePath + "/" + manifest.main` with `import(/* @vite-ignore */ entryUrl)`. If this doesn't work with Tauri's webview, fall back to fetching the file content via a Rust command and using `new Function` or `blob:` URL. Document the approach taken.
5. `const module = await import(/* @vite-ignore */ entryUrl)`.
6. Verify `typeof module.onActivate === "function"` -- throw if not.
7. `await module.onActivate(api)`.
8. Store `api` in `extensionApis` Map and `module` in `extensionModules` Map.
9. Set status to "active", clear error.
10. Wrap steps 4-9 in try-catch. On error: call `api.cleanup()` to remove partial registrations, set status to "error" with error message, call `toast.error(...)`.

**deactivateExtension:**
1. Get extension info. If status !== "active", return.
2. Get module from `extensionModules`. If it has `onDeactivate` function, call `await module.onDeactivate()` (wrapped in try-catch -- log errors but don't stop cleanup).
3. Get api from `extensionApis`. Call `api.cleanup()`.
4. Remove from both Maps.
5. Set status to "deactivated".

**activateAll:**
Iterate extensions Map. For each with status "discovered", call `activateExtension(id)`. Use sequential await (not Promise.all) to avoid race conditions in registry mutations.

**deactivateAll:**
Iterate extensions Map. For each with status "active", call `deactivateExtension(id)`. Sequential await.

Store creation:
```typescript
export const useExtensionHost = create<ExtensionHostState>()(
  devtools(
    (set, get) => ({ ... }),
    { name: "extension-host", enabled: import.meta.env.DEV },
  ),
);
```

**src/extensions/index.ts:**
Barrel export file:
```typescript
export { useExtensionHost, CURRENT_API_VERSION } from "./ExtensionHost";
export { ExtensionAPI } from "./ExtensionAPI";
export type { ExtensionManifest, ExtensionContributes, ExtensionBladeContribution, ExtensionCommandContribution, ExtensionToolbarContribution } from "./extensionManifest";
export type { ExtensionStatus, ExtensionInfo } from "./extensionTypes";
```
  </action>
  <verify>
1. `npx tsc --noEmit` -- no new errors.
2. `npx vitest run` -- all existing tests pass (no runtime changes to core code).
3. Manually verify the store shape: `useExtensionHost.getState()` should have `extensions` (Map), `isDiscovering` (boolean), and the 5 action methods.
4. Verify the barrel export in index.ts re-exports all public API types and the store.
  </verify>
  <done>
ExtensionHost Zustand store manages full lifecycle: discovery (via Rust command), apiVersion validation (with toast error on mismatch), activation (dynamic import + onActivate + registration tracking), deactivation (onDeactivate + cleanup of all registrations). ExtensionAPI facade provides namespaced registerBlade/registerCommand/contributeToolbar. Barrel exports expose the complete extension system API.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (no new errors beyond pre-existing TS2440)
2. `npx vitest run` passes (all existing tests green)
3. Extension system types compile: ExtensionManifest, ExtensionInfo, ExtensionStatus, ExtensionAPI
4. useExtensionHost store has all lifecycle methods: discoverExtensions, activateExtension, deactivateExtension, activateAll, deactivateAll
5. ExtensionAPI namespaces registrations: registerBlade creates ext:{id}:{name} types, registerCommand creates ext:{id}:{cmdId} commands
6. cleanup() removes all tracked registrations from all three registries
7. apiVersion mismatch sets status to "error" and shows toast
8. Activation failure triggers cleanup of partial registrations
</verification>

<success_criteria>
- src/extensions/ directory exists with 5 files: index.ts, ExtensionHost.ts, ExtensionAPI.ts, extensionManifest.ts, extensionTypes.ts
- useExtensionHost is a Zustand store with devtools middleware
- CURRENT_API_VERSION = "1"
- discoverExtensions calls Rust command and filters by apiVersion
- activateExtension loads entry point, creates ExtensionAPI, calls onActivate, tracks in module-level Maps
- deactivateExtension calls onDeactivate, calls api.cleanup(), removes from Maps
- ExtensionAPI namespaces all registrations with ext:{extensionId}: prefix
- ExtensionAPI.cleanup() atomically removes all tracked registrations
- Incompatible apiVersion shows toast.error with clear message
- Failed activation cleans up partial registrations
- All existing tests pass, no new TS errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-extension-system-foundation/33-03-SUMMARY.md`
</output>
