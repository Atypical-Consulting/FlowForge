---
phase: 33-extension-system-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/bladeTypes.ts
  - src/lib/bladeRegistry.ts
  - src/blades/_discovery.ts
  - src/machines/navigation/types.ts
  - src/machines/navigation/navigationMachine.ts
  - src/lib/bladeOpener.ts
  - src/hooks/useBladeNavigation.ts
  - src/lib/commandRegistry.ts
  - src/components/command-palette/CommandPalette.tsx
autonomous: true

must_haves:
  truths:
    - "Extension blade types (ext:{extId}:{name}) are accepted by the navigation machine and blade registry without TypeScript errors"
    - "Core blade code retains compile-time type safety through CoreBladeType"
    - "unregisterBlade() removes a blade registration by type string"
    - "unregisterCommand() removes a command by id string"
    - "Extension command categories appear in the command palette after core categories"
    - "HMR dispose clears only core blade registrations, preserving extension registrations"
  artifacts:
    - path: "src/stores/bladeTypes.ts"
      provides: "CoreBladeType, ExtensionBladeType, widened BladeType union"
      exports: ["CoreBladeType", "ExtensionBladeType", "BladeType", "BladePropsMap", "TypedBlade"]
    - path: "src/lib/bladeRegistry.ts"
      provides: "unregisterBlade, unregisterBySource, clearCoreRegistry, source tracking"
      exports: ["registerBlade", "unregisterBlade", "unregisterBySource", "clearCoreRegistry", "getBladeRegistration", "getAllBladeTypes", "isSingletonBlade"]
    - path: "src/lib/commandRegistry.ts"
      provides: "Map-based storage, unregisterCommand, unregisterCommandsBySource, getOrderedCategories, source tracking"
      exports: ["registerCommand", "unregisterCommand", "unregisterCommandsBySource", "getCommands", "getEnabledCommands", "getCommandById", "executeCommand", "getOrderedCategories", "CoreCommandCategory", "CommandCategory"]
    - path: "src/machines/navigation/types.ts"
      provides: "Widened NavigationEvent accepting BladeType (including extension types)"
      contains: "ExtensionBladeType"
  key_links:
    - from: "src/stores/bladeTypes.ts"
      to: "src/lib/bladeRegistry.ts"
      via: "BladeType import used as Map key"
      pattern: "Map<string,"
    - from: "src/stores/bladeTypes.ts"
      to: "src/machines/navigation/types.ts"
      via: "BladeType used in NavigationEvent"
      pattern: "bladeType: BladeType"
    - from: "src/lib/bladeRegistry.ts"
      to: "src/blades/_discovery.ts"
      via: "clearCoreRegistry replaces clearRegistry in HMR dispose"
      pattern: "clearCoreRegistry"
    - from: "src/lib/commandRegistry.ts"
      to: "src/components/command-palette/CommandPalette.tsx"
      via: "getOrderedCategories replaces hardcoded CATEGORY_ORDER"
      pattern: "getOrderedCategories"
---

<objective>
Refactor the blade registry, command registry, navigation types, and BladeType system to support dynamic extension registrations while preserving compile-time type safety for core blades.

Purpose: This is the foundational refactoring that makes all three registries (blade, command, toolbar -- toolbar is already ready) accept dynamic extension registrations with source tracking and cleanup support. Without this, the ExtensionHost (Plan 03) cannot register extension blades/commands.

Output: All registries accept extension types, have unregister/cleanup functions, and the navigation machine handles extension blade types.
</objective>

<execution_context>
@C:/Users/matrayp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matrayp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-extension-system-foundation/33-RESEARCH.md

@src/stores/bladeTypes.ts
@src/lib/bladeRegistry.ts
@src/lib/commandRegistry.ts
@src/blades/_discovery.ts
@src/machines/navigation/types.ts
@src/machines/navigation/navigationMachine.ts
@src/lib/bladeOpener.ts
@src/hooks/useBladeNavigation.ts
@src/components/command-palette/CommandPalette.tsx
@src/lib/toolbarRegistry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Widen BladeType system and refactor bladeRegistry for extensibility</name>
  <files>
    src/stores/bladeTypes.ts
    src/lib/bladeRegistry.ts
    src/blades/_discovery.ts
  </files>
  <action>
**src/stores/bladeTypes.ts:**
1. Keep `BladePropsMap` interface unchanged (core blades remain compile-time safe).
2. Add `CoreBladeType = keyof BladePropsMap` as a named export.
3. Add `ExtensionBladeType = \`ext:${string}:${string}\`` as a template literal type export.
4. Change `BladeType` from `keyof BladePropsMap` to `CoreBladeType | ExtensionBladeType`.
5. Add a type guard: `export function isCoreBladeType(type: BladeType): type is CoreBladeType` that checks against `!type.startsWith("ext:")`. Note: this must also be a runtime check, not just a type predicate. Implement it by checking the key exists in a known set or simply that the string does not start with "ext:".
6. Update `TypedBlade` to handle extension types. Extension blades use `Record<string, unknown>` for props:
   ```typescript
   export type TypedBlade =
     | { [K in CoreBladeType]: { id: string; type: K; title: string; props: BladePropsMap[K] } }[CoreBladeType]
     | { id: string; type: ExtensionBladeType; title: string; props: Record<string, unknown> };
   ```

**src/lib/bladeRegistry.ts:**
1. Change `BladeRegistration.type` from `BladeType` to `string` to accept any blade type including extension strings.
2. Add optional `source?: string` field to `BladeRegistration` (values: `"core"` or `"ext:{extensionId}"`).
3. Change the internal `registry` Map key from `BladeType` to `string`: `const registry = new Map<string, BladeRegistration<any>>()`.
4. Add `unregisterBlade(type: string): boolean` that calls `registry.delete(type)` and returns the result.
5. Add `unregisterBySource(source: string): void` that iterates the registry and deletes all entries where `reg.source === source`.
6. Rename `clearRegistry()` to `clearCoreRegistry()` and change implementation to only delete entries where `!type.startsWith("ext:")` (preserving extension registrations during HMR).
7. Export the old `clearRegistry` name as a deprecated re-export pointing to `clearCoreRegistry` for safety, OR simply rename all usages (there is only one in _discovery.ts).
8. Update `getBladeRegistration` parameter type from `BladeType` to `string`.
9. Update `getAllBladeTypes` return type from `BladeType[]` to `string[]`.
10. Update `isSingletonBlade` parameter type from `BladeType` to `string`.

**src/blades/_discovery.ts:**
1. Change `import { clearRegistry }` to `import { clearCoreRegistry }` (matching the rename from bladeRegistry.ts).
2. Update the HMR dispose handler to call `clearCoreRegistry()` instead of `clearRegistry()`.
3. In the dev-mode exhaustiveness check, cast `t as any` is already there, so no change needed for the EXPECTED_TYPES check.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no new TypeScript errors beyond the pre-existing TS2440 in bindings.ts. Specifically verify that all existing blade registration files (src/blades/*/registration.ts) still compile without changes.
  </verify>
  <done>
BladeType is a union of CoreBladeType | ExtensionBladeType. bladeRegistry accepts string keys, has unregisterBlade(), unregisterBySource(), clearCoreRegistry(), and source tracking. HMR preserves extension registrations. All existing core blade registrations continue to work unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Widen navigation machine and blade openers for extension types</name>
  <files>
    src/machines/navigation/types.ts
    src/machines/navigation/navigationMachine.ts
    src/lib/bladeOpener.ts
    src/hooks/useBladeNavigation.ts
  </files>
  <action>
**src/machines/navigation/types.ts:**
1. The file re-exports `BladeType, BladePropsMap, TypedBlade` from `../../stores/bladeTypes`. Add re-export of `CoreBladeType` and `ExtensionBladeType`.
2. Update the `PUSH_BLADE` event type: change `props: BladePropsMap[BladeType]` to `props: Record<string, unknown>` since extension blades can have arbitrary props. Actually, use a union: for core blades props should be `BladePropsMap[CoreBladeType]`, for extension blades `Record<string, unknown>`. The simplest approach: change `props` to `BladePropsMap[BladeType] | Record<string, unknown>` OR just `Record<string, unknown>` since all core blade props are subtypes of `Record<string, unknown>`. Use the broader type since the machine doesn't inspect props -- it just stores them. Change the `PUSH_BLADE` and `REPLACE_BLADE` event props fields to `Record<string, unknown>`.
3. Keep `BladeType` as the type for `bladeType` in PUSH_BLADE and REPLACE_BLADE (it already includes ExtensionBladeType via the widened union).

**src/machines/navigation/navigationMachine.ts:**
1. The `SINGLETON_TYPES` Set currently has hardcoded core blade types. This Set is used by the `isNotSingleton` guard. Extension singletons declared in the manifest need to be checked dynamically. Change the approach: instead of a static Set, call `isSingletonBlade(event.bladeType)` from bladeRegistry (import it). This way, extensions that register as `singleton: true` in the blade registry will automatically be treated as singletons by the navigation machine.
2. Import `isSingletonBlade` from `../../lib/bladeRegistry`.
3. Update the `isNotSingleton` guard: replace `if (!SINGLETON_TYPES.has(event.bladeType))` with `if (!isSingletonBlade(event.bladeType))`.
4. Remove the `SINGLETON_TYPES` constant entirely.

**src/lib/bladeOpener.ts:**
1. Add an overload signature for extension blade types. The current signature is `openBlade<K extends BladeType>(type: K, props: BladePropsMap[K], title?: string)`. This won't work for extension types because `BladePropsMap` doesn't have keys for extension types.
2. Add a second overload: `function openBlade(type: string, props: Record<string, unknown>, title?: string): void`.
3. The implementation body stays the same -- it already does `getBladeRegistration(type)` which now accepts `string`, and passes props through. Just widen the implementation signature to `(type: string, props: Record<string, unknown>, title?: string)`.
4. Keep the generic overload for core blades so callers retain type safety: `function openBlade<K extends CoreBladeType>(type: K, props: BladePropsMap[K], title?: string): void`.
5. Update imports: import `CoreBladeType` from bladeTypes, and update the `BladePropsMap` import.

**src/hooks/useBladeNavigation.ts:**
1. Apply the same overload pattern to the inner `openBlade` function: keep generic for `CoreBladeType`, add string overload for extension types.
2. Apply the same overload pattern to `pushBlade` and `replaceBlade`.
3. Update imports: add `CoreBladeType` import from navigation/types.
4. Update the `.send()` calls for `PUSH_BLADE` and `REPLACE_BLADE` -- the `props` field in the event is now `Record<string, unknown>`, so cast with `as Record<string, unknown>` or `as any` if needed to satisfy TypeScript.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no new TypeScript errors. Run `npx vitest run` -- all existing tests pass. Verify that opening a core blade like "settings" still compiles with type-safe props.
  </verify>
  <done>
Navigation machine uses dynamic singleton check via bladeRegistry. PUSH_BLADE and REPLACE_BLADE events accept extension blade types and Record<string, unknown> props. bladeOpener and useBladeNavigation have overloaded signatures preserving type safety for core blades while accepting extension blade types. All existing navigation behavior is unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor commandRegistry to Map-based storage with unregister and dynamic categories</name>
  <files>
    src/lib/commandRegistry.ts
    src/components/command-palette/CommandPalette.tsx
  </files>
  <action>
**src/lib/commandRegistry.ts:**
1. Add `CoreCommandCategory` type with all current literal values: `"Repository" | "Branches" | "Sync" | "Stash" | "Tags" | "Worktrees" | "Navigation" | "Settings"`.
2. Widen `CommandCategory` to `CoreCommandCategory | (string & {})`. The `(string & {})` trick preserves autocompletion for core categories while allowing any string.
3. Add `source?: string` field to the `Command` interface.
4. Change storage from `const commands: Command[] = []` to `const commands = new Map<string, Command>()`.
5. Update `registerCommand`: change from findIndex+push pattern to `commands.set(cmd.id, cmd)`.
6. Add `unregisterCommand(id: string): boolean` that returns `commands.delete(id)`.
7. Add `unregisterCommandsBySource(source: string): void` that iterates the Map and deletes entries where `cmd.source === source`.
8. Update `getCommands()` to return `Array.from(commands.values())`.
9. Update `getEnabledCommands()` to use `Array.from(commands.values()).filter(...)`.
10. Update `getCommandById(id: string)` to use `commands.get(id)`.
11. Add `getOrderedCategories(): CommandCategory[]` function:
    - Define `CORE_ORDER: CoreCommandCategory[]` with the canonical order: `["Navigation", "Repository", "Sync", "Branches", "Stash", "Tags", "Worktrees", "Settings"]`.
    - Collect all unique categories from registered commands.
    - Return core categories (in CORE_ORDER, filtered to only those that have commands) followed by extension categories (alphabetically sorted, not in CORE_ORDER).
12. Export `CoreCommandCategory`.

**src/components/command-palette/CommandPalette.tsx:**
1. Remove the hardcoded `CATEGORY_ORDER` constant.
2. Import `getOrderedCategories` from `../../lib/commandRegistry`.
3. In the `groupedResults` useMemo, replace the `CATEGORY_ORDER.filter(...)` pattern with `getOrderedCategories().filter(cat => groups.has(cat))`.
4. The rest of the component logic stays the same -- it already groups by category and renders group headers.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no new TypeScript errors. Run `npx vitest run` -- all existing tests pass. Open the app and verify the command palette still shows commands grouped by category in the same order.
  </verify>
  <done>
commandRegistry uses Map<string, Command> for O(1) lookups, has unregisterCommand(), unregisterCommandsBySource(), source tracking, and widened CommandCategory. CommandPalette derives category ordering dynamically from registered commands, with core categories first and extension categories appended alphabetically.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (no new errors beyond pre-existing TS2440 in bindings.ts)
2. `npx vitest run` passes (all 140+ existing tests green)
3. All existing blade registrations in `src/blades/*/registration.ts` compile without changes
4. Core blade type-safety is preserved: `openBlade("settings", {})` compiles, `openBlade("settings", { bad: true })` does not
5. Extension blade types are accepted: `openBlade("ext:github:pull-requests", { repo: "foo" })` compiles
6. Command palette still groups commands correctly with core categories in canonical order
</verification>

<success_criteria>
- BladeType = CoreBladeType | ExtensionBladeType (widened union)
- bladeRegistry: unregisterBlade(), unregisterBySource(), clearCoreRegistry(), source field
- commandRegistry: Map-based, unregisterCommand(), unregisterCommandsBySource(), getOrderedCategories(), source field, widened CommandCategory
- Navigation machine uses dynamic singleton check from bladeRegistry
- Navigation events accept extension blade types
- bladeOpener + useBladeNavigation have overloaded signatures for extension types
- HMR preserves extension blade registrations
- CommandPalette derives categories dynamically
- All existing tests pass, no new TS errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-extension-system-foundation/33-01-SUMMARY.md`
</output>
