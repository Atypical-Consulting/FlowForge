---
phase: 33-extension-system-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/extensions/mod.rs
  - src-tauri/src/extensions/manifest.rs
  - src-tauri/src/extensions/discovery.rs
  - src-tauri/src/lib.rs
  - src/bindings.ts
autonomous: true

must_haves:
  truths:
    - "Rust command scans .flowforge/extensions/*/flowforge.extension.json and returns parsed manifests"
    - "Invalid JSON or missing required fields in a manifest does not crash discovery -- the extension is skipped with a warning"
    - "An empty or nonexistent extensions directory returns an empty array (not an error)"
    - "The discover_extensions command is callable from the frontend via generated bindings"
  artifacts:
    - path: "src-tauri/src/extensions/manifest.rs"
      provides: "ExtensionManifest, ExtensionContributes, and contribution structs with serde + specta derives"
      contains: "ExtensionManifest"
    - path: "src-tauri/src/extensions/discovery.rs"
      provides: "discover_extensions Tauri command"
      contains: "pub async fn discover_extensions"
    - path: "src-tauri/src/extensions/mod.rs"
      provides: "Module exports for extensions"
      contains: "pub mod discovery"
    - path: "src-tauri/src/lib.rs"
      provides: "Extension commands registered in the Tauri builder"
      contains: "discover_extensions"
  key_links:
    - from: "src-tauri/src/extensions/discovery.rs"
      to: "src-tauri/src/extensions/manifest.rs"
      via: "Deserializes JSON into ExtensionManifest"
      pattern: "serde_json::from_str::<ExtensionManifest>"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/extensions/discovery.rs"
      via: "Registers discover_extensions as a Tauri command"
      pattern: "discover_extensions"
    - from: "src/bindings.ts"
      to: "src-tauri/src/extensions/discovery.rs"
      via: "tauri-specta generates TypeScript binding for discover_extensions"
      pattern: "discoverExtensions"
---

<objective>
Create the Rust-side extension manifest types and filesystem discovery command that scans .flowforge/extensions/ for valid extension manifests.

Purpose: The ExtensionHost (Plan 03) needs a way to discover extensions from the filesystem. Doing this in Rust avoids giving the frontend filesystem access and leverages serde for compile-time validated JSON parsing. This is the secure discovery path.

Output: New `src-tauri/src/extensions/` module with manifest types and discovery command, registered in the Tauri command builder, with auto-generated TypeScript bindings.
</objective>

<execution_context>
@C:/Users/matrayp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matrayp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-extension-system-foundation/33-RESEARCH.md

@src-tauri/src/lib.rs
@src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extension manifest types and discovery command in Rust</name>
  <files>
    src-tauri/src/extensions/mod.rs
    src-tauri/src/extensions/manifest.rs
    src-tauri/src/extensions/discovery.rs
  </files>
  <action>
**src-tauri/src/extensions/mod.rs:**
Create module root that re-exports the discovery command:
```rust
pub mod discovery;
pub mod manifest;
```

**src-tauri/src/extensions/manifest.rs:**
Define the manifest structs matching the flowforge.extension.json schema. All structs need `#[derive(Debug, Serialize, Deserialize, Type, Clone)]` for serde parsing and specta TypeScript generation.

```rust
use serde::{Deserialize, Serialize};
use specta::Type;
```

Structs:
1. `ExtensionManifest` with fields:
   - `id: String` (required)
   - `name: String` (required)
   - `version: String` (required)
   - `description: Option<String>`
   - `api_version: String` (required, serde rename `apiVersion`)
   - `main: String` (required -- relative path to JS entry point)
   - `contributes: Option<ExtensionContributes>`
   - `permissions: Option<Vec<String>>`
   - `base_path: Option<String>` (serde rename `basePath`, populated by discovery, not from JSON -- use `#[serde(default)]`)

Use `#[serde(rename_all = "camelCase")]` on ExtensionManifest for JSON field mapping.

2. `ExtensionContributes` with fields:
   - `blades: Option<Vec<ExtensionBladeContribution>>`
   - `commands: Option<Vec<ExtensionCommandContribution>>`
   - `toolbar: Option<Vec<ExtensionToolbarContribution>>`

3. `ExtensionBladeContribution` with fields:
   - `r#type: String` (the `r#` prefix is needed because `type` is a Rust keyword)
   - `title: String`
   - `singleton: Option<bool>`

4. `ExtensionCommandContribution` with fields:
   - `id: String`
   - `title: String`
   - `category: Option<String>`

5. `ExtensionToolbarContribution` with fields:
   - `id: String`
   - `label: String`
   - `group: Option<String>`
   - `priority: Option<i32>`

**src-tauri/src/extensions/discovery.rs:**
Create the `discover_extensions` Tauri command:

```rust
use super::manifest::ExtensionManifest;
use std::path::PathBuf;
```

The command signature: `pub async fn discover_extensions(extensions_dir: String) -> Result<Vec<ExtensionManifest>, String>`

Add `#[tauri::command]` and `#[specta::specta]` attributes.

Implementation:
1. Convert `extensions_dir` to a `PathBuf`. If the directory does not exist, return `Ok(vec![])` (not an error -- extensions are optional).
2. Use `tokio::fs::read_dir` to iterate subdirectories.
3. For each subdirectory entry, check if it contains `flowforge.extension.json`.
4. Read the manifest JSON with `tokio::fs::read_to_string`.
5. Parse with `serde_json::from_str::<ExtensionManifest>`. On parse error, log with `eprintln!` and skip (do not fail the entire discovery).
6. After successful parse, set the `base_path` field to the subdirectory's path as a string (this tells the frontend where the extension lives on disk).
7. Collect all successfully parsed manifests and return them.

Error handling: Only return `Err` for truly unrecoverable errors (e.g., failed to read the extensions directory at all when it exists). Individual extension failures are logged and skipped.
  </action>
  <verify>
Run `cargo build` from the `src-tauri` directory. Verify the build succeeds with no errors. Run `cargo clippy -- -D warnings` to check for linting issues (warnings are OK for the pre-existing bindings issue, but no new warnings in the extensions module).
  </verify>
  <done>
Three new Rust files exist: mod.rs, manifest.rs, discovery.rs. The ExtensionManifest struct matches the flowforge.extension.json schema. The discover_extensions command scans a directory, parses manifests, skips invalid ones, and returns valid manifests. Rust builds successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register extension discovery command in Tauri builder and regenerate bindings</name>
  <files>
    src-tauri/src/lib.rs
    src/bindings.ts
  </files>
  <action>
**src-tauri/src/lib.rs:**
1. Add `mod extensions;` at the top of the file alongside `mod git;` and `mod gitflow;`.
2. Add `use extensions::discovery::discover_extensions;` to the imports.
3. Add `discover_extensions` to the `collect_commands!` macro invocation in the builder. Place it in a new comment section at the end:
   ```rust
   // Extension discovery commands
   discover_extensions,
   ```

**src/bindings.ts:**
After modifying lib.rs, trigger a dev build to regenerate the TypeScript bindings. Run `cargo build` from src-tauri (in debug mode, the specta export runs and writes to ../src/bindings.ts).

Verify that the generated `bindings.ts` now includes:
- A `discoverExtensions` function
- TypeScript types for `ExtensionManifest`, `ExtensionContributes`, `ExtensionBladeContribution`, `ExtensionCommandContribution`, `ExtensionToolbarContribution`

Note: The pre-existing TS2440 warning in bindings.ts is expected and not caused by this change. Do NOT attempt to fix it.

Stage and verify that `src/bindings.ts` has the new types. If the bindings are not auto-generated during `cargo build` (only happens in debug builds), run `cargo build` from within `src-tauri/` explicitly.
  </action>
  <verify>
1. `cargo build` succeeds in src-tauri directory.
2. `src/bindings.ts` contains `discoverExtensions` function and `ExtensionManifest` type.
3. `npx tsc --noEmit` passes (no new errors beyond pre-existing TS2440).
4. `npx vitest run` passes (existing tests unaffected).
  </verify>
  <done>
The discover_extensions Rust command is registered in the Tauri builder. TypeScript bindings are regenerated with discoverExtensions function and all manifest types. Frontend can call `commands.discoverExtensions(extensionsDir)` to get parsed extension manifests.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` passes in src-tauri directory
2. `cargo clippy -- -D warnings` passes for the extensions module (no new warnings)
3. `npx tsc --noEmit` passes
4. `npx vitest run` passes
5. Generated bindings.ts has `discoverExtensions` function and `ExtensionManifest` type
</verification>

<success_criteria>
- src-tauri/src/extensions/ module exists with manifest.rs, discovery.rs, mod.rs
- ExtensionManifest struct has all required fields (id, name, version, apiVersion, main, contributes, permissions)
- discover_extensions command scans filesystem and returns parsed manifests
- Empty/missing extensions directory returns empty array (not error)
- Invalid manifests are skipped with log warning (not fatal)
- Command registered in Tauri builder
- TypeScript bindings generated with discoverExtensions function and manifest types
</success_criteria>

<output>
After completion, create `.planning/phases/33-extension-system-foundation/33-02-SUMMARY.md`
</output>
