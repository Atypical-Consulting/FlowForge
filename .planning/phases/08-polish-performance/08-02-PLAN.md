---
phase: 08-polish-performance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/git/watcher.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/commands.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Application detects file changes made outside the app within 500ms"
    - "File watcher emits events to frontend for UI refresh"
    - "Watcher is cleaned up when repository is closed"
  artifacts:
    - path: "src-tauri/src/git/watcher.rs"
      provides: "File system watcher using notify-rs"
      exports: ["start_watching", "stop_watching"]
    - path: "src-tauri/Cargo.toml"
      provides: "notify and notify-debouncer-mini dependencies"
      contains: "notify"
  key_links:
    - from: "src-tauri/src/git/watcher.rs"
      to: "notify"
      via: "RecommendedWatcher"
      pattern: "notify::.*Watcher"
    - from: "src-tauri/src/git/watcher.rs"
      to: "tauri::AppHandle"
      via: "emit event"
      pattern: "app_handle.*emit"
---

<objective>
Implement file system watcher using notify-rs to detect external changes to repository files within 500ms.

Purpose: Fulfills PERF-05 (file watcher detects changes within 500ms). Enables auto-refresh when files change outside the app.
Output: Backend watcher module that emits events when repository files change.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-polish-performance/08-RESEARCH.md

@src-tauri/Cargo.toml
@src-tauri/src/git/mod.rs
@src-tauri/src/git/repository.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add notify-rs dependencies and create watcher module</name>
  <files>
    - src-tauri/Cargo.toml
    - src-tauri/src/git/watcher.rs
    - src-tauri/src/git/mod.rs
  </files>
  <action>
1. Update `src-tauri/Cargo.toml` to add dependencies:
```toml
notify = "8"
notify-debouncer-mini = "0.5"
```

2. Create `src-tauri/src/git/watcher.rs`:

```rust
use notify::{Config, RecommendedWatcher, RecursiveMode, Watcher};
use notify_debouncer_mini::{new_debouncer, DebouncedEvent, Debouncer};
use std::path::PathBuf;
use std::sync::Arc;
use std::time::Duration;
use tauri::{AppHandle, Emitter, Manager};
use tokio::sync::Mutex;

use crate::git::error::GitError;

/// Global watcher state - one watcher per app instance
pub struct WatcherState {
    debouncer: Option<Debouncer<RecommendedWatcher>>,
    watched_path: Option<PathBuf>,
}

impl WatcherState {
    pub fn new() -> Self {
        Self {
            debouncer: None,
            watched_path: None,
        }
    }
}

impl Default for WatcherState {
    fn default() -> Self {
        Self::new()
    }
}

/// Event emitted when repository files change
#[derive(Clone, serde::Serialize)]
pub struct FileChangeEvent {
    pub paths: Vec<String>,
}

/// Start watching a repository directory for changes.
/// Debounces events with 500ms delay as per PERF-05.
pub fn start_watching(
    state: &mut WatcherState,
    repo_path: PathBuf,
    app_handle: AppHandle,
) -> Result<(), GitError> {
    // Stop any existing watcher first
    stop_watching(state);

    let app_handle_clone = app_handle.clone();
    
    // Create debouncer with 500ms delay
    let debouncer = new_debouncer(
        Duration::from_millis(500),
        move |result: Result<Vec<DebouncedEvent>, notify::Error>| {
            match result {
                Ok(events) => {
                    let paths: Vec<String> = events
                        .iter()
                        .map(|e| e.path.to_string_lossy().to_string())
                        .collect();
                    
                    if !paths.is_empty() {
                        // Emit event to frontend
                        let _ = app_handle_clone.emit("repository-changed", FileChangeEvent { paths });
                    }
                }
                Err(e) => {
                    eprintln!("Watcher error: {:?}", e);
                }
            }
        },
    )
    .map_err(|e| GitError::Internal(format!("Failed to create watcher: {}", e)))?;

    // Get mutable reference to debouncer's watcher
    let mut debouncer = debouncer;
    
    // Watch the repository directory recursively
    debouncer
        .watcher()
        .watch(&repo_path, RecursiveMode::Recursive)
        .map_err(|e| GitError::Internal(format!("Failed to watch path: {}", e)))?;

    state.debouncer = Some(debouncer);
    state.watched_path = Some(repo_path);

    Ok(())
}

/// Stop watching the current repository.
pub fn stop_watching(state: &mut WatcherState) {
    if let (Some(mut debouncer), Some(path)) = (state.debouncer.take(), state.watched_path.take()) {
        let _ = debouncer.watcher().unwatch(&path);
    }
}
```

3. Update `src-tauri/src/git/mod.rs` to export the watcher module:
```rust
pub mod watcher;
```
  </action>
  <verify>
```bash
cd src-tauri && cargo check
```
Should compile without errors.
  </verify>
  <done>notify-rs dependencies added and watcher module compiles successfully</done>
</task>

<task type="auto">
  <name>Task 2: Integrate watcher with IPC commands and app lifecycle</name>
  <files>
    - src-tauri/src/git/commands.rs
    - src-tauri/src/lib.rs
  </files>
  <action>
1. Update `src-tauri/src/lib.rs` to:
   - Add WatcherState to app state (wrapped in Mutex)
   - Start watcher when repository is opened
   - Stop watcher when repository is closed

```rust
// Add to state setup in lib.rs
use crate::git::watcher::WatcherState;
use std::sync::Mutex;

// In run() function, add to managed state:
.manage(Mutex::new(WatcherState::new()))
```

2. Update `src-tauri/src/git/commands.rs`:
   - Modify `open_repository` to start watcher after successful open
   - Modify `close_repository` to stop watcher

```rust
use tauri::State;
use std::sync::Mutex;
use crate::git::watcher::{WatcherState, start_watching, stop_watching};

// In open_repository command, after successful open:
pub async fn open_repository(
    path: String,
    state: State<'_, RepositoryState>,
    watcher_state: State<'_, Mutex<WatcherState>>,
    app_handle: tauri::AppHandle,
) -> Result<RepoStatus, GitError> {
    // ... existing open logic ...
    
    // Start watching after successful open
    if let Ok(mut watcher) = watcher_state.lock() {
        let _ = start_watching(&mut watcher, PathBuf::from(&path), app_handle);
    }
    
    // ... return result ...
}

// In close_repository command:
pub async fn close_repository(
    state: State<'_, RepositoryState>,
    watcher_state: State<'_, Mutex<WatcherState>>,
) -> Result<(), GitError> {
    // Stop watcher first
    if let Ok(mut watcher) = watcher_state.lock() {
        stop_watching(&mut watcher);
    }
    
    // ... existing close logic ...
}
```

3. Update command registration in `src-tauri/src/lib.rs`:
   - Ensure the modified commands have correct state parameters
   - Regenerate TypeScript bindings with `cargo tauri dev` or `cargo build`

4. Add frontend event listener in a later plan (this plan focuses on backend only). The frontend will listen for `repository-changed` event and trigger refresh.

Note: The event is named `repository-changed` and carries `FileChangeEvent { paths: Vec<String> }`.
  </action>
  <verify>
1. `cargo build` succeeds
2. Open app, open a repo
3. In another terminal, touch a file in the repo
4. Check Tauri console/logs for "repository-changed" event emission (may need to add debug log)
  </verify>
  <done>Watcher starts/stops with repository lifecycle and emits events to frontend</done>
</task>

</tasks>

<verification>
1. `cargo build` completes without errors
2. TypeScript bindings regenerate
3. Watcher starts when repo opens (check logs)
4. External file changes trigger events within 500ms
5. Watcher stops when repo closes (no memory leak)
6. Multiple open/close cycles work correctly
</verification>

<success_criteria>
- PERF-05: File watcher detects external changes within 500ms
- Watcher lifecycle properly tied to repository open/close
- Events emitted to frontend for UI integration
</success_criteria>

<output>
After completion, create `.planning/phases/08-polish-performance/08-02-SUMMARY.md`
</output>
