---
phase: 08-polish-performance
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - src-tauri/src/git/history.rs
  - src-tauri/src/git/commands.rs
  - src/components/commit/CommitHistory.tsx
  - src/components/commit/CommitSearch.tsx
autonomous: true

must_haves:
  truths:
    - "User can type search text and see matching commits"
    - "Search matches against commit message text"
    - "Search results appear quickly (debounced input)"
    - "Clearing search shows full history again"
  artifacts:
    - path: "src-tauri/src/git/history.rs"
      provides: "search_commits function"
      exports: ["search_commits"]
    - path: "src/components/commit/CommitSearch.tsx"
      provides: "Search input component"
      exports: ["CommitSearch"]
  key_links:
    - from: "src/components/commit/CommitHistory.tsx"
      to: "src/components/commit/CommitSearch.tsx"
      via: "search state"
      pattern: "searchQuery"
    - from: "src/components/commit/CommitHistory.tsx"
      to: "commands.searchCommits"
      via: "useQuery when search active"
      pattern: "searchCommits"
---

<objective>
Implement commit search by message text with debounced input and backend filtering.

Purpose: Fulfills UX-05 (user can search commits by message text). Helps find specific commits quickly.
Output: Search input above commit history that filters commits by message content.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-polish-performance/08-RESEARCH.md

@src-tauri/src/git/history.rs
@src/components/commit/CommitHistory.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add search_commits backend command</name>
  <files>
    - src-tauri/src/git/history.rs
    - src-tauri/src/git/commands.rs
  </files>
  <action>
1. Add `search_commits` function to `src-tauri/src/git/history.rs`:

```rust
/// Search commits by message text.
/// Returns up to `limit` commits whose message contains `query` (case-insensitive).
#[tauri::command]
#[specta::specta]
pub async fn search_commits(
    query: String,
    limit: u32,
    state: State<'_, RepositoryState>,
) -> Result<Vec<CommitSummary>, GitError> {
    let repo_path = state
        .get_path()
        .await
        .ok_or_else(|| GitError::NotFound("No repository open".to_string()))?;

    let query_lower = query.to_lowercase();

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;

        // Handle empty repo
        match repo.head() {
            Err(e) if e.code() == git2::ErrorCode::UnbornBranch => {
                return Ok(vec![]);
            }
            Err(e) => return Err(e.into()),
            Ok(_) => {}
        }

        let mut revwalk = repo.revwalk()?;
        revwalk.push_head()?;
        revwalk.set_sorting(git2::Sort::TIME)?;

        let mut results = Vec::new();
        
        for oid_result in revwalk {
            if results.len() >= limit as usize {
                break;
            }
            
            let oid = match oid_result {
                Ok(o) => o,
                Err(_) => continue,
            };
            
            let commit = match repo.find_commit(oid) {
                Ok(c) => c,
                Err(_) => continue,
            };
            
            // Check if message contains query (case-insensitive)
            let message = commit.message().unwrap_or("");
            if message.to_lowercase().contains(&query_lower) {
                let author = commit.author();
                results.push(CommitSummary {
                    oid: oid.to_string(),
                    short_oid: format!("{:.7}", oid),
                    message_subject: commit.summary().unwrap_or("").to_string(),
                    author_name: author.name().unwrap_or("Unknown").to_string(),
                    author_email: author.email().unwrap_or("").to_string(),
                    timestamp_ms: (author.when().seconds() as f64) * 1000.0,
                });
            }
        }

        Ok(results)
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}
```

2. Register the command in `src-tauri/src/git/commands.rs` (or wherever commands are collected):
   - Add `search_commits` to the `generate_handler!` macro
   - Ensure it's included in specta bindings

3. Regenerate TypeScript bindings by running `cargo build` or `npm run tauri dev`.
  </action>
  <verify>
```bash
cd src-tauri && cargo check
```
Should compile. Then verify `src/bindings.ts` contains `searchCommits` after build.
  </verify>
  <done>search_commits command added and bindings generated</done>
</task>

<task type="auto">
  <name>Task 2: Create CommitSearch component</name>
  <files>
    - src/components/commit/CommitSearch.tsx
  </files>
  <action>
Create `src/components/commit/CommitSearch.tsx`:

```typescript
import { Search, X } from "lucide-react";
import { useEffect, useState } from "react";
import { cn } from "../../lib/utils";

interface CommitSearchProps {
  value: string;
  onChange: (value: string) => void;
  className?: string;
}

export function CommitSearch({ value, onChange, className }: CommitSearchProps) {
  const [localValue, setLocalValue] = useState(value);
  
  // Debounce the onChange callback
  useEffect(() => {
    const timer = setTimeout(() => {
      onChange(localValue);
    }, 300);
    
    return () => clearTimeout(timer);
  }, [localValue, onChange]);
  
  // Sync external value changes
  useEffect(() => {
    setLocalValue(value);
  }, [value]);
  
  return (
    <div className={cn("relative", className)}>
      <Search className="absolute left-2 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-ctp-overlay0" />
      <input
        type="text"
        value={localValue}
        onChange={(e) => setLocalValue(e.target.value)}
        placeholder="Search commits..."
        className={cn(
          "w-full pl-7 pr-7 py-1.5 text-sm",
          "bg-ctp-surface0 border border-ctp-surface1 rounded",
          "text-ctp-text placeholder:text-ctp-overlay0",
          "focus:outline-none focus:border-ctp-blue focus:ring-1 focus:ring-ctp-blue/50",
        )}
      />
      {localValue && (
        <button
          type="button"
          onClick={() => {
            setLocalValue("");
            onChange("");
          }}
          className="absolute right-2 top-1/2 -translate-y-1/2 p-0.5 hover:bg-ctp-surface1 rounded"
        >
          <X className="w-3 h-3 text-ctp-overlay0" />
        </button>
      )}
    </div>
  );
}
```

Features:
- Debounced input (300ms) to avoid excessive API calls
- Clear button when search has text
- Consistent styling with existing search inputs (FileTreeSearch pattern)
  </action>
  <verify>
Import and render component in isolation to verify it renders correctly.
  </verify>
  <done>CommitSearch component created with debounced input</done>
</task>

<task type="auto">
  <name>Task 3: Integrate search with CommitHistory</name>
  <files>
    - src/components/commit/CommitHistory.tsx
  </files>
  <action>
Update `src/components/commit/CommitHistory.tsx` to support search:

```typescript
import { useInfiniteQuery, useQuery } from "@tanstack/react-query";
import { GitCommit, Loader2 } from "lucide-react";
import { useCallback, useEffect, useState } from "react";
import { Virtuoso } from "react-virtuoso";
import { type CommitSummary, commands } from "../../bindings";
import { cn } from "../../lib/utils";
import { CommitSearch } from "./CommitSearch";

interface CommitHistoryProps {
  onSelectCommit: (commit: CommitSummary) => void;
  selectedOid: string | null;
}

const PAGE_SIZE = 50;
const SEARCH_LIMIT = 100;

export function CommitHistory({
  onSelectCommit,
  selectedOid,
}: CommitHistoryProps) {
  const [searchQuery, setSearchQuery] = useState("");
  
  // Regular paginated history (when not searching)
  const historyQuery = useInfiniteQuery({
    queryKey: ["commitHistory"],
    queryFn: async ({ pageParam = 0 }) => {
      const result = await commands.getCommitHistory(pageParam, PAGE_SIZE);
      if (result.status === "ok") {
        return result.data;
      }
      throw new Error(
        result.error && "message" in result.error
          ? String(result.error.message)
          : "Unknown error",
      );
    },
    getNextPageParam: (lastPage, allPages) =>
      lastPage.length === PAGE_SIZE ? allPages.flat().length : undefined,
    initialPageParam: 0,
    enabled: !searchQuery, // Disable when searching
  });
  
  // Search query (when searching)
  const searchQueryResult = useQuery({
    queryKey: ["commitSearch", searchQuery],
    queryFn: async () => {
      const result = await commands.searchCommits(searchQuery, SEARCH_LIMIT);
      if (result.status === "ok") {
        return result.data;
      }
      throw new Error(
        result.error && "message" in result.error
          ? String(result.error.message)
          : "Unknown error",
      );
    },
    enabled: !!searchQuery,
  });
  
  // Determine which data to show
  const isSearching = !!searchQuery;
  const commits = isSearching 
    ? (searchQueryResult.data ?? [])
    : (historyQuery.data?.pages.flat() ?? []);
  const isLoading = isSearching ? searchQueryResult.isLoading : historyQuery.isLoading;
  const error = isSearching ? searchQueryResult.error : historyQuery.error;
  
  // Auto-select first commit when data loads and no selection exists
  useEffect(() => {
    if (commits.length > 0 && !selectedOid) {
      onSelectCommit(commits[0]);
    }
  }, [commits, selectedOid, onSelectCommit]);

  const handleSearchChange = useCallback((value: string) => {
    setSearchQuery(value);
  }, []);

  return (
    <div className="flex flex-col h-full">
      {/* Search input */}
      <div className="px-2 py-2 border-b border-ctp-surface0">
        <CommitSearch
          value={searchQuery}
          onChange={handleSearchChange}
        />
      </div>
      
      {/* Results */}
      <div className="flex-1 min-h-0">
        {isLoading ? (
          <div className="flex items-center justify-center h-full">
            <Loader2 className="w-5 h-5 animate-spin text-ctp-subtext0" />
          </div>
        ) : error ? (
          <div className="flex items-center justify-center h-full text-ctp-red text-sm">
            Failed to load history
          </div>
        ) : commits.length === 0 ? (
          <div className="flex items-center justify-center h-full text-ctp-overlay0 text-sm">
            {isSearching ? "No matching commits" : "No commits yet"}
          </div>
        ) : (
          <Virtuoso
            data={commits}
            endReached={() => {
              if (!isSearching && historyQuery.hasNextPage && !historyQuery.isFetchingNextPage) {
                historyQuery.fetchNextPage();
              }
            }}
            itemContent={(_, commit) => (
              <button
                type="button"
                key={commit.oid}
                onClick={() => onSelectCommit(commit)}
                className={cn(
                  "w-full text-left px-3 py-2 cursor-pointer border-b border-ctp-surface0",
                  "hover:bg-ctp-surface0/50 transition-colors",
                  selectedOid === commit.oid && "bg-ctp-blue/20",
                )}
              >
                <div className="flex items-start gap-2">
                  <GitCommit className="w-4 h-4 text-ctp-overlay0 mt-0.5 shrink-0" />
                  <div className="flex-1 min-w-0">
                    <p className="text-sm text-ctp-subtext1 truncate">
                      {commit.messageSubject}
                    </p>
                    <div className="flex items-center gap-2 mt-1 text-xs text-ctp-overlay0">
                      <span className="font-mono">{commit.shortOid}</span>
                      <span>{commit.authorName}</span>
                      <span>{formatTimestamp(commit.timestampMs)}</span>
                    </div>
                  </div>
                </div>
              </button>
            )}
            components={{
              Footer: () =>
                !isSearching && historyQuery.isFetchingNextPage ? (
                  <div className="flex justify-center py-2">
                    <Loader2 className="w-4 h-4 animate-spin text-ctp-subtext0" />
                  </div>
                ) : null,
            }}
          />
        )}
      </div>
    </div>
  );
}

function formatTimestamp(timestampMs: number): string {
  const date = new Date(timestampMs);
  const now = new Date();
  const diff = now.getTime() - date.getTime();

  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);

  if (minutes < 60) return `${minutes}m ago`;
  if (hours < 24) return `${hours}h ago`;
  if (days < 7) return `${days}d ago`;

  return date.toLocaleDateString();
}
```

Key changes:
- Added search state and CommitSearch component
- Two queries: paginated history (normal) and search results (when searching)
- Search disables infinite scroll (limited to SEARCH_LIMIT results)
- "No matching commits" message when search yields no results
  </action>
  <verify>
1. `npm run dev` + `npm run tauri dev`
2. Open a repository with commits
3. Type in search box - see results filter
4. Clear search - see full history again
5. Search for non-existent text - see "No matching commits"
  </verify>
  <done>Commit search integrated with history view</done>
</task>

</tasks>

<verification>
1. Search input appears above commit list
2. Typing filters commits by message (case-insensitive)
3. Search is debounced (no flicker on fast typing)
4. Clear button clears search and shows all commits
5. Empty search results show appropriate message
6. Pagination still works when not searching
</verification>

<success_criteria>
- UX-05: User can search commits by message text
- Search results appear quickly (debounced input)
- Search integrates seamlessly with existing commit history
</success_criteria>

<output>
After completion, create `.planning/phases/08-polish-performance/08-04-SUMMARY.md`
</output>
