---
phase: 08-polish-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - index.html
  - src/index.css
  - src/stores/theme.ts
  - src/components/ui/ThemeToggle.tsx
  - src/components/Header.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User sees light theme when Latte is selected"
    - "User sees dark theme when Mocha is selected"
    - "Theme preference persists across app restarts"
    - "No flash of wrong theme on load (FOUC prevention)"
  artifacts:
    - path: "src/stores/theme.ts"
      provides: "Theme state management with persistence"
      exports: ["useThemeStore", "Theme"]
    - path: "src/components/ui/ThemeToggle.tsx"
      provides: "Three-way toggle (Light/Dark/System)"
      exports: ["ThemeToggle"]
    - path: "src/index.css"
      provides: "Both Catppuccin Latte and Mocha imports"
      contains: "@catppuccin/tailwindcss/latte"
  key_links:
    - from: "src/stores/theme.ts"
      to: "@tauri-apps/plugin-store"
      via: "getStore().get/set"
      pattern: "getStore.*theme"
    - from: "src/App.tsx"
      to: "src/stores/theme.ts"
      via: "useThemeStore subscription"
      pattern: "useThemeStore"
    - from: "index.html"
      to: "src/stores/theme.ts"
      via: "inline script reads localStorage"
      pattern: "data-theme"
---

<objective>
Implement theme toggle system with Catppuccin Latte (light) and Mocha (dark) support, including system preference detection and persistence.

Purpose: Fulfills UX-02 (light mode) and UX-03 (theme toggle with persistence). Users can choose their preferred visual mode.
Output: Working theme system with toggle in header, no FOUC on load.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-polish-performance/08-RESEARCH.md

@src/index.css
@src/stores/repository.ts
@src/components/Header.tsx
@src/lib/store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Catppuccin Latte CSS and theme infrastructure</name>
  <files>
    - src/index.css
    - index.html
  </files>
  <action>
1. Update `src/index.css`:
   - Add Latte import: `@import "@catppuccin/tailwindcss/latte.css";`
   - Keep Mocha import for dark mode
   - Add CSS rules that activate based on `[data-theme="light"]` on html element
   - Add `.dark` selector rules that use Mocha variables
   - Default to Mocha (dark) when no data-theme attribute

2. Update `index.html`:
   - Add inline script BEFORE the React root that:
     - Reads theme preference from localStorage key `flowforge-theme`
     - If "system", checks `window.matchMedia('(prefers-color-scheme: dark)')`
     - Sets `document.documentElement.dataset.theme = 'light' | 'dark'`
     - Sets `document.documentElement.classList.add('dark')` if dark
   - This prevents FOUC by setting theme before React hydrates

The CSS structure should use Tailwind v4's CSS variable approach:
```css
@import "@catppuccin/tailwindcss/latte.css" layer(theme);
@import "@catppuccin/tailwindcss/mocha.css" layer(theme);

/* Default to mocha (dark) */
:root {
  --ctp-flavor: mocha;
}

[data-theme="light"] {
  --ctp-flavor: latte;
}
```

Note: Check Catppuccin Tailwind docs for exact v4 syntax. The library may use CSS layers differently.
  </action>
  <verify>
Manually toggle `data-theme` attribute on html element in browser devtools:
- `document.documentElement.dataset.theme = 'light'` shows light colors
- `document.documentElement.dataset.theme = 'dark'` shows dark colors
  </verify>
  <done>Both Latte and Mocha themes render correctly based on data-theme attribute</done>
</task>

<task type="auto">
  <name>Task 2: Create theme store with Tauri persistence</name>
  <files>
    - src/stores/theme.ts
  </files>
  <action>
Create `src/stores/theme.ts` using zustand pattern from existing stores:

```typescript
import { create } from "zustand";
import { getStore } from "../lib/store";

export type Theme = "light" | "dark" | "system";

interface ThemeState {
  theme: Theme;
  resolvedTheme: "light" | "dark"; // Actual applied theme
  isLoading: boolean;
  
  setTheme: (theme: Theme) => Promise<void>;
  initTheme: () => Promise<void>;
}

export const useThemeStore = create<ThemeState>((set, get) => ({
  theme: "system",
  resolvedTheme: "dark",
  isLoading: true,
  
  initTheme: async () => {
    const store = await getStore();
    const saved = await store.get<Theme>("theme");
    const theme = saved ?? "system";
    
    const resolved = resolveTheme(theme);
    applyTheme(resolved);
    
    set({ theme, resolvedTheme: resolved, isLoading: false });
    
    // Listen for system preference changes
    if (theme === "system") {
      window.matchMedia("(prefers-color-scheme: dark)")
        .addEventListener("change", (e) => {
          if (get().theme === "system") {
            const newResolved = e.matches ? "dark" : "light";
            applyTheme(newResolved);
            set({ resolvedTheme: newResolved });
          }
        });
    }
  },
  
  setTheme: async (theme) => {
    const store = await getStore();
    await store.set("theme", theme);
    await store.save();
    
    const resolved = resolveTheme(theme);
    applyTheme(resolved);
    
    set({ theme, resolvedTheme: resolved });
  },
}));

function resolveTheme(theme: Theme): "light" | "dark" {
  if (theme === "system") {
    return window.matchMedia("(prefers-color-scheme: dark)").matches 
      ? "dark" 
      : "light";
  }
  return theme;
}

function applyTheme(resolved: "light" | "dark") {
  document.documentElement.dataset.theme = resolved;
  // Also sync to localStorage for the inline script on next load
  localStorage.setItem("flowforge-theme", resolved);
}
```

Key patterns:
- Uses getStore() from lib/store.ts (already exists)
- Persists to Tauri store AND localStorage (for FOUC prevention)
- System preference listener only active when theme === "system"
  </action>
  <verify>
In browser console:
```js
// After app loads
const { useThemeStore } = await import('./stores/theme');
useThemeStore.getState().setTheme('light');
// Should see theme change AND persist
```
  </verify>
  <done>Theme store manages state with persistence to Tauri store and localStorage</done>
</task>

<task type="auto">
  <name>Task 3: Create ThemeToggle component and integrate with Header</name>
  <files>
    - src/components/ui/ThemeToggle.tsx
    - src/components/Header.tsx
    - src/App.tsx
  </files>
  <action>
1. Create `src/components/ui/ThemeToggle.tsx`:
   - Import Moon, Sun, Monitor icons from lucide-react
   - Use useThemeStore to get/set theme
   - Render three-button toggle group (similar to existing view mode toggle pattern)
   - Show current selection with visual indicator (bg-ctp-surface0 like existing)
   - Accessible: aria-label on each button, keyboard navigation

```typescript
import { Moon, Sun, Monitor } from "lucide-react";
import { useThemeStore, type Theme } from "../../stores/theme";
import { Button } from "./button";
import { cn } from "../../lib/utils";

export function ThemeToggle() {
  const { theme, setTheme, isLoading } = useThemeStore();
  
  if (isLoading) return null;
  
  const options: { value: Theme; icon: typeof Sun; label: string }[] = [
    { value: "light", icon: Sun, label: "Light theme" },
    { value: "dark", icon: Moon, label: "Dark theme" },
    { value: "system", icon: Monitor, label: "System theme" },
  ];
  
  return (
    <div className="flex items-center gap-0.5 bg-ctp-surface0 rounded p-0.5">
      {options.map(({ value, icon: Icon, label }) => (
        <Button
          key={value}
          variant={theme === value ? "secondary" : "ghost"}
          size="sm"
          onClick={() => setTheme(value)}
          title={label}
          aria-label={label}
          className={cn("h-7 w-7 p-0")}
        >
          <Icon className="w-3.5 h-3.5" />
        </Button>
      ))}
    </div>
  );
}
```

2. Update `src/components/Header.tsx`:
   - Import ThemeToggle
   - Add ThemeToggle to header actions (before the Open button)

3. Update `src/App.tsx`:
   - Import useThemeStore
   - Add useEffect to call initTheme() on mount
   - Handle loading state if needed (though inline script handles initial render)

```typescript
// In App.tsx
import { useThemeStore } from "./stores/theme";

function App() {
  const initTheme = useThemeStore((s) => s.initTheme);
  
  useEffect(() => {
    initTheme();
  }, [initTheme]);
  
  // ... rest of component
}
```
  </action>
  <verify>
1. Run `npm run dev` and `npm run tauri dev`
2. Click theme toggle buttons - UI should change immediately
3. Refresh page - theme should persist
4. Close and reopen app - theme should persist
5. Set to "System" and change OS preference - app should follow
  </verify>
  <done>ThemeToggle in header allows switching themes with instant feedback and persistence</done>
</task>

</tasks>

<verification>
1. Theme switching works without page reload
2. Theme persists across browser refresh
3. Theme persists across app restart
4. No FOUC (flash of unstyled content) on page load
5. System preference detection works when "System" is selected
6. All UI elements respect the theme (check Toast, dialogs, React Flow)
</verification>

<success_criteria>
- UX-02: Light mode support via Catppuccin Latte
- UX-03: Toggle between themes with persistence
- No FOUC on any load scenario
- Header displays theme toggle accessible to all users
</success_criteria>

<output>
After completion, create `.planning/phases/08-polish-performance/08-01-SUMMARY.md`
</output>
