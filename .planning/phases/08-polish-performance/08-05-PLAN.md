---
phase: 08-polish-performance
plan: 05
type: execute
wave: 3
depends_on: ["08-04"]
files_modified:
  - src-tauri/src/git/undo.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/commands.rs
  - src/stores/undo.ts
  - src/components/Header.tsx
autonomous: true

must_haves:
  truths:
    - "User can undo last commit operation"
    - "User sees undo button enabled only when undo is possible"
    - "Undo shows confirmation before executing"
    - "After undo, UI reflects the reverted state"
  artifacts:
    - path: "src-tauri/src/git/undo.rs"
      provides: "Reflog-based undo operations"
      exports: ["get_undo_info", "undo_last_operation"]
    - path: "src/stores/undo.ts"
      provides: "Undo state management"
      exports: ["useUndoStore"]
  key_links:
    - from: "src-tauri/src/git/undo.rs"
      to: "git2::Repository::reflog"
      via: "reflog iteration"
      pattern: "reflog"
    - from: "src/components/Header.tsx"
      to: "src/stores/undo.ts"
      via: "useUndoStore"
      pattern: "useUndoStore"
---

<objective>
Implement undo functionality for Git operations using reflog.

Purpose: Fulfills UX-06 (user can undo last Git operation where possible). Reduces anxiety when making changes.
Output: Undo button in header that reverts last commit/reset operation.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-polish-performance/08-RESEARCH.md

@src-tauri/src/git/mod.rs
@src-tauri/src/git/commit.rs
@src/components/Header.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create undo backend module with reflog</name>
  <files>
    - src-tauri/src/git/undo.rs
    - src-tauri/src/git/mod.rs
  </files>
  <action>
1. Create `src-tauri/src/git/undo.rs`:

```rust
use serde::{Deserialize, Serialize};
use specta::Type;
use tauri::State;

use crate::git::error::GitError;
use crate::git::repository::RepositoryState;

/// Information about what can be undone
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct UndoInfo {
    /// Whether undo is available
    pub can_undo: bool,
    /// Description of what will be undone
    pub description: Option<String>,
    /// The reflog entry message
    pub reflog_message: Option<String>,
    /// The commit OID to revert to
    pub target_oid: Option<String>,
}

/// Get information about what can be undone.
/// Looks at HEAD reflog to find the previous state.
#[tauri::command]
#[specta::specta]
pub async fn get_undo_info(
    state: State<'_, RepositoryState>,
) -> Result<UndoInfo, GitError> {
    let repo_path = state
        .get_path()
        .await
        .ok_or_else(|| GitError::NotFound("No repository open".to_string()))?;

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;

        // Get HEAD reflog
        let reflog = match repo.reflog("HEAD") {
            Ok(r) => r,
            Err(_) => {
                return Ok(UndoInfo {
                    can_undo: false,
                    description: None,
                    reflog_message: None,
                    target_oid: None,
                });
            }
        };

        // Need at least 2 entries to undo (current + previous)
        if reflog.len() < 2 {
            return Ok(UndoInfo {
                can_undo: false,
                description: None,
                reflog_message: None,
                target_oid: None,
            });
        }

        // Entry 0 is current state, entry 1 is previous state
        let current = reflog.get(0);
        let previous = reflog.get(1);

        match (current, previous) {
            (Some(curr), Some(prev)) => {
                let curr_msg = curr.message().unwrap_or("").to_string();
                let prev_oid = prev.id_new().to_string();
                
                // Parse the reflog message to create a human-readable description
                let description = parse_undo_description(&curr_msg);
                
                Ok(UndoInfo {
                    can_undo: true,
                    description: Some(description),
                    reflog_message: Some(curr_msg),
                    target_oid: Some(prev_oid),
                })
            }
            _ => Ok(UndoInfo {
                can_undo: false,
                description: None,
                reflog_message: None,
                target_oid: None,
            }),
        }
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}

/// Undo the last operation by resetting HEAD to the previous reflog entry.
#[tauri::command]
#[specta::specta]
pub async fn undo_last_operation(
    state: State<'_, RepositoryState>,
) -> Result<(), GitError> {
    let repo_path = state
        .get_path()
        .await
        .ok_or_else(|| GitError::NotFound("No repository open".to_string()))?;

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;

        // Get the target from reflog
        let reflog = repo.reflog("HEAD")?;
        
        if reflog.len() < 2 {
            return Err(GitError::OperationFailed("Nothing to undo".to_string()));
        }

        let previous = reflog.get(1)
            .ok_or_else(|| GitError::OperationFailed("Could not find previous state".to_string()))?;
        
        let target_oid = previous.id_new();
        let target_commit = repo.find_commit(target_oid)?;

        // Reset to the previous state (mixed reset - keeps working directory changes)
        repo.reset(
            target_commit.as_object(),
            git2::ResetType::Mixed,
            None,
        )?;

        Ok(())
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}

/// Parse reflog message into human-readable description
fn parse_undo_description(msg: &str) -> String {
    if msg.starts_with("commit:") {
        format!("Undo commit: {}", msg.trim_start_matches("commit:").trim())
    } else if msg.starts_with("commit (amend):") {
        "Undo amend commit".to_string()
    } else if msg.starts_with("reset:") {
        "Undo reset".to_string()
    } else if msg.starts_with("checkout:") {
        "Undo checkout".to_string()
    } else if msg.starts_with("merge") {
        "Undo merge".to_string()
    } else if msg.starts_with("rebase") {
        "Undo rebase".to_string()
    } else if msg.starts_with("pull:") {
        "Undo pull".to_string()
    } else {
        format!("Undo: {}", msg)
    }
}
```

2. Update `src-tauri/src/git/mod.rs`:
```rust
pub mod undo;
```
  </action>
  <verify>
```bash
cd src-tauri && cargo check
```
  </verify>
  <done>Undo backend module created with reflog-based operations</done>
</task>

<task type="auto">
  <name>Task 2: Register IPC commands and generate bindings</name>
  <files>
    - src-tauri/src/git/commands.rs
    - src-tauri/src/lib.rs
  </files>
  <action>
1. Add undo commands to IPC registration:
   - Import `get_undo_info` and `undo_last_operation` from undo module
   - Add to `generate_handler!` macro or equivalent command list
   - Add to specta binding generation

2. Rebuild to generate TypeScript bindings:
```bash
cargo build
```

3. Verify `src/bindings.ts` contains:
   - `getUndoInfo(): Promise<Result<UndoInfo, ...>>`
   - `undoLastOperation(): Promise<Result<void, ...>>`
   - `UndoInfo` type definition
  </action>
  <verify>
```bash
cargo build && grep -l "getUndoInfo" src/bindings.ts
```
  </verify>
  <done>Undo commands registered and TypeScript bindings generated</done>
</task>

<task type="auto">
  <name>Task 3: Create undo store and integrate with Header</name>
  <files>
    - src/stores/undo.ts
    - src/components/Header.tsx
  </files>
  <action>
1. Create `src/stores/undo.ts`:

```typescript
import { create } from "zustand";
import { commands, type UndoInfo } from "../bindings";

interface UndoState {
  undoInfo: UndoInfo | null;
  isLoading: boolean;
  isUndoing: boolean;
  
  loadUndoInfo: () => Promise<void>;
  performUndo: () => Promise<boolean>;
}

export const useUndoStore = create<UndoState>((set, get) => ({
  undoInfo: null,
  isLoading: false,
  isUndoing: false,
  
  loadUndoInfo: async () => {
    set({ isLoading: true });
    try {
      const result = await commands.getUndoInfo();
      if (result.status === "ok") {
        set({ undoInfo: result.data, isLoading: false });
      } else {
        set({ undoInfo: null, isLoading: false });
      }
    } catch (e) {
      console.error("Failed to load undo info:", e);
      set({ undoInfo: null, isLoading: false });
    }
  },
  
  performUndo: async () => {
    const { undoInfo } = get();
    if (!undoInfo?.canUndo) return false;
    
    set({ isUndoing: true });
    try {
      const result = await commands.undoLastOperation();
      if (result.status === "ok") {
        // Reload undo info after successful undo
        await get().loadUndoInfo();
        set({ isUndoing: false });
        return true;
      }
      set({ isUndoing: false });
      return false;
    } catch (e) {
      console.error("Failed to undo:", e);
      set({ isUndoing: false });
      return false;
    }
  },
}));
```

2. Update `src/components/Header.tsx`:
   - Import Undo2 icon from lucide-react
   - Import useUndoStore
   - Add undo button with confirmation dialog or direct action
   - Refresh undo info after commits/operations

```typescript
import { Undo2 } from "lucide-react";
import { useUndoStore } from "../stores/undo";
import { useQueryClient } from "@tanstack/react-query";

export function Header() {
  const { undoInfo, isUndoing, loadUndoInfo, performUndo } = useUndoStore();
  const queryClient = useQueryClient();
  
  // Load undo info when repo opens
  useEffect(() => {
    if (status) {
      loadUndoInfo();
    }
  }, [status, loadUndoInfo]);
  
  const handleUndo = async () => {
    if (!undoInfo?.canUndo) return;
    
    // Confirm before undo
    const confirmed = window.confirm(
      `Are you sure you want to undo?\n\n${undoInfo.description}`
    );
    
    if (confirmed) {
      const success = await performUndo();
      if (success) {
        // Invalidate relevant queries to refresh UI
        queryClient.invalidateQueries({ queryKey: ["commitHistory"] });
        queryClient.invalidateQueries({ queryKey: ["stagingStatus"] });
      }
    }
  };
  
  // In the header actions area, add:
  {status && undoInfo?.canUndo && (
    <Button
      variant="ghost"
      size="sm"
      onClick={handleUndo}
      disabled={isUndoing}
      title={undoInfo.description || "Undo last operation"}
    >
      <Undo2 className={`w-4 h-4 ${isUndoing ? "animate-spin" : ""}`} />
    </Button>
  )}
}
```

Also add a keyboard shortcut for undo (Cmd+Z) in the shortcuts hook - but be careful not to conflict with text input undo. Only trigger when not focused on input fields.
  </action>
  <verify>
1. `npm run dev` + `npm run tauri dev`
2. Open repo, make a commit
3. See undo button appear in header
4. Click undo, confirm
5. See commit reversed (check history)
6. Undo button should update or disappear
  </verify>
  <done>Undo button in header allows reverting last commit operation</done>
</task>

</tasks>

<verification>
1. Undo button only appears when undo is possible
2. Undo shows descriptive message of what will be undone
3. Confirmation prevents accidental undo
4. After undo, commit history reflects the change
5. Multiple undos work (can undo multiple times)
6. Undo does not affect uncommitted working directory changes (mixed reset)
</verification>

<success_criteria>
- UX-06: User can undo last Git operation where possible
- Clear indication of what will be undone
- Confirmation prevents accidents
- UI updates correctly after undo
</success_criteria>

<output>
After completion, create `.planning/phases/08-polish-performance/08-05-SUMMARY.md`
</output>
