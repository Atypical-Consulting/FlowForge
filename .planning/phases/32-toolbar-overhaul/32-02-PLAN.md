---
phase: 32-toolbar-overhaul
plan: 02
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - src/components/toolbar/Toolbar.tsx
  - src/components/toolbar/ToolbarButton.tsx
  - src/components/toolbar/ToolbarGroup.tsx
  - src/components/toolbar/ToolbarOverflowMenu.tsx
  - src/components/toolbar/useToolbarOverflow.ts
  - src/components/toolbar/useRovingTabindex.ts
  - src/components/Header.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Toolbar actions are visually grouped by intent (Navigation, Git Actions, Views, App) with dividers separating each group"
    - "When the window is narrowed, lower-priority actions collapse into an overflow menu with a count badge"
    - "All toolbar buttons use consistent icon-only rendering with accessible ShortcutTooltip labels"
    - "Repository-specific toolbar actions disappear when no repo is open and reappear when one is opened"
    - "ThemeToggle renders as a compound widget within the toolbar, not a standard button"
    - "Header.tsx is a thin shell composing structural components and the Toolbar"
    - "ARIA toolbar role with roving tabindex keyboard navigation is implemented"
  artifacts:
    - path: "src/components/toolbar/Toolbar.tsx"
      provides: "Main toolbar component rendering grouped actions with overflow"
      contains: "role=\"toolbar\""
    - path: "src/components/toolbar/ToolbarButton.tsx"
      provides: "Individual action button with ShortcutTooltip"
      contains: "data-toolbar-item"
    - path: "src/components/toolbar/ToolbarGroup.tsx"
      provides: "Visual group wrapper with divider"
      contains: "divider"
    - path: "src/components/toolbar/ToolbarOverflowMenu.tsx"
      provides: "Overflow dropdown with count badge"
      contains: "overflow"
    - path: "src/components/toolbar/useToolbarOverflow.ts"
      provides: "ResizeObserver hook for overflow detection"
      contains: "ResizeObserver"
    - path: "src/components/toolbar/useRovingTabindex.ts"
      provides: "ARIA roving tabindex keyboard navigation hook"
      contains: "tabIndex"
    - path: "src/components/Header.tsx"
      provides: "Thin header shell with structural components + Toolbar"
      contains: "<Toolbar"
  key_links:
    - from: "src/components/toolbar/Toolbar.tsx"
      to: "src/lib/toolbarRegistry.ts"
      via: "useToolbarRegistry subscription"
      pattern: "useToolbarRegistry"
    - from: "src/components/toolbar/Toolbar.tsx"
      to: "src/stores/domain/preferences/settings.slice.ts"
      via: "hiddenActions filter"
      pattern: "hiddenActions"
    - from: "src/components/Header.tsx"
      to: "src/components/toolbar/Toolbar.tsx"
      via: "component composition"
      pattern: "<Toolbar"
    - from: "src/App.tsx"
      to: "src/commands/toolbar-actions.ts"
      via: "side-effect import for registration"
      pattern: "toolbar-actions"
---

<objective>
Build the complete toolbar UI component tree and refactor Header.tsx from a 417-line monolith into a thin composition shell. Implement ResizeObserver overflow, ARIA keyboard navigation, and group dividers.

Purpose: This is the visible payoff -- users see grouped, responsive, accessible toolbar buttons. Header.tsx drops from ~417 lines to ~80 lines. The toolbar renders entirely from registry data, proving the extensibility pattern works for Phase 33.

Output: 6 new toolbar component files, refactored Header.tsx, App.tsx import.
</objective>

<execution_context>
@C:/Users/matrayp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matrayp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-toolbar-overhaul/32-RESEARCH.md
@.planning/phases/32-toolbar-overhaul/32-01-SUMMARY.md
@src/lib/toolbarRegistry.ts
@src/commands/toolbar-actions.ts
@src/components/Header.tsx
@src/components/sync/SyncButtons.tsx
@src/components/sync/SyncProgress.tsx
@src/components/ui/ShortcutTooltip.tsx
@src/components/ui/ThemeToggle.tsx
@src/components/ui/button.tsx
@src/stores/domain/preferences/settings.slice.ts
@src/stores/domain/preferences/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create toolbar UI components (Toolbar, ToolbarButton, ToolbarGroup, ToolbarOverflowMenu, useToolbarOverflow, useRovingTabindex)</name>
  <files>
    src/components/toolbar/Toolbar.tsx
    src/components/toolbar/ToolbarButton.tsx
    src/components/toolbar/ToolbarGroup.tsx
    src/components/toolbar/ToolbarOverflowMenu.tsx
    src/components/toolbar/useToolbarOverflow.ts
    src/components/toolbar/useRovingTabindex.ts
  </files>
  <action>
Create 6 files in `src/components/toolbar/`:

**1. useToolbarOverflow.ts -- ResizeObserver hook:**
- Exports `useToolbarOverflow()` returning `{ containerRef, visibleCount }`.
- `containerRef` is `useRef<HTMLDivElement>(null)`.
- `visibleCount` is state, initialized to `Infinity` (show all).
- Uses `ResizeObserver` on the container element.
- On resize callback (wrapped in `requestAnimationFrame` to avoid infinite loops):
  - Query all `[data-toolbar-item]` children of the container.
  - Calculate cumulative width of items left to right.
  - Reserve 40px for the overflow button.
  - When cumulative width + overflow button width exceeds `container.clientWidth`, stop counting.
  - Set `visibleCount` to the count of items that fit. If all fit, set to `Infinity`.
- Cleanup: disconnect observer on unmount.
- Important: Only observe width changes. Use a `prevWidth` ref to skip height-only changes and avoid the ResizeObserver infinite loop pitfall from research.

**2. useRovingTabindex.ts -- ARIA keyboard navigation:**
- Exports `useRovingTabindex(itemCount: number)` returning `{ activeIndex, getTabIndex, handleKeyDown }`.
- `activeIndex` tracks which item has `tabIndex={0}` (all others get `-1`).
- `getTabIndex(index: number)` returns `0` if `index === activeIndex`, else `-1`.
- `handleKeyDown(e: React.KeyboardEvent)` handles:
  - `ArrowRight`: move to next item (wrap around).
  - `ArrowLeft`: move to previous item (wrap around).
  - `Home`: jump to first item.
  - `End`: jump to last item.
  - All arrow/home/end keys call `e.preventDefault()`.
  - After updating activeIndex, focus the element at the new index using `e.currentTarget.querySelectorAll<HTMLElement>('[data-toolbar-item]')[newIndex]?.focus()`.
- Tab/Shift+Tab exits the toolbar naturally (no prevention).

**3. ToolbarButton.tsx:**
- Props: `{ action: ToolbarAction; tabIndex?: number }`.
- Renders a `<Button variant="ghost" size="sm">` with:
  - `onClick={() => action.execute()}`
  - `disabled={action.isLoading?.() ?? false}`
  - `aria-label={action.label}`
  - `data-toolbar-item` attribute (for overflow measurement + roving tabindex)
  - `tabIndex={tabIndex ?? 0}` (controlled by roving tabindex)
- Icon: `<action.icon className="w-4 h-4" />`. If `isLoading()` is true, add `animate-spin` to the icon.
- Wrap in `<ShortcutTooltip>` with the action's shortcut and label. If no shortcut, still wrap with empty shortcut string (tooltip shows label only).
- Import ShortcutTooltip from `../ui/ShortcutTooltip`, Button from `../ui/button`.

**4. ToolbarGroup.tsx:**
- Props: `{ children: ReactNode; showDivider?: boolean }`.
- Renders a flex container: `<div className="flex items-center gap-1">`.
- If `showDivider` is true, prepend a visual divider: `<div className="w-px h-5 bg-ctp-surface1 mx-1" />`.
- The divider is purely visual -- NOT a toolbar item, no `data-toolbar-item`.

**5. ToolbarOverflowMenu.tsx:**
- Props: `{ actions: ToolbarAction[]; count: number }`.
- Renders a dropdown trigger button with the `MoreHorizontal` icon (from lucide-react) and a count badge.
- The badge is a small circle showing `count` (the number of overflowed actions).
- Badge styling: `absolute -top-1 -right-1 bg-ctp-blue text-ctp-base text-[10px] rounded-full w-4 h-4 flex items-center justify-center`.
- The trigger button has `data-toolbar-item` so it participates in roving tabindex.
- On click, toggles a dropdown menu. The dropdown is absolutely positioned below the trigger.
- Each menu item shows `action.icon` + `action.label` + shortcut (if any).
- Clicking a menu item calls `action.execute()` and closes the menu.
- Close on click outside (use `useEffect` with document click listener).
- Close on Escape key.
- The dropdown has `role="menu"`, items have `role="menuitem"`.

**6. Toolbar.tsx -- Main composition component:**
- Subscribes to `useToolbarRegistry((s) => s.actions)` for reactivity.
- Subscribes to `usePreferencesStore((s) => s.settingsData.toolbar?.hiddenActions ?? [])` for user visibility preferences.
- Subscribes to `useRepositoryStore((s) => s.repoStatus)` to trigger re-evaluation of `when()` conditions.
- Calls `useToolbarOverflow()` for responsive collapse.
- Calls `useRovingTabindex(inlineCount)` for ARIA keyboard nav.

Rendering logic:
1. Get grouped actions: `useToolbarRegistry.getState().getGrouped()`.
2. Flatten into ordered list using `TOOLBAR_GROUP_ORDER`: for each group, filter out actions whose IDs are in `hiddenActions`.
3. Split into `inline` (first `visibleCount` items) and `overflowed` (the rest).
4. Render the container div with `role="toolbar"`, `aria-label="Main toolbar"`, `aria-orientation="horizontal"`, and the `onKeyDown` handler from roving tabindex.
5. For each group in `TOOLBAR_GROUP_ORDER`, render a `<ToolbarGroup>` with `showDivider` (true for all groups except the first that has visible actions). Inside each group, render `<ToolbarButton>` for each inline action in that group.
6. **Special case for `tb:theme-toggle`:** If the action ID is "tb:theme-toggle", render `<ThemeToggle />` instead of `<ToolbarButton>`. Import ThemeToggle from `../ui/ThemeToggle`.
7. If `overflowed.length > 0`, render `<ToolbarOverflowMenu>`.
8. The container ref goes on the outer div for ResizeObserver.

Important: The Toolbar component must NOT contain business logic. It reads from the registry and renders. All logic lives in the registered action execute/when/isLoading functions.
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify all 6 files exist. Verify Toolbar.tsx contains `role="toolbar"`, `ResizeObserver` usage (via hook), and `useToolbarRegistry` subscription.
  </verify>
  <done>
Six toolbar component files exist: Toolbar.tsx (main composition), ToolbarButton.tsx (individual action), ToolbarGroup.tsx (visual grouping with dividers), ToolbarOverflowMenu.tsx (overflow dropdown with count badge), useToolbarOverflow.ts (ResizeObserver hook), useRovingTabindex.ts (ARIA keyboard navigation). All follow WCAG 2.1 AA toolbar pattern requirements.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor Header.tsx to thin shell and wire toolbar registration</name>
  <files>
    src/components/Header.tsx
    src/App.tsx
  </files>
  <action>
**1. Refactor Header.tsx:**

Replace the current 417-line Header.tsx with a thin composition shell (~80-100 lines):

- Keep these structural components as direct children:
  - `<h1>` logo/title
  - `<RepoSwitcher>` (when repo is open)
  - `<BranchSwitcher>` (when repo is open)
  - `<ProcessNavigation>` (when repo is open)
  - Stash-and-switch confirmation dialog (stays with BranchSwitcher context)
- Add `<Toolbar />` as the right-side content.

The header layout:
```
[Logo] [RepoSwitcher] [BranchSwitcher] [ProcessNav] --- [Toolbar with overflow]
```

**What to REMOVE from Header.tsx:**
- All individual button JSX (settings, theme toggle, command palette, undo, refresh, sync, gitflow, repo-browser, changelog, close, reveal, clone, open) -- these are now in the registry and rendered by `<Toolbar>`.
- `handleRefreshAll` function -- moved to toolbar action execute.
- `handleOpenRepo` function -- moved to toolbar action execute.
- `handleClose` function -- moved to toolbar action execute.
- `handleUndo` function -- moved to toolbar action execute.
- All icon imports that are no longer used directly.
- `isRefreshing` state -- moved to toolbar action.
- `useCommandPaletteStore` import.
- `useUndoStore` import.
- `<SyncButtons />` rendering -- sync actions are now toolbar actions that call Tauri commands directly with toast feedback (registered in Plan 01).
- `SyncButtons` import.

**What to KEEP in Header.tsx:**
- `handleRepoSwitch` callback -- used by RepoSwitcher. This is structural navigation logic, not a toolbar action.
- `handleBranchSwitch` callback -- used by BranchSwitcher.
- `performBranchSwitch` callback.
- `handleStashAndSwitch` callback.
- `stashConfirmTarget` state and its dialog JSX.
- Imports for RepoSwitcher, BranchSwitcher, ProcessNavigation.
- Store subscriptions needed by the above: `useRepositoryStore`, `useBranchStore`, `useStashStore`, `useTagStore` (if needed for stash dialog), `useNavigationStore`, `useRecentRepos`.

**2. Remove SyncButtons from Header rendering (do NOT refactor SyncButtons.tsx itself):**

The SyncButtons component is no longer rendered in Header.tsx. The toolbar actions registered in Plan 01 (tb:fetch, tb:pull, tb:push) handle sync execution by calling Tauri commands directly with `Channel` + `toast` feedback. The `SyncButtons.tsx` and `SyncProgressDisplay` files are left in place untouched -- they are dead code after this change but can be cleaned up or re-used in a future polish pass if inline progress display (beyond toasts) is wanted. Do NOT modify `src/components/sync/SyncButtons.tsx`.

**3. Wire toolbar-actions.ts import in App.tsx:**

Add `import "./commands/toolbar-actions";` (or the correct relative path from App.tsx) near the top of `src/App.tsx` as a side-effect import. This ensures all core toolbar actions are registered before the first render. Place it alongside any existing side-effect imports (e.g., blade registrations). Check existing App.tsx for the import pattern used by other side-effect registrations and follow it.
  </action>
  <verify>
1. `npx tsc --noEmit` passes.
2. Run `npx vitest run` to ensure existing tests pass.
3. Header.tsx is under 120 lines.
4. Header.tsx contains `<Toolbar` component.
5. Header.tsx does NOT contain individual button JSX for settings, theme, command palette, undo, refresh, gitflow, repo-browser, changelog.
6. App.tsx imports toolbar-actions.ts.
  </verify>
  <done>
Header.tsx is refactored to a thin shell (~80-100 lines) that composes [Logo, RepoSwitcher, BranchSwitcher, ProcessNav, Toolbar]. All toolbar actions render from the registry via the Toolbar component. SyncButtons is no longer rendered (sync actions are toolbar actions with direct Tauri command calls). toolbar-actions.ts is imported in App.tsx for side-effect registration. Stash-and-switch dialog remains functional.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add ToolbarSettings panel to Settings blade</name>
  <files>
    src/blades/settings/components/ToolbarSettings.tsx
    src/blades/settings/SettingsBlade.tsx
  </files>
  <action>
**1. Create ToolbarSettings.tsx:**

Create `src/blades/settings/components/ToolbarSettings.tsx`:

- Import `useToolbarRegistry` from `../../../lib/toolbarRegistry`.
- Import preferences store to read/write `hiddenActions`.
- Display all registered toolbar actions as a list of toggle switches.
- Group actions by their `group` field with group headers.
- Each row shows: [checkbox/toggle] [icon] [label] [shortcut if any].
- Toggling an action adds/removes its `id` from `settingsData.toolbar.hiddenActions` via `updateSetting("toolbar", "hiddenActions", newArray)`.
- Style consistently with existing settings panels (see GeneralSettings.tsx, GitSettings.tsx for patterns).
- Use the existing `SettingsField` component from `./SettingsField` if it provides the right layout.
- Add a "Reset to defaults" link/button that clears `hiddenActions` back to `[]`.

**2. Add toolbar tab to SettingsBlade.tsx:**

Add a new tab entry to the `settingsTabs` array:
```typescript
{
  id: "toolbar",
  label: "Toolbar",
  icon: <LayoutGrid className="w-4 h-4" />,  // or PanelTop from lucide-react
  panel: <ToolbarSettings />,
},
```

Import `LayoutGrid` (or `PanelTop`) from lucide-react and `ToolbarSettings` from `./components/ToolbarSettings`.

Place the toolbar tab after "appearance" in the settings tabs list.

Note: SettingsBlade.tsx currently imports `useSettingsStore` from `../../stores/settings` (a re-export shim). Follow the same import pattern for consistency, or use the direct import from `../../stores/domain/preferences` if that's the modern pattern.
  </action>
  <verify>
1. `npx tsc --noEmit` passes.
2. `src/blades/settings/components/ToolbarSettings.tsx` exists and imports `useToolbarRegistry`.
3. `src/blades/settings/SettingsBlade.tsx` has a "toolbar" tab in settingsTabs.
4. The ToolbarSettings component reads from the toolbar registry and writes to the preferences store.
  </verify>
  <done>
ToolbarSettings panel exists in the Settings blade with toggles for showing/hiding each toolbar action. The panel groups actions by intent group and shows icon + label + shortcut. Toggling persists to the Tauri store via the settings slice. A "Toolbar" tab appears in the settings sidebar.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero new TypeScript errors
2. `npx vitest run` -- all existing tests pass (no regressions)
3. Visual verification: toolbar renders grouped buttons with dividers between groups
4. Narrow the window: lower-priority buttons collapse into overflow menu with count badge
5. Open/close a repo: repo-specific buttons appear/disappear
6. Open Settings > Toolbar: toggles work, hiding a toolbar button persists across app restart
7. Keyboard: Arrow Left/Right moves focus between toolbar buttons, Home/End jump to first/last
8. Header.tsx is under 120 lines, contains no hardcoded toolbar buttons
9. ThemeToggle renders as its compound widget (not a single icon button)
</verification>

<success_criteria>
- Toolbar visually groups actions by intent with dividers (TB-01)
- Data-driven registry replaces hardcoded buttons (TB-02)
- Overflow menu collapses lower-priority actions with count badge (TB-03)
- All buttons use icon-only rendering with ShortcutTooltip (TB-04)
- Repo-specific actions hide/show based on repository context (TB-05)
- ToolbarSettings panel persists show/hide preferences (TB-06)
- WCAG 2.1 AA: role="toolbar", roving tabindex, aria-labels on all buttons
- Header.tsx is a thin shell under 120 lines
</success_criteria>

<output>
After completion, create `.planning/phases/32-toolbar-overhaul/32-02-SUMMARY.md`
</output>
