---
phase: 32-toolbar-overhaul
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/toolbarRegistry.ts
  - src/commands/toolbar-actions.ts
  - src/stores/domain/preferences/settings.slice.ts
autonomous: true

must_haves:
  truths:
    - "ToolbarRegistry Zustand store exists with register/unregister/unregisterBySource/getGrouped methods"
    - "All 16 Header.tsx toolbar actions are registered as ToolbarAction entries with correct group and priority"
    - "Settings slice has a toolbar.hiddenActions array persisted through the Tauri store"
    - "Extension-contributed actions can be registered and bulk-removed via unregisterBySource"
  artifacts:
    - path: "src/lib/toolbarRegistry.ts"
      provides: "ToolbarAction type, ToolbarGroup type, useToolbarRegistry Zustand store"
      exports: ["ToolbarAction", "ToolbarGroup", "useToolbarRegistry", "TOOLBAR_GROUP_ORDER"]
    - path: "src/commands/toolbar-actions.ts"
      provides: "All core toolbar action registrations"
      contains: "tb:settings"
    - path: "src/stores/domain/preferences/settings.slice.ts"
      provides: "ToolbarSettings type with hiddenActions, extended Settings interface"
      contains: "toolbar"
  key_links:
    - from: "src/commands/toolbar-actions.ts"
      to: "src/lib/toolbarRegistry.ts"
      via: "useToolbarRegistry.getState().register()"
      pattern: "register\\("
    - from: "src/stores/domain/preferences/settings.slice.ts"
      to: "src/lib/store.ts"
      via: "getStore() persistence"
      pattern: "toolbar"
---

<objective>
Create the ToolbarRegistry Zustand store, register all 16 core toolbar actions from Header.tsx, and extend the settings slice with toolbar visibility preferences.

Purpose: Establish the data-driven foundation that Plan 02 will render. The registry must be designed for Phase 33 extension contributions from day one -- extensions will use the same register/unregister API with namespaced IDs and source tracking.

Output: Three files -- the registry store, the core action registrations, and the extended settings slice.
</objective>

<execution_context>
@C:/Users/matrayp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matrayp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-toolbar-overhaul/32-RESEARCH.md
@src/lib/commandRegistry.ts
@src/lib/bladeRegistry.ts
@src/components/Header.tsx
@src/components/sync/SyncButtons.tsx
@src/components/ui/ThemeToggle.tsx
@src/stores/domain/preferences/settings.slice.ts
@src/stores/domain/preferences/index.ts
@src/stores/domain/preferences/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ToolbarRegistry Zustand store with extensibility-first design</name>
  <files>src/lib/toolbarRegistry.ts</files>
  <action>
Create `src/lib/toolbarRegistry.ts` with these exports:

**ToolbarGroup type:**
```typescript
export type ToolbarGroup = "navigation" | "git-actions" | "views" | "app";
```
Use a union type (not enum) so Phase 33 extensions can declare custom groups by extending the type.

**TOOLBAR_GROUP_ORDER constant:**
```typescript
export const TOOLBAR_GROUP_ORDER: ToolbarGroup[] = ["navigation", "git-actions", "views", "app"];
```
Defines the visual rendering order of groups in the toolbar (left to right).

**ToolbarAction interface:**
```typescript
export interface ToolbarAction {
  id: string;                      // Unique ID. Core: "tb:{name}". Extensions: "ext:{extId}:{name}"
  label: string;                   // Display label for tooltip + overflow menu text
  icon: LucideIcon;                // Icon component for icon-only rendering
  group: ToolbarGroup;             // Visual group assignment
  priority: number;                // Higher = more important = collapses last in overflow
  shortcut?: string;               // Keyboard shortcut (react-hotkeys-hook format, e.g. "mod+o")
  when?: () => boolean;            // Visibility condition. Reads store .getState() at eval time (NOT closures)
  execute: () => void | Promise<void>;  // Action handler
  isLoading?: () => boolean;       // Loading/pending state indicator
  source?: string;                 // "core" for built-in, "ext:{extId}" for extensions
}
```

**ToolbarRegistryState interface and Zustand store:**
```typescript
interface ToolbarRegistryState {
  actions: Map<string, ToolbarAction>;
  register: (action: ToolbarAction) => void;
  registerMany: (actions: ToolbarAction[]) => void;   // Batch registration for core actions
  unregister: (id: string) => void;
  unregisterBySource: (source: string) => void;        // Extension cleanup
  getGrouped: () => Record<ToolbarGroup, ToolbarAction[]>;
}
```

Use `create()` with `devtools` middleware (enabled only in DEV, name: "toolbar-registry").

**register:** Creates new Map copy, sets action (overwrite if exists), returns new state.
**registerMany:** Same pattern but batches all actions into a single state update.
**unregister:** Creates new Map copy, deletes by id.
**unregisterBySource:** Creates new Map copy, iterates and deletes all actions where `action.source === source`. Critical for Phase 33 extension deactivation cleanup.
**getGrouped:** Returns `Record<ToolbarGroup, ToolbarAction[]>`. Iterates `actions.values()`, skips actions where `action.when?.() === false`, groups by `action.group`, sorts each group by priority descending (higher priority first). Uses `TOOLBAR_GROUP_ORDER` keys for the result shape.

Important implementation notes:
- The `getGrouped` method should use `get().actions` to read fresh state.
- Do NOT use `subscribeWithSelector` -- the consumer (Toolbar component) will subscribe to `actions` Map reference changes.
- Export `useToolbarRegistry` as the hook and also export the store for non-React access (e.g., extension API calling `useToolbarRegistry.getState().register()`).
- Do NOT register with the store registry for reset -- toolbar actions survive repo switches (like preferences). Repo-specific actions use `when()` conditions to hide themselves, not deregistration.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify type correctness. Grep the file for all 6 exported symbols: ToolbarAction, ToolbarGroup, useToolbarRegistry, TOOLBAR_GROUP_ORDER, ToolbarRegistryState (if exported), registerMany.
  </verify>
  <done>
`src/lib/toolbarRegistry.ts` exists with a Zustand store exposing register, registerMany, unregister, unregisterBySource, and getGrouped. The ToolbarAction interface includes all fields needed for both core actions and Phase 33 extension contributions (id, label, icon, group, priority, shortcut, when, execute, isLoading, source).
  </done>
</task>

<task type="auto">
  <name>Task 2: Register all 16 core toolbar actions from Header.tsx inventory</name>
  <files>src/commands/toolbar-actions.ts</files>
  <action>
Create `src/commands/toolbar-actions.ts` that registers all toolbar actions from the Header.tsx inventory. This file is a barrel of side-effect registrations -- importing it registers all core actions.

Use `useToolbarRegistry.getState().registerMany([...])` for a single batch registration.

Register these 16 actions (all with `source: "core"`):

**App group:**
1. `tb:open-repo` -- label "Open Repository", icon FolderOpen, group "app", priority 100, shortcut "mod+o". Execute: dispatch `CustomEvent("open-repository-dialog")` on document. No `when` (always visible).
2. `tb:settings` -- label "Settings", icon Settings, group "app", priority 90, shortcut "mod+,". Execute: `openBlade("settings", {} as Record<string, never>)` using the blade opener from `../hooks/useBladeNavigation` -- BUT this is a module-level registration so we cannot use hooks. Instead, import `getNavigationActor` from `../machines/navigation/context` and send a PUSH_BLADE event, OR use the `executeCommand("open-settings")` pattern from commandRegistry if it exists. Check `src/commands/` for an existing settings command first. If none exists, use: `getNavigationActor().send({ type: "PUSH_BLADE", blade: { type: "settings", props: {} } })`. No `when`.
3. `tb:command-palette` -- label "Command Palette", icon Search, group "app", priority 80, shortcut "mod+shift+P". Execute: `useCommandPaletteStore.getState().togglePalette()`. No `when`.
4. `tb:theme-toggle` -- label "Theme", icon Palette (from lucide-react), group "app", priority 70. No shortcut. This is a SPECIAL action -- it will be rendered as the ThemeToggle widget component, not a standard button. Add a custom property `widget: "theme-toggle"` by extending the ToolbarAction type OR by adding a `render` field. **Decision: Add an optional `component?: ComponentType` field to ToolbarAction.** When present, the Toolbar renders this component instead of the standard ToolbarButton. Set `component: ThemeToggle`. Execute is a no-op (`() => {}`). No `when`.

Wait -- adding `component` to ToolbarAction changes the type definition from Task 1. Instead, keep ThemeToggle as a special case handled in the Toolbar rendering. Register it with a marker: set `id: "tb:theme-toggle"` and the Toolbar component will check for this ID and render ThemeToggle instead of ToolbarButton. The execute function is a no-op. This avoids polluting the generic ToolbarAction interface with React component references.

**Git Actions group (all require repo):**
5. `tb:undo` -- label "Undo", icon Undo2, group "git-actions", priority 80. Execute: delegate to undo logic (import `useUndoStore`, call `getState()` to check `canUndo`, confirm with `window.confirm`, call `performUndo`, invalidate queries). `when: () => { const s = useUndoStore.getState(); return !!useRepositoryStore.getState().repoStatus && !!s.undoInfo?.canUndo; }`. `isLoading: () => useUndoStore.getState().undoIsUndoing`.
6. `tb:refresh-all` -- label "Refresh All", icon RefreshCw, group "git-actions", priority 70. Execute: call `loadBranches()`, `loadStashes()`, `loadTags()`, `loadUndoInfo()` via their store `.getState()` methods. `when: () => !!useRepositoryStore.getState().repoStatus`. For `isLoading`, read the loading states from each store.
7. `tb:fetch` -- label "Fetch", icon CloudDownload, group "git-actions", priority 60, shortcut "mod+shift+F". Execute: delegate to the existing fetch command from commandRegistry via `executeCommand("fetch")` OR implement directly. Since SyncButtons uses `commands.fetchFromRemote` with a Channel, this is complex. For now, dispatch a custom event `document.dispatchEvent(new CustomEvent("toolbar-fetch"))` that SyncButtons (kept as the sync action handler) will listen to, OR directly import and call the Tauri command. **Best approach:** Keep the SyncButtons component as a non-visible "sync controller" that provides mutation functions, OR inline the Tauri command calls. Given the complexity of progress channels, the simplest approach is: the `execute` function for fetch/pull/push will dispatch custom events that a SyncController component listens to. Register with `when: () => !!useRepositoryStore.getState().repoStatus`.
8. `tb:pull` -- label "Pull", icon ArrowDown, group "git-actions", priority 50, shortcut "mod+shift+L". Same pattern as fetch.
9. `tb:push` -- label "Push", icon ArrowUp, group "git-actions", priority 40, shortcut "mod+shift+U". Same pattern as fetch.

**Actually, re-reading the current SyncButtons code:** It uses React Query mutations with a progress channel. The mutations need to live in a React component context for `useQueryClient()` and `useMutation()`. The toolbar actions just need to trigger these mutations. The cleanest approach: keep SyncButtons as a headless component that registers its own toolbar actions ON MOUNT (using `useEffect`) and unregisters on unmount. This way the mutations and progress state stay in React context.

**Revised approach for sync actions (tb:fetch, tb:pull, tb:push):** Do NOT register these in `toolbar-actions.ts`. Instead, SyncButtons will be refactored in Plan 02 to register its own actions via `useEffect`. For now in this file, register placeholder entries that will be overridden by SyncButtons at runtime. Mark them with a comment `// Overridden by SyncButtons component at mount`.

Actually, this is getting complex. **Simplest correct approach:** Register tb:fetch, tb:pull, tb:push with simple execute functions that call the Tauri commands directly (no progress channel -- the progress toast is nice-to-have but not required for the registry migration). The SyncProgressDisplay can be preserved as a separate visual element. Use:

```typescript
import { commands as tauriCommands } from "../bindings";
import { Channel } from "@tauri-apps/api/core";

execute: async () => {
  const channel = new Channel();
  await tauriCommands.fetchFromRemote("origin", channel);
  toast.success("Fetched from origin");
}
```

With error handling via try/catch + toast.error. The progress channel is created but not wired to UI in this plan (Plan 02 will handle progress display). Use `when: () => !!useRepositoryStore.getState().repoStatus`.

**Views group (all require repo):**
10. `tb:gitflow-guide` -- label "Gitflow Guide", icon GitBranch, group "views", priority 50. Execute: push gitflow-cheatsheet blade. `when: () => !!useRepositoryStore.getState().repoStatus`.
11. `tb:repo-browser` -- label "Browse Repository", icon FolderTree, group "views", priority 40. Execute: push repo-browser blade. `when: () => !!useRepositoryStore.getState().repoStatus`.
12. `tb:changelog` -- label "Changelog", icon FileText, group "views", priority 30. Execute: push changelog blade. `when: () => !!useRepositoryStore.getState().repoStatus`.

**Navigation group (context-dependent):**
13. `tb:close-repo` -- label "Close Repository", icon X (from lucide-react), group "navigation", priority 60. Execute: `useRepositoryStore.getState().closeRepository()`. `when: () => !!useRepositoryStore.getState().repoStatus`.
14. `tb:reveal-in-finder` -- label "Reveal in File Manager", icon FolderOpen, group "navigation", priority 50. Execute: dynamic import `@tauri-apps/plugin-opener`, call `revealItemInDir(useRepositoryStore.getState().repoStatus!.repoPath)`. `when: () => !!useRepositoryStore.getState().repoStatus`.
15. `tb:clone-repo` -- label "Clone Repository", icon GitFork, group "navigation", priority 40. Execute: dispatch `CustomEvent("clone-repository-dialog")`. `when: () => !useRepositoryStore.getState().repoStatus` (visible when NO repo is open).

**Note on blade pushing from module scope:** For actions that open blades, use `getNavigationActor()` from `../machines/navigation/context`:
```typescript
import { getNavigationActor } from "../machines/navigation/context";
getNavigationActor().send({ type: "PUSH_BLADE", blade: { type: "settings", props: {} } });
```

Import all needed stores at the top of the file. All `when()` and `execute()` functions MUST use `.getState()` to read fresh state -- never close over values.

End the file by importing it in a comment explaining that this file must be imported at app startup for side-effect registration (e.g., imported from App.tsx or main.tsx).
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify that the file registers 15-16 actions by counting `id:` occurrences. Verify all 4 groups are represented.
  </verify>
  <done>
`src/commands/toolbar-actions.ts` registers all toolbar actions from the Header.tsx inventory. Each action has an id, label, icon, group, priority, and execute function. Repo-specific actions have `when()` conditions that read `useRepositoryStore.getState().repoStatus`. ThemeToggle is registered with `id: "tb:theme-toggle"` as a marker for special rendering.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend settings slice with toolbar visibility preferences</name>
  <files>src/stores/domain/preferences/settings.slice.ts</files>
  <action>
Extend the existing `settings.slice.ts` to add toolbar visibility preferences:

1. **Add ToolbarSettings interface:**
```typescript
export interface ToolbarSettings {
  /** Action IDs the user has explicitly hidden from the toolbar */
  hiddenActions: string[];
}
```

2. **Add `toolbar` to Settings interface:**
```typescript
export interface Settings {
  general: GeneralSettings;
  git: GitSettings;
  integrations: IntegrationsSettings;
  toolbar: ToolbarSettings;  // NEW
}
```

3. **Update defaultSettings:**
```typescript
const defaultSettings: Settings = {
  // ...existing...
  toolbar: {
    hiddenActions: [],
  },
};
```

4. **Update mergeSettings function** to include toolbar:
```typescript
function mergeSettings(saved: Partial<Settings>): Settings {
  return {
    general: { ...defaultSettings.general, ...saved.general },
    git: { ...defaultSettings.git, ...saved.git },
    integrations: { ...defaultSettings.integrations, ...saved.integrations },
    toolbar: { ...defaultSettings.toolbar, ...saved.toolbar },
  };
}
```

5. **Add "toolbar" to SettingsCategory type:**
```typescript
export type SettingsCategory =
  | "general"
  | "git"
  | "appearance"
  | "integrations"
  | "review"
  | "toolbar";   // NEW
```

The existing `updateSetting` generic function already handles any `keyof Settings` category, so it will automatically work for `toolbar.hiddenActions` updates without code changes.

Important: Do NOT change any existing settings behavior. This is purely additive.
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify the file contains "toolbar" as a SettingsCategory. Verify `ToolbarSettings` is exported. Verify `mergeSettings` handles `saved.toolbar`.
  </verify>
  <done>
The settings slice has a `ToolbarSettings` type with `hiddenActions: string[]`, added to the `Settings` interface with proper defaults and merge logic. The `SettingsCategory` union includes "toolbar". Preferences persist through the existing Tauri store mechanism.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors
2. `src/lib/toolbarRegistry.ts` exports ToolbarAction, ToolbarGroup, useToolbarRegistry, TOOLBAR_GROUP_ORDER
3. `src/commands/toolbar-actions.ts` registers 15+ actions covering all 4 groups
4. `src/stores/domain/preferences/settings.slice.ts` has ToolbarSettings with hiddenActions
5. No existing functionality is broken -- Header.tsx is unchanged in this plan
</verification>

<success_criteria>
- ToolbarRegistry Zustand store is functional with register/unregister/unregisterBySource/getGrouped
- All Header.tsx buttons have corresponding ToolbarAction registrations with correct groups, priorities, and when() conditions
- Settings slice supports toolbar.hiddenActions persistence
- TypeScript compiles without errors
- Existing app behavior is completely unchanged (Header.tsx not modified yet)
</success_criteria>

<output>
After completion, create `.planning/phases/32-toolbar-overhaul/32-01-SUMMARY.md`
</output>
