---
phase: 32-toolbar-overhaul
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/toolbarRegistry.ts
  - src/commands/toolbar-actions.ts
  - src/stores/domain/preferences/settings.slice.ts
autonomous: true

must_haves:
  truths:
    - "ToolbarRegistry Zustand store exists with register/unregister/unregisterBySource/getGrouped methods"
    - "All 16 Header.tsx toolbar actions are registered as ToolbarAction entries with correct group and priority"
    - "Settings slice has a toolbar.hiddenActions array persisted through the Tauri store"
    - "Extension-contributed actions can be registered and bulk-removed via unregisterBySource"
  artifacts:
    - path: "src/lib/toolbarRegistry.ts"
      provides: "ToolbarAction type, ToolbarGroup type, useToolbarRegistry Zustand store"
      exports: ["ToolbarAction", "ToolbarGroup", "useToolbarRegistry", "TOOLBAR_GROUP_ORDER"]
    - path: "src/commands/toolbar-actions.ts"
      provides: "All core toolbar action registrations"
      contains: "tb:settings"
    - path: "src/stores/domain/preferences/settings.slice.ts"
      provides: "ToolbarSettings type with hiddenActions, extended Settings interface"
      contains: "toolbar"
  key_links:
    - from: "src/commands/toolbar-actions.ts"
      to: "src/lib/toolbarRegistry.ts"
      via: "useToolbarRegistry.getState().register()"
      pattern: "register\\("
    - from: "src/stores/domain/preferences/settings.slice.ts"
      to: "src/lib/store.ts"
      via: "getStore() persistence"
      pattern: "toolbar"
---

<objective>
Create the ToolbarRegistry Zustand store, register all 16 core toolbar actions from Header.tsx, and extend the settings slice with toolbar visibility preferences.

Purpose: Establish the data-driven foundation that Plan 02 will render. The registry must be designed for Phase 33 extension contributions from day one -- extensions will use the same register/unregister API with namespaced IDs and source tracking.

Output: Three files -- the registry store, the core action registrations, and the extended settings slice.
</objective>

<execution_context>
@C:/Users/matrayp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matrayp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-toolbar-overhaul/32-RESEARCH.md
@src/lib/commandRegistry.ts
@src/lib/bladeRegistry.ts
@src/components/Header.tsx
@src/components/sync/SyncButtons.tsx
@src/components/ui/ThemeToggle.tsx
@src/stores/domain/preferences/settings.slice.ts
@src/stores/domain/preferences/index.ts
@src/stores/domain/preferences/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ToolbarRegistry Zustand store with extensibility-first design</name>
  <files>src/lib/toolbarRegistry.ts</files>
  <action>
Create `src/lib/toolbarRegistry.ts` with these exports:

**ToolbarGroup type:**
```typescript
export type ToolbarGroup = "navigation" | "git-actions" | "views" | "app";
```
Use a union type (not enum) so Phase 33 extensions can declare custom groups by extending the type.

**TOOLBAR_GROUP_ORDER constant:**
```typescript
export const TOOLBAR_GROUP_ORDER: ToolbarGroup[] = ["navigation", "git-actions", "views", "app"];
```
Defines the visual rendering order of groups in the toolbar (left to right).

**ToolbarAction interface:**
```typescript
export interface ToolbarAction {
  id: string;                      // Unique ID. Core: "tb:{name}". Extensions: "ext:{extId}:{name}"
  label: string;                   // Display label for tooltip + overflow menu text
  icon: LucideIcon;                // Icon component for icon-only rendering
  group: ToolbarGroup;             // Visual group assignment
  priority: number;                // Higher = more important = collapses last in overflow
  shortcut?: string;               // Keyboard shortcut (react-hotkeys-hook format, e.g. "mod+o")
  when?: () => boolean;            // Visibility condition. Reads store .getState() at eval time (NOT closures)
  execute: () => void | Promise<void>;  // Action handler
  isLoading?: () => boolean;       // Loading/pending state indicator
  source?: string;                 // "core" for built-in, "ext:{extId}" for extensions
}
```

**ToolbarRegistryState interface and Zustand store:**
```typescript
interface ToolbarRegistryState {
  actions: Map<string, ToolbarAction>;
  register: (action: ToolbarAction) => void;
  registerMany: (actions: ToolbarAction[]) => void;   // Batch registration for core actions
  unregister: (id: string) => void;
  unregisterBySource: (source: string) => void;        // Extension cleanup
  getGrouped: () => Record<ToolbarGroup, ToolbarAction[]>;
}
```

Use `create()` with `devtools` middleware (enabled only in DEV, name: "toolbar-registry").

**register:** Creates new Map copy, sets action (overwrite if exists), returns new state.
**registerMany:** Same pattern but batches all actions into a single state update.
**unregister:** Creates new Map copy, deletes by id.
**unregisterBySource:** Creates new Map copy, iterates and deletes all actions where `action.source === source`. Critical for Phase 33 extension deactivation cleanup.
**getGrouped:** Returns `Record<ToolbarGroup, ToolbarAction[]>`. Iterates `actions.values()`, skips actions where `action.when?.() === false`, groups by `action.group`, sorts each group by priority descending (higher priority first). Uses `TOOLBAR_GROUP_ORDER` keys for the result shape.

Important implementation notes:
- The `getGrouped` method should use `get().actions` to read fresh state.
- Do NOT use `subscribeWithSelector` -- the consumer (Toolbar component) will subscribe to `actions` Map reference changes.
- Export `useToolbarRegistry` as the hook and also export the store for non-React access (e.g., extension API calling `useToolbarRegistry.getState().register()`).
- Do NOT register with the store registry for reset -- toolbar actions survive repo switches (like preferences). Repo-specific actions use `when()` conditions to hide themselves, not deregistration.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify type correctness. Grep the file for all 6 exported symbols: ToolbarAction, ToolbarGroup, useToolbarRegistry, TOOLBAR_GROUP_ORDER, ToolbarRegistryState (if exported), registerMany.
  </verify>
  <done>
`src/lib/toolbarRegistry.ts` exists with a Zustand store exposing register, registerMany, unregister, unregisterBySource, and getGrouped. The ToolbarAction interface includes all fields needed for both core actions and Phase 33 extension contributions (id, label, icon, group, priority, shortcut, when, execute, isLoading, source).
  </done>
</task>

<task type="auto">
  <name>Task 2: Register all 16 core toolbar actions from Header.tsx inventory</name>
  <files>src/commands/toolbar-actions.ts</files>
  <action>
Create `src/commands/toolbar-actions.ts` that registers all toolbar actions from the Header.tsx inventory. This file is a barrel of side-effect registrations -- importing it registers all core actions.

Use `useToolbarRegistry.getState().registerMany([...])` for a single batch registration.

Import all needed stores at the top of the file. All `when()` and `execute()` functions MUST use `.getState()` to read fresh state -- never close over values.

Register these 15 actions (all with `source: "core"`):

**App group:**
1. `tb:open-repo` -- label "Open Repository", icon FolderOpen, group "app", priority 100, shortcut "mod+o". Execute: dispatch `CustomEvent("open-repository-dialog")` on document. No `when` (always visible).
2. `tb:settings` -- label "Settings", icon Settings, group "app", priority 90, shortcut "mod+,". Execute: `openBlade("settings", {} as Record<string, never>)` imported from `../lib/bladeOpener`. This is the existing non-React blade opener used by `src/commands/settings.ts` -- safe to call from module scope. No `when`.
3. `tb:command-palette` -- label "Command Palette", icon Search, group "app", priority 80, shortcut "mod+shift+P". Execute: `useCommandPaletteStore.getState().togglePalette()`. No `when`.
4. `tb:theme-toggle` -- label "Theme", icon Palette (from lucide-react), group "app", priority 70. No shortcut. Execute is a no-op (`() => {}`). Register with `id: "tb:theme-toggle"` as a marker -- the Toolbar component (Plan 02) will check for this ID and render the `<ThemeToggle />` widget instead of a standard ToolbarButton. Do NOT add a `component` field to the ToolbarAction interface; this is a one-off special case handled in the renderer. No `when`.

**Git Actions group (all require repo -- use `when: () => !!useRepositoryStore.getState().repoStatus`):**
5. `tb:undo` -- label "Undo", icon Undo2, group "git-actions", priority 80. Execute: delegate to undo logic (import `useUndoStore`, call `getState()` to check `canUndo`, confirm with `window.confirm`, call `performUndo`, invalidate queries). `when: () => !!useRepositoryStore.getState().repoStatus && !!useUndoStore.getState().undoInfo?.canUndo`. `isLoading: () => useUndoStore.getState().undoIsUndoing`.
6. `tb:refresh-all` -- label "Refresh All", icon RefreshCw, group "git-actions", priority 70. Execute: call `loadBranches()`, `loadStashes()`, `loadTags()`, `loadUndoInfo()` via their store `.getState()` methods. For `isLoading`, read the loading states from each store.
7. `tb:fetch` -- label "Fetch", icon CloudDownload, group "git-actions", priority 60, shortcut "mod+shift+F". Execute: call `commands.fetchFromRemote("origin", new Channel())` from `../bindings` with a `Channel` from `@tauri-apps/api/core`. Wrap in try/catch, call `toast.success("Fetched from origin")` on success, `toast.error(...)` on failure. The progress channel is created but not wired to UI in this plan (toast feedback is sufficient). `isLoading`: track via a module-level `syncLoading` flag or a small Zustand atom.
8. `tb:pull` -- label "Pull", icon ArrowDown, group "git-actions", priority 50, shortcut "mod+shift+L". Same pattern as fetch: `commands.pullFromRemote("origin", new Channel())` with try/catch + toast.
9. `tb:push` -- label "Push", icon ArrowUp, group "git-actions", priority 40, shortcut "mod+shift+U". Same pattern as fetch: `commands.pushToRemote("origin", new Channel())` with try/catch + toast.

**Views group (all require repo):**
10. `tb:gitflow-guide` -- label "Gitflow Guide", icon GitBranch, group "views", priority 50. Execute: `openBlade("gitflow-cheatsheet", {} as Record<string, never>)`. `when: () => !!useRepositoryStore.getState().repoStatus`.
11. `tb:repo-browser` -- label "Browse Repository", icon FolderTree, group "views", priority 40. Execute: `openBlade("repo-browser", {} as Record<string, never>)`. `when: () => !!useRepositoryStore.getState().repoStatus`.
12. `tb:changelog` -- label "Changelog", icon FileText, group "views", priority 30. Execute: `openBlade("changelog", {} as Record<string, never>)`. `when: () => !!useRepositoryStore.getState().repoStatus`.

**Navigation group (context-dependent):**
13. `tb:close-repo` -- label "Close Repository", icon X (from lucide-react), group "navigation", priority 60. Execute: `useRepositoryStore.getState().closeRepository()`. `when: () => !!useRepositoryStore.getState().repoStatus`.
14. `tb:reveal-in-finder` -- label "Reveal in File Manager", icon FolderOpen, group "navigation", priority 50. Execute: dynamic import `@tauri-apps/plugin-opener`, call `revealItemInDir(useRepositoryStore.getState().repoStatus!.repoPath)`. `when: () => !!useRepositoryStore.getState().repoStatus`.
15. `tb:clone-repo` -- label "Clone Repository", icon GitFork, group "navigation", priority 40. Execute: dispatch `CustomEvent("clone-repository-dialog")`. `when: () => !useRepositoryStore.getState().repoStatus` (visible when NO repo is open).

End the file with a comment explaining that this file must be imported at app startup for side-effect registration (e.g., imported from App.tsx or main.tsx).
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify that the file registers 15 actions by counting `id:` occurrences. Verify all 4 groups are represented.
  </verify>
  <done>
`src/commands/toolbar-actions.ts` registers all toolbar actions from the Header.tsx inventory. Each action has an id, label, icon, group, priority, and execute function. Repo-specific actions have `when()` conditions that read `useRepositoryStore.getState().repoStatus`. ThemeToggle is registered with `id: "tb:theme-toggle"` as a marker for special rendering.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend settings slice with toolbar visibility preferences</name>
  <files>src/stores/domain/preferences/settings.slice.ts</files>
  <action>
Extend the existing `settings.slice.ts` to add toolbar visibility preferences:

1. **Add ToolbarSettings interface:**
```typescript
export interface ToolbarSettings {
  /** Action IDs the user has explicitly hidden from the toolbar */
  hiddenActions: string[];
}
```

2. **Add `toolbar` to Settings interface:**
```typescript
export interface Settings {
  general: GeneralSettings;
  git: GitSettings;
  integrations: IntegrationsSettings;
  toolbar: ToolbarSettings;  // NEW
}
```

3. **Update defaultSettings:**
```typescript
const defaultSettings: Settings = {
  // ...existing...
  toolbar: {
    hiddenActions: [],
  },
};
```

4. **Update mergeSettings function** to include toolbar:
```typescript
function mergeSettings(saved: Partial<Settings>): Settings {
  return {
    general: { ...defaultSettings.general, ...saved.general },
    git: { ...defaultSettings.git, ...saved.git },
    integrations: { ...defaultSettings.integrations, ...saved.integrations },
    toolbar: { ...defaultSettings.toolbar, ...saved.toolbar },
  };
}
```

5. **Add "toolbar" to SettingsCategory type:**
```typescript
export type SettingsCategory =
  | "general"
  | "git"
  | "appearance"
  | "integrations"
  | "review"
  | "toolbar";   // NEW
```

The existing `updateSetting` generic function already handles any `keyof Settings` category, so it will automatically work for `toolbar.hiddenActions` updates without code changes.

Important: Do NOT change any existing settings behavior. This is purely additive.
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify the file contains "toolbar" as a SettingsCategory. Verify `ToolbarSettings` is exported. Verify `mergeSettings` handles `saved.toolbar`.
  </verify>
  <done>
The settings slice has a `ToolbarSettings` type with `hiddenActions: string[]`, added to the `Settings` interface with proper defaults and merge logic. The `SettingsCategory` union includes "toolbar". Preferences persist through the existing Tauri store mechanism.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors
2. `src/lib/toolbarRegistry.ts` exports ToolbarAction, ToolbarGroup, useToolbarRegistry, TOOLBAR_GROUP_ORDER
3. `src/commands/toolbar-actions.ts` registers 15 actions covering all 4 groups
4. `src/stores/domain/preferences/settings.slice.ts` has ToolbarSettings with hiddenActions
5. No existing functionality is broken -- Header.tsx is unchanged in this plan
</verification>

<success_criteria>
- ToolbarRegistry Zustand store is functional with register/unregister/unregisterBySource/getGrouped
- All Header.tsx buttons have corresponding ToolbarAction registrations with correct groups, priorities, and when() conditions
- Settings slice supports toolbar.hiddenActions persistence
- TypeScript compiles without errors
- Existing app behavior is completely unchanged (Header.tsx not modified yet)
</success_criteria>

<output>
After completion, create `.planning/phases/32-toolbar-overhaul/32-01-SUMMARY.md`
</output>
