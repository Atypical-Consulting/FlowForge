---
phase: 23-branch-management
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/branch.rs
  - src-tauri/src/lib.rs
  - src/bindings.ts
autonomous: true

must_haves:
  truths:
    - "Rust backend provides get_recent_checkouts command returning branch names with timestamps from reflog"
    - "Rust backend provides batch_delete_branches command that deletes multiple branches and reports per-branch success/failure"
    - "Both new commands are registered in lib.rs and have auto-generated TypeScript bindings"
  artifacts:
    - path: "src-tauri/src/git/branch.rs"
      provides: "get_recent_checkouts and batch_delete_branches Tauri commands"
      contains: "pub async fn get_recent_checkouts"
    - path: "src-tauri/src/lib.rs"
      provides: "New commands registered in collect_commands!"
      contains: "get_recent_checkouts"
    - path: "src/bindings.ts"
      provides: "Auto-generated TypeScript types for RecentCheckout and BatchDeleteResult"
      contains: "getRecentCheckouts|batchDeleteBranches"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/git/branch.rs"
      via: "use branch::{get_recent_checkouts, batch_delete_branches}"
      pattern: "get_recent_checkouts.*batch_delete_branches"
---

<objective>
Add Rust backend commands for reflog-based recent branch tracking and batch branch deletion.

Purpose: BRANCH-01 requires showing recently checked-out branches. The git reflog is the authoritative source because it captures ALL checkouts (CLI, GUI, other tools), not just app-mediated ones. BRANCH-04 requires bulk branch deletion with error aggregation. A single Rust command that processes all deletions avoids N IPC round-trips and N branch-list reloads.

Output: Two new Tauri commands (`get_recent_checkouts`, `batch_delete_branches`) with associated Rust types, registered in lib.rs, with auto-generated TypeScript bindings.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src-tauri/src/git/branch.rs (existing branch commands)
@src-tauri/src/git/error.rs (GitError enum)
@src-tauri/src/git/repository.rs (RepositoryState)
@src-tauri/src/lib.rs (command registration)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_recent_checkouts and batch_delete_branches Rust commands</name>
  <files>src-tauri/src/git/branch.rs</files>
  <action>
Add two new Tauri commands and their associated types to `branch.rs`. Place them AFTER the existing `checkout_remote_branch` function (at the end of the file).

**New types (add before the new functions):**

```rust
/// A recently checked-out branch extracted from the reflog.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct RecentCheckout {
    /// Branch name (bare, without refs/heads/ prefix)
    pub name: String,
    /// Unix timestamp in milliseconds when the checkout occurred
    pub last_checkout_ms: f64,
}

/// Result of deleting a single branch in a batch operation.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct BranchDeleteResult {
    /// Branch name that was targeted
    pub name: String,
    /// Whether the branch was successfully deleted
    pub deleted: bool,
    /// Error message if deletion failed
    pub error: Option<String>,
}

/// Result of a batch branch deletion operation.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct BatchDeleteResult {
    /// Per-branch results
    pub results: Vec<BranchDeleteResult>,
    /// Count of successfully deleted branches
    pub total_deleted: u32,
    /// Count of branches that failed to delete
    pub total_failed: u32,
}
```

**get_recent_checkouts command:**

Parse HEAD reflog to extract recent checkout branch names with timestamps. The reflog message format for checkouts is `"checkout: moving from X to Y"`. Extract the target branch name (after "to").

Key implementation details:
- Use `repo.reflog("HEAD")` to get the reflog
- Iterate entries, match `"checkout: moving from "` prefix
- Extract the target branch name: `msg.strip_prefix("checkout: moving from ").and_then(|rest| rest.rsplit(" to ").next())`
- Use `HashSet` to deduplicate (only first/most-recent occurrence per branch)
- Get timestamp: `entry.committer().when().seconds()` (epoch seconds, multiply by 1000 for JS ms)
- Filter out detached HEAD entries: skip if branch name looks like a hex hash (40 chars, all hex)
- Default limit: 10, configurable via parameter
- Use `std::collections::HashSet` (add `use std::collections::HashSet;` at top of file)

```rust
#[tauri::command]
#[specta::specta]
pub async fn get_recent_checkouts(
    limit: Option<usize>,
    state: State<'_, RepositoryState>,
) -> Result<Vec<RecentCheckout>, GitError> {
    let repo_path = state
        .get_path()
        .await
        .ok_or_else(|| GitError::NotFound("No repository open".to_string()))?;
    let max = limit.unwrap_or(10);

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;
        let reflog = repo
            .reflog("HEAD")
            .map_err(|e| GitError::OperationFailed(e.message().to_string()))?;

        let mut seen = HashSet::new();
        let mut recent = Vec::new();

        for entry in reflog.iter() {
            let msg = entry.message().unwrap_or("");
            if let Some(branch_name) = msg
                .strip_prefix("checkout: moving from ")
                .and_then(|rest| rest.rsplit(" to ").next())
            {
                // Skip detached HEAD entries (40-char hex hashes)
                if branch_name.len() == 40 && branch_name.chars().all(|c| c.is_ascii_hexdigit()) {
                    continue;
                }

                if seen.insert(branch_name.to_string()) {
                    let timestamp_secs = entry.committer().when().seconds();
                    recent.push(RecentCheckout {
                        name: branch_name.to_string(),
                        last_checkout_ms: (timestamp_secs as f64) * 1000.0,
                    });
                    if recent.len() >= max {
                        break;
                    }
                }
            }
        }

        Ok(recent)
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}
```

**batch_delete_branches command:**

Delete multiple branches sequentially with per-branch error reporting. Does NOT stop on first failure — continues through all branches and reports results.

Key implementation details:
- Open repo once, iterate over branch names
- For each branch: find it, check safety (is_head, merge check if not force), delete
- Collect per-branch success/failure into BranchDeleteResult vec
- Return BatchDeleteResult with totals
- Use existing GitError types for error messages

```rust
#[tauri::command]
#[specta::specta]
pub async fn batch_delete_branches(
    branch_names: Vec<String>,
    force: bool,
    state: State<'_, RepositoryState>,
) -> Result<BatchDeleteResult, GitError> {
    let repo_path = state
        .get_path()
        .await
        .ok_or_else(|| GitError::NotFound("No repository open".to_string()))?;

    tokio::task::spawn_blocking(move || {
        let repo = git2::Repository::open(&repo_path)?;

        let head_commit = match repo.head() {
            Ok(head) => Some(head.peel_to_commit()?),
            Err(e) if e.code() == git2::ErrorCode::UnbornBranch => None,
            Err(e) => return Err(e.into()),
        };

        let mut results = Vec::with_capacity(branch_names.len());
        let mut total_deleted = 0u32;
        let mut total_failed = 0u32;

        for name in &branch_names {
            let result: Result<(), String> = (|| {
                let mut branch = repo
                    .find_branch(name, git2::BranchType::Local)
                    .map_err(|_| format!("Branch '{}' not found", name))?;

                if branch.is_head() {
                    return Err("Cannot delete the current branch".to_string());
                }

                if !force {
                    if let Some(ref head) = head_commit {
                        let branch_commit = branch
                            .get()
                            .peel_to_commit()
                            .map_err(|e| e.message().to_string())?;
                        let merge_base = repo
                            .merge_base(head.id(), branch_commit.id())
                            .map_err(|e| e.message().to_string())?;
                        if merge_base != branch_commit.id() {
                            return Err(format!("Branch '{}' is not fully merged", name));
                        }
                    }
                }

                branch.delete().map_err(|e| e.message().to_string())?;
                Ok(())
            })();

            match result {
                Ok(()) => {
                    total_deleted += 1;
                    results.push(BranchDeleteResult {
                        name: name.clone(),
                        deleted: true,
                        error: None,
                    });
                }
                Err(e) => {
                    total_failed += 1;
                    results.push(BranchDeleteResult {
                        name: name.clone(),
                        deleted: false,
                        error: Some(e),
                    });
                }
            }
        }

        Ok(BatchDeleteResult {
            results,
            total_deleted,
            total_failed,
        })
    })
    .await
    .map_err(|e| GitError::Internal(format!("Task join error: {}", e)))?
}
```
  </action>
  <verify>Run `cd src-tauri && cargo check 2>&1` — should compile without errors. Verify the new functions exist: `grep -n "pub async fn get_recent_checkouts\|pub async fn batch_delete_branches" src-tauri/src/git/branch.rs`.</verify>
  <done>Two new Rust commands added to branch.rs: get_recent_checkouts (reflog parsing with dedup and hash filtering) and batch_delete_branches (sequential deletion with per-branch error reporting). Both follow existing async + spawn_blocking + RepositoryState patterns.</done>
</task>

<task type="auto">
  <name>Task 2: Register new commands in lib.rs and regenerate bindings</name>
  <files>src-tauri/src/lib.rs, src/bindings.ts</files>
  <action>
**src-tauri/src/lib.rs:**

1. Update the `use` import block for branch to include the new commands:
   Change: `branch::{checkout_branch, checkout_remote_branch, create_branch, delete_branch, list_all_branches, list_branches,}`
   To: `branch::{batch_delete_branches, checkout_branch, checkout_remote_branch, create_branch, delete_branch, get_recent_checkouts, list_all_branches, list_branches,}`

2. Add both commands to the `collect_commands![]` macro, in the Branch commands section:
   After `checkout_remote_branch,` add:
   ```
   batch_delete_branches,
   get_recent_checkouts,
   ```

**Regenerate bindings:**

Run `cd src-tauri && cargo build 2>&1` (in debug mode, this triggers the bindings export to `../src/bindings.ts` via the `#[cfg(debug_assertions)]` block in lib.rs).

After build, verify that `src/bindings.ts` contains:
- `getRecentCheckouts` command
- `batchDeleteBranches` command
- `RecentCheckout` type
- `BatchDeleteResult` type
- `BranchDeleteResult` type

NOTE: The pre-existing TS2440 error in bindings.ts should be ignored (it's a known issue documented in MEMORY.md).
  </action>
  <verify>Run `cd src-tauri && cargo build 2>&1` — should compile. Then verify bindings: `grep -n "getRecentCheckouts\|batchDeleteBranches\|RecentCheckout\|BatchDeleteResult" src/bindings.ts | head -10` — should show the new commands and types.</verify>
  <done>New Rust commands registered in lib.rs collect_commands! macro. TypeScript bindings auto-generated with getRecentCheckouts, batchDeleteBranches commands and RecentCheckout, BatchDeleteResult, BranchDeleteResult types.</done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` — compiles without errors
2. `grep -n "get_recent_checkouts\|batch_delete_branches" src-tauri/src/lib.rs` — both registered
3. `grep -n "getRecentCheckouts\|batchDeleteBranches" src/bindings.ts` — both in bindings
4. `grep -n "RecentCheckout\|BatchDeleteResult\|BranchDeleteResult" src/bindings.ts` — types generated
</verification>

<success_criteria>
- get_recent_checkouts parses HEAD reflog, returns deduplicated branch names with ms timestamps, filters hex hashes
- batch_delete_branches processes all branches without stopping on failure, reports per-branch results
- Both commands registered in lib.rs and accessible from TypeScript bindings
- Rust compiles without errors
- TypeScript bindings include new types (RecentCheckout, BatchDeleteResult, BranchDeleteResult)
</success_criteria>

<output>
After completion, create `.planning/phases/23-branch-management/23-03-SUMMARY.md`
</output>
