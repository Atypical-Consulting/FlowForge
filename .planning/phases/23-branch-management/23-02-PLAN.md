---
phase: 23-branch-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/branchMetadata.ts
  - src/lib/branchScopes.ts
  - src/hooks/useBranches.ts
  - src/hooks/useBranchScopes.ts
autonomous: true

must_haves:
  truths:
    - "Branch metadata (pins, recents, scope preference) is persisted per-repo via Tauri plugin-store"
    - "Scope registry allows filtering branches by local/remote/recent with a single-object addition pattern"
    - "Composition hook produces EnrichedBranch[] combining git data with user metadata"
  artifacts:
    - path: "src/stores/branchMetadata.ts"
      provides: "Zustand store for per-repo branch pins, recents, and scope preferences with Tauri persistence"
      exports: ["useBranchMetadataStore", "RecentBranchEntry"]
    - path: "src/lib/branchScopes.ts"
      provides: "Registry-based scope system for extensible branch filtering"
      exports: ["registerScope", "getScope", "getAllScopes", "getPrimaryScopes", "BranchScopeDefinition"]
    - path: "src/hooks/useBranches.ts"
      provides: "Composition hook combining git branch data with metadata into EnrichedBranch[]"
      exports: ["useBranches"]
    - path: "src/hooks/useBranchScopes.ts"
      provides: "Hook for scope-filtered branches with scope state management"
      exports: ["useBranchScopes"]
  key_links:
    - from: "src/hooks/useBranches.ts"
      to: "src/stores/branches.ts"
      via: "import useBranchStore"
      pattern: "useBranchStore"
    - from: "src/hooks/useBranches.ts"
      to: "src/stores/branchMetadata.ts"
      via: "import useBranchMetadataStore"
      pattern: "useBranchMetadataStore"
    - from: "src/hooks/useBranchScopes.ts"
      to: "src/lib/branchScopes.ts"
      via: "import { getScope, getPrimaryScopes }"
      pattern: "getScope|getPrimaryScopes"
---

<objective>
Create the branch metadata store, scope registry, and composition hooks that form the extensibility backbone for all branch management features.

Purpose: Separating user metadata (pins, recents, scope preferences) from git branch data enables independent persistence and prevents coupling. The scope registry pattern (inspired by the blade registry) makes adding new branch scopes a single-file change. The composition hooks provide a clean consumption point for all downstream UI components.

Output: Four new files forming the branch management data layer — all new files, zero modifications to existing code.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/stores/navigation.ts (persistence pattern reference — getStore, store.set, store.save)
@src/stores/branches.ts (git branch store — pure data)
@src/stores/repository.ts (for repoPath access)
@src/lib/branchClassifier.ts (classifyBranch, EnrichedBranch type)
@src/lib/store.ts (getStore singleton)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create branchMetadata store and branchScopes registry</name>
  <files>src/stores/branchMetadata.ts, src/lib/branchScopes.ts</files>
  <action>
**src/stores/branchMetadata.ts — Branch metadata store with Tauri persistence:**

Create a Zustand store following the EXACT pattern from `navigation.ts` (getStore, store.set, store.save). The store manages per-repo data using `Record<string, T>` keyed by repository path.

State:
- `pinnedBranches: Record<string, string[]>` — repoPath -> pinned branch names (bare names, max 5)
- `recentBranches: Record<string, RecentBranchEntry[]>` — repoPath -> recent entries (max 10)
- `scopePreference: Record<string, string>` — repoPath -> scope ID (default: "local")

Export `RecentBranchEntry` interface: `{ name: string; lastVisited: number }` (Date.now timestamp).

Actions (all follow navigation.ts pattern: optimistic set + async persist):
- `pinBranch(repoPath, branchName)` — add to pins if not present, cap at 5. Store key: `"branch-pinned"`.
- `unpinBranch(repoPath, branchName)` — remove from pins. Store key: `"branch-pinned"`.
- `isPinned(repoPath, branchName) -> boolean` — synchronous check.
- `recordBranchVisit(repoPath, branchName)` — add/move to front of recents, cap at 10. Store key: `"branch-recent"`.
- `getRecentBranches(repoPath) -> RecentBranchEntry[]` — synchronous accessor.
- `setScopePreference(repoPath, scopeId)` — persist scope preference. Store key: `"branch-scope"`.
- `getScopePreference(repoPath) -> string` — returns stored preference or "local" default.
- `initMetadata()` — load all three keys from Tauri store (called at app startup).

Pattern from navigation.ts to replicate:
```typescript
try {
  const store = await getStore();
  await store.set("branch-pinned", updated);
  await store.save();
} catch (e) {
  console.error("Failed to persist pinned branches:", e);
}
set({ pinnedBranches: updated });
```

**src/lib/branchScopes.ts — Scope registry:**

Create a registry inspired by the blade registry pattern. Each scope is a filter/sort configuration.

Export interface `BranchScopeDefinition`:
```typescript
export interface BranchScopeDefinition {
  id: string;
  label: string;
  filter: (branch: EnrichedBranch) => boolean;
  sort?: (a: EnrichedBranch, b: EnrichedBranch) => number;
  primary: boolean; // shown in segmented control
}
```

Import `EnrichedBranch` from `../lib/branchClassifier`.

Internal: `const scopeRegistry = new Map<string, BranchScopeDefinition>()`.

Export functions:
- `registerScope(scope: BranchScopeDefinition): void` — adds to registry.
- `getScope(id: string): BranchScopeDefinition | undefined` — lookup.
- `getAllScopes(): BranchScopeDefinition[]` — all registered scopes.
- `getPrimaryScopes(): BranchScopeDefinition[]` — scopes with `primary: true`.

Register three built-in scopes at module load time:
1. `local`: `{ id: "local", label: "Local", primary: true, filter: (b) => !b.isRemote, sort: alpha with HEAD first }`
2. `remote`: `{ id: "remote", label: "Remote", primary: true, filter: (b) => b.isRemote, sort: alpha }`
3. `recent`: `{ id: "recent", label: "Last Used", primary: true, filter: (b) => b.lastVisited !== null, sort: by lastVisited descending }`

NOTE: The `EnrichedBranch.isRemote` comes from the underlying `BranchInfo` type. The `lastVisited` comes from the metadata composition.
  </action>
  <verify>Run `npx tsc --noEmit 2>&1 | grep -v 'bindings.ts'` — no new type errors. Verify exports: `grep -n "export" src/stores/branchMetadata.ts src/lib/branchScopes.ts`.</verify>
  <done>branchMetadata.ts store is created with pin/recent/scope persistence following navigation.ts pattern. branchScopes.ts registry is created with 3 built-in scopes (local, remote, recent) and extensible registration API.</done>
</task>

<task type="auto">
  <name>Task 2: Create useBranches and useBranchScopes composition hooks</name>
  <files>src/hooks/useBranches.ts, src/hooks/useBranchScopes.ts</files>
  <action>
**src/hooks/useBranches.ts — Composition hook:**

This hook composes git branch data from `useBranchStore` with user metadata from `useBranchMetadataStore` and branch classification from `classifyBranch`. It produces `EnrichedBranch[]` via `useMemo`.

```typescript
export function useBranches() {
  // Get repoPath from repository store
  const repoPath = useRepositoryStore(s => s.status?.repoPath ?? "");
  // Get git branch data
  const { branches, allBranches, isLoading, error, loadBranches, loadAllBranches } = useBranchStore();
  // Get user metadata
  const metadata = useBranchMetadataStore();

  const enriched = useMemo((): EnrichedBranch[] => {
    if (!repoPath) return [];
    const pins = new Set(metadata.pinnedBranches[repoPath] ?? []);
    const recents = metadata.recentBranches[repoPath] ?? [];
    const recentMap = new Map(recents.map(r => [r.name, r.lastVisited]));

    // Enrich allBranches (which includes remote if loaded)
    return allBranches.map(branch => {
      // Use bare name for metadata lookup (strip remote prefix)
      const bareName = branch.name
        .replace(/^refs\/heads\//, "")
        .replace(/^origin\//, "");
      return {
        ...branch,
        branchType: classifyBranch(branch.name),
        isPinned: pins.has(bareName),
        lastVisited: recentMap.get(bareName) ?? null,
      };
    });
  }, [allBranches, metadata.pinnedBranches, metadata.recentBranches, repoPath]);

  return {
    branches: enriched,
    localBranches: branches,
    isLoading,
    error,
    loadBranches,
    loadAllBranches,
    repoPath,
  };
}
```

Import from: `../stores/branches`, `../stores/branchMetadata`, `../stores/repository`, `../lib/branchClassifier`.

**src/hooks/useBranchScopes.ts — Scope-filtered hook:**

Wraps `useBranches` and applies scope filtering/sorting.

```typescript
export function useBranchScopes() {
  const { branches, repoPath, ...rest } = useBranches();
  const { getScopePreference, setScopePreference } = useBranchMetadataStore();

  const activeScopeId = getScopePreference(repoPath) || "local";
  const activeScope = getScope(activeScopeId);

  // Scope-filtered branches (for the main list)
  const filtered = useMemo(() => {
    if (!activeScope) return branches;
    let result = branches.filter(activeScope.filter);
    if (activeScope.sort) {
      result = [...result].sort(activeScope.sort);
    }
    return result;
  }, [branches, activeScope]);

  // Pinned branches (scope-independent — always show)
  const pinnedBranches = useMemo(
    () => branches.filter(b => b.isPinned),
    [branches]
  );

  // Recent branches (top 5, exclude current and pinned)
  const recentBranches = useMemo(
    () => branches
      .filter(b => b.lastVisited !== null && !b.isPinned && !b.isHead)
      .sort((a, b) => (b.lastVisited ?? 0) - (a.lastVisited ?? 0))
      .slice(0, 5),
    [branches]
  );

  const setScope = (scopeId: string) => {
    setScopePreference(repoPath, scopeId);
  };

  return {
    branches: filtered,
    allBranches: branches,
    pinnedBranches,
    recentBranches,
    activeScopeId,
    setScope,
    scopes: getPrimaryScopes(),
    repoPath,
    ...rest,
  };
}
```

Import from: `./useBranches`, `../stores/branchMetadata`, `../lib/branchScopes`.
  </action>
  <verify>Run `npx tsc --noEmit 2>&1 | grep -v 'bindings.ts'` — no new type errors. Verify exports: `grep -n "export function" src/hooks/useBranches.ts src/hooks/useBranchScopes.ts`.</verify>
  <done>useBranches hook produces EnrichedBranch[] combining git data + metadata + classification. useBranchScopes hook adds scope filtering, pinned extraction, and recent extraction. Both export correctly with proper TypeScript types.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit 2>&1 | grep -v 'bindings.ts'` — no new type errors
2. `grep -rn "export.*useBranchMetadataStore" src/stores/branchMetadata.ts` — store exported
3. `grep -rn "registerScope" src/lib/branchScopes.ts` — function exported and 3 scopes registered
4. `grep -rn "export function useBranches" src/hooks/useBranches.ts` — hook exported
5. `grep -rn "export function useBranchScopes" src/hooks/useBranchScopes.ts` — hook exported
6. All 4 files are NEW — no existing code modified
</verification>

<success_criteria>
- branchMetadata store persists pins/recents/scope per-repo using getStore() pattern
- Scope registry has 3 built-in scopes (local, remote, recent) with extensible registration
- useBranches hook composes git data + metadata into EnrichedBranch[]
- useBranchScopes hook provides filtered branches, pinned list, recent list, and scope management
- All new files — zero changes to existing code in this plan
- TypeScript compiles without new errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-branch-management/23-02-SUMMARY.md`
</output>
