---
phase: 23-branch-management
plan: 06
type: execute
wave: 3
depends_on: [23-04, 23-05]
files_modified:
  - src/components/branches/BranchList.tsx
  - src/components/Header.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Bulk delete mode is integrated into the branch list with selection checkboxes"
    - "Feature branch type badges appear in purple in both the topology graph and branch list"
    - "Clone button transforms into 'Reveal in Finder' when inside a repository"
    - "Branch metadata store initializes at app startup alongside navigation and settings"
  artifacts:
    - path: "src/components/branches/BranchList.tsx"
      provides: "Branch list with integrated bulk delete mode, checkboxes, and floating action bar"
      contains: "useBulkSelect|BulkDeleteDialog|BranchBulkActions"
    - path: "src/components/Header.tsx"
      provides: "Header with contextual clone/reveal button"
      contains: "revealItemInDir|Reveal"
    - path: "src/App.tsx"
      provides: "App initialization includes branchMetadata init"
      contains: "initMetadata"
  key_links:
    - from: "src/components/branches/BranchList.tsx"
      to: "src/hooks/useBulkSelect.ts"
      via: "import { useBulkSelect }"
      pattern: "useBulkSelect"
    - from: "src/components/branches/BranchList.tsx"
      to: "src/lib/bulkBranchOps.ts"
      via: "import { bulkDeleteBranches, getProtectedBranches }"
      pattern: "bulkDeleteBranches"
    - from: "src/components/Header.tsx"
      to: "@tauri-apps/plugin-opener"
      via: "import { revealItemInDir }"
      pattern: "revealItemInDir"
---

<objective>
Integrate bulk delete into BranchList, add contextual clone/reveal button, and wire app initialization.

Purpose: This plan connects the infrastructure from plans 23-04 and 23-05 into a cohesive experience. Bulk delete mode is wired into the branch list with checkboxes and the confirmation dialog. The Header clone button becomes context-aware (BRANCH-06). The branchMetadata store is initialized at app startup.

Output: Updated BranchList with full bulk delete integration, Header with contextual action, and App.tsx with metadata initialization.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-branch-management/23-04-SUMMARY.md
@.planning/phases/23-branch-management/23-05-SUMMARY.md
@src/components/branches/BranchList.tsx (from plan 23-04)
@src/components/Header.tsx
@src/App.tsx
@src/hooks/useBulkSelect.ts (from plan 23-05)
@src/lib/bulkBranchOps.ts (from plan 23-05)
@src/components/branches/BulkDeleteDialog.tsx (from plan 23-05)
@src/components/branches/BranchBulkActions.tsx (from plan 23-05)
@src/stores/gitflow.ts (for protected branch detection)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate bulk delete into BranchList with checkboxes and dialog</name>
  <files>src/components/branches/BranchList.tsx</files>
  <action>
Enhance the BranchList (already refactored in 23-04) with bulk delete integration.

Add imports:
- `useBulkSelect` from `../../hooks/useBulkSelect`
- `bulkDeleteBranches`, `getProtectedBranches` from `../../lib/bulkBranchOps`
- `BulkDeleteDialog` from `./BulkDeleteDialog`
- `BranchBulkActions` from `./BranchBulkActions`
- `useGitflowStore` from `../../stores/gitflow` (already likely imported if gitflow panel exists)

Integration points:

1. **Bulk select state**: Call `useBulkSelect(branches.map(b => b.name))` where `branches` is the scope-filtered list from useBranchScopes.

2. **Protected branches**: Use `useMemo` to compute protected set:
   ```typescript
   const gitflowStatus = useGitflowStore(s => s.status);
   const protectedBranches = useMemo(() =>
     getProtectedBranches(gitflowStatus),
     [gitflowStatus]
   );
   ```

3. **BranchBulkActions placement**: Add the toolbar between the scope selector and the main branch list section:
   ```tsx
   <BranchBulkActions
     selectionMode={selectionMode}
     selectedCount={selectedCount}
     onEnterSelectionMode={enterSelectionMode}
     onExitSelectionMode={exitSelectionMode}
     onSelectAllMerged={() => {
       const merged = branches
         .filter(b => b.isMerged && !b.isHead && !protectedBranches.has(b.name))
         .map(b => b.name);
       selectAllMerged(merged);
     }}
     onDeleteSelected={() => setShowDeleteDialog(true)}
   />
   ```

4. **BranchItem in selection mode**: When `selectionMode` is true, show a checkbox on the LEFT side of each BranchItem in the main list (not in Quick Access or Recent sections). Protected branches show a disabled checkbox with Shield icon. Pass these as props or wrap BranchItem conditionally:
   ```tsx
   {selectionMode && (
     <input
       type="checkbox"
       checked={isSelected(branch.name)}
       disabled={protectedBranches.has(branch.name)}
       onChange={(e) => toggleSelect(branch.name, e.nativeEvent instanceof MouseEvent ? (e.nativeEvent as MouseEvent).shiftKey : false)}
       className="accent-ctp-blue shrink-0"
       aria-label={`Select ${branch.name}`}
     />
   )}
   ```
   If branch is protected, show Shield icon with tooltip "Protected branch" instead of checkbox.

5. **BulkDeleteDialog**: Add state `const [showDeleteDialog, setShowDeleteDialog] = useState(false)` and `const [isDeleting, setIsDeleting] = useState(false)`.
   Render at bottom of component:
   ```tsx
   {showDeleteDialog && (
     <BulkDeleteDialog
       branches={branches.filter(b => selected.has(b.name))}
       protectedBranches={Array.from(protectedBranches)}
       isDeleting={isDeleting}
       onConfirm={handleBulkDelete}
       onCancel={() => setShowDeleteDialog(false)}
     />
   )}
   ```

6. **handleBulkDelete function**:
   ```typescript
   const handleBulkDelete = async () => {
     setIsDeleting(true);
     try {
       const result = await bulkDeleteBranches({
         branchNames: Array.from(selected),
         force: false,
       });
       if (result.totalDeleted > 0) {
         toast.success(`Deleted ${result.totalDeleted} branch${result.totalDeleted !== 1 ? 'es' : ''}`);
       }
       if (result.totalFailed > 0) {
         toast.warning(`Failed to delete ${result.totalFailed} branch${result.totalFailed !== 1 ? 'es' : ''}`);
       }
       // Refresh branch list
       await loadBranches();
       await loadAllBranches(true);
     } catch (e) {
       toast.error(`Bulk delete failed: ${e instanceof Error ? e.message : String(e)}`);
     } finally {
       setIsDeleting(false);
       setShowDeleteDialog(false);
       exitSelectionMode();
     }
   };
   ```
  </action>
  <verify>Run `npx tsc --noEmit 2>&1 | grep -v 'bindings.ts'` — no new errors. Verify bulk delete flow: selection mode toggle, checkbox selection, dialog opens with branch list, protected branches are disabled.</verify>
  <done>BranchList has full bulk delete integration: BranchBulkActions toolbar, checkboxes in selection mode, protected branch shielding, BulkDeleteDialog confirmation, toast feedback, and branch list refresh after deletion.</done>
</task>

<task type="auto">
  <name>Task 2: Contextual clone/reveal button in Header and metadata initialization in App</name>
  <files>src/components/Header.tsx, src/App.tsx</files>
  <action>
**Header.tsx — Contextual clone/reveal button (BRANCH-06):**

Replace the Clone button logic so it's context-aware:
- When NO repo is open (`!status`): Show "Clone" button (current behavior)
- When a repo IS open (`status`): Show "Reveal" button that opens the repo directory in the system file manager

Find the existing Clone button (around line 333-347):
```tsx
<Button
  variant="ghost" size="sm"
  onClick={() => { document.dispatchEvent(new CustomEvent("clone-repository-dialog")); }}
  disabled={isLoading}
  className="text-ctp-subtext1 hover:text-ctp-text"
  title="Clone Repository"
>
  <GitFork className="w-4 h-4 mr-2" /> Clone
</Button>
```

Replace with conditional rendering:
```tsx
{status ? (
  <Button
    variant="ghost"
    size="sm"
    onClick={async () => {
      try {
        const { revealItemInDir } = await import("@tauri-apps/plugin-opener");
        await revealItemInDir(status.repoPath);
      } catch (e) {
        toast.error(`Failed to reveal: ${e instanceof Error ? e.message : String(e)}`);
      }
    }}
    className="text-ctp-subtext1 hover:text-ctp-text"
    title="Reveal in Finder"
    aria-label="Reveal repository in file manager"
  >
    <FolderOpen className="w-4 h-4 mr-2" />
    Reveal
  </Button>
) : (
  <Button
    variant="ghost"
    size="sm"
    onClick={() => {
      document.dispatchEvent(new CustomEvent("clone-repository-dialog"));
    }}
    disabled={isLoading}
    className="text-ctp-subtext1 hover:text-ctp-text"
    title="Clone Repository"
  >
    <GitFork className="w-4 h-4 mr-2" />
    Clone
  </Button>
)}
```

The `FolderOpen` icon is already imported in the Header. The `@tauri-apps/plugin-opener` package is already a dependency and `revealItemInDir` is already used in `worktrees.ts`. Use dynamic import (same pattern as worktrees.ts) to avoid importing at module level.

NOTE: Keep Clone accessible via Command Palette even when a repo is open (no change needed to CommandPalette — it's separate).

**App.tsx — Initialize branchMetadata store:**

Find where `initNavigation` is called (likely in a useEffect in App.tsx or a similar init point). Add `initMetadata` call alongside it.

Search for the initialization pattern:
```typescript
import { useBranchMetadataStore } from "./stores/branchMetadata";

// In the initialization effect:
useBranchMetadataStore.getState().initMetadata();
```

This should be called at app startup so pin/recent/scope data is loaded from Tauri store before any branch list renders. Add it to the same useEffect that calls `initNavigation()` (or `initSettings()` if that's the startup point). If there's no single init effect, add one.
  </action>
  <verify>Run `npx tsc --noEmit 2>&1 | grep -v 'bindings.ts'` — no new errors. Verify: (1) When repo is open, header shows "Reveal" button with FolderOpen icon. (2) When no repo is open, header shows "Clone" button with GitFork icon. (3) branchMetadata initMetadata is called at app startup.</verify>
  <done>Header clone button is context-aware: shows "Reveal" with FolderOpen when repo is open (uses revealItemInDir from plugin-opener), shows "Clone" with GitFork when no repo. branchMetadata store initializes at app startup alongside navigation/settings stores.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit 2>&1 | grep -v 'bindings.ts'` — no new type errors
2. Bulk mode: "Clean up" button visible in branch list, enters selection mode
3. Bulk mode: Checkboxes appear next to branches, protected branches show shield
4. Bulk mode: "Delete N" opens confirmation dialog with branch list
5. Bulk mode: Delete executes, shows toast results, refreshes list, exits selection mode
6. Header: "Reveal" button visible when repo is open, opens system file manager
7. Header: "Clone" button visible when no repo is open
8. App startup: branchMetadata store loads pins/recents/scope from persistent storage
</verification>

<success_criteria>
- BRANCH-04 complete: Bulk delete with Gitflow protection, confirmation dialog, error reporting
- BRANCH-06 complete: Clone button context-aware (Reveal in Finder when repo open)
- branchMetadata persistence initialized at app startup
- All existing functionality preserved (merge dialog, create dialog, single branch delete)
- TypeScript compiles without new errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-branch-management/23-06-SUMMARY.md`
</output>
