---
phase: 39-conventional-commits-extraction
plan: 03
type: execute
wave: 2
depends_on: ["39-01"]
files_modified:
  - src/extensions/__tests__/conventional-commits.test.ts
  - src/components/commit/__tests__/CommitForm.test.tsx
autonomous: true

must_haves:
  truths:
    - "Extension lifecycle tests verify conventional-commit and changelog blade types are registered on activation"
    - "Extension lifecycle tests verify coreOverride (no ext: prefix) on both blade types"
    - "Extension lifecycle tests verify cleanup removes all blade types on deactivation"
    - "CommitForm degradation test verifies CC toggle is hidden when extension is not active"
    - "CommitForm degradation test verifies simple textarea commit form works when extension is not active"
  artifacts:
    - path: "src/extensions/__tests__/conventional-commits.test.ts"
      provides: "Extension lifecycle tests for conventional-commits"
    - path: "src/components/commit/__tests__/CommitForm.test.tsx"
      provides: "CommitForm degradation tests"
  key_links:
    - from: "src/extensions/__tests__/conventional-commits.test.ts"
      to: "src/extensions/conventional-commits/index.ts"
      via: "import onActivate/onDeactivate for lifecycle testing"
      pattern: "import.*conventional-commits"
    - from: "src/extensions/__tests__/conventional-commits.test.ts"
      to: "src/lib/bladeRegistry.ts"
      via: "getBladeRegistration to verify blade types"
      pattern: "getBladeRegistration"
---

<objective>
Add extension lifecycle tests and CommitForm degradation tests to verify the conventional-commits extraction.

Purpose: This plan ensures the extraction is correct and robust by testing: (1) the extension lifecycle -- blade registration, coreOverride namespacing, lazy flags, source tracking, and cleanup; (2) CommitForm graceful degradation -- CC toggle visibility based on extension status, auto-reset of useConventional, and simple form availability. These tests guard against regressions when the extension system evolves.

Output: Extension lifecycle test suite and CommitForm degradation test suite, both passing.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-conventional-commits-extraction/39-RESEARCH.md
@.planning/phases/39-conventional-commits-extraction/39-01-SUMMARY.md

@src/extensions/conventional-commits/index.ts
@src/extensions/__tests__/content-viewers.test.ts
@src/extensions/__tests__/ExtensionAPI.test.ts
@src/extensions/ExtensionAPI.ts
@src/lib/bladeRegistry.ts
@src/components/commit/CommitForm.tsx
@src/extensions/ExtensionHost.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conventional-commits extension lifecycle tests</name>
  <files>
    src/extensions/__tests__/conventional-commits.test.ts
  </files>
  <action>
    **1. Create `src/extensions/__tests__/conventional-commits.test.ts`:**

    Follow the exact pattern from `src/extensions/__tests__/content-viewers.test.ts`. The test verifies extension activation, blade registration, coreOverride namespacing, lazy flags, source tracking, and cleanup.

    ```typescript
    import { describe, it, expect, beforeEach } from "vitest";
    import { ExtensionAPI } from "../ExtensionAPI";
    import { getBladeRegistration } from "../../lib/bladeRegistry";
    import { onActivate, onDeactivate } from "../conventional-commits";

    describe("conventional-commits extension", () => {
      let api: ExtensionAPI;

      beforeEach(() => {
        api = new ExtensionAPI("conventional-commits");
      });

      it("registers conventional-commit and changelog blade types on activation", async () => {
        await onActivate(api);

        expect(getBladeRegistration("conventional-commit")).toBeDefined();
        expect(getBladeRegistration("changelog")).toBeDefined();

        api.cleanup();
      });

      it("registers blade types without ext: namespace (coreOverride)", async () => {
        await onActivate(api);

        // Should NOT be namespaced
        expect(getBladeRegistration("ext:conventional-commits:conventional-commit")).toBeUndefined();
        expect(getBladeRegistration("ext:conventional-commits:changelog")).toBeUndefined();

        api.cleanup();
      });

      it("marks both blades as lazy for Suspense wrapping", async () => {
        await onActivate(api);

        const cc = getBladeRegistration("conventional-commit");
        const changelog = getBladeRegistration("changelog");

        expect(cc?.lazy).toBe(true);
        expect(changelog?.lazy).toBe(true);

        api.cleanup();
      });

      it("marks both blades as singletons", async () => {
        await onActivate(api);

        const cc = getBladeRegistration("conventional-commit");
        const changelog = getBladeRegistration("changelog");

        expect(cc?.singleton).toBe(true);
        expect(changelog?.singleton).toBe(true);

        api.cleanup();
      });

      it("tracks source as ext:conventional-commits for cleanup", async () => {
        await onActivate(api);

        const cc = getBladeRegistration("conventional-commit");
        expect(cc?.source).toBe("ext:conventional-commits");

        const changelog = getBladeRegistration("changelog");
        expect(changelog?.source).toBe("ext:conventional-commits");

        api.cleanup();
      });

      it("unregisters all blade types on cleanup", async () => {
        await onActivate(api);
        api.cleanup();

        expect(getBladeRegistration("conventional-commit")).toBeUndefined();
        expect(getBladeRegistration("changelog")).toBeUndefined();
      });

      it("onDeactivate is a no-op (cleanup handled by ExtensionAPI)", () => {
        // Should not throw
        expect(() => onDeactivate()).not.toThrow();
      });
    });
    ```

    **Notes:**
    - Each test that calls `onActivate` must call `api.cleanup()` at the end to avoid polluting the shared blade registry between tests.
    - The `React.lazy()` calls in onActivate create lazy components. Tests do not need to render them -- just verify registration metadata.
    - If the extension's `onActivate` now also registers commands and toolbar actions (from Plan 02), those are tracked by the API and cleaned up automatically. We only test blade registration here since the command/toolbar registry tests are covered by ExtensionAPI.test.ts patterns.
  </action>
  <verify>
    Run `npx vitest run src/extensions/__tests__/conventional-commits.test.ts` -- all 7 tests pass.
    Run `npx vitest run` -- full suite passes.
  </verify>
  <done>
    Extension lifecycle tests verify: both blade types registered on activation, coreOverride (no ext: prefix), lazy and singleton flags, source tracking, cleanup removes all registrations, and onDeactivate is a no-op.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CommitForm graceful degradation tests</name>
  <files>
    src/components/commit/__tests__/CommitForm.test.tsx
  </files>
  <action>
    **1. Create `src/components/commit/__tests__/CommitForm.test.tsx`:**

    This test verifies that CommitForm correctly shows/hides the CC toggle based on extension status. It needs to mock several dependencies.

    Set up the test file with required mocks:

    ```typescript
    import { describe, it, expect, vi, beforeEach } from "vitest";
    import { render, screen } from "@testing-library/react";
    import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

    // Mock the extensions module to control isCCActive
    const mockExtensionStatus = vi.hoisted(() => ({
      status: "inactive" as "active" | "inactive",
    }));

    vi.mock("../../../extensions", () => ({
      useExtensionHost: (selector: (s: any) => any) =>
        selector({
          extensions: new Map([
            ["conventional-commits", mockExtensionStatus],
          ]),
        }),
    }));

    // Mock useBladeNavigation
    vi.mock("../../../hooks/useBladeNavigation", () => ({
      useBladeNavigation: () => ({
        bladeStack: [],
        openBlade: vi.fn(),
      }),
    }));

    // Mock useCommitExecution
    vi.mock("../../../hooks/useCommitExecution", () => ({
      useCommitExecution: () => ({
        commit: vi.fn(),
        isCommitting: false,
        commitError: null,
      }),
    }));

    // Mock useAmendPrefill
    vi.mock("../../../hooks/useAmendPrefill", () => ({
      useAmendPrefill: () => ({
        amend: false,
        toggleAmend: vi.fn(),
        setAmend: vi.fn(),
      }),
    }));

    // Mock Tauri commands for staging status
    vi.mock("../../../bindings", () => ({
      commands: {
        getStagingStatus: vi.fn().mockResolvedValue({
          status: "ok",
          data: { staged: [], unstaged: [], untracked: [] },
        }),
      },
    }));

    // Mock ConventionalCommitForm since it has deep dependencies
    vi.mock("../ConventionalCommitForm", () => ({
      ConventionalCommitForm: () => <div data-testid="cc-form">CC Form</div>,
    }));

    import { CommitForm } from "../CommitForm";
    ```

    Write the test cases:

    ```typescript
    describe("CommitForm graceful degradation", () => {
      let queryClient: QueryClient;

      beforeEach(() => {
        queryClient = new QueryClient({
          defaultOptions: { queries: { retry: false } },
        });
        mockExtensionStatus.status = "inactive";
      });

      const renderCommitForm = () =>
        render(
          <QueryClientProvider client={queryClient}>
            <CommitForm />
          </QueryClientProvider>
        );

      it("hides CC toggle when extension is inactive", () => {
        mockExtensionStatus.status = "inactive";
        renderCommitForm();

        expect(screen.queryByText("Conventional Commits")).not.toBeInTheDocument();
      });

      it("shows CC toggle when extension is active", () => {
        mockExtensionStatus.status = "active";
        renderCommitForm();

        expect(screen.getByText("Conventional Commits")).toBeInTheDocument();
      });

      it("shows simple commit form when extension is inactive", () => {
        mockExtensionStatus.status = "inactive";
        renderCommitForm();

        expect(screen.getByPlaceholderText("Commit message...")).toBeInTheDocument();
        expect(screen.getByText("Commit")).toBeInTheDocument();
      });

      it("shows Commit heading regardless of extension status", () => {
        mockExtensionStatus.status = "inactive";
        renderCommitForm();

        expect(screen.getByText("Commit")).toBeInTheDocument();
      });
    });
    ```

    **Notes:**
    - The test controls extension status via `mockExtensionStatus.status` -- setting it to "active" or "inactive" before each render.
    - `ConventionalCommitForm` is mocked because it has deep Tauri/Zustand dependencies that are hard to mock in isolation.
    - The QueryClientProvider wrapper is needed because CommitForm uses `useQuery` for staging status.
    - The mock structure for `useExtensionHost` matches how CommitForm uses it: `s.extensions.get("conventional-commits")?.status === "active"`.
  </action>
  <verify>
    Run `npx vitest run src/components/commit/__tests__/CommitForm.test.tsx` -- all 4 tests pass.
    Run `npx vitest run` -- full suite passes.
    Run `npx tsc --noEmit` -- no new TypeScript errors.
  </verify>
  <done>
    CommitForm degradation tests verify: CC toggle hidden when extension inactive, CC toggle shown when extension active, simple commit form works when extension inactive, and Commit heading always visible.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (ignore pre-existing TS2440 in bindings.ts)
2. `npx vitest run` -- full test suite passes
3. `npx vitest run src/extensions/__tests__/conventional-commits.test.ts` -- all 7 lifecycle tests pass
4. `npx vitest run src/components/commit/__tests__/CommitForm.test.tsx` -- all 4 degradation tests pass
5. Extension lifecycle tests cover: activation, coreOverride, lazy, singleton, source, cleanup, onDeactivate
6. CommitForm tests cover: toggle hidden when inactive, toggle shown when active, simple form when inactive
</verification>

<success_criteria>
- conventional-commits.test.ts exists with 7 lifecycle tests
- All lifecycle tests pass: registration, coreOverride, lazy, singleton, source, cleanup, onDeactivate
- CommitForm.test.tsx exists with 4 degradation tests
- All degradation tests pass: toggle visibility, simple form availability
- Full test suite continues to pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/39-conventional-commits-extraction/39-03-SUMMARY.md`
</output>
