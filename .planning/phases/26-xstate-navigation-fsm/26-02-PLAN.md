---
phase: 26-xstate-navigation-fsm
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - src/machines/navigation/context.tsx
  - src/machines/navigation/inspector.ts
  - src/machines/navigation/index.ts
  - src/lib/bladeRegistry.ts
  - src/components/blades/registrations/settings.ts
  - src/components/blades/registrations/changelog.ts
  - src/components/blades/registrations/gitflow-cheatsheet.ts
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "NavigationMachineContext.Provider wraps the app and provides the FSM actor to all descendants"
    - "getNavigationActor() returns the module-level actor ref for non-React access"
    - "Developer sees XState inspector in dev mode showing navigation state and events"
    - "Blade registrations for settings, changelog, gitflow-cheatsheet include singleton: true metadata"
  artifacts:
    - path: "src/machines/navigation/context.tsx"
      provides: "createActorContext provider, NavigationProvider, getNavigationActor, setNavigationActor"
      exports: ["NavigationMachineContext", "NavigationProvider", "getNavigationActor", "setNavigationActor"]
    - path: "src/machines/navigation/inspector.ts"
      provides: "Dev-mode inspector setup with createBrowserInspector"
      exports: ["getInspector"]
    - path: "src/lib/bladeRegistry.ts"
      provides: "Enhanced BladeRegistration with singleton field"
      contains: "singleton"
    - path: "src/App.tsx"
      provides: "NavigationProvider wrapping app content"
      contains: "NavigationProvider"
  key_links:
    - from: "src/machines/navigation/context.tsx"
      to: "src/machines/navigation/navigationMachine.ts"
      via: "createActorContext(navigationMachine)"
      pattern: "createActorContext"
    - from: "src/App.tsx"
      to: "src/machines/navigation/context.tsx"
      via: "NavigationProvider component"
      pattern: "NavigationProvider"
    - from: "src/machines/navigation/inspector.ts"
      to: "@statelyai/inspect"
      via: "dynamic import"
      pattern: "createBrowserInspector"
---

<objective>
Wire the XState navigation machine into React via createActorContext, set up the module-level actor for non-React access, install the dev-mode inspector, and enhance blade registrations with singleton metadata.

Purpose: Establish the React integration layer so that Plan 03 can migrate consumers. The NavigationProvider wraps the app, providing the FSM actor to all components via context. The module-level ref enables bladeOpener.ts and keyboard shortcuts to send events. The inspector satisfies NAV-08. Singleton metadata in registrations removes hardcoded arrays.

Output: Working provider in App.tsx, inspector in dev mode, singleton metadata on 3 blade registrations.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-xstate-navigation-fsm/26-01-SUMMARY.md
@.planning/phases/26-xstate-navigation-fsm/26-RESEARCH-ARCHITECTURE.md
@.planning/phases/26-xstate-navigation-fsm/26-RESEARCH-IMPLEMENTATION.md

@src/App.tsx
@src/machines/navigation/index.ts
@src/lib/bladeRegistry.ts
@src/components/blades/registrations/settings.ts
@src/components/blades/registrations/changelog.ts
@src/components/blades/registrations/gitflow-cheatsheet.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create React integration layer with createActorContext and module-level actor</name>
  <files>
    src/machines/navigation/context.tsx
    src/machines/navigation/inspector.ts
    src/machines/navigation/index.ts
  </files>
  <action>
    Create `src/machines/navigation/context.tsx`:
    1. Import `createActorContext` from `@xstate/react` and `navigationMachine` from `./navigationMachine`
    2. Create `NavigationMachineContext = createActorContext(navigationMachine)`
    3. Create a module-level variable `_actorRef` typed as `ActorRefFrom<typeof navigationMachine> | null`
    4. Export `getNavigationActor()` that returns `_actorRef` or throws if null
    5. Export `setNavigationActor(ref)` to set/clear the module-level ref
    6. Create `NavigationProvider` component that:
       - Renders `NavigationMachineContext.Provider` as wrapper
       - Inside, renders a `NavigationActorBridge` child component that calls `NavigationMachineContext.useActorRef()` to get the actor ref
       - In a `useEffect`, calls `setNavigationActor(actorRef)` and returns cleanup `() => setNavigationActor(null)`
       - Passes children through
    7. Re-export `NavigationMachineContext` for direct useSelector/useActorRef access in components

    Create `src/machines/navigation/inspector.ts`:
    1. Export async function `getInspector()` that:
       - Returns `undefined` if `!import.meta.env.DEV`
       - Lazily imports `@statelyai/inspect` via dynamic `import()`
       - Calls `createBrowserInspector()` with an optional filter that excludes high-frequency MARK_DIRTY/MARK_CLEAN events
       - Caches the instance in a module-level variable
       - Returns `inspectorInstance.inspect`
    2. The inspector is NOT wired into the provider yet (that happens in `context.tsx` conditionally). Add a comment noting the provider can pass `inspect` to `createActorContext` options if needed, or the actor can be created with inspect option.

    **Important:** For the inspector integration with `createActorContext`, the machine actor is created internally by `createActorContext`. To attach the inspector, use the `logic` and `observe` patterns from @xstate/react, or create the actor manually and pass it. Research shows `createActorContext` accepts `options` including `inspect`. Wire this:
    ```tsx
    // In NavigationProvider:
    const inspect = useMemo(() => {
      if (!import.meta.env.DEV) return undefined;
      // Synchronous check; async inspector loaded separately
      return undefined; // Inspector attached via useEffect after actor is available
    }, []);
    ```

    Actually, the simplest approach: Do NOT use createActorContext's built-in actor creation. Instead:
    1. Create the actor manually with `createActor(navigationMachine, { inspect })` in a module-level singleton
    2. Wrap it in a plain React context
    3. Start the actor immediately (module-level)
    4. This gives both React context AND module-level access from the same actor instance

    Pattern:
    ```tsx
    import { createActor } from 'xstate';
    import { navigationMachine } from './navigationMachine';

    // Module-level singleton actor
    const navigationActor = createActor(navigationMachine);
    navigationActor.start();

    export function getNavigationActor() {
      return navigationActor;
    }

    // React context that provides the actor
    const NavigationActorContext = createContext(navigationActor);

    export function NavigationProvider({ children }) {
      return (
        <NavigationActorContext.Provider value={navigationActor}>
          {children}
        </NavigationActorContext.Provider>
      );
    }

    export function useNavigationActorRef() {
      return useContext(NavigationActorContext);
    }
    ```

    This avoids the createActorContext complexity while giving the same API. Components use `useSelector(actorRef, selector)` from `@xstate/react`.

    For inspector: in dev mode, recreate the actor with inspect option. Use a lazy initialization pattern:
    ```typescript
    let navigationActor: ActorRefFrom<typeof navigationMachine>;

    if (import.meta.env.DEV) {
      // Inspector will be attached asynchronously
      navigationActor = createActor(navigationMachine);
      // Async: attach inspector after import
      import('@statelyai/inspect').then(({ createBrowserInspector }) => {
        // Note: inspector must be created BEFORE the actor.
        // If needed, recreate actor with inspect option.
        // For simplicity, just create inspector and it will observe existing actors.
      });
    } else {
      navigationActor = createActor(navigationMachine);
    }
    navigationActor.start();
    ```

    **Simplest viable approach for NAV-08:** Install `@statelyai/inspect` as a dev dependency. Create the inspector BEFORE the actor. Use conditional dynamic import. If the async import timing is tricky, use a flag/env check at module level.

    Update `src/machines/navigation/index.ts` barrel export to include context.tsx exports.
  </action>
  <verify>
    ```bash
    # Type-check
    npx tsc --noEmit 2>&1 | grep -v "bindings.ts"

    # Verify exports
    grep -r "getNavigationActor\|NavigationProvider\|useNavigationActorRef" src/machines/navigation/
    ```
  </verify>
  <done>
    NavigationProvider component exists and provides actor via React context. getNavigationActor() returns module-level actor. Inspector setup file exists. Barrel export updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add singleton metadata to blade registrations and wire provider into App</name>
  <files>
    src/lib/bladeRegistry.ts
    src/components/blades/registrations/settings.ts
    src/components/blades/registrations/changelog.ts
    src/components/blades/registrations/gitflow-cheatsheet.ts
    src/App.tsx
  </files>
  <action>
    **Enhance BladeRegistration interface** in `src/lib/bladeRegistry.ts`:
    1. Add `singleton?: boolean` field to `BladeRegistration` interface
    2. Add helper function `isSingletonBlade(type: BladeType): boolean` that checks `registry.get(type)?.singleton === true`
    3. Export `isSingletonBlade`

    **Update 3 blade registrations** to add `singleton: true`:
    - `src/components/blades/registrations/settings.ts`: Add `singleton: true` to the registerBlade call
    - `src/components/blades/registrations/changelog.ts`: Add `singleton: true`
    - `src/components/blades/registrations/gitflow-cheatsheet.ts`: Add `singleton: true`

    **Wire NavigationProvider into App.tsx:**
    1. Import `NavigationProvider` from `./machines/navigation/context`
    2. Wrap the entire app content (inside the root div) with `<NavigationProvider>`:
    ```tsx
    return (
      <NavigationProvider>
        <div className="flex flex-col h-screen bg-ctp-base text-ctp-text font-sans">
          <Header />
          ...
        </div>
      </NavigationProvider>
    );
    ```
    3. The Zustand blade store continues to work unchanged. Both systems coexist during migration.

    **Install @statelyai/inspect:**
    ```bash
    npm install --save-dev @statelyai/inspect
    ```
  </action>
  <verify>
    ```bash
    # Install check
    grep "@statelyai/inspect" package.json

    # Singleton metadata
    grep -r "singleton.*true" src/components/blades/registrations/

    # Provider in App
    grep "NavigationProvider" src/App.tsx

    # isSingletonBlade export
    grep "isSingletonBlade" src/lib/bladeRegistry.ts

    # App still builds
    npx vite build 2>&1 | tail -5

    # Existing tests still pass
    npx vitest run
    ```
  </verify>
  <done>
    BladeRegistration has singleton field. 3 registrations marked singleton: true. NavigationProvider wraps App. @statelyai/inspect installed. isSingletonBlade() exported from bladeRegistry. All existing tests pass. App builds without errors.
  </done>
</task>

</tasks>

<verification>
```bash
# Full test suite passes
npx vitest run

# App builds
npx vite build 2>&1 | tail -5

# NavigationProvider in App
grep "NavigationProvider" src/App.tsx

# Singleton metadata on registrations
grep -rn "singleton" src/components/blades/registrations/

# Inspector file exists
ls src/machines/navigation/inspector.ts

# getNavigationActor is accessible
grep "getNavigationActor" src/machines/navigation/context.tsx
```
</verification>

<success_criteria>
- NavigationProvider wraps the App component tree
- getNavigationActor() returns the module-level FSM actor
- @statelyai/inspect is installed as devDependency
- Inspector setup file exists with createBrowserInspector logic
- BladeRegistration interface includes optional `singleton` field
- settings, changelog, gitflow-cheatsheet registrations have `singleton: true`
- isSingletonBlade() helper exported from bladeRegistry
- All existing tests pass (no regressions)
- App builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-xstate-navigation-fsm/26-02-SUMMARY.md`
</output>
