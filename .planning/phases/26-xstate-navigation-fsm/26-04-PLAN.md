---
phase: 26-xstate-navigation-fsm
plan: 04
type: execute
wave: 4
depends_on: ["26-03"]
files_modified:
  - src/machines/navigation/guards.ts
  - src/machines/navigation/navigationMachine.ts
  - src/machines/navigation/navigationMachine.test.ts
  - src/machines/navigation/types.ts
  - src/components/blades/BladeContainer.tsx
  - src/components/blades/BladeStrip.tsx
  - src/components/blades/NavigationGuardDialog.tsx
  - src/hooks/useBladeFormGuard.ts
  - src/stores/blades.ts
  - src/stores/blades.test.ts
autonomous: true

must_haves:
  truths:
    - "User is prevented from navigating away from a blade with dirty form state -- confirmation dialog appears"
    - "User can confirm discard and proceed, or cancel and stay on the current blade"
    - "Dirty blade strips show a yellow dot indicator with subtle pulse animation"
    - "BladeStrip aria-label includes 'Unsaved changes' when blade is dirty"
    - "Max stack depth guard blocks pushes at 8 blades with a toast notification"
    - "Blade dirty state is cleaned up when blades are popped from the stack"
    - "Old Zustand blade store is removed or fully deprecated with redirect"
  artifacts:
    - path: "src/components/blades/NavigationGuardDialog.tsx"
      provides: "Confirmation dialog for unsaved changes"
      contains: "Unsaved Changes"
    - path: "src/hooks/useBladeFormGuard.ts"
      provides: "Hook for blades to register dirty state with FSM"
      exports: ["useBladeFormGuard"]
    - path: "src/components/blades/BladeStrip.tsx"
      provides: "Dirty indicator dot on strips"
      contains: "dirty"
  key_links:
    - from: "src/components/blades/NavigationGuardDialog.tsx"
      to: "src/machines/navigation/context.tsx"
      via: "useSelector for isConfirmingDiscard + useActorRef for CONFIRM/CANCEL"
      pattern: "selectIsConfirmingDiscard"
    - from: "src/hooks/useBladeFormGuard.ts"
      to: "src/machines/navigation/context.tsx"
      via: "useNavigationActorRef().send(MARK_DIRTY/MARK_CLEAN)"
      pattern: "MARK_DIRTY"
    - from: "src/components/blades/BladeStrip.tsx"
      to: "src/machines/navigation/selectors.ts"
      via: "selectDirtyBladeIds to check if blade ID is dirty"
      pattern: "selectDirtyBladeIds"
---

<objective>
Add dirty-form protection, navigation guard dialog, dirty indicators on blade strips, max stack depth enforcement, useBladeFormGuard hook, and clean up the deprecated Zustand store.

Purpose: Complete the remaining NAV requirements: NAV-03 (dirty-form guards), NAV-06 (max stack depth), NAV-10 (dirty indicators), and final cleanup of the old blade store. After this plan, the FSM fully governs all navigation with data-loss prevention, visual indicators, and a clean codebase with no legacy store.

Output: Working dirty-form guard flow with confirmation dialog, dirty indicators on blade strips, max depth enforcement, useBladeFormGuard hook for blade components, and deprecated Zustand store removed.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-xstate-navigation-fsm/26-01-SUMMARY.md
@.planning/phases/26-xstate-navigation-fsm/26-02-SUMMARY.md
@.planning/phases/26-xstate-navigation-fsm/26-03-SUMMARY.md
@.planning/phases/26-xstate-navigation-fsm/26-RESEARCH-UX.md
@.planning/phases/26-xstate-navigation-fsm/26-RESEARCH-ARCHITECTURE.md

@src/machines/navigation/navigationMachine.ts
@src/machines/navigation/guards.ts
@src/machines/navigation/types.ts
@src/machines/navigation/context.tsx
@src/machines/navigation/selectors.ts
@src/components/blades/BladeContainer.tsx
@src/components/blades/BladeStrip.tsx
@src/components/ui/dialog.tsx
@src/stores/blades.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add navigation guard dialog, dirty indicators, useBladeFormGuard hook, and max depth toast</name>
  <files>
    src/components/blades/NavigationGuardDialog.tsx
    src/hooks/useBladeFormGuard.ts
    src/components/blades/BladeContainer.tsx
    src/components/blades/BladeStrip.tsx
    src/machines/navigation/selectors.ts
  </files>
  <action>
    **Create `src/components/blades/NavigationGuardDialog.tsx`:**
    1. Import the existing `Dialog`, `DialogContent`, `DialogHeader`, `DialogTitle`, `DialogDescription`, `DialogFooter` from `../../components/ui/dialog`
    2. Import `useNavigationActorRef` from `../../machines/navigation/context`
    3. Import `useSelector` from `@xstate/react`
    4. Import `selectIsConfirmingDiscard`, `selectDirtyBladeIds`, `selectBladeStack` from `../../machines/navigation/selectors`
    5. Import `AlertTriangle` from `lucide-react`
    6. The dialog is open when `isConfirmingDiscard` is true (FSM is in `confirmingDiscard` state)
    7. Display:
       - Title: "Unsaved Changes"
       - Icon: AlertTriangle with `text-ctp-yellow`
       - Body: "You have unsaved changes in {dirty blade title(s)} that will be lost if you navigate away."
       - To get dirty blade titles: filter bladeStack where blade.id is in dirtyBladeIds
       - "Stay" button (secondary, auto-focus): sends `{ type: 'CANCEL_DISCARD' }` via actorRef
       - "Discard Changes" button (destructive, `bg-ctp-red text-ctp-base`): sends `{ type: 'CONFIRM_DISCARD' }` via actorRef
    8. Escape key closes (stay behavior) -- Dialog component handles this via onOpenChange
    9. `aria-labelledby` on title, `aria-describedby` on body
    10. **Do NOT** add "Save and Leave" button (no generic save action per UX research)

    **Create `src/hooks/useBladeFormGuard.ts`:**
    1. Hook signature: `useBladeFormGuard(bladeId: string)`
    2. Returns: `{ markDirty: () => void, markClean: () => void, isDirty: boolean }`
    3. Uses `useNavigationActorRef()` to get actor ref
    4. Uses `useSelector(actorRef, snap => !!snap.context.dirtyBladeIds[bladeId])` for isDirty
    5. `markDirty` sends `{ type: 'MARK_DIRTY', bladeId }`
    6. `markClean` sends `{ type: 'MARK_CLEAN', bladeId }`
    7. **Automatic cleanup on unmount:** `useEffect(() => () => actorRef.send({ type: 'MARK_CLEAN', bladeId }), [bladeId])`
       This prevents dirty state from leaking when a blade component unmounts

    **Update `src/components/blades/BladeContainer.tsx`:**
    1. Add `<NavigationGuardDialog />` component at the end of the return JSX (always rendered, visibility controlled by FSM state)
    2. Import `NavigationGuardDialog` from `./NavigationGuardDialog`

    **Update `src/components/blades/BladeStrip.tsx`:**
    1. Add `isDirty` prop to `BladeStripProps` interface
    2. Import `Circle` from `lucide-react`
    3. When `isDirty`:
       - Show a yellow dot: `<Circle className="w-2 h-2 fill-ctp-yellow text-ctp-yellow shrink-0 motion-safe:animate-dirty-pulse" />`
       - Add a 2px left border: `isDirty && "border-l-2 border-l-ctp-yellow"`
       - Change title text color to yellow: `isDirty ? "text-ctp-yellow" : "text-ctp-subtext0"`
    4. Update `aria-label` to include dirty state: `` `${isDirty ? 'Unsaved changes in ' : ''}${title} panel. Click to expand.` ``

    **Update BladeContainer to pass isDirty to BladeStrip:**
    1. In BladeContainer, read dirtyBladeIds from FSM: `const dirtyBladeIds = useSelector(actorRef, selectDirtyBladeIds);`
    2. Pass `isDirty={!!dirtyBladeIds[blade.id]}` to each `<BladeStrip>` in the strip loop

    **Add `selectDirtyBladeIds` selector** to `src/machines/navigation/selectors.ts` if not already present:
    ```typescript
    export const selectDirtyBladeIds = (snap: NavSnapshot) => snap.context.dirtyBladeIds;
    ```

    **Max stack depth toast:**
    The FSM guard already blocks pushes at max depth (from Plan 01). Add a toast notification as an effect. In `BladeContainer.tsx` or `useBladeNavigation.ts`, add logic to show a toast when a push is silently blocked by the max depth guard.

    Approach: After sending PUSH_BLADE, check if bladeStack.length didn't change. If the event was sent but stack didn't grow, show toast: `"Maximum blade depth reached. Close some blades first."` This is tricky with async state. Simpler approach: add an `onMaxDepthReached` callback action in the machine that triggers a toast. But XState actions should be pure.

    **Simplest approach for max depth toast:** Add a `PUSH_BLOCKED` event that the machine emits (or an action that calls a registered callback). Actually, the simplest: in the guard, when it returns false, have a side effect in the transition definition. XState v5 doesn't support side effects in guards. Instead: use a separate transition path with `guard: not('isUnderMaxDepth')` that goes to a transient "pushing-blocked" state or executes an action.

    **Practical solution:** In the PUSH_BLADE transitions in the machine, add a third case after singleton and depth guards:
    ```
    PUSH_BLADE: [
      { guard: not('isUnderMaxDepth'), actions: 'notifyMaxDepth' },  // fires toast
      { guard: and(['isNotSingleton', 'isUnderMaxDepth']), actions: 'pushBlade' },
    ]
    ```
    The `notifyMaxDepth` action imports `toast.info("Maximum blade depth reached. Close some blades first.")`. This action is registered in setup({ actions }).

    **Note:** XState actions should ideally be pure, but toast notifications are side effects. Using `toast.info()` in an action is acceptable as a pragmatic choice (the machine is not a server-side machine). Register it as a named action so it can be overridden in tests with `machine.provide()`.
  </action>
  <verify>
    ```bash
    # Type-check
    npx tsc --noEmit 2>&1 | grep -v "bindings.ts"

    # NavigationGuardDialog exists
    ls src/components/blades/NavigationGuardDialog.tsx

    # useBladeFormGuard exists
    ls src/hooks/useBladeFormGuard.ts

    # BladeStrip has dirty prop
    grep "isDirty" src/components/blades/BladeStrip.tsx

    # Dialog rendered in BladeContainer
    grep "NavigationGuardDialog" src/components/blades/BladeContainer.tsx

    # Build
    npx vite build 2>&1 | tail -5
    ```
  </verify>
  <done>
    NavigationGuardDialog shows when FSM enters confirmingDiscard state. useBladeFormGuard hook provides markDirty/markClean/isDirty with automatic cleanup. BladeStrip shows yellow dot + border for dirty blades with proper aria-label. Max depth toast fires when push is blocked. All types check and build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add machine tests for dirty-form flow, clean up old store, update existing tests</name>
  <files>
    src/machines/navigation/navigationMachine.test.ts
    src/stores/blades.ts
    src/stores/blades.test.ts
  </files>
  <action>
    **Add dirty-form flow tests to `src/machines/navigation/navigationMachine.test.ts`:**
    If these tests weren't added in Plan 01 (they should have been since the machine supports them), verify they exist and add any missing:

    1. `it('POP_TO_INDEX with dirty blade above index enters confirmingDiscard')`
    2. `it('REPLACE_BLADE with dirty top blade enters confirmingDiscard')`
    3. `it('SWITCH_PROCESS with dirty blades enters confirmingDiscard')`
    4. `it('RESET_STACK with dirty blades enters confirmingDiscard')`
    5. `it('CONFIRM_DISCARD after SWITCH_PROCESS performs the switch')`
    6. `it('pendingEvent is stored correctly when entering confirmingDiscard')`
    7. `it('pendingEvent is cleared after CONFIRM_DISCARD')`
    8. `it('pendingEvent is cleared after CANCEL_DISCARD')`
    9. `it('max depth guard blocks push and triggers notifyMaxDepth action')` -- test with machine.provide to override notifyMaxDepth
    10. `it('popping a blade clears its dirty entry from dirtyBladeIds')`
    11. `it('resetStack clears all dirty entries')`
    12. `it('MARK_CLEAN on unmount removes blade from dirtyBladeIds')`

    **Deprecate/remove old Zustand blade store:**
    1. Check if ANY production code still imports `useBladeStore` from `src/stores/blades.ts` (should be zero after Plan 03)
    2. If zero imports remain: Add a large deprecation comment and mark all exports as `@deprecated`. Keep the file for reference but make it clear it's dead code.
    3. If the test file `src/stores/blades.test.ts` exists and tests old store behavior: either remove the file entirely (the machine tests now cover this) OR keep it but mark as deprecated.
    4. Verify no circular dependencies were introduced.

    **Final cleanup:**
    1. Verify barrel export `src/machines/navigation/index.ts` exports everything needed
    2. Verify `ProcessType` is exported from `src/machines/navigation/types.ts` and used consistently (not from `src/stores/blades.ts`)
    3. Run full test suite and fix any failures
  </action>
  <verify>
    ```bash
    # All machine tests pass
    npx vitest run src/machines/navigation/navigationMachine.test.ts

    # Full test suite passes
    npx vitest run

    # No useBladeStore in production code
    grep -rn "useBladeStore" src/ --include="*.ts" --include="*.tsx" | grep -v "test\|__mocks__\|stores/blades.ts"
    # Should return zero lines

    # Type-check
    npx tsc --noEmit 2>&1 | grep -v "bindings.ts"

    # Build
    npx vite build 2>&1 | tail -5
    ```
  </verify>
  <done>
    Machine tests cover all dirty-form scenarios (12+ test cases). Old Zustand blade store marked as deprecated with no production consumers. Full test suite passes. App builds. ProcessType imported from navigation types consistently.
  </done>
</task>

</tasks>

<verification>
```bash
# Full test suite
npx vitest run

# Machine test count
npx vitest run src/machines/navigation/navigationMachine.test.ts --reporter=verbose 2>&1 | grep "✓\|✗" | wc -l
# Should be 30+

# No production useBladeStore usage
grep -rn "useBladeStore" src/ --include="*.ts" --include="*.tsx" | grep -v "test\|__mocks__\|stores/blades.ts" | wc -l
# Should be 0

# NavigationGuardDialog exists and renders
grep "NavigationGuardDialog" src/components/blades/BladeContainer.tsx

# Dirty indicators
grep "isDirty" src/components/blades/BladeStrip.tsx

# useBladeFormGuard hook
grep "useBladeFormGuard" src/hooks/useBladeFormGuard.ts

# Build
npx vite build 2>&1 | tail -5
```
</verification>

<success_criteria>
- NavigationGuardDialog appears when FSM enters confirmingDiscard state
- "Stay" button sends CANCEL_DISCARD, "Discard Changes" sends CONFIRM_DISCARD
- Dialog shows dirty blade title(s) in the message body
- BladeStrip shows yellow dot indicator for dirty blades
- BladeStrip aria-label includes "Unsaved changes" for dirty blades
- useBladeFormGuard hook auto-cleans dirty state on unmount
- Max depth guard fires toast notification when push is blocked
- 30+ machine tests pass covering all navigation and dirty-form scenarios
- Old Zustand blade store marked deprecated, no production consumers
- App builds without errors
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/26-xstate-navigation-fsm/26-04-SUMMARY.md`
</output>
