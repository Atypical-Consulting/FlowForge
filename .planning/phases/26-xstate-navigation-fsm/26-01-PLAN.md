---
phase: 26-xstate-navigation-fsm
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/machines/navigation/types.ts
  - src/machines/navigation/guards.ts
  - src/machines/navigation/actions.ts
  - src/machines/navigation/navigationMachine.ts
  - src/machines/navigation/selectors.ts
  - src/machines/navigation/navigationMachine.test.ts
  - src/machines/navigation/index.ts
autonomous: true

must_haves:
  truths:
    - "XState navigation machine starts in navigating state with staging root blade"
    - "PUSH_BLADE adds a blade to the stack with forward lastAction"
    - "POP_BLADE removes the top blade with pop lastAction, but never the root blade"
    - "Singleton guard blocks duplicate settings/changelog/gitflow-cheatsheet blades"
    - "SWITCH_PROCESS atomically resets stack to new process root blade"
    - "MARK_DIRTY / MARK_CLEAN track dirty blade IDs in context"
    - "Dirty top blade triggers confirmingDiscard state on POP_BLADE"
    - "CONFIRM_DISCARD replays pendingEvent and clears dirty state"
    - "CANCEL_DISCARD returns to navigating with no stack change"
    - "Max stack depth guard blocks pushes when limit reached"
  artifacts:
    - path: "src/machines/navigation/types.ts"
      provides: "NavigationContext, NavigationEvent, ProcessType types"
      contains: "NavigationContext"
    - path: "src/machines/navigation/guards.ts"
      provides: "Named guard implementations"
      exports: ["navigationGuards"]
    - path: "src/machines/navigation/actions.ts"
      provides: "Named action implementations with assign()"
      exports: ["navigationActions"]
    - path: "src/machines/navigation/navigationMachine.ts"
      provides: "XState v5 machine definition with setup()"
      exports: ["navigationMachine"]
    - path: "src/machines/navigation/selectors.ts"
      provides: "Typed snapshot selectors"
      exports: ["selectBladeStack", "selectActiveBlade", "selectActiveProcess", "selectIsConfirmingDiscard", "selectLastAction", "selectDirtyBladeIds"]
    - path: "src/machines/navigation/navigationMachine.test.ts"
      provides: "Comprehensive pure machine tests"
      min_lines: 150
    - path: "src/machines/navigation/index.ts"
      provides: "Public barrel export"
  key_links:
    - from: "src/machines/navigation/navigationMachine.ts"
      to: "src/machines/navigation/guards.ts"
      via: "setup({ guards })"
      pattern: "import.*guards"
    - from: "src/machines/navigation/navigationMachine.ts"
      to: "src/machines/navigation/actions.ts"
      via: "setup({ actions })"
      pattern: "import.*actions"
    - from: "src/machines/navigation/navigationMachine.ts"
      to: "src/stores/bladeTypes.ts"
      via: "TypedBlade, BladeType types"
      pattern: "import.*bladeTypes"
---

<objective>
Define the XState v5 navigation machine with full type safety, named guards, named actions, and comprehensive pure machine tests using TDD.

Purpose: Create the core FSM that will replace the imperative Zustand blade store. This machine is the single source of truth for blade navigation state, enforcing valid transitions, singleton constraints, dirty-form guards, max stack depth, and process switching -- all testable without React or DOM.

Output: Working, fully tested XState machine in `src/machines/navigation/` with all guards, actions, and types. Tests verify every NAV requirement's machine-level behavior.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-xstate-navigation-fsm/26-RESEARCH-ARCHITECTURE.md
@.planning/phases/26-xstate-navigation-fsm/26-RESEARCH-IMPLEMENTATION.md

@src/stores/bladeTypes.ts
@src/stores/blades.ts
@src/lib/bladeRegistry.ts
@src/lib/xstate-example.test.ts
</context>

<task type="tdd">
<files>
  src/machines/navigation/types.ts
  src/machines/navigation/guards.ts
  src/machines/navigation/actions.ts
  src/machines/navigation/navigationMachine.ts
  src/machines/navigation/selectors.ts
  src/machines/navigation/navigationMachine.test.ts
  src/machines/navigation/index.ts
</files>
<action>
Create the XState v5 navigation machine using TDD (write tests RED first, then make them GREEN).

**Machine Architecture:**

Two states:
- `navigating` (initial): Normal state. Accepts PUSH_BLADE, POP_BLADE, POP_TO_INDEX, REPLACE_BLADE, RESET_STACK, SWITCH_PROCESS, MARK_DIRTY, MARK_CLEAN.
- `confirmingDiscard`: Entered when a destructive navigation event fires while dirty blades exist. Stores `pendingEvent` in context. Accepts CONFIRM_DISCARD or CANCEL_DISCARD.

Context shape:
```typescript
{
  activeProcess: ProcessType;           // 'staging' | 'topology'
  bladeStack: TypedBlade[];             // The blade stack array
  dirtyBladeIds: Record&lt;string, true&gt;;  // Plain object (not Set) for reference equality
  lastAction: 'push' | 'pop' | 'replace' | 'reset' | 'init';  // For animation direction
  maxStackDepth: number;                // Default 8
  pendingEvent: NavigationEvent | null; // Stored when entering confirmingDiscard
}
```

**Guards (named, registered in setup()):**
- `isNotSingleton`: Returns true if blade type is not singleton OR is singleton but not in stack
- `isUnderMaxDepth`: `bladeStack.length &lt; maxStackDepth`
- `hasMultipleBlades`: `bladeStack.length &gt; 1`
- `hasDirtyBlades`: `Object.keys(dirtyBladeIds).length &gt; 0`
- `isTopBladeDirty`: Top blade's ID is in `dirtyBladeIds`
- `isValidIndex`: Event index is within stack bounds
- `hasDirtyBladesAboveIndex`: For POP_TO_INDEX, checks if any blade being removed is dirty

**Dirty-form transition logic:**
- PUSH_BLADE: Does NOT check dirty (pushing adds to stack, does not discard)
- POP_BLADE: If top blade dirty -> confirmingDiscard. If clean -> pop.
- POP_TO_INDEX: If any blade above index dirty -> confirmingDiscard. If clean -> pop.
- REPLACE_BLADE: If top blade dirty -> confirmingDiscard. If clean -> replace.
- RESET_STACK / SWITCH_PROCESS: If any dirty blade -> confirmingDiscard. If clean -> reset/switch.

**Actions (named, registered in setup() using assign()):**
- `pushBlade`: Append blade with crypto.randomUUID(), set lastAction='push'
- `popBlade`: Remove top, clean its dirty entry, set lastAction='pop'
- `popToIndex`: Slice stack, clean dirty entries for removed blades, set lastAction='pop'
- `replaceBlade`: Replace top with new blade, set lastAction='replace'
- `resetStack`: Reset to process root, clear all dirty, set lastAction='reset'
- `switchProcess`: Change process + reset stack, clear dirty, set lastAction='reset'
- `markDirty` / `markClean`: Add/remove bladeId from dirtyBladeIds
- `storePendingEvent` / `clearPendingEvent`: Manage pendingEvent in context
- `clearAllDirty`: Empty dirtyBladeIds

**Implementation approach:**
Use XState v5 `setup().createMachine()` with typed context/events. Named guards in setup({ guards }), named actions in setup({ actions }). Guard combinators: `and()`, `not()` from xstate. `Record&lt;string, true&gt;` for dirtyBladeIds (not Set). For CONFIRM_DISCARD: use `enqueueActions` to conditionally replay pendingEvent. SINGLETON_TYPES initially hardcoded (moved to registry in plan 02).

**TDD test cases (21 cases, RED first then GREEN):**
1. Starts in navigating with staging root blade
2. PUSH_BLADE adds blade, sets lastAction='push'
3. POP_BLADE removes top blade when stack > 1, sets lastAction='pop'
4. POP_BLADE is no-op when only root blade exists
5. POP_TO_INDEX slices stack to index
6. REPLACE_BLADE swaps top blade, sets lastAction='replace'
7. RESET_STACK returns to single root blade
8. SWITCH_PROCESS changes process and resets to new root
9. Singleton guard blocks duplicate settings push
10. Singleton guard allows non-singleton duplicates
11. Max stack depth guard blocks push at limit
12. MARK_DIRTY adds blade ID to dirtyBladeIds
13. MARK_CLEAN removes blade ID from dirtyBladeIds
14. POP_BLADE on dirty top blade enters confirmingDiscard with pendingEvent
15. CONFIRM_DISCARD from confirmingDiscard pops blade and returns to navigating
16. CANCEL_DISCARD from confirmingDiscard returns to navigating with no stack change
17. SWITCH_PROCESS with dirty blades enters confirmingDiscard
18. RESET_STACK with dirty blades enters confirmingDiscard
19. PUSH_BLADE does NOT trigger confirmingDiscard (pushing doesn't discard)
20. Popped blade IDs are removed from dirtyBladeIds
21. machine.provide() can override guards for testing
</action>

<verify>
```bash
# Run pure machine tests
npx vitest run src/machines/navigation/navigationMachine.test.ts

# Type-check
npx tsc --noEmit 2>&1 | grep -v "bindings.ts"

# All 21 test cases pass
```
</verify>

<done>
- All 21+ test cases pass in navigationMachine.test.ts
- Machine starts in navigating state with staging root blade
- All 6 navigation operations (push/pop/popToIndex/replace/reset/switchProcess) work correctly
- Singleton guard blocks duplicate pushes for settings, changelog, gitflow-cheatsheet
- Max depth guard blocks pushes at limit
- Dirty-form guard routes to confirmingDiscard state with pendingEvent
- CONFIRM_DISCARD replays pending action and clears dirty state
- CANCEL_DISCARD returns to navigating with no changes
- No TypeScript errors (excluding pre-existing bindings.ts)
- No React or DOM dependencies in any machine file
</done>
</task>

<output>
After completion, create `.planning/phases/26-xstate-navigation-fsm/26-01-SUMMARY.md`
</output>
