---
phase: 26-xstate-navigation-fsm
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/machines/navigation/types.ts
  - src/machines/navigation/guards.ts
  - src/machines/navigation/actions.ts
  - src/machines/navigation/navigationMachine.ts
  - src/machines/navigation/selectors.ts
  - src/machines/navigation/navigationMachine.test.ts
  - src/machines/navigation/index.ts
autonomous: true

must_haves:
  truths:
    - "XState navigation machine starts in navigating state with staging root blade"
    - "PUSH_BLADE adds a blade to the stack with forward lastAction"
    - "POP_BLADE removes the top blade with pop lastAction, but never the root blade"
    - "Singleton guard blocks duplicate settings/changelog/gitflow-cheatsheet blades"
    - "SWITCH_PROCESS atomically resets stack to new process root blade"
    - "MARK_DIRTY / MARK_CLEAN track dirty blade IDs in context"
    - "Dirty top blade triggers confirmingDiscard state on POP_BLADE"
    - "CONFIRM_DISCARD replays pendingEvent and clears dirty state"
    - "CANCEL_DISCARD returns to navigating with no stack change"
    - "Max stack depth guard blocks pushes when limit reached"
  artifacts:
    - path: "src/machines/navigation/types.ts"
      provides: "NavigationContext, NavigationEvent, ProcessType types"
      contains: "NavigationContext"
    - path: "src/machines/navigation/guards.ts"
      provides: "Named guard implementations"
      exports: ["navigationGuards"]
    - path: "src/machines/navigation/actions.ts"
      provides: "Named action implementations with assign()"
      exports: ["navigationActions"]
    - path: "src/machines/navigation/navigationMachine.ts"
      provides: "XState v5 machine definition with setup()"
      exports: ["navigationMachine"]
    - path: "src/machines/navigation/selectors.ts"
      provides: "Typed snapshot selectors"
      exports: ["selectBladeStack", "selectActiveBlade", "selectActiveProcess", "selectIsConfirmingDiscard", "selectLastAction", "selectDirtyBladeIds"]
    - path: "src/machines/navigation/navigationMachine.test.ts"
      provides: "Comprehensive pure machine tests"
      min_lines: 150
    - path: "src/machines/navigation/index.ts"
      provides: "Public barrel export"
  key_links:
    - from: "src/machines/navigation/navigationMachine.ts"
      to: "src/machines/navigation/guards.ts"
      via: "setup({ guards })"
      pattern: "import.*guards"
    - from: "src/machines/navigation/navigationMachine.ts"
      to: "src/machines/navigation/actions.ts"
      via: "setup({ actions })"
      pattern: "import.*actions"
    - from: "src/machines/navigation/navigationMachine.ts"
      to: "src/stores/bladeTypes.ts"
      via: "TypedBlade, BladeType types"
      pattern: "import.*bladeTypes"
---

<objective>
Define the XState v5 navigation machine with full type safety, named guards, named actions, and comprehensive pure machine tests using TDD.

Purpose: Create the core FSM that will replace the imperative Zustand blade store. This machine is the single source of truth for blade navigation state, enforcing valid transitions, singleton constraints, dirty-form guards, max stack depth, and process switching -- all testable without React or DOM.

Output: Working, fully tested XState machine in `src/machines/navigation/` with all guards, actions, and types. Tests verify every NAV requirement's machine-level behavior.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-xstate-navigation-fsm/26-RESEARCH-ARCHITECTURE.md
@.planning/phases/26-xstate-navigation-fsm/26-RESEARCH-IMPLEMENTATION.md

@src/stores/bladeTypes.ts
@src/stores/blades.ts
@src/lib/bladeRegistry.ts
@src/lib/xstate-example.test.ts
</context>

<task type="tdd">
<feature>
  <name>XState Navigation Machine (TDD)</name>
  <files>
    src/machines/navigation/types.ts
    src/machines/navigation/guards.ts
    src/machines/navigation/actions.ts
    src/machines/navigation/navigationMachine.ts
    src/machines/navigation/selectors.ts
    src/machines/navigation/navigationMachine.test.ts
    src/machines/navigation/index.ts
  </files>
  <behavior>
    The navigation machine governs all blade stack operations via typed events and guards.

    **States:**
    - `navigating` (initial): Normal state. Accepts PUSH_BLADE, POP_BLADE, POP_TO_INDEX, REPLACE_BLADE, RESET_STACK, SWITCH_PROCESS, MARK_DIRTY, MARK_CLEAN.
    - `confirmingDiscard`: Entered when a destructive navigation event (POP_BLADE, POP_TO_INDEX, REPLACE_BLADE, RESET_STACK, SWITCH_PROCESS) fires while dirty blades exist. Stores the `pendingEvent` in context. Accepts CONFIRM_DISCARD (replays pending event, clears dirty) or CANCEL_DISCARD (returns to navigating, no change).

    **Context:**
    ```typescript
    {
      activeProcess: ProcessType;           // 'staging' | 'topology'
      bladeStack: TypedBlade[];             // The blade stack array
      dirtyBladeIds: Record<string, true>;  // Plain object (not Set) for reference equality
      lastAction: 'push' | 'pop' | 'replace' | 'reset' | 'init';  // For animation direction
      maxStackDepth: number;                // Default 8
      pendingEvent: NavigationEvent | null; // Stored when entering confirmingDiscard
    }
    ```

    **Guards (named, registered in setup()):**
    - `isNotSingleton`: Checks blade registry `singleton` field (or hardcoded list initially). Returns true if blade type is not singleton OR is singleton but not in stack.
    - `isUnderMaxDepth`: `bladeStack.length < maxStackDepth`
    - `hasMultipleBlades`: `bladeStack.length > 1`
    - `hasDirtyBlades`: `Object.keys(dirtyBladeIds).length > 0`
    - `isTopBladeDirty`: Top blade's ID is in `dirtyBladeIds`
    - `isValidIndex`: Event index is within stack bounds
    - `hasDirtyBladesAboveIndex`: For POP_TO_INDEX, checks if any blade being removed is dirty

    **Transition logic for dirty-form handling:**
    - PUSH_BLADE: Does NOT check dirty (pushing adds to stack, does not discard)
    - POP_BLADE: If top blade is dirty -> confirmingDiscard. If clean -> pop.
    - POP_TO_INDEX: If any blade above index is dirty -> confirmingDiscard. If clean -> pop.
    - REPLACE_BLADE: If top blade is dirty -> confirmingDiscard. If clean -> replace.
    - RESET_STACK: If any dirty blade -> confirmingDiscard. If clean -> reset.
    - SWITCH_PROCESS: If any dirty blade -> confirmingDiscard. If clean -> switch.

    **Actions (named, registered in setup()):**
    - `pushBlade`: Append blade with crypto.randomUUID(), set lastAction='push'
    - `popBlade`: Remove top, clean its dirty entry, set lastAction='pop'
    - `popToIndex`: Slice stack, clean dirty entries for removed blades, set lastAction='pop'
    - `replaceBlade`: Replace top with new blade, set lastAction='replace'
    - `resetStack`: Reset to process root, clear all dirty, set lastAction='reset'
    - `switchProcess`: Change process + reset stack, clear dirty, set lastAction='reset'
    - `markDirty`: Add bladeId to dirtyBladeIds
    - `markClean`: Remove bladeId from dirtyBladeIds
    - `storePendingEvent`: Save the original event to context.pendingEvent
    - `clearPendingEvent`: Set pendingEvent to null
    - `clearAllDirty`: Empty dirtyBladeIds

    **Test cases (RED first, then GREEN):**
    1. Starts in navigating with staging root blade
    2. PUSH_BLADE adds blade, sets lastAction='push'
    3. POP_BLADE removes top blade when stack > 1, sets lastAction='pop'
    4. POP_BLADE is no-op when only root blade exists
    5. POP_TO_INDEX slices stack to index
    6. REPLACE_BLADE swaps top blade, sets lastAction='replace'
    7. RESET_STACK returns to single root blade
    8. SWITCH_PROCESS changes process and resets to new root
    9. Singleton guard blocks duplicate settings push
    10. Singleton guard allows non-singleton duplicates
    11. Max stack depth guard blocks push at limit
    12. MARK_DIRTY adds blade ID to dirtyBladeIds
    13. MARK_CLEAN removes blade ID from dirtyBladeIds
    14. POP_BLADE on dirty top blade enters confirmingDiscard with pendingEvent
    15. CONFIRM_DISCARD from confirmingDiscard pops blade and returns to navigating
    16. CANCEL_DISCARD from confirmingDiscard returns to navigating with no stack change
    17. SWITCH_PROCESS with dirty blades enters confirmingDiscard
    18. RESET_STACK with dirty blades enters confirmingDiscard
    19. PUSH_BLADE does NOT trigger confirmingDiscard (pushing doesn't discard)
    20. Popped blade IDs are removed from dirtyBladeIds
    21. machine.provide() can override guards for testing
  </behavior>
  <implementation>
    Use XState v5 `setup().createMachine()` pattern. Follow the architecture research exactly:
    - `setup()` with typed context and events
    - Named guards registered in setup({ guards })
    - Named actions registered in setup({ actions }) using assign()
    - Guard combinators: `and()`, `not()` from xstate where useful
    - `Record<string, true>` for dirtyBladeIds (not Set) to avoid reference equality issues with useSelector
    - `pendingEvent` stored in context for confirmingDiscard replay
    - `rootBladeForProcess()` helper shared between actions (imported from types or defined locally)
    - SINGLETON_TYPES initially hardcoded in guards (will be moved to registry in plan 02)

    For CONFIRM_DISCARD action: use `enqueueActions` to conditionally execute the pending action based on pendingEvent.type. Clear pendingEvent and dirty state for affected blades.
  </implementation>
</feature>

<verify>
```bash
# Run pure machine tests
npx vitest run src/machines/navigation/navigationMachine.test.ts

# Type-check
npx tsc --noEmit 2>&1 | grep -v "bindings.ts"

# All 21 test cases pass
```
</verify>

<done>
- All 21+ test cases pass in navigationMachine.test.ts
- Machine starts in navigating state with staging root blade
- All 6 navigation operations (push/pop/popToIndex/replace/reset/switchProcess) work correctly
- Singleton guard blocks duplicate pushes for settings, changelog, gitflow-cheatsheet
- Max depth guard blocks pushes at limit
- Dirty-form guard routes to confirmingDiscard state with pendingEvent
- CONFIRM_DISCARD replays pending action and clears dirty state
- CANCEL_DISCARD returns to navigating with no changes
- No TypeScript errors (excluding pre-existing bindings.ts)
- No React or DOM dependencies in any machine file
</done>
</task>

<output>
After completion, create `.planning/phases/26-xstate-navigation-fsm/26-01-SUMMARY.md`
</output>
