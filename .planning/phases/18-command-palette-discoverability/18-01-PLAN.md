---
phase: 18-command-palette-discoverability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/commandRegistry.ts
  - src/lib/fuzzySearch.ts
  - src/stores/commandPalette.ts
autonomous: true

must_haves:
  truths:
    - "A typed Command interface exists with id, title, description, category, shortcut, icon, action, enabled fields"
    - "registerCommand() adds a command to the registry and getCommands()/getEnabledCommands() retrieve them"
    - "searchCommands() returns scored results ordered by exact > starts-with > substring > description > fuzzy"
    - "Zustand store manages palette open/close state, query string, and selectedIndex"
  artifacts:
    - path: "src/lib/commandRegistry.ts"
      provides: "Command type, CommandCategory type, registerCommand, getCommands, getEnabledCommands, getCommandById, executeCommand"
      exports: ["Command", "CommandCategory", "registerCommand", "getCommands", "getEnabledCommands", "getCommandById", "executeCommand"]
    - path: "src/lib/fuzzySearch.ts"
      provides: "Fuzzy search with tiered scoring and match range highlighting"
      exports: ["searchCommands", "ScoredCommand", "fuzzyMatch", "highlightMatches"]
    - path: "src/stores/commandPalette.ts"
      provides: "Zustand store for palette UI state"
      exports: ["useCommandPaletteStore"]
  key_links:
    - from: "src/lib/fuzzySearch.ts"
      to: "src/lib/commandRegistry.ts"
      via: "imports Command type"
      pattern: "import.*Command.*from.*commandRegistry"
---

<objective>
Create the command registry infrastructure, fuzzy search utility, and command palette Zustand store.

Purpose: These three modules form the foundation for the command palette feature. The registry provides a typed, module-level command storage following the existing ViewerRegistry.ts pattern. The fuzzy search scores and ranks commands with match highlighting. The store manages palette open/close UI state.

Output: Three new library/store files that are pure logic with no UI. Ready for command registration (Plan 03) and palette UI (Plan 04).
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/viewers/ViewerRegistry.ts
@src/stores/toast.ts
@src/stores/settings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create command registry module and fuzzy search utility</name>
  <files>src/lib/commandRegistry.ts, src/lib/fuzzySearch.ts</files>
  <action>
Create `src/lib/commandRegistry.ts` following the ViewerRegistry.ts pattern (module-level array, NOT a Zustand store):

1. Define `CommandCategory` type union: `"Repository" | "Branches" | "Sync" | "Stash" | "Tags" | "Worktrees" | "Navigation" | "Settings"`

2. Define `Command` interface:
   - `id: string` (kebab-case, e.g., "open-repository")
   - `title: string` (display title, e.g., "Open Repository")
   - `description?: string` (shown below title in palette)
   - `category: CommandCategory`
   - `shortcut?: string` (react-hotkeys-hook format: "mod+shift+p")
   - `icon?: LucideIcon` (from lucide-react)
   - `action: () => void | Promise<void>` (the command handler)
   - `enabled?: () => boolean` (dynamic predicate, defaults to `() => true`)
   - `keywords?: string[]` (additional search terms)

3. Module-level `const commands: Command[] = []`

4. Export functions:
   - `registerCommand(cmd: Command): void` — push to array, prevent duplicate IDs (replace if exists)
   - `getCommands(): Command[]` — return all commands
   - `getEnabledCommands(): Command[]` — filter by `enabled()` predicate (default to true if not provided)
   - `getCommandById(id: string): Command | undefined` — find by id
   - `executeCommand(id: string): void` — find command, check enabled, call action()

Create `src/lib/fuzzySearch.ts`:

1. Define `ScoredCommand` interface: `{ command: Command; score: number; matchedRanges: [number, number][] }`

2. Implement `searchCommands(query: string, commands: Command[]): ScoredCommand[]`:
   - If query is empty/whitespace, return all commands with score 0 and empty ranges
   - Lowercase comparison throughout
   - Tiered scoring:
     - Exact title match: score 100, full title range
     - Title starts-with: score 80, prefix range
     - Title contains (substring): score 60, substring range
     - Description contains: score 40, empty ranges (match is in description, not title)
     - Keywords match: score 35, empty ranges
     - Fuzzy subsequence in title: score 20, character ranges from fuzzyMatch
   - Sort by score descending
   - Return only matches (filter out nulls)

3. Implement `fuzzyMatch(query: string, text: string): [number, number][] | null`:
   - Simple subsequence matcher: all query chars appear in text in order
   - Track contiguous ranges for highlighting
   - Return null if not all chars match
   - Return array of [startIndex, endIndex] ranges for matched character groups

4. Implement `highlightMatches` as a utility type/interface for the UI to consume (return the ranges, let the component handle rendering).

IMPORTANT: Do NOT use fuse.js. The research consensus (2 of 3 researchers) recommends hand-rolled fuzzy search for ~13 commands. It has zero bundle impact and is simpler.

Use `import type { LucideIcon } from "lucide-react"` for the icon type (type-only import).
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors in commandRegistry.ts or fuzzySearch.ts. Both files should compile cleanly.
  </verify>
  <done>
commandRegistry.ts exports Command type and CRUD functions. fuzzySearch.ts exports tiered scoring search with match highlighting ranges. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create command palette Zustand store</name>
  <files>src/stores/commandPalette.ts</files>
  <action>
Create `src/stores/commandPalette.ts` following the existing store pattern (see `src/stores/settings.ts` as reference):

1. Define `CommandPaletteState` interface:
   - `isOpen: boolean` (default false)
   - `query: string` (default "")
   - `selectedIndex: number` (default 0)
   - `open: () => void` — sets isOpen true, resets query and selectedIndex to defaults
   - `close: () => void` — sets isOpen false, resets query and selectedIndex
   - `toggle: () => void` — if open, close; if closed, open (with reset)
   - `setQuery: (query: string) => void` — updates query, resets selectedIndex to 0
   - `setSelectedIndex: (index: number) => void` — updates selectedIndex

2. Export `useCommandPaletteStore` created with `create<CommandPaletteState>((set) => ({...}))`

3. No middleware needed (no persistence, no devtools). Match existing store conventions exactly.

4. Do NOT put the command list in this store. Commands live in the registry module (commandRegistry.ts). This store only handles palette UI state.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors in commandPalette.ts. Store should compile cleanly.
  </verify>
  <done>
useCommandPaletteStore exports a Zustand store with isOpen, query, selectedIndex state and open/close/toggle/setQuery/setSelectedIndex actions. No commands stored in this store.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (ignore pre-existing TS2440 in bindings.ts)
2. All three new files exist and export their documented interfaces
3. commandRegistry.ts follows ViewerRegistry.ts pattern (module-level array, not Zustand)
4. fuzzySearch.ts implements tiered scoring: exact (100) > starts-with (80) > substring (60) > description (40) > keywords (35) > fuzzy (20)
5. commandPalette.ts follows existing Zustand store conventions
</verification>

<success_criteria>
- Command, CommandCategory types are exported and usable
- registerCommand/getCommands/getEnabledCommands/getCommandById/executeCommand all exported
- searchCommands returns ScoredCommand[] with proper scoring tiers
- fuzzyMatch returns character ranges for highlight rendering
- useCommandPaletteStore manages palette UI state independently from command data
</success_criteria>

<output>
After completion, create `.planning/phases/18-command-palette-discoverability/18-01-SUMMARY.md`
</output>
