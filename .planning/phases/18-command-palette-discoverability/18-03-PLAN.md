---
phase: 18-command-palette-discoverability
plan: 03
type: execute
wave: 2
depends_on: ["18-01", "18-02"]
files_modified:
  - src/commands/repository.ts
  - src/commands/sync.ts
  - src/commands/branches.ts
  - src/commands/navigation.ts
  - src/commands/settings.ts
  - src/commands/index.ts
autonomous: true

must_haves:
  truths:
    - "All 14 commands are registered: open-repository, close-repository, clone-repository, open-settings, push, pull, fetch, stage-all, toggle-amend, create-branch, generate-changelog, refresh-all, toggle-theme, command-palette"
    - "Commands that require an open repo have enabled predicates that check useRepositoryStore.getState().status"
    - "Command actions use getState() or CustomEvent dispatches — no React hooks in action closures"
    - "Each command has an appropriate Lucide icon, category, and description"
  artifacts:
    - path: "src/commands/repository.ts"
      provides: "open-repository, close-repository, clone-repository, generate-changelog, refresh-all commands"
    - path: "src/commands/sync.ts"
      provides: "push, pull, fetch, stage-all, toggle-amend commands"
    - path: "src/commands/branches.ts"
      provides: "create-branch command"
    - path: "src/commands/navigation.ts"
      provides: "command-palette command (self-referential)"
    - path: "src/commands/settings.ts"
      provides: "open-settings, toggle-theme commands"
    - path: "src/commands/index.ts"
      provides: "Barrel that imports all command files to trigger registration"
  key_links:
    - from: "src/commands/sync.ts"
      to: "src/lib/commandRegistry.ts"
      via: "registerCommand calls"
      pattern: "registerCommand\\("
    - from: "src/commands/navigation.ts"
      to: "src/stores/commandPalette.ts"
      via: "toggle palette action"
      pattern: "useCommandPaletteStore\\.getState\\(\\)\\.toggle"
    - from: "src/commands/repository.ts"
      to: "src/stores/repository.ts"
      via: "enabled predicate checks repo status"
      pattern: "useRepositoryStore\\.getState\\(\\)"
---

<objective>
Register all 14 initial commands in category-organized files, creating the complete command catalog for the palette.

Purpose: Commands are the data that powers both the command palette UI and future shortcut-from-registry binding. Each command declares its title, description, category, icon, shortcut, action, and enabled predicate. The commands/index.ts barrel ensures all commands register at import time.

Output: Six new files in src/commands/ with all 14 commands registered. Importing commands/index.ts triggers registration.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-command-palette-discoverability/18-01-SUMMARY.md
@.planning/phases/18-command-palette-discoverability/18-02-SUMMARY.md
@src/lib/commandRegistry.ts
@src/stores/commandPalette.ts
@src/hooks/useKeyboardShortcuts.ts
@src/stores/repository.ts
@src/stores/settings.ts
@src/stores/changelogStore.ts
@src/stores/theme.ts
@src/stores/branches.ts
@src/components/Header.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create command registration files for all categories</name>
  <files>src/commands/repository.ts, src/commands/sync.ts, src/commands/branches.ts, src/commands/navigation.ts, src/commands/settings.ts</files>
  <action>
Create five command registration files. Each file imports `registerCommand` from `../lib/commandRegistry` and registers commands for its category.

**CRITICAL PATTERNS:**
- All `action` closures use `useXxxStore.getState().method()` for store interactions (imperative, outside React — same pattern as `toast.success()` in toast.ts)
- For actions that need CustomEvent (open-repository-dialog, clone-repository-dialog, toggle-amend): use `document.dispatchEvent(new CustomEvent("event-name"))`
- For sync operations (push, pull, fetch): Command actions invoke Tauri commands directly via `commands.pushToRemote()` etc., with `Channel` + `toast` feedback. These are fire-and-forget from the palette's perspective (no loading spinner in palette, toast provides feedback)
- `enabled` predicates: `() => !!useRepositoryStore.getState().status` for repo-requiring commands
- Import `Channel` from `@tauri-apps/api/core` and `commands as tauriCommands` from `../bindings` (rename to avoid collision with the folder name)
- Import `type { SyncProgress }` from `../bindings`

**src/commands/repository.ts** — 5 commands:

1. `open-repository`: category "Repository", shortcut "mod+o", icon FolderOpen, action dispatches "open-repository-dialog" CustomEvent, always enabled, description "Open a local Git repository"
2. `close-repository`: category "Repository", no shortcut, icon X, action calls `useRepositoryStore.getState().closeRepository()`, enabled when repo open, description "Close the current repository"
3. `clone-repository`: category "Repository", no shortcut, icon GitFork, action dispatches "clone-repository-dialog" CustomEvent, always enabled, description "Clone a remote Git repository"
4. `generate-changelog`: category "Repository", no shortcut, icon FileText, action calls `useChangelogStore.getState().openDialog()`, enabled when repo open, description "Generate a changelog from commits"
5. `refresh-all`: category "Repository", no shortcut, icon RefreshCw, action calls `loadBranches()` + `loadStashes()` + `loadTags()` on respective stores (via getState()), enabled when repo open, description "Refresh branches, stashes, and tags"

For refresh-all action: call `useBranchStore.getState().loadBranches()`, `useStashStore.getState().loadStashes()`, `useTagStore.getState().loadTags()` in parallel with Promise.all. Import these stores.

**src/commands/sync.ts** — 5 commands:

1. `push`: category "Sync", shortcut "mod+shift+u", icon ArrowUp, enabled when repo open, description "Push commits to remote"
   Action: Create Channel<SyncProgress>, call `tauriCommands.pushToRemote("origin", channel)`, toast success/error
2. `pull`: category "Sync", shortcut "mod+shift+l", icon ArrowDown, enabled when repo open, description "Pull changes from remote"
   Action: Create Channel<SyncProgress>, call `tauriCommands.pullFromRemote("origin", channel)`, toast success/error
3. `fetch`: category "Sync", shortcut "mod+shift+f", icon CloudDownload, enabled when repo open, description "Fetch updates from remote"
   Action: Create Channel<SyncProgress>, call `tauriCommands.fetchFromRemote("origin", channel)`, toast success/error
4. `stage-all`: category "Sync", shortcut "mod+shift+a", icon FileCheck, enabled when repo open, description "Stage all changes for commit"
   Action: Call `tauriCommands.stageAll()`, toast success/error, no channel needed
5. `toggle-amend`: category "Sync", shortcut "mod+shift+m", icon RotateCcw, enabled when repo open, description "Toggle amend mode for next commit"
   Action: Dispatch "toggle-amend" CustomEvent

For sync commands that need channels: wrap in async IIFE with try/catch, call toast.success on success, toast.error on error. Do NOT use useMutation (that's a React hook). Use direct try/catch around the Tauri command calls.

**src/commands/branches.ts** — 1 command:

1. `create-branch`: category "Branches", no shortcut, icon GitBranch, enabled when repo open, description "Create a new Git branch"
   Action: Dispatch "create-branch-dialog" CustomEvent (check if this event exists in codebase; if not, dispatch it and note that the dialog component should listen for it — or alternatively use a different mechanism if the create branch dialog uses a different pattern). If the create branch dialog is state-driven (e.g., a state variable in RepositoryView), then set that state. Check how CreateBranchDialog is currently opened and replicate that mechanism.

   IMPORTANT: Check how the create branch dialog currently opens. If it uses component state in RepositoryView, use a CustomEvent "create-branch-dialog" and add a listener in RepositoryView, OR if there's already a store-based mechanism, use that instead.

**src/commands/navigation.ts** — 1 command:

1. `command-palette`: category "Navigation", shortcut "mod+shift+p", icon Search (from lucide-react), always enabled, description "Open the command palette"
   Action: `useCommandPaletteStore.getState().toggle()`

**src/commands/settings.ts** — 2 commands:

1. `open-settings`: category "Settings", shortcut "mod+,", icon Settings, always enabled, description "Open application settings"
   Action: `useSettingsStore.getState().openSettings()`
2. `toggle-theme`: category "Settings", no shortcut, icon Sun, always enabled, description "Cycle through light, dark, and system themes"
   Action: `useThemeStore.getState()` — check how ThemeToggle cycles themes and replicate. The theme store likely has a `setTheme()` or `toggleTheme()` method. Read the store to determine the exact API. Cycle through: if current is "dark" -> "light", if "light" -> "system", if "system" -> "dark".
  </action>
  <verify>
1. `npx tsc --noEmit` passes (ignore pre-existing TS2440)
2. All 5 files exist in src/commands/
3. Each file imports and calls registerCommand
4. `grep -r "registerCommand" src/commands/` shows calls in all 5 files
  </verify>
  <done>
All 14 commands registered across 5 category files with appropriate icons, shortcuts, descriptions, actions, and enabled predicates. Actions use getState() and CustomEvent patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create barrel index and verify full command catalog</name>
  <files>src/commands/index.ts</files>
  <action>
Create `src/commands/index.ts` as a barrel file that imports all command files to trigger their side-effect registration:

```typescript
// Command registration barrel
// Importing these files triggers registerCommand() calls at module load time
import "./repository";
import "./sync";
import "./branches";
import "./navigation";
import "./settings";
```

That's all this file needs. The side-effect imports cause each command file's top-level `registerCommand()` calls to execute.

After creating the file, verify by checking that `getCommands()` would return 14 commands if called after this import. This will be wired into App.tsx in Plan 04.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `src/commands/index.ts` exists and imports all 5 command files
3. All imports are side-effect imports (no named imports needed)
  </verify>
  <done>
Barrel file imports all command registration modules. Importing this single file registers all 14 commands in the registry.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (ignore pre-existing TS2440)
2. All 6 new files exist: src/commands/{index,repository,sync,branches,navigation,settings}.ts
3. `grep -c "registerCommand" src/commands/repository.ts` returns 5
4. `grep -c "registerCommand" src/commands/sync.ts` returns 5
5. `grep -c "registerCommand" src/commands/branches.ts` returns 1
6. `grep -c "registerCommand" src/commands/navigation.ts` returns 1
7. `grep -c "registerCommand" src/commands/settings.ts` returns 2
8. Total: 14 commands registered
</verification>

<success_criteria>
- 14 commands registered across 5 category files
- Each command has: id, title, description, category, icon, action, and enabled predicate
- Commands with shortcuts have the correct shortcut strings
- Push uses "mod+shift+u" (NOT "mod+shift+p")
- Command palette uses "mod+shift+p"
- Barrel index triggers all registrations on import
</success_criteria>

<output>
After completion, create `.planning/phases/18-command-palette-discoverability/18-03-SUMMARY.md`
</output>
