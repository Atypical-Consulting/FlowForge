---
phase: 42-audit-tech-debt-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/bladeRegistry.ts
  - src/blades/_shared/BladeRenderer.tsx
  - src/extensions/sandbox/SandboxedExtensionAPI.ts
  - .planning/REQUIREMENTS.md
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "When a disabled extension is re-enabled, already-open blades auto-restore without manual close/reopen"
    - "SandboxedExtensionAPI stub methods are generated from REQUIRES_TRUST_METHODS constant, not hardcoded"
    - "GFEX-03 checkbox in REQUIREMENTS.md is checked to reflect ADR-2 satisfaction"
  artifacts:
    - path: "src/lib/bladeRegistry.ts"
      provides: "Zustand-based blade registry with reactive subscriptions"
      contains: "create<BladeRegistryState>"
      exports: ["useBladeRegistry", "registerBlade", "unregisterBlade", "getBladeRegistration", "getAllBladeTypes", "isSingletonBlade", "unregisterBySource", "clearCoreRegistry"]
    - path: "src/blades/_shared/BladeRenderer.tsx"
      provides: "Blade renderer that subscribes to registry changes"
      contains: "useBladeRegistry"
    - path: "src/extensions/sandbox/SandboxedExtensionAPI.ts"
      provides: "Dynamic trust-error stubs from REQUIRES_TRUST_METHODS constant"
      contains: "REQUIRES_TRUST_METHODS"
    - path: ".planning/REQUIREMENTS.md"
      provides: "GFEX-03 checkbox checked"
      contains: "[x] **GFEX-03**"
  key_links:
    - from: "src/blades/_shared/BladeRenderer.tsx"
      to: "src/lib/bladeRegistry.ts"
      via: "useBladeRegistry Zustand hook subscription"
      pattern: "useBladeRegistry"
    - from: "src/extensions/sandbox/SandboxedExtensionAPI.ts"
      to: "src/extensions/sandbox/sandbox-api-surface.ts"
      via: "REQUIRES_TRUST_METHODS import used in constructor loop"
      pattern: "REQUIRES_TRUST_METHODS\\.forEach|for.*of.*REQUIRES_TRUST_METHODS"
---

<objective>
Close three tech debt items from the v1.6.0 milestone audit: convert BladeRegistry to a Zustand store so BladeRenderer reactively re-renders on registry changes, use the REQUIRES_TRUST_METHODS constant in SandboxedExtensionAPI instead of hardcoded stubs, and check the GFEX-03 requirement checkbox.

Purpose: Eliminate the last inconsistency in the registry layer (BladeRegistry was the only non-reactive Map), enforce single-source-of-truth for sandbox trust boundaries, and align requirement docs with ADR-2 decision.

Output: 4 files modified, 0 new files, all existing tests pass, BladeRenderer auto-restores blades when a disabled extension is re-enabled.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-audit-tech-debt-cleanup/42-RESEARCH.md

@src/lib/bladeRegistry.ts
@src/lib/sidebarPanelRegistry.ts
@src/blades/_shared/BladeRenderer.tsx
@src/extensions/sandbox/SandboxedExtensionAPI.ts
@src/extensions/sandbox/sandbox-api-surface.ts
@src/extensions/ExtensionAPI.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert BladeRegistry to Zustand store and update BladeRenderer subscription</name>
  <files>
    src/lib/bladeRegistry.ts
    src/blades/_shared/BladeRenderer.tsx
  </files>
  <action>
**bladeRegistry.ts** — Convert the plain Map to a Zustand store following the exact pattern in `sidebarPanelRegistry.ts`:

1. Import `create` from "zustand" and `devtools` from "zustand/middleware".
2. Define `BladeRegistryState` interface with:
   - `registrations: Map<string, BladeRegistration<any>>`
   - `registryTick: number` (for forcing re-renders on registration changes)
   - `register(config: BladeRegistration<any>): void` — clones Map, sets entry, increments tick
   - `unregister(type: string): boolean` — clones Map, deletes entry, increments tick, returns whether key existed
   - `unregisterBySource(source: string): void` — clones Map, deletes matching entries, increments tick
   - `clearCoreRegistrations(): void` — clones Map, deletes non-`ext:` entries, increments tick
   - `get(type: string): BladeRegistration | undefined` — reads from Map
   - `getAllTypes(): string[]` — returns Array.from(keys)
3. Create the store: `export const useBladeRegistry = create<BladeRegistryState>()(devtools(..., { name: "blade-registry", enabled: import.meta.env.DEV }))`.
4. Use devtools action labels like `"blade-registry/register"`, `"blade-registry/unregister"`, etc. (matching the sidebarPanelRegistry pattern).
5. **Backward-compatible function exports** — Keep ALL existing exported functions as thin wrappers around `useBladeRegistry.getState()`:
   - `registerBlade(config)` → `useBladeRegistry.getState().register(config)`
   - `unregisterBlade(type)` → `useBladeRegistry.getState().unregister(type)`
   - `unregisterBySource(source)` → `useBladeRegistry.getState().unregisterBySource(source)`
   - `clearCoreRegistry()` → `useBladeRegistry.getState().clearCoreRegistrations()`
   - `getBladeRegistration(type)` → `useBladeRegistry.getState().get(type)`
   - `getAllBladeTypes()` → `useBladeRegistry.getState().getAllTypes()`
   - `isSingletonBlade(type)` → `useBladeRegistry.getState().get(type)?.singleton === true`
6. Keep ALL existing type exports (`BladeRenderContext`, `BladeRegistration`) unchanged.

**BladeRenderer.tsx** — Subscribe to registry changes:

1. Import `useBladeRegistry` from `../../lib/bladeRegistry`.
2. At the top of the `BladeRenderer` component, add two selector subscriptions:
   ```tsx
   const registrations = useBladeRegistry((s) => s.registrations);
   const tick = useBladeRegistry((s) => s.registryTick);
   ```
3. Replace `const reg = getBladeRegistration(blade.type)` with:
   ```tsx
   const reg = useMemo(() => registrations.get(blade.type), [blade.type, registrations, tick]);
   ```
4. Add `useMemo` import from "react" (already imports `Suspense`).
5. Remove the `getBladeRegistration` import since we now use the hook directly.
6. The rest of the component remains unchanged — it already handles `!reg` with the Puzzle fallback.

This ensures that when an extension is disabled (blades unregistered), the Puzzle fallback shows immediately, and when re-enabled (blades re-registered), the component auto-renders without user intervention.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no new type errors (pre-existing TS2440 in bindings.ts is expected).
2. Run `npx vitest run` — all 233+ tests pass unchanged.
3. Grep for all 24 consumer files: `grep -r "from.*bladeRegistry" src/` — all still import the same function names.
4. Confirm `useBladeRegistry` is exported: `grep "export const useBladeRegistry" src/lib/bladeRegistry.ts`.
5. Confirm `BladeRenderer.tsx` imports `useBladeRegistry` and uses `useMemo`.
  </verify>
  <done>
BladeRegistry is a Zustand store with devtools integration. All 24 consumers continue using the same function exports unchanged. BladeRenderer subscribes to registry state and re-renders automatically when registrations change — when a disabled extension is re-enabled, open blades auto-restore from Puzzle fallback to the real component.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor SandboxedExtensionAPI to use REQUIRES_TRUST_METHODS constant</name>
  <files>
    src/extensions/sandbox/SandboxedExtensionAPI.ts
  </files>
  <action>
Replace the 6 hardcoded method stubs (lines 35-57) with a constructor loop over the `REQUIRES_TRUST_METHODS` constant:

1. Keep the existing import of `REQUIRES_TRUST_METHODS` from `./sandbox-api-surface` (line 1).
2. Also import the `RequiresTrustMethod` type from `./sandbox-api-surface`.
3. In the constructor, after `this.hostApi = hostApi`, add a loop:
   ```typescript
   for (const method of REQUIRES_TRUST_METHODS) {
     (this as any)[method] = () => {
       throw this.trustError(method);
     };
   }
   ```
4. Remove the 6 individual method stubs: `registerBlade()`, `registerCommand()`, `contributeToolbar()`, `contributeContextMenu()`, `contributeSidebarPanel()`, `contributeStatusBar()`.
5. To preserve TypeScript type-safety, add explicit method signatures above the class or as interface declaration merging so callers still see typed methods. Add a type assertion comment explaining the dynamic assignment pattern. Alternatively, declare the methods in the class body with `!: () => never` to satisfy the type system:
   ```typescript
   // Blocked methods (dynamically assigned from REQUIRES_TRUST_METHODS in constructor)
   registerBlade!: () => never;
   registerCommand!: () => never;
   contributeToolbar!: () => never;
   contributeContextMenu!: () => never;
   contributeSidebarPanel!: () => never;
   contributeStatusBar!: () => never;
   ```
   This provides type information while the actual implementation comes from the constructor loop.
6. Keep the `trustError` private method unchanged.
7. Keep the 3 sandbox-safe methods (`onDidGit`, `onWillGit`, `onDispose`) unchanged.

The net result: ~30 lines of repetitive stubs replaced by a 3-line loop + 6 type declarations. Adding a new requires-trust method now only requires updating `REQUIRES_TRUST_METHODS` in `sandbox-api-surface.ts` and adding a type declaration line.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no new type errors.
2. Run `npx vitest run` — SandboxBridge tests pass (they call blocked methods and expect trust errors).
3. Verify the constant is used: `grep "REQUIRES_TRUST_METHODS" src/extensions/sandbox/SandboxedExtensionAPI.ts` shows it is referenced in constructor loop, not just imported.
4. Verify no hardcoded stubs remain: `grep -c "trustError" src/extensions/sandbox/SandboxedExtensionAPI.ts` should show exactly 1 occurrence (the private method definition), plus 1 in the constructor loop = 2 total.
  </verify>
  <done>
SandboxedExtensionAPI generates all trust-error stubs dynamically from the REQUIRES_TRUST_METHODS constant. The constant in sandbox-api-surface.ts is the single source of truth — adding a new requires-trust method only needs an update there plus a type declaration. SandboxBridge tests still pass (identical runtime behavior).
  </done>
</task>

<task type="auto">
  <name>Task 3: Check GFEX-03 requirement checkbox</name>
  <files>
    .planning/REQUIREMENTS.md
  </files>
  <action>
On line 38 of `.planning/REQUIREMENTS.md`, change the unchecked checkbox to checked:

Change: `- [ ] **GFEX-03**: Branch classification and coloring remains in core ...`
To:     `- [x] **GFEX-03**: Branch classification and coloring remains in core ...`

The requirement text is already correct per ADR-2 (updated during Phase 40). The traceability table at line 113 already shows `Satisfied (ADR-2)`. This task aligns the checkbox with the satisfaction status.

No other changes needed to this file.
  </action>
  <verify>
1. `grep "GFEX-03" .planning/REQUIREMENTS.md` shows `[x]` checkbox.
2. Line 38 contains `- [x] **GFEX-03**`.
  </verify>
  <done>
GFEX-03 requirement checkbox is checked, aligning with the existing "Satisfied (ADR-2)" status in the traceability table. All 3 audit tech debt items are resolved.
  </done>
</task>

</tasks>

<verification>
After all 3 tasks:

1. `npx tsc --noEmit` passes (ignoring pre-existing TS2440 in bindings.ts)
2. `npx vitest run` — all existing tests pass with zero changes
3. BladeRegistry is a Zustand store: `grep "create<BladeRegistryState>" src/lib/bladeRegistry.ts`
4. Backward-compat wrappers exist: `grep "export function registerBlade" src/lib/bladeRegistry.ts`
5. BladeRenderer subscribes: `grep "useBladeRegistry" src/blades/_shared/BladeRenderer.tsx`
6. SandboxedExtensionAPI uses constant: `grep "REQUIRES_TRUST_METHODS" src/extensions/sandbox/SandboxedExtensionAPI.ts` (used in loop, not just imported)
7. GFEX-03 checked: `grep "\[x\].*GFEX-03" .planning/REQUIREMENTS.md`
</verification>

<success_criteria>
- BladeRenderer reactively re-renders when blade registrations change (auto-restore on extension re-enable)
- SandboxedExtensionAPI uses REQUIRES_TRUST_METHODS as single source of truth for blocked methods
- GFEX-03 checkbox is checked in REQUIREMENTS.md
- All existing tests pass unchanged
- All 24 bladeRegistry consumers work unchanged via backward-compatible function exports
</success_criteria>

<output>
After completion, create `.planning/phases/42-audit-tech-debt-cleanup/42-01-SUMMARY.md`
</output>
