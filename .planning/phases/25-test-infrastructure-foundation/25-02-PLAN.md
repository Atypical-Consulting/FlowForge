---
phase: 25-test-infrastructure-foundation
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - src/test-utils/render.tsx
  - src/test-utils/index.ts
  - src/test-utils/mocks/tauri-commands.ts
  - src/stores/repository.test.ts
  - src/stores/toast.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can mock Tauri IPC commands with type-safe factories that match actual binding signatures"
    - "Developer can write store tests using typed mock commands without hand-crafting IPC payloads"
  artifacts:
    - path: "src/test-utils/mocks/tauri-commands.ts"
      provides: "Typed mock factories for bindings.ts commands"
      contains: "createMockCommands"
    - path: "src/test-utils/render.tsx"
      provides: "Custom render with QueryClientProvider + MotionConfig"
      contains: "AllTheProviders"
    - path: "src/stores/repository.test.ts"
      provides: "Store test demonstrating Tauri IPC mocking"
      contains: "openRepository"
  key_links:
    - from: "src/test-utils/mocks/tauri-commands.ts"
      to: "src/bindings.ts"
      via: "import type"
      pattern: "import type.*bindings"
    - from: "src/test-utils/render.tsx"
      to: "@tanstack/react-query"
      via: "QueryClientProvider"
      pattern: "QueryClientProvider"
    - from: "src/stores/repository.test.ts"
      to: "src/test-utils/mocks/tauri-commands.ts"
      via: "mock factory import"
      pattern: "createMockCommands|createRepoStatus"
---

<objective>
Create typed Tauri IPC mock factories, custom render wrapper with providers, and store tests that demonstrate mocking Tauri commands.

Purpose: This plan provides the mock infrastructure that all future tests consume. The typed mock factories ensure test data matches actual bindings.ts types. The custom render wrapper ensures component tests get the correct provider tree (QueryClient, MotionConfig). The store tests prove the pattern works end-to-end.

Output: Tauri command mock factory module, custom render wrapper, updated barrel export, and 2 store test files (repository, toast) demonstrating the mocking pattern.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-test-infrastructure-foundation/25-RESEARCH.md
@.planning/phases/25-test-infrastructure-foundation/25-RESEARCH-ARCHITECTURE.md
@.planning/phases/25-test-infrastructure-foundation/25-01-SUMMARY.md
@src/bindings.ts
@src/stores/repository.ts
@src/stores/toast.ts
@src/test-utils/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typed Tauri command mock factories and custom render wrapper</name>
  <files>
    src/test-utils/mocks/tauri-commands.ts
    src/test-utils/render.tsx
    src/test-utils/index.ts
  </files>
  <action>
1. Create `src/test-utils/mocks/tauri-commands.ts` -- typed mock factories for bindings.ts:

   This file provides:
   - `ok<T>(data)` and `err(error)` helpers that wrap values in Result<T, GitError> shape matching bindings.ts
   - Factory functions for common data types: `createRepoStatus()`, `createStagingStatus()`, `createFileChange()`, `createBranchInfo()`, `createCommitSummary()`, `createFileDiff()`
   - `createMockCommands()` that returns a full mock `commands` object with vi.fn() stubs and sensible defaults

   Each factory accepts optional `Partial<T>` overrides. Default values should be minimal but valid per the TypeScript types in bindings.ts.

   Read `src/bindings.ts` carefully to determine:
   - All exported types (RepoStatus, StagingStatus, FileChange, BranchInfo, CommitSummary, FileDiff, GitError, TagInfo, StashEntry, etc.)
   - The Result<T, E> type shape (it uses `{ status: "ok", data: T } | { status: "error", error: E }`)
   - All command method signatures on the `commands` object

   The `createMockCommands()` function should cover ALL commands in bindings.ts (approximately 50+). Each command should return a sensible default:
   - Commands returning `Result<T, GitError>`: use `ok()` with a default factory value
   - Commands returning primitives: use a direct default
   - Commands returning arrays: use `ok([])` (empty arrays)
   - Commands returning null/void results: use `ok(null)`

   Import types using `import type` syntax from `../../bindings` (relative path -- the codebase does NOT use `@/` alias for imports).

2. Create `src/test-utils/render.tsx` -- custom render with providers:

   ```tsx
   import type { ReactElement, ReactNode } from "react";
   import { render, type RenderOptions } from "@testing-library/react";
   import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
   import { MotionConfig } from "framer-motion";

   function createTestQueryClient() {
     return new QueryClient({
       defaultOptions: {
         queries: {
           retry: false,
           gcTime: 0,
         },
         mutations: {
           retry: false,
         },
       },
     });
   }

   function AllTheProviders({ children }: { children: ReactNode }) {
     const queryClient = createTestQueryClient();
     return (
       <QueryClientProvider client={queryClient}>
         <MotionConfig reducedMotion="always">
           {children}
         </MotionConfig>
       </QueryClientProvider>
     );
   }

   const customRender = (
     ui: ReactElement,
     options?: Omit<RenderOptions, "wrapper">,
   ) => render(ui, { wrapper: AllTheProviders, ...options });

   // Re-export everything from RTL
   export * from "@testing-library/react";
   // Override render with custom version
   export { customRender as render };
   ```

   Key design: A NEW QueryClient is created per render call (inside AllTheProviders), preventing cache pollution between tests. `retry: false` prevents flaky tests. `gcTime: 0` triggers immediate garbage collection. `MotionConfig reducedMotion="always"` disables framer-motion animations.

3. Update `src/test-utils/index.ts` barrel export to re-export from the custom render:

   ```typescript
   // Test utilities barrel export
   export { render, screen, within, waitFor, fireEvent, cleanup, act } from "./render";
   export { ok, err, createMockCommands, createRepoStatus, createStagingStatus, createFileChange, createBranchInfo } from "./mocks/tauri-commands";
   ```
  </action>
  <verify>
TypeScript should compile the new files without errors: `npx tsc --noEmit` (ignoring pre-existing TS2440 in bindings.ts). Verify `src/test-utils/mocks/tauri-commands.ts` imports from `../../bindings` and all factory return types match the bindings types.
  </verify>
  <done>
`src/test-utils/mocks/tauri-commands.ts` exists with typed factories for all command types. `src/test-utils/render.tsx` provides custom render with QueryClientProvider + MotionConfig. `src/test-utils/index.ts` re-exports all utilities.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create repository store test and toast store test demonstrating IPC mock pattern</name>
  <files>
    src/stores/repository.test.ts
    src/stores/toast.test.ts
  </files>
  <action>
1. Create `src/stores/repository.test.ts` -- demonstrates the Tauri IPC mocking pattern:

   This test:
   - Creates a mock commands object using `createMockCommands()` from test-utils
   - Mocks `../bindings` module with `vi.mock("../bindings", ...)` at the top
   - Tests `openRepository` success path (verifies status is set, isLoading is false)
   - Tests `openRepository` error path (verifies error state)
   - Tests auto-reset between tests (state does not leak)

   Read `src/stores/repository.ts` to understand:
   - The store's state shape (status, isLoading, error, etc.)
   - How `openRepository` calls `commands.openRepository` and processes the Result
   - What error handling looks like

   Pattern for mocking bindings per-file:
   ```typescript
   import { createMockCommands, createRepoStatus, ok, err } from "../test-utils/mocks/tauri-commands";

   const mockCommands = createMockCommands();
   vi.mock("../bindings", () => ({
     commands: mockCommands,
   }));

   // Import store AFTER mock setup
   import { useRepositoryStore } from "./repository";
   ```

   IMPORTANT: The `vi.mock()` call is hoisted by Vitest to the top of the file, but the variable `mockCommands` must be defined with `const` before the mock (Vitest handles this via hoisting). The store import MUST come after `vi.mock()`.

   Add `beforeEach(() => { vi.clearAllMocks(); })` to reset mock call counts between tests.

2. Create `src/stores/toast.test.ts` -- demonstrates a simpler store test (no IPC):

   This test verifies:
   - Initial state has empty toasts array
   - `addToast` adds a toast with a generated UUID id (proves crypto polyfill works)
   - `removeToast` removes by id
   - Auto-reset clears toasts between tests

   Read `src/stores/toast.ts` to understand the store shape and actions.

   This test exercises the crypto.randomUUID polyfill from setup.ts (toast store generates UUIDs for toast IDs).
  </action>
  <verify>
Run `npm test` -- all tests should pass:
- blades.test.ts: 5 tests (from Plan 01)
- repository.test.ts: ~4 tests (initial state, success, error, auto-reset)
- toast.test.ts: ~4 tests (initial state, add, remove, auto-reset)

Total: ~13 passing tests.
  </verify>
  <done>
`src/stores/repository.test.ts` demonstrates Tauri IPC mock pattern with success and error cases. `src/stores/toast.test.ts` demonstrates simpler store testing with crypto.randomUUID verification. All tests pass with `npm test`.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes with all store tests (blades + repository + toast)
2. Typed mock factories compile without TypeScript errors
3. Repository test demonstrates mock commands with `ok()` and `err()` wrappers
4. Custom render wrapper provides QueryClientProvider (verified by it importing correctly -- component tests use it in Plan 03)
5. Toast test proves crypto.randomUUID polyfill works in test environment
</verification>

<success_criteria>
- All tests pass with `npm test` (exit code 0)
- `createMockCommands()` returns typed mocks for all bindings commands
- Factory functions accept `Partial<T>` overrides
- Custom render creates fresh QueryClient per render call
- Repository store test shows the complete per-file mock pattern
</success_criteria>

<output>
After completion, create `.planning/phases/25-test-infrastructure-foundation/25-02-SUMMARY.md`
</output>
