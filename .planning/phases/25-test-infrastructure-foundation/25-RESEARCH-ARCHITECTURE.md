# Phase 25: Test Infrastructure Foundation - Architecture Research

**Researched:** 2026-02-08
**Domain:** Test infrastructure for Tauri v2 + React + TypeScript + Zustand
**Perspective:** Technical Architecture
**Confidence:** HIGH

## Summary

FlowForge currently has zero test files, no Vitest configuration, and no test dependencies installed. The codebase has 215 source files across 21 Zustand stores (19 using `create()` directly, 1 using `devtools` middleware), 13 blade types with a registry pattern, and ~50 Tauri IPC commands generated by tauri-specta. The test infrastructure must mock two external boundaries: (1) the Tauri IPC layer (`@tauri-apps/api/core` invoke) consumed through the generated `bindings.ts` commands object, and (2) the Tauri plugin-store (`@tauri-apps/plugin-store`) used by 5 stores for persistence. Every store and blade component depends on one or both of these boundaries.

The architecture uses a single Vitest workspace (no multi-workspace split needed at this scale), jsdom environment, the official Zustand auto-reset mock pattern from their docs (Vitest variant), and a typed mock factory that wraps the `commands` object from `bindings.ts`. The test infrastructure is designed as three semi-independent utility modules (`test-utils/tauri-mocks`, `test-utils/store-helpers`, `test-utils/render`) that future phases can extend without modifying.

**Primary recommendation:** Use Vitest with jsdom, `@testing-library/react`, and `@testing-library/jest-dom`. Mock Tauri IPC at the `bindings.ts` module level (not at `window.__TAURI_INTERNALS__`), use the official Zustand auto-reset mock pattern, and create a custom render wrapper that provides QueryClientProvider.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

No locked decisions -- user deferred all implementation decisions to Claude.

### Claude's Discretion

User deferred all implementation decisions to Claude. The following areas are open for Claude to decide during research and planning:

**Mock strategy:**
- How Tauri IPC mocks are structured (factory functions, fixtures, or inline)
- Fidelity level of mock responses relative to real Tauri bindings
- Type-safety approach for mock factories

**Test organization:**
- File placement (co-located vs separate directory)
- Naming convention (*.test.ts vs *.spec.ts)
- Test utility and helper organization

**Coverage & CI expectations:**
- Whether to enforce coverage thresholds in this phase
- Which test types run in CI vs locally only
- Fail-on-regression policy

**Smoke test scope:**
- Which blade types get smoke tests (all vs representative subset)
- Depth of smoke tests (render-only vs basic interaction)

### Deferred Ideas (OUT OF SCOPE)

None -- discussion stayed within phase scope.
</user_constraints>

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| vitest | ^3.x or ^4.x | Test runner, assertion library | Vite-native, shares config with existing vite.config.ts, ESM-first |
| @testing-library/react | ^16.x | Component rendering & queries | De facto standard for React component testing |
| @testing-library/jest-dom | ^6.x | DOM assertion matchers | Provides `toBeInTheDocument()`, `toHaveTextContent()`, etc. |
| @testing-library/user-event | ^14.x | User interaction simulation | Realistic event firing (click, type, etc.) |
| jsdom | ^25.x or ^26.x | DOM environment | Required by vitest `environment: 'jsdom'` |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @testing-library/jest-dom/vitest | (included) | Vitest-specific matchers setup | Import in setup file |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| jsdom | happy-dom | happy-dom is faster but less complete DOM implementation; jsdom is safer for complex components |
| `@tauri-apps/api/mocks` `mockIPC()` | vi.mock of bindings module | mockIPC works at window.__TAURI_INTERNALS__ level; module-level mock is more type-safe and simpler for tauri-specta generated bindings |
| Single vitest config | Vitest workspaces | Workspaces add complexity; single config with glob patterns is sufficient for this project size |

**Installation:**
```bash
npm install -D vitest jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

## Architecture Patterns

### Recommended Test File Structure

```
src/
├── test-utils/
│   ├── tauri-mocks.ts        # Typed mock factories for bindings.commands
│   ├── store-helpers.ts       # Zustand store reset utilities
│   └── render.tsx             # Custom render with providers (QueryClient, etc.)
├── __mocks__/
│   └── zustand.ts             # Zustand auto-reset mock (official pattern)
├── stores/
│   ├── blades.ts
│   ├── blades.test.ts         # Co-located store test
│   ├── repository.ts
│   └── repository.test.ts
├── components/
│   └── blades/
│       ├── SettingsBlade.tsx
│       └── SettingsBlade.test.tsx  # Co-located smoke test
├── lib/
│   ├── errors.ts
│   └── errors.test.ts         # Pure function tests
├── vitest.setup.ts             # Global setup (jest-dom, zustand mock, crypto polyfill)
└── ...
```

**Rationale for co-located tests:** Phase 29 will restructure files into blade-centric feature modules. Co-locating tests now means they naturally move with their source files. The `*.test.ts` convention (not `*.spec.ts`) is used because it is the Vitest default and most common in the React ecosystem.

### Pattern 1: Vitest Configuration Extending Vite Config

**What:** Create `vitest.config.ts` that merges with existing `vite.config.ts` to inherit path aliases and plugin settings.
**When to use:** Always -- ensures `@/` alias resolution works in tests.

```typescript
// vitest.config.ts
import { defineConfig, mergeConfig } from "vitest/config";
import viteConfig from "./vite.config";

export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      environment: "jsdom",
      globals: true,
      setupFiles: ["./src/vitest.setup.ts"],
      include: ["src/**/*.test.{ts,tsx}"],
      css: false, // Skip CSS processing for speed
    },
  }),
);
```

**Key decisions:**
- `globals: true` -- enables `describe`, `it`, `expect` without imports (matches ecosystem convention)
- `css: false` -- Tailwind CSS processing is unnecessary for unit/smoke tests
- Inherits `resolve.alias: { "@": "/src" }` from vite.config.ts

### Pattern 2: Zustand Auto-Reset Mock (Official Vitest Pattern)

**What:** Module-level mock of `zustand` that captures initial state of every store and resets after each test.
**When to use:** Every test file -- activated globally via `vi.mock('zustand')` in setup.
**Source:** https://zustand.docs.pmnd.rs/guides/testing

```typescript
// src/__mocks__/zustand.ts
import { act } from "@testing-library/react";
import type * as ZustandExportedTypes from "zustand";
export * from "zustand";

const { create: actualCreate, createStore: actualCreateStore } =
  await vi.importActual<typeof ZustandExportedTypes>("zustand");

export const storeResetFns = new Set<() => void>();

const createUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>,
) => {
  const store = actualCreate(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const create = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>,
) => {
  return typeof stateCreator === "function"
    ? createUncurried(stateCreator)
    : createUncurried;
}) as typeof ZustandExportedTypes.create;

const createStoreUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>,
) => {
  const store = actualCreateStore(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const createStore = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>,
) => {
  return typeof stateCreator === "function"
    ? createStoreUncurried(stateCreator)
    : createStoreUncurried;
}) as typeof ZustandExportedTypes.createStore;

afterEach(() => {
  act(() => {
    storeResetFns.forEach((resetFn) => {
      resetFn();
    });
  });
});
```

**Critical note:** The `useBladeStore` uses `devtools()` middleware wrapping `create()`. The mock intercepts `create()` which is the outermost call, so the devtools middleware state creator is still passed through. The mock correctly handles this because `devtools()` returns a `StateCreator` that `actualCreate` processes normally. The `enabled: import.meta.env.DEV` flag in the devtools middleware will be `false` in test environment by default, which is correct behavior.

### Pattern 3: Tauri IPC Mock at Module Level

**What:** Mock the entire `../bindings` module with typed factory functions instead of using `@tauri-apps/api/mocks` `mockIPC()`.
**When to use:** Any test that exercises code calling Tauri commands.

**Why module-level mock over `mockIPC()`:**
1. The codebase uses tauri-specta generated bindings where commands are called as `commands.openRepository(path)`, not raw `invoke("open_repository", { path })`. Mocking at the module level preserves type safety.
2. `mockIPC()` requires setting up `window.__TAURI_INTERNALS__` and polyfilling WebCrypto -- more ceremony for less type safety.
3. Module-level mocks let each test file configure exactly which commands return what, with TypeScript checking the return types.

```typescript
// src/test-utils/tauri-mocks.ts
import type {
  RepoStatus,
  StagingStatus,
  BranchInfo,
  CommitSummary,
  FileChange,
  Result,
  GitError,
  TagInfo,
  StashEntry,
  // ... other types as needed
} from "../bindings";

// ---- Factory: Success/Error result wrappers ----

export function ok<T>(data: T): Result<T, GitError> {
  return { status: "ok", data };
}

export function err<T>(error: GitError): Result<T, GitError> {
  return { status: "error", error };
}

// ---- Factory: Domain fixtures ----

export function createRepoStatus(
  overrides: Partial<RepoStatus> = {},
): RepoStatus {
  return {
    branchName: "main",
    isDirty: false,
    repoPath: "/mock/repo",
    repoName: "mock-repo",
    ...overrides,
  };
}

export function createFileChange(
  overrides: Partial<FileChange> = {},
): FileChange {
  return {
    path: "src/index.ts",
    status: "modified",
    additions: 10,
    deletions: 5,
    ...overrides,
  };
}

export function createStagingStatus(
  overrides: Partial<StagingStatus> = {},
): StagingStatus {
  return {
    staged: [],
    unstaged: [],
    untracked: [],
    ...overrides,
  };
}

export function createBranchInfo(
  overrides: Partial<BranchInfo> = {},
): BranchInfo {
  return {
    name: "main",
    isHead: true,
    isRemote: false,
    upstream: null,
    oid: "abc123",
    shortOid: "abc",
    lastCommitMessage: "initial commit",
    lastCommitTimestamp: Date.now(),
    aheadBehind: { ahead: 0, behind: 0 },
    ...overrides,
  };
}

// ---- Mock commands object ----

export function createMockCommands() {
  return {
    greet: vi.fn().mockResolvedValue("Hello"),
    openRepository: vi.fn().mockResolvedValue(ok(createRepoStatus())),
    getRepositoryStatus: vi.fn().mockResolvedValue(ok(createRepoStatus())),
    isGitRepository: vi.fn().mockResolvedValue(ok(true)),
    closeRepository: vi.fn().mockResolvedValue(ok(null)),
    getStagingStatus: vi.fn().mockResolvedValue(ok(createStagingStatus())),
    stageFile: vi.fn().mockResolvedValue(ok(null)),
    unstageFile: vi.fn().mockResolvedValue(ok(null)),
    stageFiles: vi.fn().mockResolvedValue(ok(null)),
    unstageFiles: vi.fn().mockResolvedValue(ok(null)),
    stageAll: vi.fn().mockResolvedValue(ok(null)),
    unstageAll: vi.fn().mockResolvedValue(ok(null)),
    getFileDiff: vi.fn().mockResolvedValue(ok({ path: "", oldContent: "", newContent: "", hunks: [], isBinary: false, language: "" })),
    getCommitFileDiff: vi.fn().mockResolvedValue(ok({ path: "", oldContent: "", newContent: "", hunks: [], isBinary: false, language: "" })),
    createCommit: vi.fn().mockResolvedValue(ok({ oid: "abc123", shortOid: "abc", messageSubject: "test" })),
    getLastCommitMessage: vi.fn().mockResolvedValue(ok({ subject: "", body: null, fullMessage: "" })),
    getCommitHistory: vi.fn().mockResolvedValue(ok([])),
    getCommitDetails: vi.fn().mockResolvedValue(ok({})),
    searchCommits: vi.fn().mockResolvedValue(ok([])),
    getCommitGraph: vi.fn().mockResolvedValue(ok({ nodes: [], edges: [] })),
    getRemotes: vi.fn().mockResolvedValue(ok([])),
    listBranches: vi.fn().mockResolvedValue(ok([])),
    createBranch: vi.fn().mockResolvedValue(ok(createBranchInfo())),
    checkoutBranch: vi.fn().mockResolvedValue(ok(null)),
    deleteBranch: vi.fn().mockResolvedValue(ok(null)),
    listAllBranches: vi.fn().mockResolvedValue(ok([])),
    checkoutRemoteBranch: vi.fn().mockResolvedValue(ok(null)),
    batchDeleteBranches: vi.fn().mockResolvedValue(ok({ results: [], totalDeleted: 0, totalFailed: 0 })),
    getRecentCheckouts: vi.fn().mockResolvedValue(ok([])),
    listStashes: vi.fn().mockResolvedValue(ok([])),
    stashSave: vi.fn().mockResolvedValue(ok("")),
    stashApply: vi.fn().mockResolvedValue(ok(null)),
    stashPop: vi.fn().mockResolvedValue(ok(null)),
    stashDrop: vi.fn().mockResolvedValue(ok(null)),
    listTags: vi.fn().mockResolvedValue(ok([])),
    createTag: vi.fn().mockResolvedValue(ok({})),
    deleteTag: vi.fn().mockResolvedValue(ok(null)),
    mergeBranch: vi.fn().mockResolvedValue(ok({ success: true, analysis: "normal", commitOid: null, fastForwarded: false, hasConflicts: false, conflictedFiles: [] })),
    getMergeStatus: vi.fn().mockResolvedValue(ok({ inProgress: false, conflictedFiles: [] })),
    abortMerge: vi.fn().mockResolvedValue(ok(null)),
    initGitflow: vi.fn().mockResolvedValue(ok({})),
    startFeature: vi.fn().mockResolvedValue(ok("")),
    finishFeature: vi.fn().mockResolvedValue(ok(null)),
    startRelease: vi.fn().mockResolvedValue(ok("")),
    finishRelease: vi.fn().mockResolvedValue(ok("")),
    startHotfix: vi.fn().mockResolvedValue(ok("")),
    finishHotfix: vi.fn().mockResolvedValue(ok("")),
    getGitflowStatus: vi.fn().mockResolvedValue(ok({})),
    abortGitflow: vi.fn().mockResolvedValue(ok(null)),
    validateConventionalCommit: vi.fn().mockResolvedValue({ isValid: true, errors: [], warnings: [] }),
    suggestCommitType: vi.fn().mockResolvedValue(ok({ suggestedType: "feat", confidence: "low", reason: "mock" })),
    getScopeSuggestions: vi.fn().mockResolvedValue(ok([])),
    inferScopeFromStaged: vi.fn().mockResolvedValue(ok(null)),
    generateChangelogCmd: vi.fn().mockResolvedValue(ok({ markdown: "", groups: [] })),
    listWorktrees: vi.fn().mockResolvedValue(ok([])),
    createWorktree: vi.fn().mockResolvedValue(ok({})),
    deleteWorktree: vi.fn().mockResolvedValue(ok(null)),
    getUndoInfo: vi.fn().mockResolvedValue(ok({ canUndo: false, description: null, reflogMessage: null, targetOid: null })),
    undoLastOperation: vi.fn().mockResolvedValue(ok(null)),
    cloneRepository: vi.fn().mockResolvedValue(ok("")),
    gitInit: vi.fn().mockResolvedValue(ok({})),
    fetchFromRemote: vi.fn().mockResolvedValue(ok({ success: true, message: "", commitsTransferred: 0 })),
    pushToRemote: vi.fn().mockResolvedValue(ok({ success: true, message: "", commitsTransferred: 0 })),
    pullFromRemote: vi.fn().mockResolvedValue(ok({ success: true, message: "", commitsTransferred: 0 })),
    // Add remaining commands as needed -- the pattern is the same
  };
}

// Type to ensure mock matches real commands shape
export type MockCommands = ReturnType<typeof createMockCommands>;
```

**Usage in tests:**
```typescript
// src/stores/repository.test.ts
import { createMockCommands, createRepoStatus, ok } from "../test-utils/tauri-mocks";

const mockCommands = createMockCommands();
vi.mock("../bindings", () => ({
  commands: mockCommands,
}));

import { useRepositoryStore } from "./repository";

describe("useRepositoryStore", () => {
  it("opens a repository successfully", async () => {
    const status = createRepoStatus({ branchName: "develop" });
    mockCommands.openRepository.mockResolvedValue(ok(status));

    await useRepositoryStore.getState().openRepository("/path/to/repo");

    expect(useRepositoryStore.getState().status).toEqual(status);
    expect(useRepositoryStore.getState().isLoading).toBe(false);
  });
});
```

### Pattern 4: Tauri Plugin-Store Mock

**What:** Mock `@tauri-apps/plugin-store` for the 5 stores that use persistent storage (theme, settings, navigation, branchMetadata, reviewChecklist).
**When to use:** Tests involving stores that call `getStore()`.

```typescript
// Mock for src/lib/store.ts
vi.mock("../lib/store", () => ({
  getStore: vi.fn().mockResolvedValue({
    get: vi.fn().mockResolvedValue(null),
    set: vi.fn().mockResolvedValue(undefined),
    save: vi.fn().mockResolvedValue(undefined),
  }),
}));
```

### Pattern 5: Custom Render with Providers

**What:** Wraps components in QueryClientProvider (and potentially MotionConfig) for tests.
**When to use:** Every component test -- imported from `test-utils/render` instead of `@testing-library/react`.

```typescript
// src/test-utils/render.tsx
import type { ReactElement } from "react";
import { render, type RenderOptions } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

function createTestQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
      },
    },
  });
}

function AllProviders({ children }: { children: React.ReactNode }) {
  const queryClient = createTestQueryClient();
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, "wrapper">,
) => render(ui, { wrapper: AllProviders, ...options });

export * from "@testing-library/react";
export { customRender as render };
```

### Pattern 6: XState Machine Testing (Preparation for Phase 26)

**What:** Test XState v5 actors using createActor/getSnapshot without DOM.
**When to use:** Phase 26 XState navigation machine tests -- infrastructure must support this.

```typescript
// Example: testing an XState v5 machine (Phase 26 will create the actual machine)
import { setup, createActor } from "xstate";

test("navigation machine handles push event", () => {
  const machine = setup({/* ... */}).createMachine({/* ... */});
  const actor = createActor(machine);
  actor.start();

  actor.send({ type: "PUSH_BLADE", blade: { type: "settings", title: "Settings" } });

  const snapshot = actor.getSnapshot();
  expect(snapshot.context.bladeStack).toHaveLength(2);
});
```

**Key insight:** XState v5 machine tests do not need jsdom -- they run in Node environment. However, keeping a single vitest environment (jsdom) is simpler than workspace splitting since the overhead is minimal.

### Pattern 7: Blade Smoke Tests

**What:** Verify each blade type renders without crashing by rendering its component with minimal required props and mocked dependencies.
**When to use:** Every blade component should have at least a smoke test.

```typescript
// src/components/blades/SettingsBlade.test.tsx
import { render, screen } from "../../test-utils/render";

// Mock bindings
vi.mock("../../bindings", () => ({
  commands: createMockCommands(),
}));

// Mock Tauri plugin-store
vi.mock("../../lib/store", () => ({
  getStore: vi.fn().mockResolvedValue({
    get: vi.fn().mockResolvedValue(null),
    set: vi.fn().mockResolvedValue(undefined),
    save: vi.fn().mockResolvedValue(undefined),
  }),
}));

describe("SettingsBlade", () => {
  it("renders without crashing", () => {
    render(<SettingsBlade />);
    // Verify something renders -- exact assertion depends on component
    expect(document.body.firstChild).not.toBeNull();
  });
});
```

### Anti-Patterns to Avoid

- **Testing implementation details:** Don't test Zustand store internals by directly asserting on `set()` calls. Test through the public API (actions + state reads).
- **Snapshot-heavy testing:** Avoid `toMatchSnapshot()` for blade smoke tests. Snapshots are brittle for UI components with Tailwind classes that change frequently.
- **Over-mocking:** Don't mock Zustand stores in component tests -- use the auto-reset mock pattern instead. The real store logic should execute; only external boundaries (Tauri IPC, plugin-store) need mocking.
- **`mockIPC()` for tauri-specta bindings:** The official `@tauri-apps/api/mocks` `mockIPC()` works at the raw invoke level. Since FlowForge uses tauri-specta generated typed commands, mocking at the module level is strictly more type-safe and avoids the WebCrypto polyfill ceremony.
- **Separate test directories:** Don't put tests in `__tests__/` or `test/` directories. Co-located tests are idiomatic for Vite/Vitest projects and will align with Phase 29's blade-centric restructuring.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| DOM environment | Custom JSDOM setup | `vitest environment: 'jsdom'` | Vitest manages jsdom lifecycle, cleanup |
| Zustand store reset between tests | Manual `beforeEach` setState in each test | Official `__mocks__/zustand.ts` pattern | Handles all 21 stores automatically, including middleware |
| DOM assertion matchers | Custom matchers | `@testing-library/jest-dom` | Comprehensive matchers (`toBeInTheDocument`, `toHaveClass`, etc.) |
| User interaction simulation | `fireEvent` calls | `@testing-library/user-event` | Realistic event sequences (focus, keyboard, pointer events) |
| Query client for tests | Production QueryClient | `createTestQueryClient()` with `retry: false` | Avoids flaky tests from retries, fast GC |

**Key insight:** The Zustand auto-reset pattern is the single most impactful choice. Without it, every test file would need manual `beforeEach` blocks to reset every store it touches -- and with 21 stores, cross-test pollution is almost guaranteed.

## Common Pitfalls

### Pitfall 1: `import.meta.env.DEV` in Store Code

**What goes wrong:** The `useBladeStore` uses `{ enabled: import.meta.env.DEV }` for devtools. In Vitest, `import.meta.env.DEV` is `false` by default (mode is "test"), so devtools are disabled -- this is actually correct behavior for tests.
**Why it happens:** Vitest sets `mode: 'test'` which makes `DEV` false.
**How to avoid:** Do not override `import.meta.env.DEV` to `true`. The production store behavior (devtools disabled) is what tests should exercise.
**Warning signs:** Tests that manually set `import.meta.env.DEV = true` and then see side effects from Redux DevTools Extension.

### Pitfall 2: `import.meta.glob` in Blade Registrations

**What goes wrong:** The `src/components/blades/registrations/index.ts` uses `import.meta.glob()` for auto-discovery. In Vitest, `import.meta.glob` is supported but the file must be imported for the side effects to execute.
**Why it happens:** Blade registration is side-effect-based -- importing the registration module calls `registerBlade()`.
**How to avoid:** In blade smoke tests, import the specific blade component directly rather than relying on auto-discovery. For tests that need the full registry, import `../components/blades/registrations` explicitly.
**Warning signs:** `getBladeRegistration(type)` returning `undefined` in tests.

### Pitfall 3: `import.meta.hot` References

**What goes wrong:** The blade registrations index uses `import.meta.hot` for HMR. In test environment, `import.meta.hot` is `undefined`.
**Why it happens:** HMR is only available in dev server mode.
**How to avoid:** The existing code already guards with `if (import.meta.hot)`, so no action needed. Just be aware this code path is untested by design.
**Warning signs:** None expected -- the guards are already in place.

### Pitfall 4: WebCrypto Dependency

**What goes wrong:** Tests that use `crypto.randomUUID()` (used in `useBladeStore.pushBlade()` and `useToastStore.addToast()`) fail because jsdom does not provide a complete WebCrypto implementation.
**Why it happens:** jsdom does not implement `crypto.getRandomValues` or `crypto.randomUUID`.
**How to avoid:** Add WebCrypto polyfill in the setup file using Node's `crypto` module.
**Warning signs:** `TypeError: crypto.randomUUID is not a function` in tests.

```typescript
// vitest.setup.ts
import { randomFillSync, randomUUID } from "node:crypto";

if (!globalThis.crypto?.randomUUID) {
  Object.defineProperty(globalThis, "crypto", {
    value: {
      getRandomValues: (buffer: Buffer) => randomFillSync(buffer),
      randomUUID: () => randomUUID(),
    },
  });
}
```

### Pitfall 5: Zustand Devtools Middleware and the Auto-Reset Mock

**What goes wrong:** The `useBladeStore` wraps its state creator with `devtools()` middleware before passing to `create()`. The auto-reset mock intercepts `create()` and captures `getInitialState()`.
**Why it happens:** The mock's `createUncurried` calls `actualCreate(stateCreator)` where `stateCreator` is the function returned by `devtools(...)`. This works correctly because `actualCreate` processes the middleware chain normally.
**How to avoid:** No special handling needed. The mock correctly handles middleware. Just verify that `getInitialState()` returns the expected initial state (it will, because devtools middleware is transparent to state shape).
**Warning signs:** If initial state reset doesn't work for `useBladeStore` specifically, check that the mock is intercepting the curried form of `create()()`.

### Pitfall 6: Async Store Actions and `act()` Warnings

**What goes wrong:** React Testing Library warns about state updates not wrapped in `act()` when store actions trigger async re-renders.
**Why it happens:** Zustand store actions that call `set()` after an `await` trigger React re-renders outside the test's synchronous flow.
**How to avoid:** Use `await act(async () => { ... })` when calling async store actions in tests, or use `waitFor()` from Testing Library.
**Warning signs:** Console warnings about `act()` in test output.

### Pitfall 7: `@tauri-apps/api/event` Listen in App.tsx

**What goes wrong:** `App.tsx` imports `listen` from `@tauri-apps/api/event` for file watcher events. Tests importing components that eventually import App context will fail without mocking.
**Why it happens:** The Tauri event system requires the IPC bridge.
**How to avoid:** Mock `@tauri-apps/api/event` in tests that render App-level components:
```typescript
vi.mock("@tauri-apps/api/event", () => ({
  listen: vi.fn().mockResolvedValue(() => {}),
}));
```
**Warning signs:** `Cannot read properties of undefined` errors related to `__TAURI_INTERNALS__`.

## Code Examples

### Complete Setup File

```typescript
// src/vitest.setup.ts
import "@testing-library/jest-dom/vitest";
import { randomFillSync, randomUUID } from "node:crypto";

// Enable Zustand auto-reset mock (like Jest auto-mocking)
vi.mock("zustand");

// Polyfill WebCrypto for jsdom (used by crypto.randomUUID in stores)
if (!globalThis.crypto?.randomUUID) {
  Object.defineProperty(globalThis, "crypto", {
    value: {
      getRandomValues: (buffer: Buffer) => randomFillSync(buffer),
      randomUUID: () => randomUUID(),
      subtle: {},
    },
  });
}

// Mock Tauri event system globally
vi.mock("@tauri-apps/api/event", () => ({
  listen: vi.fn().mockResolvedValue(() => {}),
  once: vi.fn().mockResolvedValue(() => {}),
  emit: vi.fn().mockResolvedValue(undefined),
}));

// Mock Tauri core (Channel class used by sync operations)
vi.mock("@tauri-apps/api/core", () => ({
  invoke: vi.fn(),
  Channel: vi.fn().mockImplementation(() => ({
    onmessage: vi.fn(),
  })),
}));

// Mock Tauri plugin-store globally
vi.mock("@tauri-apps/plugin-store", () => ({
  Store: {
    load: vi.fn().mockResolvedValue({
      get: vi.fn().mockResolvedValue(null),
      set: vi.fn().mockResolvedValue(undefined),
      save: vi.fn().mockResolvedValue(undefined),
    }),
  },
}));

// Mock Tauri plugin-dialog
vi.mock("@tauri-apps/plugin-dialog", () => ({
  open: vi.fn(),
  save: vi.fn(),
  ask: vi.fn(),
  confirm: vi.fn(),
  message: vi.fn(),
}));
```

### Complete Vitest Configuration

```typescript
// vitest.config.ts
import { defineConfig, mergeConfig } from "vitest/config";
import viteConfig from "./vite.config";

export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      environment: "jsdom",
      globals: true,
      setupFiles: ["./src/vitest.setup.ts"],
      include: ["src/**/*.test.{ts,tsx}"],
      exclude: ["node_modules", "dist", "src-tauri"],
      css: false,
    },
  }),
);
```

### Complete package.json Script Addition

```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  }
}
```

### Store Test Example (Repository Store)

```typescript
// src/stores/repository.test.ts
import { describe, it, expect, vi, beforeEach } from "vitest";
import { createMockCommands, createRepoStatus, ok, err } from "../test-utils/tauri-mocks";

const mockCommands = createMockCommands();
vi.mock("../bindings", () => ({
  commands: mockCommands,
}));

vi.mock("../lib/store", () => ({
  getStore: vi.fn().mockResolvedValue({
    get: vi.fn().mockResolvedValue(null),
    set: vi.fn().mockResolvedValue(undefined),
    save: vi.fn().mockResolvedValue(undefined),
  }),
}));

// Import AFTER mocks are set up
import { useRepositoryStore } from "./repository";

describe("useRepositoryStore", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("has correct initial state", () => {
    const state = useRepositoryStore.getState();
    expect(state.status).toBeNull();
    expect(state.isLoading).toBe(false);
    expect(state.error).toBeNull();
  });

  it("opens a repository successfully", async () => {
    const status = createRepoStatus({ branchName: "develop", isDirty: true });
    mockCommands.openRepository.mockResolvedValue(ok(status));

    await useRepositoryStore.getState().openRepository("/path/to/repo");

    const state = useRepositoryStore.getState();
    expect(state.status).toEqual(status);
    expect(state.isLoading).toBe(false);
    expect(state.error).toBeNull();
    expect(mockCommands.openRepository).toHaveBeenCalledWith("/path/to/repo");
  });

  it("handles open repository error", async () => {
    mockCommands.openRepository.mockResolvedValue(
      err({ type: "NotARepository", message: "Not a git repo" }),
    );

    await expect(
      useRepositoryStore.getState().openRepository("/bad/path"),
    ).rejects.toThrow();

    const state = useRepositoryStore.getState();
    expect(state.status).toBeNull();
    expect(state.error).toBe("Not a git repo");
  });

  it("resets state between tests (auto-reset)", () => {
    // This test proves auto-reset works: state from previous test is gone
    const state = useRepositoryStore.getState();
    expect(state.status).toBeNull();
    expect(state.isLoading).toBe(false);
  });
});
```

### Pure Function Test Example

```typescript
// src/lib/errors.test.ts
import { describe, it, expect } from "vitest";
import { getErrorMessage } from "./errors";
import type { GitError, GitflowError } from "../bindings";

describe("getErrorMessage", () => {
  it("extracts message from GitError with message field", () => {
    const error: GitError = { type: "NotFound", message: "Branch not found" };
    expect(getErrorMessage(error)).toBe("Branch not found");
  });

  it("uses type as message for errors without message field", () => {
    const error: GitError = { type: "NoStagedChanges" } as GitError;
    expect(getErrorMessage(error)).toBe("NoStagedChanges");
  });

  it("handles GitflowError with data string", () => {
    const error = { type: "BranchNotFound", data: "feature/xyz" } as GitflowError;
    expect(getErrorMessage(error)).toBe("BranchNotFound: feature/xyz");
  });
});
```

## Extensibility Architecture for Phases 26-30

### Phase 26: XState Navigation FSM

**What test infrastructure needs to support:**
- Testing XState v5 actors with `createActor()` / `getSnapshot()`
- Mocking actions and guards injected via `setup({ actions: { ... } })`
- No additional test utilities needed -- XState testing uses `vitest` directly

**Infrastructure extension:** None. Vitest + `xstate` is sufficient. Tests will be `*.test.ts` files (not `.tsx`) since XState machines are pure logic.

### Phase 27-28: New Blade Types (Init Repo, Conventional Commit)

**What test infrastructure needs to support:**
- Blade smoke tests following the same pattern as Phase 25 blade tests
- Additional mock fixtures for new Tauri commands (if any are added)
- Component interaction tests using `@testing-library/user-event`

**Infrastructure extension:** Add new fixture factories to `test-utils/tauri-mocks.ts`. The custom render wrapper already provides QueryClientProvider.

### Phase 29: Blade-Centric File Structure

**What test infrastructure needs to support:**
- Tests co-located in `blades/{blade-name}/` directories
- Test utility imports via `@/test-utils/` path alias

**Infrastructure extension:** None. Co-located tests will naturally move with their source files. The `@/` alias resolves correctly for test-utils imports.

### Phase 30: Store Consolidation

**What test infrastructure needs to support:**
- Testing consolidated domain stores (5 stores instead of 21)
- The Zustand auto-reset mock handles any number of stores automatically

**Infrastructure extension:** None. The auto-reset mock pattern works regardless of how many stores exist or how they're organized.

## Sub-Project Extraction Architecture

### Module: `src/test-utils/tauri-mocks.ts`

**Responsibility:** Typed mock factories for all Tauri IPC commands and plugin-store.
**Dependencies:** Types from `../bindings` (import type only), `vitest` globals.
**Evolution path:** As new Tauri commands are added (phases 27-28), new factories are added here. When stores consolidate (phase 30), the mock commands stay the same (they mirror Tauri bindings, not Zustand stores).
**Can be extracted as package?** Not recommended yet -- it depends on the project's `bindings.ts` types. Could become a separate `test-utils` package in a monorepo structure.

### Module: `src/test-utils/store-helpers.ts`

**Responsibility:** Utilities for testing Zustand stores (convenience functions for state assertions, action invocation patterns).
**Dependencies:** `zustand` types.
**Evolution path:** Phase 30 store consolidation may add domain-specific helpers. Phase 26 may add XState-to-Zustand bridge test helpers.
**Can be extracted as package?** The `__mocks__/zustand.ts` file is the real utility; `store-helpers.ts` provides thin convenience wrappers.

### Module: `src/test-utils/render.tsx`

**Responsibility:** Custom render with providers (QueryClient, future providers).
**Dependencies:** `@testing-library/react`, `@tanstack/react-query`.
**Evolution path:** Phase 26 may add an XState context provider. Phase 29 may not need changes (providers are application-level, not blade-level).
**Can be extracted as package?** Not recommended -- tightly coupled to the app's provider tree.

## Discretion Decisions (Recommendations)

### Mock Strategy: Module-level vi.mock with typed factory functions

**Decision:** Use `vi.mock("../bindings", ...)` at the module level with typed factory functions from `test-utils/tauri-mocks.ts`.
**Rationale:** Type-safe, simple, avoids WebCrypto polyfill for `@tauri-apps/api/mocks`, works naturally with tauri-specta generated code.
**Fidelity level:** Mock return values match the exact TypeScript types from `bindings.ts`. Default mock responses use sensible defaults (empty arrays, null states). Tests override specific commands as needed.

### Test Organization: Co-located, `*.test.ts` convention

**Decision:** Tests live next to source files (`foo.ts` -> `foo.test.ts`). Test utilities in `src/test-utils/`. Zustand mock in `src/__mocks__/zustand.ts`.
**Rationale:** Aligns with Phase 29 blade-centric restructuring. Vitest default convention. Easy to find tests.

### Coverage & CI: No enforcement in Phase 25

**Decision:** Do not enforce coverage thresholds in this phase. Add `test` and `test:watch` scripts. CI integration is out of scope (no CI config exists yet).
**Rationale:** Phase 25 establishes infrastructure. Enforcing coverage on a greenfield test suite with 0% baseline is meaningless. Coverage thresholds should be added when there's meaningful test mass.

### Smoke Test Scope: All 13 blade types, render-only

**Decision:** Write smoke tests for all 13 blade types. Each test verifies the component renders without throwing (no interaction testing).
**Rationale:** There are only 13 blades -- testing all of them is minimal effort. Render-only tests catch import errors, missing providers, and unguarded null access. This creates a safety net for Phase 29's file restructuring.

**The 13 blade types:**
1. staging-changes
2. topology-graph
3. commit-details
4. diff
5. viewer-nupkg
6. viewer-image
7. viewer-markdown
8. viewer-3d
9. viewer-code
10. repo-browser
11. settings
12. changelog
13. gitflow-cheatsheet

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `@xstate/test` standalone package | Integrated testing via `createActor`/`getSnapshot` in xstate v5 | Dec 2023 (XState v5 release) | No separate test package needed |
| Jest for Vite projects | Vitest | 2022-2023 | Native ESM support, shared Vite config, faster |
| Manual Zustand reset in beforeEach | `__mocks__/zustand.ts` auto-reset pattern | Documented in Zustand v4+, works in v5 | Zero-effort store isolation |
| `@tauri-apps/api/mocks` mockIPC | Module-level mocking of bindings | Community pattern for tauri-specta | Better type safety, simpler setup |

**Deprecated/outdated:**
- `@xstate/test` standalone: Superseded by built-in XState v5 testing patterns
- Jest with Vite: Requires additional transformers; Vitest is the standard choice for Vite projects

## Open Questions

1. **Vitest version: v3 vs v4?**
   - What we know: Vitest v3 is stable and widely used. Vitest v4 was recently released.
   - What's unclear: Whether v4 has breaking changes that affect the setup.
   - Recommendation: Use `^3` for stability. The config patterns are identical. Can upgrade to v4 later.

2. **`import.meta.glob` in tests?**
   - What we know: Vitest supports `import.meta.glob` but it may behave differently than in Vite dev server.
   - What's unclear: Whether blade registration auto-discovery works correctly in test environment.
   - Recommendation: For smoke tests, import blade components directly. Don't rely on `import.meta.glob` auto-discovery in tests. Test the registry separately if needed.

3. **Monaco Editor in tests?**
   - What we know: `@monaco-editor/react` and `three` (used by viewer-3d blade) are heavy dependencies that may not work in jsdom.
   - What's unclear: Whether smoke tests for `ViewerCodeBlade` and `Viewer3dBlade` will need special mocking.
   - Recommendation: Mock `@monaco-editor/react` and `three` modules in smoke tests. These are rendering libraries that need a real browser.

## Sources

### Primary (HIGH confidence)
- Zustand testing guide: https://zustand.docs.pmnd.rs/guides/testing -- Auto-reset mock pattern (Vitest variant)
- Vitest configuration: https://main.vitest.dev/config -- Environment, globals, setupFiles
- Vitest features: https://main.vitest.dev/guide/features -- Environment configuration
- Testing Library setup: https://testing-library.com/docs/react-testing-library/setup -- Custom render pattern
- Tauri v2 mocking: https://v2.tauri.app/develop/tests/mocking/ -- mockIPC, clearMocks, WebCrypto polyfill
- Tauri v2 mocks API: https://v2.tauri.app/reference/javascript/api/namespacemocks/ -- Function signatures
- XState v5 testing: https://stately.ai/docs/testing -- Actor testing with createActor/getSnapshot
- Codebase analysis: Direct inspection of 21 stores, 13 blades, bindings.ts (50+ commands)

### Secondary (MEDIUM confidence)
- Vitest + React Testing Library integration patterns: Multiple blog posts from 2025-2026 confirm the setup pattern
- XState v5 model-based testing deprecation of `@xstate/test`: https://github.com/statelyai/xstate/discussions/4761

### Tertiary (LOW confidence)
- None -- all findings verified through official docs or codebase inspection.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- Vitest + RTL + jest-dom is the undisputed standard for Vite/React projects
- Architecture: HIGH -- Patterns verified through official Zustand docs, Tauri docs, and codebase analysis
- Pitfalls: HIGH -- Identified through codebase inspection (import.meta.env, WebCrypto, glob, middleware)
- Extensibility: MEDIUM -- Phase 26-30 requirements are defined but implementations may reveal new needs

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (stable domain, 30 days)
