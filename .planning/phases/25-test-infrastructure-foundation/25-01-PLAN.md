---
phase: 25-test-infrastructure-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vitest.config.ts
  - package.json
  - tsconfig.json
  - src/__mocks__/zustand.ts
  - src/test-utils/setup.ts
  - src/test-utils/index.ts
  - src/stores/blades.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can run `npm test` and Vitest executes with jsdom environment"
    - "Developer can write a Zustand store test where state resets automatically between test cases"
  artifacts:
    - path: "vitest.config.ts"
      provides: "Vitest configuration extending vite.config.ts"
      contains: "environment.*jsdom"
    - path: "src/__mocks__/zustand.ts"
      provides: "Zustand auto-reset mock (official pattern)"
      contains: "storeResetFns"
    - path: "src/test-utils/setup.ts"
      provides: "Global test setup with polyfills and mocks"
      contains: "jest-dom/vitest"
    - path: "src/stores/blades.test.ts"
      provides: "Store test proving auto-reset works"
      contains: "resets state between tests"
  key_links:
    - from: "vitest.config.ts"
      to: "vite.config.ts"
      via: "mergeConfig"
      pattern: "mergeConfig.*viteConfig"
    - from: "vitest.config.ts"
      to: "src/test-utils/setup.ts"
      via: "setupFiles"
      pattern: "setupFiles.*setup\\.ts"
    - from: "src/test-utils/setup.ts"
      to: "src/__mocks__/zustand.ts"
      via: "vi.mock('zustand')"
      pattern: "vi\\.mock.*zustand"
---

<objective>
Install Vitest with jsdom, create the global test setup, and establish the Zustand auto-reset mock pattern with a verification test.

Purpose: This is the foundation plan. Every subsequent test depends on Vitest running, jsdom providing DOM APIs, and Zustand stores resetting between tests. Without this, no other test infrastructure work can proceed.

Output: Working `npm test` command, Vitest config, global setup file, Zustand auto-reset mock, and a blades store test proving isolation works.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-test-infrastructure-foundation/25-RESEARCH.md
@.planning/phases/25-test-infrastructure-foundation/25-RESEARCH-ARCHITECTURE.md
@vite.config.ts
@package.json
@tsconfig.json
@src/stores/blades.ts
@src/stores/bladeTypes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, create Vitest config, and update project configs</name>
  <files>
    package.json
    vitest.config.ts
    tsconfig.json
  </files>
  <action>
1. Install dev dependencies:
   ```bash
   npm install -D vitest@^3.2 jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event @vitest/coverage-v8
   ```
   Note: Use vitest ^3.2 (NOT v4) to avoid jsdom compat issues per research (GitHub issue #9279). jsdom is a peer dep of vitest jsdom environment.

2. Install production dependencies for Phase 26 preparation:
   ```bash
   npm install xstate @xstate/react
   ```
   XState is needed as a production dependency because Phase 26 will use it in source files. Installing now satisfies ARCH-02.

3. Add test scripts to `package.json` scripts section:
   ```json
   "test": "vitest run",
   "test:watch": "vitest",
   "test:coverage": "vitest run --coverage"
   ```
   - `npm test` = single run (CI, verification)
   - `npm run test:watch` = watch mode (developer workflow)
   - `npm run test:coverage` = coverage report (no thresholds enforced)

4. Create `vitest.config.ts` at project root:
   ```typescript
   import { defineConfig, mergeConfig } from "vitest/config";
   import viteConfig from "./vite.config";

   export default mergeConfig(
     viteConfig,
     defineConfig({
       test: {
         globals: true,
         environment: "jsdom",
         setupFiles: ["./src/test-utils/setup.ts"],
         include: ["src/**/*.test.{ts,tsx}"],
         exclude: ["node_modules", "dist", "src-tauri"],
         css: false,
         coverage: {
           provider: "v8",
           include: ["src/**/*.{ts,tsx}"],
           exclude: [
             "src/bindings.ts",
             "src/test-utils/**",
             "src/__mocks__/**",
             "src/vite-env.d.ts",
             "src/**/*.test.{ts,tsx}",
           ],
         },
       },
     }),
   );
   ```
   Key: `globals: true` enables describe/it/expect/vi without imports. `css: false` skips Tailwind processing. `mergeConfig` inherits the `@` path alias from vite.config.ts.

5. Update `tsconfig.json` to add vitest globals types. Add `"types": ["vitest/globals"]` inside `compilerOptions`. Also add `"paths": { "@/*": ["./src/*"] }` and `"baseUrl": "."` to compilerOptions so TypeScript resolves the `@` alias that vite.config.ts defines (this enables test-utils imports via `@/test-utils/...` if ever needed, though the codebase currently uses relative imports).

   The final compilerOptions should include:
   ```json
   "types": ["vitest/globals"]
   ```
  </action>
  <verify>
Run `npx vitest --version` to confirm Vitest is installed. Run `npx tsc --noEmit` (expect the pre-existing TS2440 error in bindings.ts only -- no new errors from config changes).
  </verify>
  <done>
Vitest ^3.2 installed, vitest.config.ts exists with jsdom environment, package.json has test/test:watch/test:coverage scripts, tsconfig.json includes vitest/globals types. XState and @xstate/react installed as production dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create global test setup, Zustand auto-reset mock, and barrel export</name>
  <files>
    src/test-utils/setup.ts
    src/test-utils/index.ts
    src/__mocks__/zustand.ts
  </files>
  <action>
1. Create `src/__mocks__/zustand.ts` with the official Zustand auto-reset mock pattern from the Zustand testing docs (Vitest variant). This file intercepts `create()` and `createStore()`, captures initial state via `getInitialState()`, and resets all stores after each test via `afterEach`. The mock handles both curried (`create()(fn)`) and uncurried (`create(fn)`) forms, which covers the `devtools` middleware used by `useBladeStore`.

   Exact content:
   ```typescript
   import { act } from "@testing-library/react";
   import type * as ZustandExportedTypes from "zustand";
   export * from "zustand";

   const { create: actualCreate, createStore: actualCreateStore } =
     await vi.importActual<typeof ZustandExportedTypes>("zustand");

   export const storeResetFns = new Set<() => void>();

   const createUncurried = <T>(
     stateCreator: ZustandExportedTypes.StateCreator<T>,
   ) => {
     const store = actualCreate(stateCreator);
     const initialState = store.getInitialState();
     storeResetFns.add(() => {
       store.setState(initialState, true);
     });
     return store;
   };

   export const create = (<T>(
     stateCreator: ZustandExportedTypes.StateCreator<T>,
   ) => {
     return typeof stateCreator === "function"
       ? createUncurried(stateCreator)
       : createUncurried;
   }) as typeof ZustandExportedTypes.create;

   const createStoreUncurried = <T>(
     stateCreator: ZustandExportedTypes.StateCreator<T>,
   ) => {
     const store = actualCreateStore(stateCreator);
     const initialState = store.getInitialState();
     storeResetFns.add(() => {
       store.setState(initialState, true);
     });
     return store;
   };

   export const createStore = (<T>(
     stateCreator: ZustandExportedTypes.StateCreator<T>,
   ) => {
     return typeof stateCreator === "function"
       ? createStoreUncurried(stateCreator)
       : createStoreUncurried;
   }) as typeof ZustandExportedTypes.createStore;

   afterEach(() => {
     act(() => {
       storeResetFns.forEach((resetFn) => {
         resetFn();
       });
     });
   });
   ```

2. Create `src/test-utils/setup.ts` -- the global setup file referenced by vitest.config.ts setupFiles:
   ```typescript
   // Global test setup - runs before every test file
   import "@testing-library/jest-dom/vitest";
   import { MotionGlobalConfig } from "framer-motion";

   // Skip framer-motion animations in tests (official solution)
   MotionGlobalConfig.skipAnimations = true;

   // Enable Zustand auto-mocking (works with __mocks__/zustand.ts)
   vi.mock("zustand");

   // Polyfill crypto.randomUUID for jsdom
   // Used by: blades store (pushBlade), toast store (addToast)
   if (!globalThis.crypto?.randomUUID) {
     const nodeCrypto = await import("node:crypto");
     Object.defineProperty(globalThis, "crypto", {
       value: {
         ...globalThis.crypto,
         getRandomValues: (buffer: Uint8Array) => nodeCrypto.randomFillSync(buffer),
         randomUUID: () => nodeCrypto.randomUUID(),
         subtle: globalThis.crypto?.subtle ?? {},
       },
     });
   }

   // Mock @tauri-apps/api/event globally (used by App.tsx for file watcher)
   vi.mock("@tauri-apps/api/event", () => ({
     listen: vi.fn().mockResolvedValue(() => {}),
     once: vi.fn().mockResolvedValue(() => {}),
     emit: vi.fn().mockResolvedValue(undefined),
   }));

   // Mock @tauri-apps/api/core (Channel class used by sync operations)
   vi.mock("@tauri-apps/api/core", () => ({
     invoke: vi.fn(),
     Channel: vi.fn().mockImplementation(() => ({
       onmessage: vi.fn(),
     })),
   }));

   // Mock @tauri-apps/plugin-store globally (used by 5 stores via getStore())
   vi.mock("@tauri-apps/plugin-store", () => ({
     Store: {
       load: vi.fn().mockResolvedValue({
         get: vi.fn().mockResolvedValue(null),
         set: vi.fn().mockResolvedValue(undefined),
         save: vi.fn().mockResolvedValue(undefined),
       }),
     },
   }));

   // Mock @tauri-apps/plugin-dialog (used by repository open dialogs)
   vi.mock("@tauri-apps/plugin-dialog", () => ({
     open: vi.fn(),
     save: vi.fn(),
     ask: vi.fn(),
     confirm: vi.fn(),
     message: vi.fn(),
   }));

   // Mock @tauri-apps/plugin-opener
   vi.mock("@tauri-apps/plugin-opener", () => ({
     openUrl: vi.fn(),
     openPath: vi.fn(),
   }));
   ```

3. Create `src/test-utils/index.ts` as a barrel export:
   ```typescript
   // Test utilities barrel export
   // Usage: import { render, screen } from "../test-utils";
   export { render, screen, within, waitFor, fireEvent, cleanup } from "./render";
   ```
   Note: The render export will be added in Plan 02. For now, just re-export from @testing-library/react as a placeholder:
   ```typescript
   // Test utilities barrel export
   // Note: Custom render with providers will be added in Plan 02
   export { render, screen, within, waitFor, fireEvent, cleanup } from "@testing-library/react";
   ```
  </action>
  <verify>
Run `npm test -- --run` (should find no test files yet but NOT error on config/setup issues). If it reports "No test files found", that's correct -- the setup loaded without errors.
  </verify>
  <done>
`src/__mocks__/zustand.ts` exists with official auto-reset pattern. `src/test-utils/setup.ts` exists with jest-dom matchers, crypto polyfill, framer-motion skip, and all Tauri plugin mocks. `src/test-utils/index.ts` exists as barrel export. Vitest setup loads without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create blades store test proving Zustand auto-reset works</name>
  <files>
    src/stores/blades.test.ts
  </files>
  <action>
Create `src/stores/blades.test.ts` to verify:
1. The Zustand auto-reset mock correctly handles the `devtools` middleware used by `useBladeStore`
2. Store state resets between tests (no cross-test pollution)
3. Basic store operations work (pushBlade, popBlade, setProcess)

The blades store uses `create()(devtools(...))` curried form. This test validates the mock handles it.

```typescript
// src/stores/blades.test.ts
import { useBladeStore } from "./blades";

describe("useBladeStore", () => {
  it("has correct initial state with staging root blade", () => {
    const state = useBladeStore.getState();
    expect(state.activeProcess).toBe("staging");
    expect(state.bladeStack).toHaveLength(1);
    expect(state.bladeStack[0].type).toBe("staging-changes");
  });

  it("pushBlade adds a blade to the stack", () => {
    useBladeStore.getState().pushBlade({
      type: "settings",
      title: "Settings",
      props: {} as Record<string, never>,
    });

    const state = useBladeStore.getState();
    expect(state.bladeStack).toHaveLength(2);
    expect(state.bladeStack[1].type).toBe("settings");
  });

  it("resets state between tests (auto-reset verification)", () => {
    // This test runs AFTER pushBlade test above.
    // If auto-reset works correctly, stack should be back to 1 blade.
    const { bladeStack } = useBladeStore.getState();
    expect(bladeStack).toHaveLength(1);
    expect(bladeStack[0].type).toBe("staging-changes");
  });

  it("popBlade does not remove root blade", () => {
    useBladeStore.getState().popBlade();
    expect(useBladeStore.getState().bladeStack).toHaveLength(1);
  });

  it("setProcess resets stack to process root", () => {
    useBladeStore.getState().setProcess("topology");
    const state = useBladeStore.getState();
    expect(state.activeProcess).toBe("topology");
    expect(state.bladeStack[0].type).toBe("topology-graph");
  });
});
```

IMPORTANT: The test order matters for the auto-reset verification. The "resets state between tests" test MUST come after "pushBlade adds a blade" to prove state was cleaned up.
  </action>
  <verify>
Run `npm test` -- all 5 tests in blades.test.ts should pass. The critical test is "resets state between tests" which proves the Zustand auto-reset mock is working correctly with the devtools middleware.
  </verify>
  <done>
`npm test` passes with 5/5 tests green. The auto-reset verification test confirms state isolation between test cases. The devtools middleware in `useBladeStore` does not interfere with the mock.
  </done>
</task>

</tasks>

<verification>
1. `npm test` runs Vitest with jsdom environment and all 5 blades store tests pass
2. `npm run test:watch` starts Vitest in watch mode (verify it starts, then Ctrl+C)
3. The auto-reset test proves Zustand store state does not leak between tests
4. No TypeScript errors from vitest.config.ts or tsconfig.json changes (ignore pre-existing TS2440 in bindings.ts)
</verification>

<success_criteria>
- `npm test` exits with code 0, showing 5 passing tests
- vitest.config.ts merges with vite.config.ts (path alias works)
- Zustand store resets between tests without manual cleanup
- All Tauri plugins are mocked in setup.ts (no __TAURI_INTERNALS__ errors)
- crypto.randomUUID() works in tests (no polyfill errors)
</success_criteria>

<output>
After completion, create `.planning/phases/25-test-infrastructure-foundation/25-01-SUMMARY.md`
</output>
