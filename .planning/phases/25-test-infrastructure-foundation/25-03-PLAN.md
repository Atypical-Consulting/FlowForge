---
phase: 25-test-infrastructure-foundation
plan: 03
type: execute
wave: 3
depends_on: ["25-02"]
files_modified:
  - src/components/blades/SettingsBlade.test.tsx
  - src/components/blades/ChangelogBlade.test.tsx
  - src/components/blades/GitflowCheatsheetBlade.test.tsx
  - src/components/blades/StagingChangesBlade.test.tsx
  - src/components/blades/TopologyRootBlade.test.tsx
  - src/components/blades/CommitDetailsBlade.test.tsx
  - src/components/blades/DiffBlade.test.tsx
  - src/components/blades/RepoBrowserBlade.test.tsx
  - src/components/blades/ViewerCodeBlade.test.tsx
  - src/components/blades/ViewerImageBlade.test.tsx
  - src/components/blades/ViewerMarkdownBlade.test.tsx
  - src/components/blades/ViewerNupkgBlade.test.tsx
  - src/components/blades/Viewer3dBlade.test.tsx
  - src/lib/xstate-example.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can run component smoke tests that verify each blade type renders without crashing"
    - "Developer can test XState machine guards and transitions with deterministic assertions (no DOM needed)"
  artifacts:
    - path: "src/components/blades/SettingsBlade.test.tsx"
      provides: "Smoke test for settings blade"
      contains: "renders without crashing"
    - path: "src/components/blades/StagingChangesBlade.test.tsx"
      provides: "Smoke test for staging blade (most complex)"
      contains: "renders without crashing"
    - path: "src/lib/xstate-example.test.ts"
      provides: "XState machine test pattern for Phase 26"
      contains: "createActor"
  key_links:
    - from: "src/components/blades/SettingsBlade.test.tsx"
      to: "src/test-utils/render.tsx"
      via: "custom render import"
      pattern: "from.*test-utils"
    - from: "src/lib/xstate-example.test.ts"
      to: "xstate"
      via: "import createActor"
      pattern: "import.*createActor.*xstate"
---

<objective>
Create smoke tests for all 13 blade types and an XState machine test example demonstrating guards and transitions.

Purpose: Blade smoke tests provide a regression safety net for Phase 29's file restructuring -- every blade that can render today will be verified after moves. The XState test demonstrates the pattern Phase 26 will follow for the navigation FSM, satisfying ARCH-02.

Output: 13 blade smoke test files (co-located) and 1 XState machine test file with guard/transition assertions.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-test-infrastructure-foundation/25-RESEARCH.md
@.planning/phases/25-test-infrastructure-foundation/25-RESEARCH-EXPERT.md
@.planning/phases/25-test-infrastructure-foundation/25-02-SUMMARY.md
@src/stores/bladeTypes.ts
@src/test-utils/render.tsx
@src/test-utils/mocks/tauri-commands.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create smoke tests for all 13 blade types</name>
  <files>
    src/components/blades/SettingsBlade.test.tsx
    src/components/blades/ChangelogBlade.test.tsx
    src/components/blades/GitflowCheatsheetBlade.test.tsx
    src/components/blades/StagingChangesBlade.test.tsx
    src/components/blades/TopologyRootBlade.test.tsx
    src/components/blades/CommitDetailsBlade.test.tsx
    src/components/blades/DiffBlade.test.tsx
    src/components/blades/RepoBrowserBlade.test.tsx
    src/components/blades/ViewerCodeBlade.test.tsx
    src/components/blades/ViewerImageBlade.test.tsx
    src/components/blades/ViewerMarkdownBlade.test.tsx
    src/components/blades/ViewerNupkgBlade.test.tsx
    src/components/blades/Viewer3dBlade.test.tsx
  </files>
  <action>
Create a smoke test for each of the 13 blade types. Each test verifies the component renders without crashing. Import components directly (bypass React.lazy wrappers -- smoke tests verify the component, not the lazy loading mechanism).

**For each blade test file:**
1. Import `render` from the custom render wrapper (`../../test-utils/render` or `../../test-utils`)
2. Import the blade component directly from its file
3. Mock `../../bindings` with `createMockCommands()` if the blade uses Tauri IPC
4. Mock any heavy third-party dependencies (Monaco Editor, Three.js) that don't work in jsdom
5. Provide required props as specified in `BladePropsMap` (from `src/stores/bladeTypes.ts`)

**Blade categories and their requirements:**

**Simple blades (no props, no IPC):**
- `SettingsBlade` -- props: `Record<string, never>`, may read from settings store
- `ChangelogBlade` -- props: `Record<string, never>`, uses changelogStore which calls IPC
- `GitflowCheatsheetBlade` -- props: `Record<string, never>`, static content

**Process root blades (no explicit props, but use stores with IPC):**
- `StagingChangesBlade` -- props: `Record<string, never>`, uses staging store + useQuery for getStagingStatus
- `TopologyRootBlade` -- props: `Record<string, never>`, uses topology store + commit graph IPC

**Detail blades (require props):**
- `CommitDetailsBlade` -- props: `{ oid: string }`, calls getCommitDetails IPC
- `DiffBlade` -- props: `{ source: DiffSource }`, calls getFileDiff IPC. Read DiffBlade.tsx to determine what DiffSource shape is needed (likely `{ type: "staging"; path: string; isStaged: boolean }` or similar)
- `RepoBrowserBlade` -- props: `{ path?: string }`, may call file listing IPC

**Viewer blades (require filePath prop, may need heavy dep mocks):**
- `ViewerCodeBlade` -- props: `{ filePath: string }`. Mock `@monaco-editor/react` (heavy dependency that doesn't work in jsdom)
- `ViewerImageBlade` -- props: `{ filePath: string; oid?: string }`
- `ViewerMarkdownBlade` -- props: `{ filePath: string }`
- `ViewerNupkgBlade` -- props: `{ filePath: string }`
- `Viewer3dBlade` -- props: `{ filePath: string }`. Mock `three` and related modules (WebGL doesn't work in jsdom)

**Heavy dependency mocking:**

For ViewerCodeBlade, mock Monaco Editor:
```typescript
vi.mock("@monaco-editor/react", () => ({
  default: () => <div data-testid="mock-monaco-editor" />,
  Editor: () => <div data-testid="mock-monaco-editor" />,
}));
```

For Viewer3dBlade, mock Three.js:
```typescript
vi.mock("three", () => ({
  Scene: vi.fn(),
  PerspectiveCamera: vi.fn(),
  WebGLRenderer: vi.fn().mockImplementation(() => ({
    setSize: vi.fn(),
    setPixelRatio: vi.fn(),
    dispose: vi.fn(),
    domElement: document.createElement("canvas"),
    render: vi.fn(),
  })),
  // ... other Three.js classes as needed
}));
vi.mock("three/examples/jsm/loaders/GLTFLoader", () => ({
  GLTFLoader: vi.fn(),
}));
vi.mock("three/examples/jsm/controls/OrbitControls", () => ({
  OrbitControls: vi.fn().mockImplementation(() => ({
    dispose: vi.fn(),
    update: vi.fn(),
  })),
}));
```

**Pattern for each smoke test:**
```tsx
// Example: src/components/blades/SettingsBlade.test.tsx
import { render } from "../../test-utils/render";
import { createMockCommands } from "../../test-utils/mocks/tauri-commands";

vi.mock("../../bindings", () => ({
  commands: createMockCommands(),
}));

// Import component AFTER mock setup
import { SettingsBlade } from "./SettingsBlade";

describe("SettingsBlade", () => {
  it("renders without crashing", () => {
    const { container } = render(<SettingsBlade />);
    expect(container.firstChild).not.toBeNull();
  });
});
```

**IMPORTANT NOTES:**
- Read each blade component file BEFORE writing its test to determine:
  - What imports it uses (stores, hooks, IPC commands)
  - Whether it uses useQuery or any React Query hooks
  - Whether it has conditional rendering based on store state
  - Whether it imports heavy libs (Monaco, Three.js, etc.)
- Some blades may need additional module mocks beyond bindings and plugins. Common candidates:
  - `@xyflow/react` (used by TopologyRootBlade) -- mock if it causes jsdom errors
  - `react-resizable-panels` -- mock if it uses ResizeObserver (not in jsdom)
  - `react-virtuoso` -- mock if it uses IntersectionObserver (not in jsdom)
- If a blade component has a default export vs named export, adjust the import accordingly
- Each test file should have EXACTLY ONE test: "renders without crashing". Do not test interactions.
- If a blade absolutely cannot render in jsdom even with mocking (extremely rare), add a TODO comment explaining why and skip it with `it.todo("renders without crashing - requires [X] mock")`
  </action>
  <verify>
Run `npm test` -- all 13 blade smoke tests should pass plus all previous tests. Total should be approximately 26+ tests passing.

If any blade fails, read the error carefully:
- "X is not defined" → need to mock another module
- "Cannot read properties of undefined" → store or IPC not mocked
- "Not implemented: X" → jsdom limitation, mock the browser API
  </verify>
  <done>
All 13 blade types have co-located smoke tests. Each test verifies the blade renders without crashing. Heavy dependencies (Monaco, Three.js) are mocked. All smoke tests pass with `npm test`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create XState machine test demonstrating guards and transitions</name>
  <files>
    src/lib/xstate-example.test.ts
  </files>
  <action>
Create `src/lib/xstate-example.test.ts` -- an XState v5 machine test that demonstrates the testing pattern Phase 26 will use for the navigation FSM.

This test satisfies ARCH-02: "Developer can test XState navigation machine guards and transitions with unit tests."

The test defines a small example navigation machine (NOT the real one -- that comes in Phase 26) and tests:
1. Initial state assertion
2. Transition on event
3. Guard that blocks transition (guard returns false)
4. Guard that allows transition (guard returns true)
5. Context updates via assign actions
6. Multiple sequential transitions

```typescript
// src/lib/xstate-example.test.ts
//
// XState v5 machine testing pattern for Phase 26.
// This file demonstrates HOW to test machines with guards and transitions.
// Phase 26 will replace this with the actual navigation FSM tests.

import { setup, assign, createActor } from "xstate";

// Example navigation machine (simplified for testing pattern demonstration)
const navigationMachine = setup({
  types: {
    context: {} as {
      repoPath: string | null;
      bladeStack: string[];
    },
    events: {} as
      | { type: "OPEN_REPO"; path: string }
      | { type: "CLOSE_REPO" }
      | { type: "PUSH_BLADE"; bladeType: string }
      | { type: "POP_BLADE" },
  },
  guards: {
    isRepoOpen: ({ context }) => context.repoPath !== null,
    hasMultipleBlades: ({ context }) => context.bladeStack.length > 1,
  },
}).createMachine({
  id: "navigation",
  initial: "idle",
  context: {
    repoPath: null,
    bladeStack: [],
  },
  states: {
    idle: {
      on: {
        OPEN_REPO: {
          target: "repoOpen",
          actions: assign({
            repoPath: ({ event }) => event.path,
            bladeStack: () => ["staging-changes"],
          }),
        },
      },
    },
    repoOpen: {
      on: {
        PUSH_BLADE: {
          guard: "isRepoOpen",
          actions: assign({
            bladeStack: ({ context, event }) => [
              ...context.bladeStack,
              event.bladeType,
            ],
          }),
        },
        POP_BLADE: {
          guard: "hasMultipleBlades",
          actions: assign({
            bladeStack: ({ context }) => context.bladeStack.slice(0, -1),
          }),
        },
        CLOSE_REPO: {
          target: "idle",
          actions: assign({
            repoPath: () => null,
            bladeStack: () => [],
          }),
        },
      },
    },
  },
});

describe("XState navigation machine (example)", () => {
  it("starts in idle state", () => {
    const actor = createActor(navigationMachine);
    actor.start();

    expect(actor.getSnapshot().value).toBe("idle");
    expect(actor.getSnapshot().context.repoPath).toBeNull();
    expect(actor.getSnapshot().context.bladeStack).toEqual([]);

    actor.stop();
  });

  it("transitions to repoOpen on OPEN_REPO", () => {
    const actor = createActor(navigationMachine);
    actor.start();

    actor.send({ type: "OPEN_REPO", path: "/test/repo" });

    const snapshot = actor.getSnapshot();
    expect(snapshot.value).toBe("repoOpen");
    expect(snapshot.context.repoPath).toBe("/test/repo");
    expect(snapshot.context.bladeStack).toEqual(["staging-changes"]);

    actor.stop();
  });

  it("PUSH_BLADE adds to stack when repo is open (guard passes)", () => {
    const actor = createActor(navigationMachine);
    actor.start();

    actor.send({ type: "OPEN_REPO", path: "/test/repo" });
    actor.send({ type: "PUSH_BLADE", bladeType: "commit-details" });

    expect(actor.getSnapshot().context.bladeStack).toEqual([
      "staging-changes",
      "commit-details",
    ]);

    actor.stop();
  });

  it("POP_BLADE removes from stack when multiple blades exist (guard passes)", () => {
    const actor = createActor(navigationMachine);
    actor.start();

    actor.send({ type: "OPEN_REPO", path: "/test/repo" });
    actor.send({ type: "PUSH_BLADE", bladeType: "diff" });
    actor.send({ type: "POP_BLADE" });

    expect(actor.getSnapshot().context.bladeStack).toEqual([
      "staging-changes",
    ]);

    actor.stop();
  });

  it("POP_BLADE does nothing when only one blade (guard blocks)", () => {
    const actor = createActor(navigationMachine);
    actor.start();

    actor.send({ type: "OPEN_REPO", path: "/test/repo" });
    // Only one blade in stack -- guard should block POP_BLADE
    actor.send({ type: "POP_BLADE" });

    expect(actor.getSnapshot().context.bladeStack).toEqual([
      "staging-changes",
    ]);

    actor.stop();
  });

  it("CLOSE_REPO returns to idle and clears context", () => {
    const actor = createActor(navigationMachine);
    actor.start();

    actor.send({ type: "OPEN_REPO", path: "/test/repo" });
    actor.send({ type: "PUSH_BLADE", bladeType: "settings" });
    actor.send({ type: "CLOSE_REPO" });

    const snapshot = actor.getSnapshot();
    expect(snapshot.value).toBe("idle");
    expect(snapshot.context.repoPath).toBeNull();
    expect(snapshot.context.bladeStack).toEqual([]);

    actor.stop();
  });

  it("ignores PUSH_BLADE in idle state (no transition defined)", () => {
    const actor = createActor(navigationMachine);
    actor.start();

    // Send PUSH_BLADE while in idle -- should be ignored
    actor.send({ type: "PUSH_BLADE", bladeType: "settings" });

    expect(actor.getSnapshot().value).toBe("idle");
    expect(actor.getSnapshot().context.bladeStack).toEqual([]);

    actor.stop();
  });
});
```

NOTE: This test does NOT need jsdom, DOM, or any mocks. It uses pure TypeScript with XState's `createActor` + `getSnapshot()`. It demonstrates the exact pattern Phase 26 will follow for the real navigation FSM machine. The machine defined here is intentionally simplified -- Phase 26 will implement the full machine with more states, guards, and side effects.
  </action>
  <verify>
Run `npm test` -- all XState tests should pass (7 tests). The critical tests are "POP_BLADE does nothing when only one blade (guard blocks)" and "ignores PUSH_BLADE in idle state" which prove guards and state isolation work deterministically.

Total test count should be approximately 33+ tests passing (5 blades + 4 repository + 4 toast + 13 smoke + 7 xstate).
  </verify>
  <done>
`src/lib/xstate-example.test.ts` exists with 7 tests demonstrating XState v5 guards, transitions, context updates, and deterministic assertions. All tests pass without DOM or mocks. Phase 26 has a clear pattern to follow.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes with ALL tests (store tests + blade smoke tests + XState tests)
2. All 13 blade types have a passing smoke test
3. XState tests demonstrate guards that block transitions and guards that allow them
4. No blade smoke test uses the lazy() wrapper -- all import directly
5. Heavy dependencies (Monaco, Three.js) are mocked in the relevant test files
6. Total test count is approximately 30+ tests
</verification>

<success_criteria>
- `npm test` exits with code 0
- Every blade type in BladePropsMap has a corresponding smoke test
- XState machine tests verify initial state, transitions, guards (pass + block), and context updates
- No tests require browser APIs beyond what jsdom provides
- Test files are co-located next to their source files
</success_criteria>

<output>
After completion, create `.planning/phases/25-test-infrastructure-foundation/25-03-SUMMARY.md`
</output>
