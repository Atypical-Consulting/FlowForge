# Phase 25: Test Infrastructure Foundation - Expert Research

**Researched:** 2026-02-08
**Domain:** Vitest + jsdom testing for Tauri v2 / React / Zustand / XState
**Confidence:** HIGH

## Summary

This phase establishes the testing foundation for a Tauri v2 desktop application built with React 19, Zustand 5, TypeScript, and Vite 7. The project currently has zero test files, no Vitest configuration, and no testing dependencies. The bindings layer (`src/bindings.ts`) is auto-generated by tauri-specta and provides 50+ IPC commands that all funnel through `TAURI_INVOKE` (imported from `@tauri-apps/api/core`). Five of the 21 Zustand stores additionally depend on `@tauri-apps/plugin-store` for persistence. One store (`blades.ts`) uses the `devtools` middleware; all others use plain `create`.

XState is **not yet in the codebase** -- it is planned for Phase 26 (Navigation FSM). However, Phase 25 requirement ARCH-02 says "Developer can test XState navigation machine guards and transitions." This means Phase 25 should install XState as a dev dependency, provide a representative test pattern/example, and ensure the test infrastructure supports XState testing when Phase 26 lands.

**Primary recommendation:** Install Vitest 3.x (avoid v4 jsdom compat issues), jsdom, @testing-library/react, and @testing-library/jest-dom. Use Tauri's built-in `@tauri-apps/api/mocks` for IPC interception. Use Zustand's official `__mocks__/zustand.ts` pattern for auto-reset. Create a custom render wrapper with QueryClientProvider + MotionConfig. Build typed mock factories for the `commands` object from bindings.ts. Co-locate test files with source files using `*.test.ts(x)` naming.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

No locked decisions -- all implementation decisions deferred to Claude.

### Claude's Discretion

User deferred all implementation decisions to Claude. The following areas are open for Claude to decide during research and planning:

**Mock strategy:**
- How Tauri IPC mocks are structured (factory functions, fixtures, or inline)
- Fidelity level of mock responses relative to real Tauri bindings
- Type-safety approach for mock factories

**Test organization:**
- File placement (co-located vs separate directory)
- Naming convention (*.test.ts vs *.spec.ts)
- Test utility and helper organization

**Coverage & CI expectations:**
- Whether to enforce coverage thresholds in this phase
- Which test types run in CI vs locally only
- Fail-on-regression policy

**Smoke test scope:**
- Which blade types get smoke tests (all vs representative subset)
- Depth of smoke tests (render-only vs basic interaction)

### Deferred Ideas (OUT OF SCOPE)

None -- discussion stayed within phase scope.
</user_constraints>

## Discretion Recommendations

Based on research findings, here are the recommendations for each discretion area:

### Mock Strategy: Typed Factory Functions

**Recommendation:** Create typed factory functions in `src/test-utils/mocks/tauri-commands.ts` that produce mock `commands` objects matching the bindings.ts signatures. Use `@tauri-apps/api/mocks` `mockIPC` for low-level IPC interception in the setup file, and provide higher-level typed factories for individual test files.

**Rationale:**
- The `commands` object in bindings.ts is a flat namespace with 50+ async methods. Each returns `Promise<Result<T, GitError>>` or similar. Factory functions can return properly typed success/error responses without hand-crafting IPC payloads.
- Inline mocks would be repetitive across 20+ store test files. Fixtures are too rigid for parameterized test scenarios. Factory functions with sensible defaults + overrides hit the sweet spot.
- Fidelity: Mock responses should match the TypeScript types exactly (using the exported types from bindings.ts) but with minimal/stub data. Full fidelity is unnecessary for unit tests -- the Rust backend is tested separately.

### Test Organization: Co-located Files

**Recommendation:** Co-locate test files next to source files using `*.test.ts` / `*.test.tsx` naming. Place shared test utilities in `src/test-utils/`.

**Rationale:**
- Co-location makes it obvious which files have tests and which do not. When refactoring, tests move with their source.
- `*.test.ts` is the Vitest default and ecosystem convention. No need to configure testMatch patterns.
- `src/test-utils/` contains the custom render, mock factories, and Zustand reset setup -- imported as `@/test-utils/...` via the existing `@` path alias.

### Coverage & CI: No Thresholds This Phase

**Recommendation:** Do NOT enforce coverage thresholds in Phase 25. Add `npm test` to the project scripts. Coverage reporting can be enabled (`vitest --coverage`) but not gated. Fail-on-regression is implicit -- if existing tests fail, CI fails.

**Rationale:**
- Phase 25 is establishing infrastructure, not comprehensive coverage. Setting a threshold (e.g., 80%) when only a handful of smoke tests exist creates a false sense of completeness or forces writing meaningless tests to hit the number.
- Future phases that implement features should add tests alongside. Coverage thresholds can be introduced in a later phase once there is meaningful baseline.
- CI should run `npm test` to catch regressions in any tests that exist.

### Smoke Test Scope: All 13 Blade Types, Render-Only

**Recommendation:** Write smoke tests for ALL 13 registered blade types. Each smoke test verifies the blade renders without crashing (no assertion beyond `expect(container).toBeTruthy()`). Do NOT test interactions.

**Rationale:**
- There are only 13 blade types. Writing a render-only test for each takes ~5 minutes per blade and catches import errors, missing providers, and TypeScript issues.
- A "representative subset" would need justification for which to include/exclude. All-or-nothing is simpler and more valuable.
- Interaction testing belongs in later phases when feature behavior is being modified.

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| vitest | ^3.2 | Test runner + assertion library | Vite-native, shares vite.config.ts transforms, fast watch mode. Avoid v4 due to jsdom compat issues (GitHub issue #9279). |
| jsdom | ^26 | DOM environment for component tests | Required for React Testing Library; `@tauri-apps/api/mocks` is designed for jsdom. Use jsdom 26.x (not bleeding edge) for Vitest 3.x stability. |
| @testing-library/react | ^16 | Component rendering + querying | Standard for behavior-driven React tests; uses user-centric queries. |
| @testing-library/jest-dom | ^6 | Custom DOM matchers (toBeVisible, etc.) | Extends expect() with DOM-specific assertions. Import via `@testing-library/jest-dom/vitest` for Vitest integration. |
| @testing-library/user-event | ^14 | Simulated user interactions | More realistic than fireEvent; handles focus, keyboard, pointer correctly. |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @tauri-apps/api (mocks) | 2.10.1 (already installed) | mockIPC, mockWindows, clearMocks | Every test that exercises Tauri IPC. Already bundled with @tauri-apps/api. |
| xstate | ^5 | XState machine definitions | Install now for ARCH-02 test examples. Phase 26 will use it in production code. |
| @xstate/react | ^5 | React bindings for XState | Install alongside xstate for testing actor integration with React components. |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| jsdom | happy-dom | happy-dom is faster but less complete; @tauri-apps/api/mocks targets jsdom explicitly. Stick with jsdom. |
| Vitest 3.x | Vitest 4.x | v4 has known jsdom compat issues (GitHub #9279). v3 is stable and works with all deps. |
| @testing-library/user-event | fireEvent | fireEvent is lower-level; user-event simulates real browser behavior. Use user-event. |
| Snapshot testing | N/A | Explicitly out of scope per REQUIREMENTS.md: "Brittle for UI; behavior-based Testing Library tests preferred" |

**Installation:**
```bash
npm install -D vitest@^3.2 jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event xstate @xstate/react
```

## Architecture Patterns

### Recommended Test File Structure
```
src/
├── __mocks__/
│   └── zustand.ts              # Zustand auto-reset mock (official pattern)
├── test-utils/
│   ├── index.ts                # Barrel export
│   ├── render.tsx              # Custom render with providers
│   ├── setup.ts                # Global test setup (vitest setupFiles)
│   └── mocks/
│       ├── tauri-commands.ts   # Typed mock factories for commands object
│       ├── tauri-store.ts      # Mock for @tauri-apps/plugin-store
│       └── tauri-events.ts     # Event listener helpers
├── stores/
│   ├── repository.ts
│   ├── repository.test.ts      # Co-located test
│   ├── blades.ts
│   ├── blades.test.ts          # Co-located test
│   └── ...
├── components/
│   └── blades/
│       ├── SettingsBlade.tsx
│       ├── SettingsBlade.test.tsx  # Smoke test
│       └── ...
├── lib/
│   ├── bladeRegistry.ts
│   ├── bladeRegistry.test.ts
│   └── ...
└── bindings.ts                 # Auto-generated, NOT tested directly
```

### Pattern 1: Vitest Configuration (vitest.config.ts)

**What:** Separate Vitest config that merges with existing vite.config.ts.
**When to use:** Always. This is the project's test configuration entry point.

```typescript
// vitest.config.ts
// Source: Vitest docs (https://main.vitest.dev/config/)
import { defineConfig, mergeConfig } from "vitest/config";
import viteConfig from "./vite.config";

export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      globals: true,
      environment: "jsdom",
      setupFiles: ["./src/test-utils/setup.ts"],
      include: ["src/**/*.test.{ts,tsx}"],
      css: false,
    },
  }),
);
```

**Key details:**
- `globals: true` -- exposes `describe`, `it`, `expect`, `vi`, `beforeEach`, `afterEach` globally without imports.
- `environment: "jsdom"` -- provides `window`, `document`, `navigator` for React/Tauri code.
- `css: false` -- skip CSS processing in tests (Tailwind is not needed for unit tests).
- `mergeConfig` inherits the `@` path alias from vite.config.ts.

### Pattern 2: Global Test Setup (setup.ts)

**What:** Setup file that runs before all test files.
**When to use:** Always. Configures Tauri mocks, jest-dom matchers, framer-motion bypass.

```typescript
// src/test-utils/setup.ts
// Sources: Tauri v2 mock docs, Zustand testing docs, framer-motion issue #1690
import "@testing-library/jest-dom/vitest";
import { MotionGlobalConfig } from "framer-motion";
import { mockIPC, mockWindows, clearMocks } from "@tauri-apps/api/mocks";

// Skip framer-motion animations in tests (official solution)
MotionGlobalConfig.skipAnimations = true;

// Enable Zustand auto-mocking (works with __mocks__/zustand.ts)
vi.mock("zustand");

// Polyfill crypto.randomUUID for jsdom (used by blades store, toast store)
if (!globalThis.crypto?.randomUUID) {
  globalThis.crypto = {
    ...globalThis.crypto,
    randomUUID: () =>
      "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
      }),
  } as Crypto;
}

// Mock @tauri-apps/plugin-store (used by 5 stores via getStore())
vi.mock("@tauri-apps/plugin-store", () => ({
  Store: {
    load: vi.fn().mockResolvedValue({
      get: vi.fn().mockResolvedValue(null),
      set: vi.fn().mockResolvedValue(undefined),
      save: vi.fn().mockResolvedValue(undefined),
    }),
  },
}));

// Default Tauri IPC + window mock for all tests
beforeEach(() => {
  mockWindows("main");
  mockIPC((cmd) => {
    console.warn(`[Test] Unmocked Tauri IPC command: ${cmd}`);
    return undefined;
  });
});

afterEach(() => {
  clearMocks();
});
```

### Pattern 3: Zustand Auto-Reset Mock (__mocks__/zustand.ts)

**What:** Intercepts Zustand's `create` to capture initial state and reset after each test.
**When to use:** Automatically applied via `vi.mock("zustand")` in setup.ts.
**Critical note:** The `__mocks__` directory MUST be placed at `src/__mocks__/` because Vitest resolves relative to the root (which is `src/` when using includes).

```typescript
// src/__mocks__/zustand.ts
// Source: Zustand official testing docs (https://zustand.docs.pmnd.rs/guides/testing)
import { act } from "@testing-library/react";
import type * as ZustandExportedTypes from "zustand";

export * from "zustand";

const { create: actualCreate, createStore: actualCreateStore } =
  await vi.importActual<typeof ZustandExportedTypes>("zustand");

export const storeResetFns = new Set<() => void>();

const createUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>,
) => {
  const store = actualCreate(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const create = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>,
) => {
  return typeof stateCreator === "function"
    ? createUncurried(stateCreator)
    : createUncurried;
}) as typeof ZustandExportedTypes.create;

const createStoreUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>,
) => {
  const store = actualCreateStore(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const createStore = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>,
) => {
  return typeof stateCreator === "function"
    ? createStoreUncurried(stateCreator)
    : createStoreUncurried;
}) as typeof ZustandExportedTypes.createStore;

afterEach(() => {
  act(() => {
    storeResetFns.forEach((resetFn) => {
      resetFn();
    });
  });
});
```

### Pattern 4: Custom Render with Providers

**What:** Wraps rendered components with QueryClientProvider and MotionConfig.
**When to use:** All component tests. Import `render` from `@/test-utils` instead of `@testing-library/react`.

```tsx
// src/test-utils/render.tsx
// Source: Testing Library docs (https://testing-library.com/docs/react-testing-library/setup)
import type { ReactElement, ReactNode } from "react";
import { render, type RenderOptions } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { MotionConfig } from "framer-motion";

function createTestQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
      },
      mutations: {
        retry: false,
      },
    },
  });
}

function AllTheProviders({ children }: { children: ReactNode }) {
  const queryClient = createTestQueryClient();
  return (
    <QueryClientProvider client={queryClient}>
      <MotionConfig reducedMotion="always">
        {children}
      </MotionConfig>
    </QueryClientProvider>
  );
}

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, "wrapper">,
) => render(ui, { wrapper: AllTheProviders, ...options });

export * from "@testing-library/react";
export { customRender as render };
```

### Pattern 5: Typed Tauri Command Mock Factory

**What:** Type-safe factories for mocking `commands` from bindings.ts.
**When to use:** Store tests and component tests that exercise IPC.

```typescript
// src/test-utils/mocks/tauri-commands.ts
import type {
  RepoStatus, StagingStatus, CommitSummary, BranchInfo,
  FileDiff, GitError, Result, TagInfo, StashEntry,
} from "@/bindings";

// Helper to create a successful Result
export function ok<T>(data: T): Result<T, GitError> {
  return { status: "ok", data };
}

// Helper to create an error Result
export function err(error: GitError): Result<never, GitError> {
  return { status: "error", error };
}

// Factory for RepoStatus
export function createRepoStatus(overrides?: Partial<RepoStatus>): RepoStatus {
  return {
    branchName: "main",
    isDirty: false,
    repoPath: "/mock/repo",
    repoName: "mock-repo",
    ...overrides,
  };
}

// Factory for StagingStatus
export function createStagingStatus(overrides?: Partial<StagingStatus>): StagingStatus {
  return {
    staged: [],
    unstaged: [],
    untracked: [],
    ...overrides,
  };
}

// Mock commands object with sensible defaults
export function createMockCommands() {
  return {
    openRepository: vi.fn().mockResolvedValue(ok(createRepoStatus())),
    getRepositoryStatus: vi.fn().mockResolvedValue(ok(createRepoStatus())),
    closeRepository: vi.fn().mockResolvedValue(ok(null)),
    getStagingStatus: vi.fn().mockResolvedValue(ok(createStagingStatus())),
    stageFile: vi.fn().mockResolvedValue(ok(null)),
    unstageFile: vi.fn().mockResolvedValue(ok(null)),
    stageAll: vi.fn().mockResolvedValue(ok(null)),
    unstageAll: vi.fn().mockResolvedValue(ok(null)),
    getFileDiff: vi.fn().mockResolvedValue(ok({ path: "", oldContent: "", newContent: "", hunks: [], isBinary: false, language: "text" })),
    getCommitHistory: vi.fn().mockResolvedValue(ok([])),
    getCommitDetails: vi.fn().mockResolvedValue(ok({ oid: "abc123", shortOid: "abc123", message: "test", authorName: "Test", authorEmail: "test@test.com", authorTimestampMs: 0, committerName: "Test", committerEmail: "test@test.com", committerTimestampMs: 0, parentOids: [], filesChanged: [] })),
    listBranches: vi.fn().mockResolvedValue(ok([])),
    listTags: vi.fn().mockResolvedValue(ok([])),
    listStashes: vi.fn().mockResolvedValue(ok([])),
    getCommitGraph: vi.fn().mockResolvedValue(ok({ nodes: [], edges: [] })),
    // ... additional commands as needed
  };
}
```

### Pattern 6: Zustand Store Testing

**What:** Test store logic directly via `getState()` and `setState()`.
**When to use:** Every store that contains business logic (conditional state transitions, computed values, side effects).

```typescript
// src/stores/blades.test.ts
import { describe, it, expect, beforeEach } from "vitest";
import { useBladeStore } from "./blades";

describe("useBladeStore", () => {
  // Store auto-resets between tests via __mocks__/zustand.ts

  it("has correct initial state", () => {
    const state = useBladeStore.getState();
    expect(state.activeProcess).toBe("staging");
    expect(state.bladeStack).toHaveLength(1);
    expect(state.bladeStack[0].type).toBe("staging-changes");
  });

  it("pushBlade adds blade to stack", () => {
    useBladeStore.getState().pushBlade({
      type: "commit-details",
      title: "Commit abc",
      props: { oid: "abc123" },
    });

    const state = useBladeStore.getState();
    expect(state.bladeStack).toHaveLength(2);
    expect(state.bladeStack[1].type).toBe("commit-details");
  });

  it("popBlade does not remove root blade", () => {
    useBladeStore.getState().popBlade();
    expect(useBladeStore.getState().bladeStack).toHaveLength(1);
  });

  it("setProcess resets stack to process root", () => {
    useBladeStore.getState().setProcess("topology");
    const state = useBladeStore.getState();
    expect(state.activeProcess).toBe("topology");
    expect(state.bladeStack[0].type).toBe("topology-graph");
  });
});
```

### Pattern 7: XState Machine Testing (for Phase 26)

**What:** Test XState v5 machines in isolation using createActor.
**When to use:** When Phase 26 introduces the navigation FSM.

```typescript
// Example: how navigation machine tests will work
// Source: XState testing docs (https://stately.ai/docs/testing)
import { describe, it, expect } from "vitest";
import { createActor, setup, assign } from "xstate";

// Example machine (Phase 26 will define the real one)
const exampleNavMachine = setup({
  guards: {
    isRepoOpen: ({ context }) => context.repoPath !== null,
  },
}).createMachine({
  id: "navigation",
  initial: "idle",
  context: { repoPath: null as string | null, bladeStack: [] as string[] },
  states: {
    idle: {
      on: {
        OPEN_REPO: {
          target: "repoOpen",
          actions: assign({ repoPath: ({ event }) => event.path }),
        },
      },
    },
    repoOpen: {
      on: {
        PUSH_BLADE: {
          guard: "isRepoOpen",
          actions: assign({
            bladeStack: ({ context, event }) => [...context.bladeStack, event.bladeType],
          }),
        },
        CLOSE_REPO: {
          target: "idle",
          actions: assign({ repoPath: null, bladeStack: [] }),
        },
      },
    },
  },
});

describe("navigation machine", () => {
  it("starts in idle state", () => {
    const actor = createActor(exampleNavMachine);
    actor.start();
    expect(actor.getSnapshot().value).toBe("idle");
  });

  it("transitions to repoOpen on OPEN_REPO", () => {
    const actor = createActor(exampleNavMachine);
    actor.start();
    actor.send({ type: "OPEN_REPO", path: "/some/repo" });
    expect(actor.getSnapshot().value).toBe("repoOpen");
    expect(actor.getSnapshot().context.repoPath).toBe("/some/repo");
  });

  it("PUSH_BLADE adds to blade stack when repo is open", () => {
    const actor = createActor(exampleNavMachine);
    actor.start();
    actor.send({ type: "OPEN_REPO", path: "/some/repo" });
    actor.send({ type: "PUSH_BLADE", bladeType: "diff" });
    expect(actor.getSnapshot().context.bladeStack).toEqual(["diff"]);
  });
});
```

### Pattern 8: Component Smoke Test

**What:** Minimal test that verifies a blade renders without crashing.
**When to use:** Every blade type.

```tsx
// src/components/blades/SettingsBlade.test.tsx
import { describe, it, expect } from "vitest";
import { render, screen } from "@/test-utils";
import { SettingsBlade } from "./SettingsBlade";

describe("SettingsBlade", () => {
  it("renders without crashing", () => {
    const { container } = render(<SettingsBlade />);
    expect(container).toBeTruthy();
  });
});
```

### Anti-Patterns to Avoid

- **Testing store implementation instead of behavior:** Do not assert on internal state shape (e.g., checking that a specific state key exists). Instead, test observable behavior: call an action, check that getState() returns expected values. This is critical because stores may be migrated to XState in later phases.
- **Mocking `bindings.ts` globally with vi.mock:** The `commands` object is the public API for Tauri IPC. Mock it at the module level per test file with `vi.mock("@/bindings")`, not in the global setup. Global mocking prevents test-specific behavior.
- **Using `import.meta.glob` in tests:** The blade registration system uses `import.meta.glob` for auto-discovery. This is a Vite-specific API that works in tests via Vitest but can cause confusion. For smoke tests, import blade components directly rather than relying on the registration system.
- **Snapshot testing:** Explicitly excluded per project requirements. Use behavior assertions instead.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| IPC mock interception | Custom window.__TAURI_INTERNALS__ patching | `@tauri-apps/api/mocks` mockIPC/clearMocks | Handles all IPC protocol details, channel support, event mocking. |
| Zustand store reset between tests | Manual `store.setState(initialState)` in afterEach | Official `__mocks__/zustand.ts` pattern | Automatically captures initial state for ALL stores, including ones created with middleware. |
| DOM matchers (toBeVisible, toHaveTextContent) | Custom expect extensions | `@testing-library/jest-dom` | 30+ matchers, maintained, TypeScript types included. |
| Animation bypass | Mocking individual framer-motion components | `MotionGlobalConfig.skipAnimations = true` | Official solution from framer-motion maintainer. One line, no maintenance burden. |
| User interaction simulation | `fireEvent.click()` | `@testing-library/user-event` | Simulates actual user behavior (focus, pointer events, keyboard). |

**Key insight:** The Tauri ecosystem provides first-party mock utilities specifically designed for Vitest + jsdom. Using `@tauri-apps/api/mocks` is far more reliable than manually patching `window.__TAURI_INTERNALS__`.

## Common Pitfalls

### Pitfall 1: jsdom Crypto Polyfill Missing

**What goes wrong:** `crypto.randomUUID()` throws in jsdom because it lacks WebCrypto. Multiple stores and components use `crypto.randomUUID()` (blades, toast).
**Why it happens:** jsdom does not implement the full WebCrypto API.
**How to avoid:** Polyfill `crypto.randomUUID` in the test setup file before any store code runs.
**Warning signs:** `TypeError: crypto.randomUUID is not a function` in test output.

### Pitfall 2: Zustand __mocks__ Directory Placement

**What goes wrong:** `vi.mock("zustand")` does nothing -- stores don't reset between tests.
**Why it happens:** Vitest resolves `__mocks__` relative to the module being mocked. Since Zustand is in `node_modules`, the mock file must be at the project root `__mocks__/zustand.ts` OR at `src/__mocks__/zustand.ts` if the Vitest root is configured to `src/`.
**How to avoid:** Place the mock at the project root `__mocks__/zustand.ts` (since our vitest config does not change the root) and call `vi.mock("zustand")` in the setup file.
**Warning signs:** Store state bleeds between tests; tests pass individually but fail in batch.

### Pitfall 3: Zustand devtools Middleware and Auto-Reset

**What goes wrong:** The `blades.ts` store uses `create()(devtools(...))` curried form. The mock's `create` intercept may not capture the initial state correctly.
**Why it happens:** The official Zustand mock pattern handles both curried (`create()(fn)`) and uncurried (`create(fn)`) forms. When devtools wraps the state creator, the mock's `createUncurried` still receives the composed state creator and calls `actualCreate(stateCreator)`. The `getInitialState()` call happens AFTER middleware composition, so it captures the real initial state.
**How to avoid:** Verify in a dedicated test that the blades store resets correctly between tests. The official pattern should work, but validate.
**Warning signs:** `bladeStack` has stale entries from a previous test.

### Pitfall 4: @tauri-apps/plugin-store Not Mocked

**What goes wrong:** 5 stores (settings, theme, navigation, branchMetadata, reviewChecklist) call `getStore()` which imports from `@tauri-apps/plugin-store`. Without mocking, this throws because the Tauri runtime isn't available.
**Why it happens:** `Store.load()` attempts IPC communication with the Rust backend.
**How to avoid:** Mock `@tauri-apps/plugin-store` in the setup file with a simple in-memory implementation.
**Warning signs:** `Error: Could not find __TAURI_INTERNALS__` when store init functions run.

### Pitfall 5: import.meta.env.DEV in Test Context

**What goes wrong:** Code that checks `import.meta.env.DEV` (blade registrations, devtools middleware) behaves differently in tests.
**Why it happens:** Vitest inherits Vite's environment variable handling. In test mode, `import.meta.env.DEV` is `true` by default (since Vitest runs in development mode). This means devtools middleware IS active in tests, and blade registration exhaustiveness checks run.
**How to avoid:** This is actually fine -- it matches development behavior. But be aware that `import.meta.hot` is NOT available in jsdom tests, so HMR-specific code paths won't execute. The blade registration `import.meta.glob` call works because Vitest handles it.
**Warning signs:** None expected, but worth understanding for debugging.

### Pitfall 6: Vitest v4 + jsdom Compatibility

**What goes wrong:** Tests fail with mysterious DOM errors when using Vitest 4.x with the latest jsdom.
**Why it happens:** Known compatibility issue documented in Vitest GitHub issue #9279.
**How to avoid:** Use Vitest ^3.2 (stable release line). Upgrade to v4 only after the jsdom compat issue is resolved.
**Warning signs:** Tests that worked on v3 suddenly fail on v4 with DOM-related errors.

### Pitfall 7: React Query in Tests Without Fresh Client

**What goes wrong:** Query cache from one test leaks into another, causing stale data assertions.
**Why it happens:** QueryClient maintains a cache. If reused across tests, queries show cached results.
**How to avoid:** Create a new QueryClient in each test via the custom render wrapper (`createTestQueryClient()` with `gcTime: 0`).
**Warning signs:** Tests pass individually but fail when run together; order-dependent failures.

### Pitfall 8: Lazy-Loaded Blade Components in Smoke Tests

**What goes wrong:** Lazy-loaded blades (DiffBlade, Viewer3dBlade, etc.) don't render content in smoke tests.
**Why it happens:** React `lazy()` + `Suspense` requires the component to be resolved asynchronously. In a synchronous test, the fallback renders instead.
**How to avoid:** For smoke tests of lazy blades, either (a) import the component directly (skip the lazy wrapper) or (b) use `waitFor` from Testing Library to wait for the Suspense boundary to resolve.
**Warning signs:** Smoke test passes but only renders the loading fallback, not the actual blade content.

## Code Examples

### Example 1: Store Test with Mocked Tauri Commands

```typescript
// src/stores/repository.test.ts
import { describe, it, expect, vi, beforeEach } from "vitest";
import { useRepositoryStore } from "./repository";
import { ok, err, createRepoStatus } from "@/test-utils/mocks/tauri-commands";

// Mock the bindings module
vi.mock("@/bindings", () => ({
  commands: {
    openRepository: vi.fn(),
    getRepositoryStatus: vi.fn(),
    closeRepository: vi.fn(),
  },
}));

// Import after mock declaration
import { commands } from "@/bindings";

describe("useRepositoryStore", () => {
  it("openRepository sets status on success", async () => {
    const mockStatus = createRepoStatus({ branchName: "develop", isDirty: true });
    vi.mocked(commands.openRepository).mockResolvedValue(ok(mockStatus));

    await useRepositoryStore.getState().openRepository("/test/repo");

    const state = useRepositoryStore.getState();
    expect(state.status).toEqual(mockStatus);
    expect(state.isLoading).toBe(false);
    expect(state.error).toBeNull();
  });

  it("openRepository sets error on failure", async () => {
    vi.mocked(commands.openRepository).mockResolvedValue(
      err({ type: "NotARepository", message: "Not a git repo" }),
    );

    await expect(
      useRepositoryStore.getState().openRepository("/bad/path"),
    ).rejects.toThrow();

    const state = useRepositoryStore.getState();
    expect(state.status).toBeNull();
    expect(state.error).toBeTruthy();
  });
});
```

### Example 2: Blade Smoke Test with Provider Wrapper

```tsx
// src/components/blades/GitflowCheatsheetBlade.test.tsx
import { describe, it, expect } from "vitest";
import { render } from "@/test-utils";
import { GitflowCheatsheetBlade } from "./GitflowCheatsheetBlade";

describe("GitflowCheatsheetBlade", () => {
  it("renders without crashing", () => {
    const { container } = render(<GitflowCheatsheetBlade />);
    expect(container).toBeTruthy();
  });

  it("shows workflow guide heading", () => {
    const { getByText } = render(<GitflowCheatsheetBlade />);
    expect(getByText("Gitflow Workflow Guide")).toBeInTheDocument();
  });
});
```

### Example 3: TypeScript Config for Tests

```json
// tsconfig.json addition needed:
// Add "vitest/globals" to compilerOptions.types for global test functions
{
  "compilerOptions": {
    "types": ["vitest/globals"]
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Jest + ts-jest | Vitest (Vite-native) | 2023-2024 | No separate TypeScript transform, shares Vite config, faster |
| enzyme / shallow rendering | Testing Library (behavior-based) | 2020+ | Tests user behavior not implementation details |
| Manual IPC patching for Tauri | @tauri-apps/api/mocks module | Tauri v1.0+ (refined in v2.7.0 with event mocking) | First-party, maintained, type-safe |
| jest.fn() for Zustand stores | Official __mocks__/zustand.ts with auto-reset | Zustand v4+ docs | Handles all store creation patterns, including middleware |
| Mocking framer-motion components | MotionGlobalConfig.skipAnimations | framer-motion v10+ | Single flag, maintained by library author |
| XState v4 interpret() + service.start() | XState v5 createActor().start() | XState v5 (2023) | Actor model, cleaner API, getSnapshot() |

**Deprecated/outdated:**
- `@testing-library/react-hooks`: Merged into `@testing-library/react` v13+. Use `renderHook` from RTL directly.
- `enzyme`: No React 18/19 support. Dead.
- `jest.mock("zustand")` with `jest.requireActual`: Zustand docs now use `vi.importActual` for Vitest.

## Open Questions

1. **Vitest version pinning vs range**
   - What we know: Vitest 3.x is stable. Vitest 4.x has jsdom issues.
   - What's unclear: Whether ^3.2 will auto-upgrade to 4.x if 4.x is released under the ^3 range. (Answer: No -- semver ^3.2 stays within 3.x. This is safe.)
   - Recommendation: Use `^3.2` which locks to 3.x line.

2. **Zustand mock with devtools middleware validation**
   - What we know: The official mock pattern handles curried create. devtools is applied via the curried form in blades.ts.
   - What's unclear: Whether `import.meta.env.DEV` check inside devtools causes issues in the mock path.
   - Recommendation: Write an explicit integration test for the blades store that verifies reset behavior. If devtools causes issues, the fallback is to conditionally skip devtools in test environment.

3. **XState as dev dependency vs production dependency**
   - What we know: Phase 26 will use XState in production code. Phase 25 only needs it for test examples.
   - What's unclear: Whether to install as devDependency now and move to dependency in Phase 26, or install as dependency now.
   - Recommendation: Install as dependency now (`npm install xstate @xstate/react`). The Phase 26 code will import it in production source files. Installing as devDependency now and then moving creates unnecessary churn.

4. **Blade smoke tests for lazy-loaded components**
   - What we know: 7 of 13 blades are lazy-loaded. Direct import works for smoke tests.
   - What's unclear: Whether importing the component directly (bypassing lazy) is sufficient or if the lazy wrapper itself needs testing.
   - Recommendation: Import directly for Phase 25 smoke tests. Testing the lazy loading mechanism is a separate concern for a later phase.

## Sources

### Primary (HIGH confidence)
- Tauri v2 Mock API docs: https://v2.tauri.app/develop/tests/mocking/ -- mockIPC, mockWindows, clearMocks setup
- Tauri v2 Mock API reference: https://v2.tauri.app/reference/javascript/api/namespacemocks/ -- function signatures and options
- `@tauri-apps/api/mocks` installed locally at v2.10.1 -- verified mocks.d.ts type signatures
- Zustand testing docs: https://zustand.docs.pmnd.rs/guides/testing -- official __mocks__/zustand.ts pattern for Vitest
- Vitest config docs: https://main.vitest.dev/config/ -- environment, setupFiles, globals configuration
- Vitest environment docs: https://main.vitest.dev/guide/environment -- jsdom setup, per-file overrides
- Testing Library setup: https://testing-library.com/docs/react-testing-library/setup -- custom render with providers
- XState testing docs: https://stately.ai/docs/testing -- createActor, getSnapshot, Arrange-Act-Assert pattern
- XState guards docs: https://stately.ai/docs/cheatsheet -- guard implementation patterns
- framer-motion issue #1690: https://github.com/framer/motion/issues/1690 -- MotionGlobalConfig.skipAnimations official solution

### Secondary (MEDIUM confidence)
- Vitest GitHub issue #9279: https://github.com/vitest-dev/vitest/issues/9279 -- Vitest v4 + jsdom compatibility issues
- Zustand GitHub discussion #1918: https://github.com/pmndrs/zustand/discussions/1918 -- vi.mock("zustand") behavior differences
- Zustand GitHub testing.md: https://github.com/pmndrs/zustand/blob/main/docs/guides/testing.md -- latest mock patterns
- Vitest + Tauri setup guide: https://yonatankra.com/how-to-setup-vitest-in-a-tauri-project/ -- practical setup walkthrough

### Tertiary (LOW confidence)
- None. All findings verified with primary or secondary sources.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- all libraries verified via official docs and installed packages
- Architecture: HIGH -- patterns from official docs, verified against actual codebase structure
- Pitfalls: HIGH -- identified from actual codebase analysis (crypto.randomUUID usage, devtools middleware, plugin-store dependency) and verified community reports
- XState testing: MEDIUM -- XState is not yet in codebase; patterns verified from XState v5 docs but not exercised against project code

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (30 days -- stable ecosystem, no major releases expected)
