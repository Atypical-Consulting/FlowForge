---
phase: 49-inline-conflict-resolution
plan: 02
type: execute
wave: 2
depends_on: ["49-01"]
files_modified:
  - src/extensions/conflict-resolution/types.ts
  - src/extensions/conflict-resolution/store.ts
  - src/extensions/conflict-resolution/lib/conflictParser.ts
  - src/extensions/conflict-resolution/manifest.json
  - src/extensions/conflict-resolution/index.ts
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Conflict resolution extension activates as a built-in extension with blade, toolbar badge, and command palette entries"
    - "Zustand store tracks per-file conflict state with independent undo stacks"
    - "Conflict marker parser correctly identifies hunk boundaries from working directory file content"
  artifacts:
    - path: "src/extensions/conflict-resolution/types.ts"
      provides: "TypeScript types for conflict hunks, files, and resolution choices"
      contains: "ConflictHunk"
    - path: "src/extensions/conflict-resolution/store.ts"
      provides: "Zustand store for conflict resolution state"
      contains: "useConflictStore"
    - path: "src/extensions/conflict-resolution/lib/conflictParser.ts"
      provides: "Parser for git conflict markers in file content"
      contains: "parseConflictMarkers"
    - path: "src/extensions/conflict-resolution/index.ts"
      provides: "Extension entry point with onActivate/onDeactivate"
      exports: ["onActivate", "onDeactivate"]
    - path: "src/extensions/conflict-resolution/manifest.json"
      provides: "Extension manifest for conflict resolution"
      contains: "conflict-resolution"
  key_links:
    - from: "src/App.tsx"
      to: "src/extensions/conflict-resolution/index.ts"
      via: "registerBuiltIn with activate/deactivate imports"
      pattern: "conflict-resolution.*registerBuiltIn"
    - from: "src/extensions/conflict-resolution/store.ts"
      to: "src/bindings.ts"
      via: "commands.listConflictFiles and commands.getConflictContent"
      pattern: "commands\\."
---

<objective>
Create the conflict-resolution built-in extension with types, Zustand store, conflict parser, and extension registration in App.tsx.

Purpose: This plan establishes the data layer and extension infrastructure that the UI blade (Plan 03) will consume. The store provides per-file conflict state with undo support, the parser maps conflict markers to hunks, and the extension entry registers blade type, toolbar badge, and command palette entries.

Output: Complete extension scaffolding at `src/extensions/conflict-resolution/` registered as built-in extension #14.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-inline-conflict-resolution/49-RESEARCH.md
@.planning/phases/49-inline-conflict-resolution/49-01-SUMMARY.md

# Key source references
@src/extensions/gitflow/index.ts         # Extension entry pattern (onActivate/onDeactivate)
@src/extensions/gitflow/manifest.json    # Manifest pattern
@src/extensions/ExtensionAPI.ts          # API facade for registrations
@src/App.tsx                             # Built-in extension registration pattern
@src/core/blades/diff/hooks/useDiffQuery.ts  # React Query data fetching pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types, conflict parser, and Zustand store</name>
  <files>
    src/extensions/conflict-resolution/types.ts
    src/extensions/conflict-resolution/lib/conflictParser.ts
    src/extensions/conflict-resolution/store.ts
  </files>
  <action>
**types.ts** — Define all TypeScript types:

```typescript
export type ResolutionChoice = "ours" | "theirs" | "both" | "custom";
export type FileResolutionStatus = "unresolved" | "partially-resolved" | "resolved";

export interface ConflictHunk {
  id: string;                    // Unique ID for stable keying (e.g., "hunk-0", "hunk-1")
  startLine: number;             // Start line in the conflict-marker file
  endLine: number;               // End line (inclusive of closing marker)
  oursContent: string;           // Content between <<<<<<< and =======
  theirsContent: string;         // Content between ======= and >>>>>>>
  resolution: ResolutionChoice | null;  // null = unresolved
}

export interface UndoEntry {
  hunkId: string;
  previousResolution: ResolutionChoice | null;
  previousResultContent: string;
}

export interface ConflictFile {
  path: string;
  status: FileResolutionStatus;
  hunks: ConflictHunk[];
  oursFullContent: string;       // Clean "ours" content from git2 index
  theirsFullContent: string;     // Clean "theirs" content from git2 index
  baseFullContent: string;       // Clean "base" content (may be empty for add/add)
  resultContent: string;         // Editable merged result (starts as oursFullContent)
  undoStack: UndoEntry[];
  oursName: string;              // e.g., "HEAD" or "main"
  theirsName: string;            // e.g., "feature/xyz"
}
```

**lib/conflictParser.ts** — Parse git conflict markers from working directory file content:

```typescript
export function parseConflictMarkers(content: string): ConflictHunk[]
```

Implementation:
- Split content by newlines
- Scan for `<<<<<<<` markers (start of hunk)
- Find matching `=======` separator
- Find matching `>>>>>>>` end marker
- Extract ours content (between <<<<<<< and =======) and theirs content (between ======= and >>>>>>>)
- Assign sequential IDs ("hunk-0", "hunk-1", etc.)
- Record startLine/endLine (1-indexed)
- Handle edge cases: nested markers (treat as literal text), empty ours/theirs sections, Windows CRLF line endings (normalize to LF before parsing)
- Return empty array if no markers found

Also export a helper:
```typescript
export function buildResolvedContent(
  originalContent: string,
  hunks: ConflictHunk[]
): string
```
This takes the original marker-containing file content and replaces each hunk region with the resolved content based on each hunk's `resolution` field:
- "ours" -> use oursContent
- "theirs" -> use theirsContent
- "both" -> oursContent + "\n" + theirsContent
- "custom" -> leave as-is (manual edit handled separately)
- null -> leave original markers in place

**store.ts** — Zustand store for conflict resolution state:

```typescript
export const useConflictStore = create<ConflictStore>()(...)
```

State shape:
```typescript
interface ConflictStore {
  files: Map<string, ConflictFile>;
  activeFilePath: string | null;

  // Actions
  loadConflictFiles: () => Promise<void>;        // Calls listConflictFiles, populates file list
  openConflictFile: (path: string) => Promise<void>;  // Calls getConflictContent, parses hunks, sets activeFilePath
  resolveHunk: (filePath: string, hunkId: string, choice: ResolutionChoice) => void;
  undoHunkResolution: (filePath: string) => void;
  updateResultContent: (filePath: string, content: string) => void;
  resetFile: (filePath: string) => void;          // Reset to original conflicted state
  markFileResolved: (filePath: string) => Promise<boolean>;  // Calls resolveConflictFile Tauri command
  getActiveFile: () => ConflictFile | undefined;

  // Derived
  conflictCount: () => number;                    // Total unresolved conflict files
  isFileFullyResolved: (filePath: string) => boolean;
}
```

Key implementation details:
- `loadConflictFiles`: Call `commands.listConflictFiles()` from bindings. Create a ConflictFile entry for each path with status "unresolved" and empty content (content loaded on demand via `openConflictFile`).
- `openConflictFile`: Call `commands.getConflictContent(path)`. Store ours/theirs/base from response. Parse the working directory file content using `parseConflictMarkers` to get hunks. Set `resultContent` to `oursFullContent` initially (VS Code convention). Set as activeFilePath.
- `resolveHunk`: Push current state to undoStack. Set hunk's resolution to the choice. Rebuild `resultContent` using `buildResolvedContent`. Update file status ("partially-resolved" if some hunks resolved, "resolved" if all resolved).
- `undoHunkResolution`: Pop from undoStack. Restore previous resolution and resultContent.
- `markFileResolved`: Call `commands.resolveConflictFile(path, resultContent)`. On success, remove file from the map. Show toast: `toast.success(\`Resolved: \${path}\`)`.
- `resetFile`: Reset all hunk resolutions to null, restore resultContent to oursFullContent, clear undoStack.
- Register store with `registerStore` for atomic reset on repo close (import from `src/core/stores/storeRegistry.ts` — check if this file exists, if not just use a standalone store).

Import `commands` from `../../bindings` and `toast` from `sonner`.
  </action>
  <verify>
Run `cd /Users/phmatray/Repositories/github-phm/FlowForge && npx tsc --noEmit 2>&1 | grep -v "bindings.ts" | head -20` — should show no new TypeScript errors (ignore pre-existing TS2440).
  </verify>
  <done>
Types define the complete conflict data model. Parser correctly identifies conflict marker hunks. Zustand store manages per-file conflict state with undo support and Tauri command integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create extension entry, manifest, and App.tsx registration</name>
  <files>
    src/extensions/conflict-resolution/manifest.json
    src/extensions/conflict-resolution/index.ts
    src/App.tsx
  </files>
  <action>
**manifest.json** — Follow the gitflow manifest pattern exactly:
```json
{
  "id": "conflict-resolution",
  "name": "Conflict Resolution",
  "version": "1.0.0",
  "description": "Provides inline merge conflict resolution with two-pane diff view, one-click hunk resolution, and manual editing.",
  "apiVersion": "1",
  "main": "index.ts",
  "contributes": {
    "blades": [
      { "type": "conflict-resolution", "title": "Conflict Resolution", "singleton": false }
    ],
    "commands": [
      { "id": "open-conflict-resolution", "title": "Resolve Merge Conflicts", "category": "Git" }
    ],
    "toolbar": [
      { "id": "conflict-badge", "label": "Merge Conflicts", "group": "status", "priority": 40 }
    ]
  },
  "permissions": null,
  "trustLevel": "built-in"
}
```

**index.ts** — Extension entry following the gitflow/index.ts pattern:

```typescript
import { lazy } from "react";
import { AlertTriangle } from "lucide-react";
import type { ExtensionAPI } from "../ExtensionAPI";
import { openBlade } from "../../core/lib/bladeOpener";
import { useConflictStore } from "./store";
import { useGitOpsStore } from "../../core/stores/domain/git-ops";
```

`onActivate(api: ExtensionAPI)`:
1. Lazy-import the ConflictResolutionBlade component:
   ```typescript
   const ConflictResolutionBlade = lazy(() =>
     import("./blades/ConflictResolutionBlade").then((m) => ({
       default: m.ConflictResolutionBlade,
     }))
   );
   ```

2. Register blade with `coreOverride: true`:
   ```typescript
   api.registerBlade({
     type: "conflict-resolution",
     title: (props) => `Resolve: ${props?.filePath || "Conflicts"}`,
     component: ConflictResolutionBlade,
     lazy: true,
     singleton: false,
     coreOverride: true,
   });
   ```

3. Contribute toolbar action with conflict count badge:
   ```typescript
   api.contributeToolbar({
     id: "conflict-badge",
     label: "Merge Conflicts",
     icon: AlertTriangle,
     group: "status",
     priority: 40,
     when: () => {
       const count = useConflictStore.getState().conflictCount();
       return count > 0;
     },
     execute: () => {
       openBlade("conflict-resolution", {});
     },
     renderCustom: (_action, tabIndex) => {
       // Render a badge showing conflict count
       // This will be a simple React element with the count
       // Use createElement since this is in a non-JSX file
       const count = useConflictStore.getState().conflictCount();
       if (count === 0) return null;
       // Return a simple badge element -- use React.createElement
       return null; // Placeholder -- renderCustom is optional, the toolbar icon with when() is sufficient
     },
   });
   ```
   NOTE: For the toolbar badge showing the count, use the `renderCustom` callback to render a small badge. If renderCustom complexity is high, skip it and just use the toolbar icon with `when()` visibility — the count will be shown in the blade itself. Keep it simple.

4. Register command palette entry:
   ```typescript
   api.registerCommand({
     id: "open-conflict-resolution",
     title: "Resolve Merge Conflicts",
     description: "Open the conflict resolution view",
     category: "Git",
     icon: AlertTriangle,
     keywords: ["conflict", "merge", "resolve", "ours", "theirs"],
     action: () => {
       useConflictStore.getState().loadConflictFiles();
       openBlade("conflict-resolution", {});
     },
     enabled: () => !!useGitOpsStore.getState().repoStatus,
   });
   ```

5. Set up auto-refresh of conflict list when merge status changes:
   ```typescript
   api.onDidGit("merge", () => {
     useConflictStore.getState().loadConflictFiles();
   });
   ```

`onDeactivate()`: No custom cleanup needed (api.cleanup() handles all registrations). Optionally reset the conflict store.

**App.tsx** — Add the built-in extension registration:

1. Add import at the top with other extension imports:
   ```typescript
   import { onActivate as conflictActivate, onDeactivate as conflictDeactivate } from "./extensions/conflict-resolution";
   ```

2. Add `registerBuiltIn` call in the useEffect after the existing built-in registrations (after "welcome-screen"):
   ```typescript
   registerBuiltIn({
     id: "conflict-resolution",
     name: "Conflict Resolution",
     version: "1.0.0",
     activate: conflictActivate,
     deactivate: conflictDeactivate,
   });
   ```

3. Make sure the import alias doesn't conflict with existing imports. Follow the naming pattern used for other extensions.
  </action>
  <verify>
Run `cd /Users/phmatray/Repositories/github-phm/FlowForge && npx tsc --noEmit 2>&1 | grep -v "bindings.ts" | head -20` — should show no new TypeScript errors.
Verify the extension is listed: `grep -c "conflict-resolution" src/App.tsx` should return 2+ matches.
  </verify>
  <done>
Conflict resolution extension is fully scaffolded as built-in extension #14 with manifest, onActivate/onDeactivate lifecycle, blade type registered, toolbar action with visibility guard, command palette entry, and git hook auto-refresh. App.tsx registers it alongside other built-in extensions.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles with no new errors
2. Extension manifest follows the established JSON schema
3. Store exports `useConflictStore` with all required actions
4. Conflict parser handles standard git conflict markers
5. App.tsx registers the extension with correct activate/deactivate imports
6. Extension registers blade, toolbar action, and command palette entry
</verification>

<success_criteria>
- Conflict resolution extension scaffolding is complete and activates without errors
- Zustand store manages conflict file state with undo support
- Conflict parser correctly identifies hunk boundaries
- Extension is registered as built-in extension #14 in App.tsx
- All registrations follow established codebase patterns
</success_criteria>

<output>
After completion, create `.planning/phases/49-inline-conflict-resolution/49-02-SUMMARY.md`
</output>
