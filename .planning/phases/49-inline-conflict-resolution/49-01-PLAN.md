---
phase: 49-inline-conflict-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/git/conflict.rs
  - src-tauri/src/git/mod.rs
  - src-tauri/src/git/error.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Rust backend can list all conflicted file paths from the git index"
    - "Rust backend can read ours/theirs/base content for any conflicted file from index stages"
    - "Rust backend can write resolved content to a conflicted file, stage it, and remove the conflict entry"
  artifacts:
    - path: "src-tauri/src/git/conflict.rs"
      provides: "Conflict resolution Tauri commands"
      exports: ["list_conflict_files", "get_conflict_content", "resolve_conflict_file"]
    - path: "src-tauri/src/git/error.rs"
      provides: "NoConflicts error variant"
      contains: "NoConflicts"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/git/conflict.rs"
      via: "collect_commands! macro"
      pattern: "list_conflict_files.*get_conflict_content.*resolve_conflict_file"
    - from: "src-tauri/src/git/conflict.rs"
      to: "git2 index stages"
      via: "index.conflict_get() and repo.find_blob()"
      pattern: "conflict_get|find_blob"
---

<objective>
Create the Rust backend module for conflict resolution with three Tauri commands that expose conflict data from the git2 index to the frontend.

Purpose: The frontend needs clean ours/theirs/base content (not marker-polluted working directory files) and a way to write resolved content back and stage it. The git2 index provides authoritative conflict data through stages 1 (ancestor/base), 2 (ours), and 3 (theirs).

Output: `src-tauri/src/git/conflict.rs` with three specta-tagged commands, error variants in `error.rs`, and registration in `lib.rs`.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-inline-conflict-resolution/49-RESEARCH.md

# Key source references
@src-tauri/src/git/merge.rs           # Existing merge commands with conflict detection pattern
@src-tauri/src/git/staging.rs          # Stage file pattern (index.add_path + index.write)
@src-tauri/src/git/error.rs            # Error enum pattern
@src-tauri/src/git/mod.rs              # Module registration
@src-tauri/src/lib.rs                  # Command registration in collect_commands!
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conflict.rs with three Tauri commands</name>
  <files>src-tauri/src/git/conflict.rs</files>
  <action>
Create `src-tauri/src/git/conflict.rs` with three specta-tagged Tauri commands:

**1. `list_conflict_files`** — List all conflicted file paths
- Signature: `async fn list_conflict_files(state: State<'_, RepositoryState>) -> Result<Vec<String>, GitError>`
- Open repo, get index, iterate `index.conflicts()`, collect file paths from whichever side is present (our > their > ancestor)
- Return empty Vec if no conflicts (not an error)
- Follow the exact same async/spawn_blocking pattern as `get_merge_status` in merge.rs

**2. `get_conflict_content`** — Read ours/theirs/base content for a specific conflicted file
- Signature: `async fn get_conflict_content(path: String, state: State<'_, RepositoryState>) -> Result<ConflictContent, GitError>`
- Define return type:
  ```rust
  #[derive(Debug, Clone, Serialize, Deserialize, Type)]
  #[serde(rename_all = "camelCase")]
  pub struct ConflictContent {
      pub path: String,
      pub ours: Option<String>,
      pub theirs: Option<String>,
      pub base: Option<String>,
      pub ours_name: String,    // e.g., "HEAD" or branch name
      pub theirs_name: String,  // e.g., "feature/xyz"
  }
  ```
- Use `index.conflict_get(&path)` to get the IndexConflict with ancestor/our/their
- For each present side, read the blob using `repo.find_blob(entry.id)` and convert to UTF-8 string with `String::from_utf8_lossy`
- Handle None sides gracefully (add/add conflicts may have no ancestor; delete/modify may have no ours or theirs)
- For branch names: read `MERGE_HEAD` file to get theirs name, use HEAD for ours name. Use `repo.head()?.shorthand()` for ours and check `.git/MERGE_MSG` or `.git/MERGE_HEAD` for theirs (just use "MERGE_HEAD" as fallback)
- Return `GitError::NotFound` if the path is not in the conflict list

**3. `resolve_conflict_file`** — Write resolved content, stage file, and clear conflict
- Signature: `async fn resolve_conflict_file(path: String, content: String, state: State<'_, RepositoryState>) -> Result<(), GitError>`
- Write `content` to the file at `repo_path.join(&path)` using `std::fs::write`
- Stage the file using `index.add_path(Path::new(&path))`
- Call `index.write()` to persist
- The staging automatically clears the conflict entry from the index
- If no merge is in progress or the file is not conflicted, return appropriate error

All three commands must have `#[tauri::command]` and `#[specta::specta]` attributes.
Use `tokio::task::spawn_blocking` for git2 operations (not Send-safe).
Follow the exact error handling pattern from merge.rs.
  </action>
  <verify>
Run `cd /Users/phmatray/Repositories/github-phm/FlowForge/src-tauri && cargo check 2>&1 | head -30` — should compile without errors (ignore pre-existing TS2440 from bindings.ts).
  </verify>
  <done>
Three Tauri commands (list_conflict_files, get_conflict_content, resolve_conflict_file) compile successfully with correct specta types for TypeScript binding generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register conflict module and commands</name>
  <files>
    src-tauri/src/git/mod.rs
    src-tauri/src/git/error.rs
    src-tauri/src/lib.rs
  </files>
  <action>
**error.rs:** Add two new error variants to the GitError enum:
```rust
// Conflict errors
#[error("No conflicts found in repository")]
NoConflicts,

#[error("File is not conflicted: {0}")]
FileNotConflicted(String),
```

**mod.rs:** Add `pub mod conflict;` to the module list.

**lib.rs:**
1. Add the conflict imports to the use block:
   ```rust
   use crate::git::conflict::{list_conflict_files, get_conflict_content, resolve_conflict_file};
   ```
   (Adjust import path to follow the existing pattern — use `git::conflict::...` like other modules.)

2. Add the three commands to `collect_commands![]` in a new "Conflict commands" section, placed after the "Merge commands" section:
   ```rust
   // Conflict commands
   list_conflict_files,
   get_conflict_content,
   resolve_conflict_file,
   ```

After this, run `cargo build` in dev mode to trigger specta binding generation. The bindings.ts file will be auto-updated with the new command types.
  </action>
  <verify>
Run `cd /Users/phmatray/Repositories/github-phm/FlowForge/src-tauri && cargo build 2>&1 | tail -5` — should build successfully. Then verify bindings were generated: `grep -c "listConflictFiles\|getConflictContent\|resolveConflictFile" ../src/bindings.ts` — should return 3+ matches.
  </verify>
  <done>
All three conflict commands are registered in the Tauri command handler, error variants exist, and TypeScript bindings are auto-generated with the new command types available for frontend consumption.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` in src-tauri passes without new errors
2. `cargo build` succeeds and updates bindings.ts
3. `grep "listConflictFiles" src/bindings.ts` returns matches
4. `grep "ConflictContent" src/bindings.ts` returns matches
5. `grep "resolveConflictFile" src/bindings.ts` returns matches
</verification>

<success_criteria>
- Three new Tauri commands exist in conflict.rs following the established Rust patterns
- Commands are registered in lib.rs and auto-generate TypeScript bindings
- Error variants for conflict-specific errors are defined
- The Rust code compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/49-inline-conflict-resolution/49-01-SUMMARY.md`
</output>
