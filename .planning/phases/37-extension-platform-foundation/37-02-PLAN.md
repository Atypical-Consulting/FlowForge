---
phase: 37-extension-platform-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ui/ContextMenu.tsx
  - src/components/ui/StatusBar.tsx
  - src/App.tsx
  - src/components/RepositoryView.tsx
  - src/components/branches/BranchItem.tsx
  - src/hooks/useCommitExecution.ts
  - src/commands/toolbar-actions.ts
  - src/stores/domain/git-ops/branches.slice.ts
autonomous: true

must_haves:
  truths:
    - "A portal-based context menu renders at mouse coordinates when onContextMenu fires on a BranchItem"
    - "The context menu closes on click-outside, Escape, or item selection"
    - "A DynamicSidebarPanels zone renders extension-contributed panels after core sections in the sidebar"
    - "A StatusBar component renders at the bottom of the app window, returning null when empty"
    - "GitHookBus emitDid is called after commit, push, pull, fetch, branch-create, branch-delete, checkout, and merge operations"
  artifacts:
    - path: "src/components/ui/ContextMenu.tsx"
      provides: "Portal-based context menu component with grouped items and keyboard nav"
      exports: ["ContextMenuPortal"]
    - path: "src/components/ui/StatusBar.tsx"
      provides: "Status bar component with left/right zones reading from StatusBarRegistry"
      exports: ["StatusBar"]
  key_links:
    - from: "src/components/ui/ContextMenu.tsx"
      to: "src/lib/contextMenuRegistry.ts"
      via: "useContextMenuRegistry subscription"
      pattern: "useContextMenuRegistry\\("
    - from: "src/components/ui/StatusBar.tsx"
      to: "src/lib/statusBarRegistry.ts"
      via: "useStatusBarRegistry subscription"
      pattern: "useStatusBarRegistry\\("
    - from: "src/components/RepositoryView.tsx"
      to: "src/lib/sidebarPanelRegistry.ts"
      via: "useSidebarPanelRegistry subscription in DynamicSidebarPanels"
      pattern: "useSidebarPanelRegistry\\("
    - from: "src/components/branches/BranchItem.tsx"
      to: "src/lib/contextMenuRegistry.ts"
      via: "onContextMenu handler calls showMenu"
      pattern: "onContextMenu"
    - from: "src/hooks/useCommitExecution.ts"
      to: "src/lib/gitHookBus.ts"
      via: "gitHookBus.emitDid in onSuccess callbacks"
      pattern: "gitHookBus\\.emitDid"
    - from: "src/App.tsx"
      to: "src/components/ui/StatusBar.tsx"
      via: "JSX child between main and ToastContainer"
      pattern: "<StatusBar"
    - from: "src/App.tsx"
      to: "src/components/ui/ContextMenu.tsx"
      via: "JSX child for portal rendering"
      pattern: "<ContextMenuPortal"
---

<objective>
Build the three new UI surfaces (ContextMenu, dynamic sidebar panels, StatusBar) and wire GitHookBus emissions into existing git operation sites.

Purpose: The registries from Plan 37-01 hold data, but without UI components to render that data and emission points to populate the GitHookBus, the extension platform has no visible or behavioral surface. This plan makes extensions visually manifest.

Output: ContextMenuPortal component (renders portal-based context menu from registry state), StatusBar component (renders left/right zones from registry), DynamicSidebarPanels zone in RepositoryView (renders extension panels), BranchItem onContextMenu wiring (first integration point), and gitHookBus.emitDid calls in 3 existing files covering 8+ git operations.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/App.tsx
@src/components/RepositoryView.tsx
@src/components/branches/BranchItem.tsx
@src/hooks/useCommitExecution.ts
@src/commands/toolbar-actions.ts
@src/stores/domain/git-ops/branches.slice.ts
@src/lib/toolbarRegistry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ContextMenu and StatusBar UI components, integrate into App.tsx</name>
  <files>
    src/components/ui/ContextMenu.tsx
    src/components/ui/StatusBar.tsx
    src/App.tsx
  </files>
  <action>
**ContextMenu.tsx** (~120 lines):
Create a `ContextMenuPortal` component that subscribes to `useContextMenuRegistry(s => s.activeMenu)` and `useContextMenuRegistry(s => s.hideMenu)`.

When `activeMenu` is null, return null.

When `activeMenu` has value, render via `createPortal(menu, document.body)`:
- A full-screen invisible overlay `div` with `className="fixed inset-0 z-[100]"` that catches click-outside.
- Inside it, a positioned `div` with `ref`, `role="menu"`, `aria-label="Context menu"`. Position using inline style `{ top, left }` from activeMenu.position, clamped to stay within viewport (subtract ~200px from window dimensions).
- Styling: `fixed min-w-48 py-1 bg-ctp-mantle border border-ctp-surface0 rounded-lg shadow-xl shadow-black/20 z-[101]`.
- Group items by `item.group ?? "__default__"` into a Map. Render groups in order, inserting a separator `div` (`my-1 border-t border-ctp-surface0`) between groups.
- Each item is a `button` with `role="menuitem"`, `type="button"`. On click: call `item.execute(activeMenu.context)`, then `hideMenu()`.
- Item styling: `w-full flex items-center gap-2 px-3 py-1.5 text-sm text-ctp-text hover:bg-ctp-surface0 transition-colors text-left`.
- If item has icon: render `<item.icon className="w-4 h-4 text-ctp-overlay1" />`.
- Keyboard handling via `useEffect`: listen for `Escape` key on document to close menu. Listen for `mousedown` outside menuRef to close menu. Cleanup both listeners on unmount.
- Focus the first menuitem on mount using `useEffect` with a ref.

**StatusBar.tsx** (~80 lines):
Create a `StatusBar` component that subscribes to `useStatusBarRegistry`.

- Read `items` and `visibilityTick` from the registry.
- Compute `leftItems` and `rightItems` via `useMemo` calling `getLeftItems()` and `getRightItems()` on the registry's getState(), with `[items, visibilityTick]` as deps.
- If both arrays are empty, return `null` (no layout impact).
- Render: `<footer role="status" aria-label="Status bar" className="flex items-center justify-between h-6 px-3 text-xs bg-ctp-mantle border-t border-ctp-surface0 select-none">`.
- Left zone: `<div className="flex items-center gap-2">`, map over leftItems rendering `<StatusBarWidget>`.
- Right zone: `<div className="flex items-center gap-2">`, map over rightItems rendering `<StatusBarWidget>`.
- `StatusBarWidget` component: calls `item.renderCustom()` for content. If `item.execute` exists, wrap in `<button type="button" onClick={item.execute} className="flex items-center gap-1 px-1.5 py-0.5 rounded text-ctp-subtext0 hover:text-ctp-text hover:bg-ctp-surface0 transition-colors cursor-pointer" title={item.tooltip}>`. Otherwise, wrap in `<span className="flex items-center gap-1 px-1.5 py-0.5 text-ctp-subtext0" title={item.tooltip}>`.

**App.tsx modifications:**
- Add imports: `import { ContextMenuPortal } from "./components/ui/ContextMenu"` and `import { StatusBar } from "./components/ui/StatusBar"`.
- In the JSX return, insert `{status && <StatusBar />}` between the `</main>` closing tag and `<ToastContainer />`. The status bar only renders when a repository is open.
- Insert `<ContextMenuPortal />` after `<CommandPalette />` (last child of the flex container, as it renders via portal to document.body anyway).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm compilation. Visually verify in dev mode: the app layout is unchanged (StatusBar returns null when empty), no context menu appears without right-clicking.
  </verify>
  <done>
ContextMenuPortal and StatusBar components exist and are integrated into App.tsx. StatusBar returns null when no items are registered. ContextMenuPortal renders nothing when no active menu.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DynamicSidebarPanels to RepositoryView, wire BranchItem context menu, emit GitHookBus events</name>
  <files>
    src/components/RepositoryView.tsx
    src/components/branches/BranchItem.tsx
    src/hooks/useCommitExecution.ts
    src/commands/toolbar-actions.ts
    src/stores/domain/git-ops/branches.slice.ts
  </files>
  <action>
**RepositoryView.tsx — DynamicSidebarPanels:**
- Add import: `import { useSidebarPanelRegistry } from "../lib/sidebarPanelRegistry"` and `import { useMemo } from "react"` (if not already imported) and `import { ErrorBoundary } from "react-error-boundary"` (or create a simple inline ErrorBoundary class component if react-error-boundary is not in package.json — check first).
- Create a `DynamicSidebarPanels` function component inside the file:
  - Subscribe to `useSidebarPanelRegistry(s => s.panels)` and `useSidebarPanelRegistry(s => s.visibilityTick)`.
  - Compute `visiblePanels` via `useMemo(() => useSidebarPanelRegistry.getState().getVisiblePanels(), [panels, visibilityTick])`.
  - If visiblePanels is empty, return null.
  - Map over visiblePanels, rendering each as a `<details key={panel.id} open={panel.defaultOpen} className="border-b border-ctp-surface0">` with the same summary pattern as existing core sections: `<summary className="p-3 cursor-pointer hover:bg-ctp-surface0/50 flex items-center gap-2 select-none sticky top-0 z-10 bg-ctp-base/70 backdrop-blur-lg border-b border-ctp-surface0/50">`.
  - Summary content: `<panel.icon className="w-4 h-4" />`, `<span className="font-semibold text-sm flex-1">{panel.title}</span>`, and `{panel.renderAction?.()}`.
  - Content: wrap `<panel.component />` in an error boundary. If react-error-boundary is available, use `<ErrorBoundary fallbackRender={({ error }) => <div className="p-3 text-xs text-ctp-red">Panel error: {error.message}</div>}>`. If not available, create a minimal `ExtensionPanelErrorBoundary` class component with componentDidCatch that renders a fallback.
- Insert `<DynamicSidebarPanels />` in the JSX immediately after the Worktrees `</details>` (before the closing `</div>` of the scrollable sections container, line ~151).

**BranchItem.tsx — Context Menu Wiring:**
- Add import: `import { useContextMenuRegistry } from "../../lib/contextMenuRegistry"`.
- Add an `onContextMenu` handler to the root `<div>` (or `<button>` — check the actual element) of BranchItem:
  ```
  onContextMenu={(e) => {
    e.preventDefault();
    useContextMenuRegistry.getState().showMenu(
      { x: e.clientX, y: e.clientY },
      "branch-list",
      { location: "branch-list", branchName: branch.name }
    );
  }}
  ```
  Where `branch.name` is the branch name prop available in the component. Read the existing component to find the correct prop name (it may be `branch.name`, `name`, or similar).

**useCommitExecution.ts — GitHookBus Emissions:**
- Add import: `import { gitHookBus } from "../lib/gitHookBus"`.
- In `commitMutation.onSuccess`, after the existing `queryClient.invalidateQueries` calls, add: `gitHookBus.emitDid("commit", { commitMessage })`.
- In `pushMutation.onSuccess`, after the existing toast/query invalidation, add: `gitHookBus.emitDid("push")`.

**toolbar-actions.ts — GitHookBus Emissions:**
- Add import: `import { gitHookBus } from "../lib/gitHookBus"`.
- Find the push action's execute function. After the `pushToRemote` success path, add: `gitHookBus.emitDid("push")`.
- Find the pull action's execute function. After the `pullFromRemote` success path, add: `gitHookBus.emitDid("pull")`.
- Find the fetch action's execute function. After the `fetchFromRemote` success path, add: `gitHookBus.emitDid("fetch")`.
- Read the file carefully to identify the exact locations. The operations are inside `try/catch` blocks in the `execute` functions. Add the emit call AFTER the successful await, BEFORE the toast/query invalidation (or alongside it).

**branches.slice.ts — GitHookBus Emissions:**
- Add import: `import { gitHookBus } from "../../../lib/gitHookBus"`.
- In `createBranch`: after `get().loadBranches()` success, add `gitHookBus.emitDid("branch-create", { branchName: name })`.
- In `deleteBranch`: after success, add `gitHookBus.emitDid("branch-delete", { branchName: name })`.
- In `checkoutBranch`: after success, add `gitHookBus.emitDid("checkout", { branchName: name })`.
- In `mergeBranch`: after success, add `gitHookBus.emitDid("merge", { branchName: sourceBranch })`.
- These are fire-and-forget calls (no await needed since emitDid returns Promise but handlers are error-isolated).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm compilation. In dev mode: (1) the sidebar looks identical (DynamicSidebarPanels renders nothing when registry is empty), (2) right-clicking a branch item does nothing visible yet (no items in registry), (3) committing/pushing logs no errors from gitHookBus.
  </verify>
  <done>
DynamicSidebarPanels zone exists in RepositoryView, BranchItem has onContextMenu wiring, and gitHookBus.emitDid is called after commit, push, pull, fetch, branch-create, branch-delete, checkout, and merge operations across 3 files.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without new errors
2. App layout unchanged when no extensions registered (StatusBar returns null, DynamicSidebarPanels returns null)
3. ContextMenuPortal mounts via portal to document.body, renders nothing when activeMenu is null
4. BranchItem has onContextMenu handler that calls showMenu on the registry
5. gitHookBus.emitDid is called in useCommitExecution.ts (commit, push), toolbar-actions.ts (push, pull, fetch), and branches.slice.ts (branch-create, branch-delete, checkout, merge)
6. Existing sidebar sections (Branches, Stashes, Tags, Gitflow, Worktrees) render identically
7. Existing commit, push, pull, fetch, branch operations continue working with no behavioral change
</verification>

<success_criteria>
- ContextMenu component renders grouped items with keyboard dismissal (Escape, click-outside)
- StatusBar component renders left/right zones from registry, returns null when empty
- DynamicSidebarPanels renders extension panels with error boundary protection
- BranchItem wired as first context menu integration point
- GitHookBus emissions cover 8 git operations across 3 files
- Zero regressions in existing UI or functionality
</success_criteria>

<output>
After completion, create `.planning/phases/37-extension-platform-foundation/37-02-SUMMARY.md`
</output>
