---
phase: 34-github-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/github/mod.rs
  - src-tauri/src/github/error.rs
  - src-tauri/src/github/types.rs
  - src-tauri/src/github/token.rs
  - src-tauri/src/github/auth.rs
  - src-tauri/src/github/remote.rs
  - src-tauri/src/github/rate_limit.rs
  - src-tauri/src/lib.rs
  - src/bindings.ts
autonomous: true
user_setup:
  - service: github-oauth-app
    why: "Device Flow requires a registered GitHub OAuth App client_id"
    env_vars: []
    dashboard_config:
      - task: "Register a GitHub OAuth App at https://github.com/settings/developers"
        location: "GitHub Settings -> Developer settings -> OAuth Apps -> New OAuth App"

must_haves:
  truths:
    - "Rust github module compiles and all commands are registered in lib.rs"
    - "keyring crate is configured with platform-specific features for macOS, Windows, and Linux"
    - "Device flow initiation returns device_code, user_code, verification_uri, expires_in, interval"
    - "Device flow polling handles all 4 GitHub error states (authorization_pending, slow_down, expired_token, access_denied)"
    - "Token is stored in OS keychain and never returned to the frontend"
    - "GitHub remote URLs (HTTPS and SSH) are correctly parsed to extract owner/repo"
    - "Rate limit info is fetched from GitHub API and returned as typed data"
    - "Auth status check validates token against GitHub /user endpoint"
  artifacts:
    - path: "src-tauri/src/github/mod.rs"
      provides: "Module root with re-exports"
    - path: "src-tauri/src/github/error.rs"
      provides: "GitHubError enum with IPC serialization"
      contains: "enum GitHubError"
    - path: "src-tauri/src/github/types.rs"
      provides: "Shared serde types for GitHub API responses"
    - path: "src-tauri/src/github/token.rs"
      provides: "Keychain CRUD via keyring crate"
    - path: "src-tauri/src/github/auth.rs"
      provides: "OAuth Device Flow commands"
    - path: "src-tauri/src/github/remote.rs"
      provides: "GitHub remote URL detection"
    - path: "src-tauri/src/github/rate_limit.rs"
      provides: "Rate limit checking command"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/github/"
      via: "mod github + collect_commands!"
      pattern: "mod github"
    - from: "src-tauri/src/github/auth.rs"
      to: "src-tauri/src/github/token.rs"
      via: "store_token after successful poll"
      pattern: "store_token"
    - from: "src-tauri/src/github/auth.rs"
      to: "src-tauri/src/github/types.rs"
      via: "shared response types"
      pattern: "use super::types"
---

<objective>
Create the complete Rust backend for GitHub OAuth Device Flow authentication, keychain token storage, remote detection, and rate limit checking.

Purpose: This is the security-critical layer. All GitHub API calls, token storage, and git remote parsing happen in Rust behind Tauri IPC. The frontend never touches tokens or makes direct HTTP calls (CSP enforced).

Output: A new `src-tauri/src/github/` module with 6 submodules and ~8 Tauri commands registered in lib.rs, with auto-generated TypeScript bindings.
</objective>

<execution_context>
@C:/Users/matrayp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matrayp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-github-authentication/34-RESEARCH.md
@.planning/phases/34-github-authentication/34-RESEARCH-ARCHITECTURE.md
@.planning/phases/34-github-authentication/34-RESEARCH-DEVELOPER.md
@src-tauri/src/lib.rs
@src-tauri/Cargo.toml
@src-tauri/src/git/error.rs
@src-tauri/src/git/nuget.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Rust module with error types, shared types, and keychain storage</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/github/mod.rs
    src-tauri/src/github/error.rs
    src-tauri/src/github/types.rs
    src-tauri/src/github/token.rs
  </files>
  <action>
1. Add `keyring` dependency to Cargo.toml:
   ```toml
   keyring = { version = "3", features = ["apple-native", "windows-native", "sync-secret-service"] }
   ```
   CRITICAL: keyring v3 has NO default features. Without explicit platform features, it compiles with only a mock store. The three features above cover macOS Keychain, Windows Credential Manager, and Linux Secret Service.

2. Create `src-tauri/src/github/mod.rs` as the module root:
   - Declare `pub mod error; pub mod types; pub mod token; pub mod auth; pub mod remote; pub mod rate_limit;`
   - Re-export key types and all Tauri command functions for easy import in lib.rs

3. Create `src-tauri/src/github/error.rs` following the exact pattern of `git/error.rs`:
   - `GitHubError` enum with `#[derive(Debug, Error, Serialize, Deserialize, Type, Clone)]`
   - Use `#[serde(tag = "type", content = "message")]` for tagged union IPC serialization
   - Variants: `OAuthFailed(String)`, `AuthorizationPending`, `AccessDenied`, `ExpiredToken`, `SlowDown`, `KeychainError(String)`, `NetworkError(String)`, `NotAuthenticated`, `RateLimitExceeded(String)`, `Internal(String)`, `Cancelled`
   - IMPORTANT: `AuthorizationPending` and `SlowDown` are used as control-flow errors during polling -- the frontend checks `err.type` to decide whether to continue polling

4. Create `src-tauri/src/github/types.rs`:
   - `DeviceFlowResponse` struct: `device_code`, `user_code`, `verification_uri`, `expires_in: u32`, `interval: u32` (all camelCase serde)
   - `AuthResult` struct: `authenticated: bool`, `username: Option<String>`, `avatar_url: Option<String>`, `scopes: Vec<String>` (returned after successful auth or status check -- NEVER contains the token)
   - `GitHubUser` internal struct (not Type): `login`, `avatar_url`, `name: Option<String>` for deserializing /user API response
   - `RateLimitInfo` struct: `limit: u32`, `remaining: u32`, `reset: u64`, `used: u32` (for rate limit display)
   - `GitHubRemoteInfo` struct: `remote_name: String`, `owner: String`, `repo: String`, `url: String`
   - All public IPC types derive `Debug, Clone, Serialize, Deserialize, Type` with `#[serde(rename_all = "camelCase")]`

5. Create `src-tauri/src/github/token.rs`:
   - Const `KEYCHAIN_SERVICE: &str = "com.flowforge.desktop.github"` and `KEYCHAIN_USER: &str = "github-oauth-token"`
   - `store_token(token: &str) -> Result<(), GitHubError>`: Creates `keyring::Entry`, calls `set_password`. Run on `tokio::task::spawn_blocking` since keyring ops are blocking.
   - `get_token() -> Result<String, GitHubError>`: Retrieves from keychain. Returns `GitHubError::NotAuthenticated` for `keyring::Error::NoEntry`.
   - `delete_token() -> Result<(), GitHubError>`: Calls `delete_credential()` (v3 API name). Treats `NoEntry` as success (already deleted).
   - `fetch_github_user(client: &reqwest::Client, token: &str) -> Result<GitHubUser, GitHubError>`: GET `https://api.github.com/user` with `Authorization: Bearer {token}`, `User-Agent: FlowForge-Desktop`, `Accept: application/json`. 10s timeout.
   - Tauri command `github_get_auth_status() -> Result<AuthResult, GitHubError>`: Calls `get_token()`, if found calls `fetch_github_user` to validate, returns AuthResult (never the token). If token invalid, auto-deletes it and returns `authenticated: false`.
   - Tauri command `github_sign_out() -> Result<(), GitHubError>`: Calls `delete_token()`.
   - IMPORTANT: Wrap ALL keyring Entry::new + operations in spawn_blocking. keyring is not async and can block.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- should compile with no errors. Verify keyring is in Cargo.lock with platform features.
  </verify>
  <done>
    github/error.rs, github/types.rs, github/token.rs compile. GitHubError has all variant types. Token CRUD functions use keyring with spawn_blocking. Auth status and sign-out commands defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Device Flow, remote detection, rate limit, and register all commands</name>
  <files>
    src-tauri/src/github/auth.rs
    src-tauri/src/github/remote.rs
    src-tauri/src/github/rate_limit.rs
    src-tauri/src/lib.rs
    src/bindings.ts
  </files>
  <action>
1. Create `src-tauri/src/github/auth.rs`:
   - Const `GITHUB_DEVICE_CODE_URL: &str = "https://github.com/login/device/code"`
   - Const `GITHUB_ACCESS_TOKEN_URL: &str = "https://github.com/login/oauth/access_token"`
   - Const `GITHUB_CLIENT_ID: &str = "Ov23li..."` -- Use a placeholder for now (the user will replace this with their registered OAuth App client_id). Add a TODO comment.
   - Internal deserialization struct `GitHubTokenResponse` with `access_token: Option<String>`, `token_type: Option<String>`, `scope: Option<String>`, `error: Option<String>`
   - Tauri command `github_start_device_flow(scopes: Vec<String>) -> Result<DeviceFlowResponse, GitHubError>`:
     - POST to GITHUB_DEVICE_CODE_URL with form body `client_id` + `scope` (scopes joined by space)
     - MUST set `Accept: application/json` header (GitHub defaults to URL-encoded without this)
     - Parse response as DeviceFlowResponse, return it
     - 10s timeout on the request
   - Tauri command `github_poll_auth(device_code: String, interval: u32) -> Result<AuthResult, GitHubError>`:
     - Single poll attempt (NOT a loop -- the frontend controls the polling loop via setTimeout)
     - POST to GITHUB_ACCESS_TOKEN_URL with form body `client_id`, `device_code`, `grant_type=urn:ietf:params:oauth:grant-type:device_code`
     - MUST set `Accept: application/json` header
     - Parse response. Check `error` field:
       - `"authorization_pending"` -> return `Err(GitHubError::AuthorizationPending)`
       - `"slow_down"` -> return `Err(GitHubError::SlowDown)`
       - `"expired_token"` -> return `Err(GitHubError::ExpiredToken)`
       - `"access_denied"` -> return `Err(GitHubError::AccessDenied)`
       - other error -> return `Err(GitHubError::OAuthFailed(...))`
     - On success (access_token present): call `token::store_token(&token)` to save to keychain, then call `token::fetch_github_user` to get user info. Return `AuthResult { authenticated: true, username, avatar_url, scopes }`. The token NEVER leaves Rust.
     - NOTE: GitHub returns scopes as comma-separated in the `scope` field, not space-separated. Split on ',' and trim.

2. Create `src-tauri/src/github/remote.rs`:
   - Pure function `parse_github_url(url: &str) -> Option<(String, String)>`:
     - Handle HTTPS: `https://github.com/owner/repo.git`
     - Handle SSH: `git@github.com:owner/repo.git`
     - Handle SSH protocol: `ssh://git@github.com/owner/repo.git`
     - Handle HTTP: `http://github.com/owner/repo.git`
     - Strip `.git` suffix, split into owner/repo
     - Case-insensitive check for "github.com" but preserve original case in owner/repo
   - Tauri command `github_detect_remotes(state: State<'_, RepositoryState>) -> Result<Vec<GitHubRemoteInfo>, GitHubError>`:
     - Get repo path from RepositoryState (same pattern as existing git commands)
     - Open git2::Repository in spawn_blocking
     - Iterate remotes, parse each URL with parse_github_url
     - Return all GitHub remotes found

3. Create `src-tauri/src/github/rate_limit.rs`:
   - Tauri command `github_check_rate_limit() -> Result<RateLimitInfo, GitHubError>`:
     - Get token from keychain via `token::get_token()`
     - GET `https://api.github.com/rate_limit` with Bearer auth, User-Agent, Accept headers
     - Parse response JSON to extract `resources.core` fields
     - Return RateLimitInfo

4. Update `src-tauri/src/lib.rs`:
   - Add `mod github;` alongside existing `mod git; mod gitflow; mod extensions;`
   - Import all GitHub commands: `github_start_device_flow`, `github_poll_auth`, `github_get_auth_status`, `github_sign_out`, `github_detect_remotes`, `github_check_rate_limit`
   - Add all 6 commands to the `collect_commands!` macro under a new `// GitHub commands` section
   - The bindings.ts file will auto-regenerate on next build with new command types

5. Run `cargo build` to generate updated bindings.ts with the new GitHub command types.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- should compile with no errors. Verify new commands appear in lib.rs collect_commands!. Run `cargo build` from the project root to regenerate bindings.
  </verify>
  <done>
    All 6 Tauri commands compile and are registered. Device flow handles all GitHub error states. Token storage uses keychain exclusively. Remote detection parses HTTPS and SSH GitHub URLs. Rate limit queries GitHub API. bindings.ts has TypeScript types for all new commands.
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` compiles without errors
2. `cargo build` generates updated bindings.ts with GitHub command types
3. All 6 commands registered in lib.rs collect_commands!
4. keyring crate in Cargo.lock with apple-native, windows-native, sync-secret-service features
5. No token value is ever returned to the frontend (only AuthResult with authenticated/username/scopes)
6. grep for "github" in the new files confirms the module structure is complete
</verification>

<success_criteria>
- GitHub Rust module has 6 submodules: error, types, token, auth, remote, rate_limit
- 6 Tauri commands registered: github_start_device_flow, github_poll_auth, github_get_auth_status, github_sign_out, github_detect_remotes, github_check_rate_limit
- keyring crate added with correct platform features
- All types derive specta::Type for TypeScript binding generation
- Token never returned to frontend -- AuthResult is the only data surface
</success_criteria>

<output>
After completion, create `.planning/phases/34-github-authentication/34-01-SUMMARY.md`
</output>
