---
phase: 34-github-authentication
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/toolbarRegistry.ts
  - src/extensions/ExtensionAPI.ts
  - src/components/toolbar/Toolbar.tsx
  - src/extensions/ExtensionHost.ts
  - src/extensions/extensionTypes.ts
autonomous: true

must_haves:
  truths:
    - "ToolbarAction supports a renderCustom property that replaces the default ToolbarButton rendering"
    - "Toolbar.tsx uses renderCustom generically instead of hardcoding action ID checks"
    - "The tb:theme-toggle special-case is migrated to use renderCustom"
    - "ExtensionHost supports registerBuiltIn() for first-party bundled extensions"
    - "Built-in extensions go through the same ExtensionAPI lifecycle as discovered extensions"
    - "ExtensionToolbarConfig supports renderCustom for extension-contributed custom widgets"
  artifacts:
    - path: "src/lib/toolbarRegistry.ts"
      provides: "ToolbarAction with renderCustom property"
      contains: "renderCustom"
    - path: "src/components/toolbar/Toolbar.tsx"
      provides: "Generic custom widget rendering via renderCustom"
    - path: "src/extensions/ExtensionHost.ts"
      provides: "registerBuiltIn method for first-party extensions"
      contains: "registerBuiltIn"
    - path: "src/extensions/ExtensionAPI.ts"
      provides: "ExtensionToolbarConfig with renderCustom support"
  key_links:
    - from: "src/components/toolbar/Toolbar.tsx"
      to: "src/lib/toolbarRegistry.ts"
      via: "action.renderCustom check replaces hardcoded ID check"
      pattern: "action\\.renderCustom"
    - from: "src/extensions/ExtensionHost.ts"
      to: "src/extensions/ExtensionAPI.ts"
      via: "registerBuiltIn creates ExtensionAPI and calls activate"
      pattern: "registerBuiltIn"
---

<objective>
Refactor the toolbar registry and extension host to support extensibility patterns needed by the GitHub extension -- specifically, custom toolbar widget rendering and built-in extension registration.

Purpose: The GitHub extension needs a toolbar button with a dynamic rate-limit badge (not a static icon), and it needs to be activated as a bundled first-party extension without filesystem discovery. These are generic extensibility improvements that benefit ALL future extensions, not GitHub-specific hacks.

Output: ToolbarAction.renderCustom property (generalizes tb:theme-toggle), ExtensionHost.registerBuiltIn() method, updated Toolbar.tsx rendering.
</objective>

<execution_context>
@C:/Users/matrayp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matrayp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-github-authentication/34-RESEARCH.md
@src/lib/toolbarRegistry.ts
@src/components/toolbar/Toolbar.tsx
@src/extensions/ExtensionHost.ts
@src/extensions/ExtensionAPI.ts
@src/extensions/extensionTypes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add renderCustom to ToolbarAction and refactor Toolbar.tsx</name>
  <files>
    src/lib/toolbarRegistry.ts
    src/extensions/ExtensionAPI.ts
    src/components/toolbar/Toolbar.tsx
  </files>
  <action>
1. In `src/lib/toolbarRegistry.ts`, add a `renderCustom` property to the `ToolbarAction` interface:
   ```typescript
   /** Optional custom render function. When provided, replaces the default ToolbarButton rendering.
    *  Receives the action and the computed tabIndex for roving tabindex integration. */
   renderCustom?: (action: ToolbarAction, tabIndex: number) => ReactNode;
   ```
   This requires importing `ReactNode` from "react" at the top of the file.

   This is the generic pattern that replaces the `if (action.id === "tb:theme-toggle")` special-case in Toolbar.tsx. Any action (core or extension) can provide a custom renderer.

2. In `src/extensions/ExtensionAPI.ts`, add `renderCustom` to `ExtensionToolbarConfig`:
   ```typescript
   /** Optional custom render function for toolbar widget (e.g., badge, toggle). */
   renderCustom?: (action: any, tabIndex: number) => ReactNode;
   ```
   This requires importing `ReactNode` from "react" (already importing ComponentType from "react", extend the import).

   The `contributeToolbar` method already spreads `...config` into the registry, so renderCustom will automatically be passed through without additional code changes.

3. In `src/components/toolbar/Toolbar.tsx`, refactor the inline rendering to use `renderCustom`:

   **BEFORE** (current code, lines ~103-110):
   ```tsx
   // Special case: render ThemeToggle widget for tb:theme-toggle
   if (action.id === "tb:theme-toggle") {
     return (
       <div key={action.id} data-toolbar-item tabIndex={getTabIndex(itemIndex)}>
         <ThemeToggle />
       </div>
     );
   }
   ```

   **AFTER** (generic pattern):
   ```tsx
   // Custom widget rendering (used by ThemeToggle, extension badges, etc.)
   if (action.renderCustom) {
     return (
       <div key={action.id} data-toolbar-item>
         {action.renderCustom(action, getTabIndex(itemIndex))}
       </div>
     );
   }
   ```

4. Now migrate the ThemeToggle registration to use `renderCustom`. Find where `tb:theme-toggle` is registered (in the toolbar action registrations, likely in `src/lib/toolbar-actions.ts` or similar) and add `renderCustom`:
   - Search for where `tb:theme-toggle` is registered
   - Add `renderCustom: (_action, tabIndex) => <ThemeToggle />` to the registration
   - The ThemeToggle import moves from Toolbar.tsx to the registration file
   - Remove the ThemeToggle import from Toolbar.tsx (it no longer needs to know about ThemeToggle)

   This completes the generalization: Toolbar.tsx no longer has ANY hardcoded ID checks. All custom rendering flows through the `renderCustom` property.

IMPORTANT: After this change, verify the ThemeToggle still renders correctly in the toolbar. The `data-toolbar-item` wrapper is preserved in the generic code path.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors. Run `npx vitest run` to check no tests break. Visually confirm ThemeToggle still appears in toolbar (if running the app).
  </verify>
  <done>
    ToolbarAction.renderCustom is a first-class property. Toolbar.tsx uses it generically. The tb:theme-toggle special-case is eliminated. Extensions can now contribute custom toolbar widgets without core code changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add registerBuiltIn to ExtensionHost for first-party bundled extensions</name>
  <files>
    src/extensions/ExtensionHost.ts
    src/extensions/extensionTypes.ts
  </files>
  <action>
1. In `src/extensions/extensionTypes.ts`, add a new type for built-in extension registration:
   ```typescript
   /** Configuration for registering a built-in (bundled) extension. */
   export interface BuiltInExtensionConfig {
     id: string;
     name: string;
     version: string;
     activate: (api: ExtensionAPI) => Promise<void>;
     deactivate?: () => Promise<void> | void;
   }
   ```
   This requires importing `ExtensionAPI` type (use `import type`).

2. In `src/extensions/ExtensionHost.ts`, add a `registerBuiltIn` method to the store:

   **Interface change:** Add to `ExtensionHostState`:
   ```typescript
   registerBuiltIn: (config: BuiltInExtensionConfig) => Promise<void>;
   ```

   **Implementation:**
   ```typescript
   registerBuiltIn: async (config) => {
     const { id, name, version, activate, deactivate } = config;

     // Create a synthetic manifest for tracking
     const manifest = {
       id,
       name,
       version,
       apiVersion: CURRENT_API_VERSION,
       main: "(built-in)",
       description: `Built-in extension: ${name}`,
     } as ExtensionManifest;

     // Register as discovered first
     const next = new Map(get().extensions);
     next.set(id, {
       id,
       name,
       version,
       status: "discovered",
       manifest,
     });
     set({ extensions: next }, false, `extension-host/register-builtin:${id}`);

     // Now activate through the standard API facade
     const api = new ExtensionAPI(id);

     try {
       await activate(api);

       // Store references for deactivation
       extensionApis.set(id, api);
       // Store a synthetic module object with onDeactivate
       extensionModules.set(id, { onDeactivate: deactivate });

       updateExtension(get, set, id, { status: "active", error: undefined });
     } catch (e) {
       api.cleanup();
       const errorMessage = e instanceof Error ? e.message : String(e);
       console.error(`Failed to activate built-in extension "${id}":`, e);
       updateExtension(get, set, id, { status: "error", error: errorMessage });
       toast.error(`Built-in extension "${name}" failed to activate: ${errorMessage}`);
     }
   },
   ```

   **Key design decisions:**
   - Built-in extensions go through the SAME ExtensionAPI facade as discovered extensions (same namespacing, same cleanup, same tracking)
   - They skip filesystem discovery and dynamic import (no convertFileSrc, no basePath)
   - A synthetic ExtensionManifest is created for tracking purposes (the extension appears in the extensions Map with all standard fields)
   - The `activate` function receives an ExtensionAPI instance directly (no module loading)
   - The `deactivate` function (if provided) is stored in extensionModules for standard deactivation flow
   - Built-in extensions can be deactivated via the existing `deactivateExtension(id)` method

3. Import `BuiltInExtensionConfig` in ExtensionHost.ts from extensionTypes.ts.

4. IMPORTANT: The `manifest` property uses `as ExtensionManifest` cast because built-in extensions don't have all manifest fields (no basePath, no contributes). This is acceptable since the manifest is only used for display/tracking purposes, not for activation. If needed, add optional fields to the manifest type instead.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors. Run `npx vitest run` to check no tests break.
  </verify>
  <done>
    ExtensionHost.registerBuiltIn() exists and accepts id, name, version, activate, deactivate. Built-in extensions get full ExtensionAPI lifecycle (namespaced registrations, tracked cleanup). No filesystem discovery needed for bundled extensions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. `npx vitest run` passes with no test regressions
3. ToolbarAction interface has `renderCustom` property
4. Toolbar.tsx has ZERO hardcoded action ID checks (no `action.id === "tb:theme-toggle"`)
5. ExtensionHost has `registerBuiltIn` in its interface and implementation
6. BuiltInExtensionConfig type is exported from extensionTypes.ts
</verification>

<success_criteria>
- renderCustom is a generic property on ToolbarAction, not a GitHub-specific addition
- Toolbar.tsx rendering logic is fully data-driven (no string ID comparisons)
- ThemeToggle still renders correctly through the renderCustom path
- registerBuiltIn creates ExtensionAPI, calls activate, tracks in extensions Map
- Built-in extensions can be deactivated via existing deactivateExtension flow
</success_criteria>

<output>
After completion, create `.planning/phases/34-github-authentication/34-02-SUMMARY.md`
</output>
