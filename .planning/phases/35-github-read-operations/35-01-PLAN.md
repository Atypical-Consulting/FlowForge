---
phase: 35-github-read-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/github/client.rs
  - src-tauri/src/github/types.rs
  - src-tauri/src/github/error.rs
  - src-tauri/src/github/pulls.rs
  - src-tauri/src/github/issues.rs
  - src-tauri/src/github/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Rust backend can fetch pull request list from GitHub REST API via authenticated request"
    - "Rust backend can fetch pull request detail with comments from GitHub REST API"
    - "Rust backend can fetch issue list (excluding PRs) from GitHub REST API"
    - "Rust backend can fetch issue detail with comments from GitHub REST API"
    - "All API calls attach Bearer token from OS keychain without exposing it"
    - "GitHub API responses are deserialized into typed IPC structs with camelCase field names"
    - "Link header pagination is parsed to provide hasNextPage/nextPage in responses"
  artifacts:
    - path: "src-tauri/src/github/client.rs"
      provides: "Shared authenticated HTTP helper with Link header parsing"
      contains: "github_get"
    - path: "src-tauri/src/github/pulls.rs"
      provides: "PR list and detail Tauri commands"
      exports: ["github_list_pull_requests", "github_get_pull_request"]
    - path: "src-tauri/src/github/issues.rs"
      provides: "Issue list and detail Tauri commands"
      exports: ["github_list_issues", "github_get_issue"]
    - path: "src-tauri/src/github/types.rs"
      provides: "PR, Issue, Comment, Label IPC types with specta Type derive"
      contains: "PullRequestSummary"
  key_links:
    - from: "src-tauri/src/github/pulls.rs"
      to: "src-tauri/src/github/client.rs"
      via: "github_get and github_get_with_params helpers"
      pattern: "client::github_get"
    - from: "src-tauri/src/github/pulls.rs"
      to: "src-tauri/src/github/types.rs"
      via: "IPC type conversion from internal deserialization types"
      pattern: "PullRequestSummary"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/github/mod.rs"
      via: "command re-exports registered in collect_commands"
      pattern: "github_list_pull_requests"
---

<objective>
Build the Rust backend layer for GitHub PR and issue read operations.

Purpose: Provides the typed Tauri commands that the frontend TanStack Query hooks will call to fetch PR/issue data. All GitHub API calls go through Rust so the OAuth token never crosses the IPC boundary.

Output: 3 new Rust files (client.rs, pulls.rs, issues.rs), extended types.rs and error.rs, updated mod.rs and lib.rs. 4 new Tauri commands registered and available via specta bindings.
</objective>

<execution_context>
@C:/Users/matrayp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matrayp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-github-read-operations/35-RESEARCH.md
@.planning/phases/35-github-read-operations/35-RESEARCH-DEVELOPER.md
@.planning/phases/35-github-read-operations/35-RESEARCH-ARCHITECTURE.md

# Key existing files to reference
@src-tauri/src/github/mod.rs
@src-tauri/src/github/error.rs
@src-tauri/src/github/types.rs
@src-tauri/src/github/token.rs
@src-tauri/src/github/rate_limit.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared GitHub API client, extend types and error enum</name>
  <files>
    src-tauri/src/github/client.rs
    src-tauri/src/github/types.rs
    src-tauri/src/github/error.rs
  </files>
  <action>
**1. Create `src-tauri/src/github/client.rs` -- shared authenticated HTTP helper:**

Create a module with these public functions:
- `pub async fn github_get(path: &str) -> Result<reqwest::Response, GitHubError>` -- Makes authenticated GET to `https://api.github.com{path}`. Gets token from `token::get_token().await?`, sets headers: `Authorization: Bearer {token}`, `User-Agent: FlowForge-Desktop`, `Accept: application/vnd.github+json`, `X-GitHub-Api-Version: 2022-11-28`, timeout 15s. Maps reqwest errors to `GitHubError::NetworkError`. Checks response status: 401 -> `NotAuthenticated`, 403 with x-ratelimit-remaining=0 -> `RateLimitExceeded`, 403 -> `Forbidden(...)`, 404 -> `NotFound(...)`, other non-success -> `ApiError(format!("HTTP {}: {}", status, body))`. Returns the Response on success.

- `pub async fn github_get_with_params(path: &str, params: &[(&str, &str)]) -> Result<reqwest::Response, GitHubError>` -- Same as github_get but adds `.query(params)` to the request.

- `pub fn parse_next_page(link_header: &str) -> Option<u32>` -- Parses GitHub's Link header. Split on `,`, find the part containing `rel="next"`, extract URL between `<` and `>`, find `page=` parameter value, parse as u32. Return None if no next page.

- `pub fn extract_rate_limit(resp: &reqwest::Response) -> (Option<u32>, Option<u32>)` -- Extract (remaining, limit) from x-ratelimit-remaining and x-ratelimit-limit headers.

Use `super::error::GitHubError` and `super::token`. Follow the exact pattern from `rate_limit.rs` for reqwest usage.

**2. Extend `src-tauri/src/github/error.rs` -- add 3 new variants:**

Add these variants to the GitHubError enum:
```rust
#[error("API error: {0}")]
ApiError(String),

#[error("Not found: {0}")]
NotFound(String),

#[error("Forbidden: {0}")]
Forbidden(String),
```

**3. Extend `src-tauri/src/github/types.rs` -- add internal deserialization types and IPC types:**

Add INTERNAL deserialization structs (no `Type` derive, no `Serialize`, no `rename_all`):
- `GitHubUserRef { login: String, avatar_url: String }` -- `#[derive(Debug, Deserialize)]`
- `GitHubLabel { id: u64, name: String, color: String, description: Option<String> }` -- `#[derive(Debug, Deserialize)]`
- `GitHubBranchRef { #[serde(rename = "ref")] ref_name: String, sha: String }` -- `#[derive(Debug, Deserialize)]`
- `GitHubPullRequest { number: u32, title: String, state: String, draft: Option<bool>, user: GitHubUserRef, head: GitHubBranchRef, base: GitHubBranchRef, labels: Vec<GitHubLabel>, created_at: String, updated_at: String, merged_at: Option<String>, body: Option<String>, comments: Option<u32>, review_comments: Option<u32>, commits: Option<u32>, additions: Option<u32>, deletions: Option<u32>, changed_files: Option<u32>, html_url: String }` -- `#[derive(Debug, Deserialize)]`
- `GitHubIssue { number: u32, title: String, state: String, user: GitHubUserRef, labels: Vec<GitHubLabel>, assignees: Vec<GitHubUserRef>, milestone: Option<GitHubMilestone>, created_at: String, updated_at: String, closed_at: Option<String>, body: Option<String>, comments: u32, html_url: String, pull_request: Option<serde_json::Value> }` -- `#[derive(Debug, Deserialize)]` -- the `pull_request` field is used to filter out PRs from the issues API
- `GitHubMilestone { number: u32, title: String, state: String }` -- `#[derive(Debug, Deserialize)]`
- `GitHubComment { id: u64, user: GitHubUserRef, body: String, created_at: String, updated_at: String, html_url: String }` -- `#[derive(Debug, Deserialize)]`

Add IPC types with `#[derive(Debug, Clone, Serialize, Deserialize, Type)]` and `#[serde(rename_all = "camelCase")]`:
- `PullRequestSummary { number: u32, title: String, state: String, draft: bool, merged: bool, author_login: String, author_avatar_url: String, head_ref: String, base_ref: String, labels: Vec<LabelInfo>, created_at: String, updated_at: String, html_url: String, comment_count: u32 }`
- `PullRequestDetail { number: u32, title: String, state: String, draft: bool, merged: bool, author_login: String, author_avatar_url: String, head_ref: String, head_sha: String, base_ref: String, labels: Vec<LabelInfo>, body: String, created_at: String, updated_at: String, html_url: String, comment_count: u32, review_comment_count: u32, commits: u32, additions: u32, deletions: u32, changed_files: u32, comments: Vec<CommentInfo> }`
- `IssueSummary { number: u32, title: String, state: String, author_login: String, author_avatar_url: String, labels: Vec<LabelInfo>, assignee_logins: Vec<String>, milestone_title: Option<String>, created_at: String, updated_at: String, html_url: String, comment_count: u32 }`
- `IssueDetail { number: u32, title: String, state: String, author_login: String, author_avatar_url: String, labels: Vec<LabelInfo>, assignees: Vec<UserInfo>, milestone: Option<MilestoneInfo>, body: String, created_at: String, updated_at: String, closed_at: Option<String>, html_url: String, comment_count: u32, comments: Vec<CommentInfo> }`
- `LabelInfo { name: String, color: String, description: Option<String> }`
- `UserInfo { login: String, avatar_url: String }`
- `MilestoneInfo { number: u32, title: String, state: String }`
- `CommentInfo { id: u64, author_login: String, author_avatar_url: String, body: String, created_at: String, updated_at: String, html_url: String }`
- `PullRequestListResponse { items: Vec<PullRequestSummary>, has_next_page: bool, next_page: Option<u32> }` -- concrete type (not generic, avoiding specta generics issues)
- `IssueListResponse { items: Vec<IssueSummary>, has_next_page: bool, next_page: Option<u32> }` -- concrete type

Use concrete list response types instead of generic `PaginatedResponse<T>` to avoid specta generic type issues (per research pitfall #7).
  </action>
  <verify>Run `cargo check` from `src-tauri/`. All new types compile. No errors in error.rs, types.rs, or client.rs.</verify>
  <done>client.rs provides reusable authenticated HTTP helpers. types.rs has all internal + IPC types for PR/issue data. error.rs has ApiError, NotFound, Forbidden variants. All compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create PR/issue Tauri commands and register in lib.rs</name>
  <files>
    src-tauri/src/github/pulls.rs
    src-tauri/src/github/issues.rs
    src-tauri/src/github/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
**1. Create `src-tauri/src/github/pulls.rs`:**

Two commands:

`github_list_pull_requests(owner: String, repo: String, state: String, page: u32, per_page: u32) -> Result<PullRequestListResponse, GitHubError>`:
- Build path: `/repos/{owner}/{repo}/pulls`
- Call `client::github_get_with_params` with params: `[("state", &state), ("page", &page.to_string()), ("per_page", &per_page.to_string()), ("sort", "updated"), ("direction", "desc")]`
- Before consuming body, extract Link header: `resp.headers().get("link").and_then(|v| v.to_str().ok()).map(String::from)` -- store as Option<String>
- Deserialize response body as `Vec<GitHubPullRequest>` (internal type)
- Convert each to `PullRequestSummary`: map fields directly; `draft: pr.draft.unwrap_or(false)`, `merged: pr.merged_at.is_some()`, `comment_count: pr.comments.unwrap_or(0)`, labels mapped to LabelInfo
- Parse next page from link_header using `client::parse_next_page`
- Return `PullRequestListResponse { items, has_next_page, next_page }`
- Add `#[tauri::command]` and `#[specta::specta]` decorators

`github_get_pull_request(owner: String, repo: String, number: u32) -> Result<PullRequestDetail, GitHubError>`:
- Fetch PR: `client::github_get(&format!("/repos/{}/{}/pulls/{}", owner, repo, number))`
- Deserialize as `GitHubPullRequest`
- Fetch comments: `client::github_get(&format!("/repos/{}/{}/issues/{}/comments", owner, repo, number))` -- NOTE: use issues endpoint for general comments, not pulls/comments
- Deserialize comments as `Vec<GitHubComment>`
- Convert to `PullRequestDetail` with all fields: `body: pr.body.unwrap_or_default()`, comments mapped to `CommentInfo`, stats from `commits/additions/deletions/changed_files` with `unwrap_or(0)`
- Add `#[tauri::command]` and `#[specta::specta]` decorators

**2. Create `src-tauri/src/github/issues.rs`:**

Two commands:

`github_list_issues(owner: String, repo: String, state: String, page: u32, per_page: u32) -> Result<IssueListResponse, GitHubError>`:
- Build path: `/repos/{owner}/{repo}/issues`
- Call `client::github_get_with_params` with params: `[("state", &state), ("page", &page.to_string()), ("per_page", &per_page.to_string()), ("sort", "updated"), ("direction", "desc")]`
- Extract Link header before consuming body
- Deserialize as `Vec<GitHubIssue>`
- **CRITICAL: Filter out PRs** -- `issues.retain(|i| i.pull_request.is_none())` -- GitHub issues API returns PRs too
- Convert each to `IssueSummary`: `assignee_logins: issue.assignees.iter().map(|a| a.login.clone()).collect()`, `milestone_title: issue.milestone.as_ref().map(|m| m.title.clone())`
- Parse next page from link_header
- Return `IssueListResponse { items, has_next_page, next_page }`
- Add `#[tauri::command]` and `#[specta::specta]` decorators

`github_get_issue(owner: String, repo: String, number: u32) -> Result<IssueDetail, GitHubError>`:
- Fetch issue: `client::github_get(&format!("/repos/{}/{}/issues/{}", owner, repo, number))`
- Deserialize as `GitHubIssue`
- Fetch comments: `client::github_get(&format!("/repos/{}/{}/issues/{}/comments", owner, repo, number))`
- Deserialize as `Vec<GitHubComment>`
- Convert to `IssueDetail`: `body: issue.body.unwrap_or_default()`, assignees mapped to UserInfo, milestone mapped to MilestoneInfo, comments mapped to CommentInfo
- Add `#[tauri::command]` and `#[specta::specta]` decorators

**3. Update `src-tauri/src/github/mod.rs`:**

Add module declarations:
```rust
pub mod client;
pub mod pulls;
pub mod issues;
```

Add re-exports:
```rust
pub use pulls::{github_list_pull_requests, github_get_pull_request};
pub use issues::{github_list_issues, github_get_issue};
```

**4. Update `src-tauri/src/lib.rs`:**

Add to the `use github::` import block:
```rust
github_list_pull_requests, github_get_pull_request,
github_list_issues, github_get_issue,
```

Add to `collect_commands![]` after the existing GitHub commands, with a comment `// GitHub read commands`:
```
github_list_pull_requests,
github_get_pull_request,
github_list_issues,
github_get_issue,
```
  </action>
  <verify>Run `cargo check` from `src-tauri/`. All 4 new commands compile. Run `cargo build` to generate specta bindings. Verify the new command types appear in `src/bindings.ts` (or manually add them if running on Windows without `tauri dev`).</verify>
  <done>4 new Tauri commands registered: github_list_pull_requests, github_get_pull_request, github_list_issues, github_get_issue. All compile cleanly. Commands are available through specta bindings for frontend consumption.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes in `src-tauri/` directory
2. `cargo build` succeeds (triggers specta binding generation in debug mode)
3. New types visible in `src/bindings.ts`: PullRequestSummary, PullRequestDetail, IssueSummary, IssueDetail, PullRequestListResponse, IssueListResponse, LabelInfo, UserInfo, MilestoneInfo, CommentInfo
4. New command functions visible in bindings: githubListPullRequests, githubGetPullRequest, githubListIssues, githubGetIssue
</verification>

<success_criteria>
- Shared client.rs eliminates auth header duplication across GitHub commands
- Internal deserialization types correctly map GitHub API snake_case JSON
- IPC types correctly use camelCase for frontend consumption
- Issues endpoint filters out PRs via pull_request field check
- Merged state detected via merged_at.is_some() on list endpoint
- Link header pagination properly extracts next page number
- All 4 commands registered and callable from frontend
</success_criteria>

<output>
After completion, create `.planning/phases/35-github-read-operations/35-01-SUMMARY.md`
</output>
