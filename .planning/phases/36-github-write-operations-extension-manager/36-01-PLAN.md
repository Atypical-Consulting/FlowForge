---
phase: 36-github-write-operations-extension-manager
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/github/client.rs
  - src-tauri/src/github/error.rs
  - src-tauri/src/github/types.rs
  - src-tauri/src/github/pulls.rs
  - src-tauri/src/github/branch_info.rs
  - src-tauri/src/github/mod.rs
  - src-tauri/src/extensions/install.rs
  - src-tauri/src/extensions/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Rust code compiles with new github_post and github_put client helpers"
    - "Tauri commands for merge PR, create PR, and get branch commits exist and are registered"
    - "Extension install/uninstall Tauri commands exist and are registered"
    - "Write-specific error variants (MergeNotAllowed, HeadChanged, ValidationFailed) are in GitHubError"
    - "TypeScript bindings are regenerated with all new commands and types"
  artifacts:
    - path: "src-tauri/src/github/client.rs"
      provides: "github_post and github_put authenticated helpers"
      contains: "pub async fn github_post"
    - path: "src-tauri/src/github/pulls.rs"
      provides: "github_merge_pull_request and github_create_pull_request commands"
      contains: "github_merge_pull_request"
    - path: "src-tauri/src/github/branch_info.rs"
      provides: "github_get_branch_info_for_pr command"
      contains: "github_get_branch_info_for_pr"
    - path: "src-tauri/src/extensions/install.rs"
      provides: "extension_fetch_manifest, extension_install, extension_uninstall commands"
      contains: "extension_fetch_manifest"
    - path: "src-tauri/src/github/error.rs"
      provides: "Write-specific error variants"
      contains: "MergeNotAllowed"
  key_links:
    - from: "src-tauri/src/github/pulls.rs"
      to: "src-tauri/src/github/client.rs"
      via: "client::github_put and client::github_post"
      pattern: "client::github_put|client::github_post"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/github/pulls.rs"
      via: "collect_commands![] registration"
      pattern: "github_merge_pull_request"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/extensions/install.rs"
      via: "collect_commands![] registration"
      pattern: "extension_fetch_manifest"
---

<objective>
Add Rust backend commands for GitHub write operations (merge PR, create PR, branch info for PR pre-fill) and extension lifecycle management (fetch manifest, install, uninstall). Extend the HTTP client with POST/PUT helpers and add write-specific error variants.

Purpose: Phase 36 frontend components need Tauri commands to call. These commands must exist and generate TypeScript bindings before any frontend work can begin.
Output: 6 new Tauri commands registered and compiled, TypeScript bindings regenerated.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src-tauri/src/github/client.rs
@src-tauri/src/github/error.rs
@src-tauri/src/github/types.rs
@src-tauri/src/github/pulls.rs
@src-tauri/src/github/mod.rs
@src-tauri/src/extensions/mod.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend GitHub client, error types, and add write commands (merge PR, create PR, branch info)</name>
  <files>
    src-tauri/src/github/client.rs
    src-tauri/src/github/error.rs
    src-tauri/src/github/types.rs
    src-tauri/src/github/pulls.rs
    src-tauri/src/github/branch_info.rs
    src-tauri/src/github/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    **1. client.rs -- Add POST and PUT helpers:**
    Add two new public async functions mirroring the existing `github_get` pattern:
    - `pub async fn github_post<T: serde::Serialize>(path: &str, body: &T) -> Result<reqwest::Response, GitHubError>` -- uses `.post(&url).json(body)`, timeout 30s (longer than GET's 15s for writes), same auth headers.
    - `pub async fn github_put<T: serde::Serialize>(path: &str, body: &T) -> Result<reqwest::Response, GitHubError>` -- same as POST but uses `.put(&url).json(body)`.
    Both call the existing `check_response_status()`. Also update `check_response_status` to handle write-specific status codes: add match arms for 405 -> `GitHubError::MergeNotAllowed`, 409 -> `GitHubError::HeadChanged`, 422 -> `GitHubError::ValidationFailed`. Add `use serde::Serialize;` to imports.

    **2. error.rs -- Add write-specific variants:**
    Add three new variants to the `GitHubError` enum:
    ```rust
    #[error("Merge not allowed: {0}")]
    MergeNotAllowed(String),

    #[error("Head has changed: {0}")]
    HeadChanged(String),

    #[error("Validation failed: {0}")]
    ValidationFailed(String),
    ```

    **3. types.rs -- Add write operation types:**
    Add internal (non-IPC) types for GitHub API request bodies:
    ```rust
    // --- Internal types for write request bodies ---
    #[derive(Debug, Serialize)]
    pub struct GitHubMergePrBody {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub commit_title: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub commit_message: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub sha: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub merge_method: Option<String>,
    }

    #[derive(Debug, Deserialize)]
    pub struct GitHubMergeResponse {
        pub sha: Option<String>,
        pub merged: bool,
        pub message: String,
    }

    #[derive(Debug, Serialize)]
    pub struct GitHubCreatePrBody {
        pub title: String,
        pub head: String,
        pub base: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub body: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
    }
    ```

    Add IPC types (with `Type` derive and `camelCase` rename):
    ```rust
    #[derive(Debug, Clone, Serialize, Deserialize, Type)]
    #[serde(rename_all = "camelCase")]
    pub struct MergePullRequestResult {
        pub merged: bool,
        pub sha: Option<String>,
        pub message: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize, Type)]
    #[serde(rename_all = "camelCase")]
    pub struct CreatePullRequestResult {
        pub number: u32,
        pub html_url: String,
        pub title: String,
        pub state: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize, Type)]
    #[serde(rename_all = "camelCase")]
    pub struct BranchInfoForPr {
        pub current_branch: String,
        pub default_base: String,
        pub suggested_title: String,
        pub commit_messages: Vec<String>,
    }
    ```

    **4. pulls.rs -- Add merge and create PR commands:**
    Add two new Tauri commands after existing `github_get_pull_request`:

    `github_merge_pull_request(owner, repo, pull_number: u32, merge_method: String, commit_title: Option<String>, commit_message: Option<String>, sha: Option<String>) -> Result<MergePullRequestResult, GitHubError>`:
    - Build `GitHubMergePrBody` from params
    - Call `client::github_put` with path `/repos/{owner}/{repo}/pulls/{pull_number}/merge`
    - Parse response as `GitHubMergeResponse`, convert to `MergePullRequestResult`

    `github_create_pull_request(owner, repo, title: String, head: String, base: String, body: Option<String>, draft: Option<bool>) -> Result<CreatePullRequestResult, GitHubError>`:
    - Build `GitHubCreatePrBody` from params
    - Call `client::github_post` with path `/repos/{owner}/{repo}/pulls`
    - Parse response as `GitHubPullRequest` (existing internal type), convert to `CreatePullRequestResult`
    - Note: `GitHubPullRequest` has `html_url` field -- need to add it if missing. Check types.rs, if `html_url` is not on `GitHubPullRequest`, add `pub html_url: String` to the struct.

    **5. branch_info.rs -- NEW file for PR pre-fill data:**
    Create `src-tauri/src/github/branch_info.rs` with one Tauri command:

    `github_get_branch_info_for_pr(state: State<'_, RepositoryState>) -> Result<BranchInfoForPr, GitHubError>`:
    - Use `state.get_path().await` to get repo path (import RepositoryState from `crate::git`)
    - `tokio::task::spawn_blocking` for git2 operations:
      - Get current branch: `repo.head()?.shorthand()` -> `current_branch`
      - Detect default base: check for `origin/main` or `origin/master` refs, fallback to `"main"`
      - Generate suggested title from branch name: strip prefixes (`feature/`, `fix/`, `hotfix/`, `bugfix/`, `release/`, `chore/`), replace `-` and `_` with spaces, capitalize first letter
      - Get commit messages ahead of base: `repo.revwalk()` from HEAD, stop when reaching merge-base with `origin/{default_base}`. Use `repo.merge_base(head_oid, base_oid)` to find the common ancestor, then walk from HEAD collecting summaries until reaching that merge-base OID. Collect `commit.summary()` as `Vec<String>`.
    - Return `BranchInfoForPr { current_branch, default_base, suggested_title, commit_messages }`

    **6. mod.rs -- Add re-exports:**
    Add to `src-tauri/src/github/mod.rs`:
    ```rust
    pub mod branch_info;
    // ... existing mods ...
    pub use pulls::{github_merge_pull_request, github_create_pull_request};
    pub use branch_info::github_get_branch_info_for_pr;
    ```

    **7. lib.rs -- Register new commands:**
    Add to the `use github::{...}` block: `github_merge_pull_request, github_create_pull_request, github_get_branch_info_for_pr`
    Add to `collect_commands![...]` after the existing GitHub read commands section:
    ```rust
    // GitHub write commands
    github_merge_pull_request,
    github_create_pull_request,
    github_get_branch_info_for_pr,
    ```
  </action>
  <verify>
    Run `cd /Users/phmatray/Repositories/github-phm/FlowForge && cargo check --manifest-path src-tauri/Cargo.toml` -- must compile without errors.
  </verify>
  <done>
    Rust compiles with github_post/github_put in client.rs, three new error variants in error.rs, write types in types.rs, merge/create commands in pulls.rs, branch_info.rs with PR pre-fill command, all re-exported in mod.rs and registered in lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add extension install/uninstall Tauri commands and regenerate bindings</name>
  <files>
    src-tauri/src/extensions/install.rs
    src-tauri/src/extensions/mod.rs
    src-tauri/src/lib.rs
    src/bindings.ts
  </files>
  <action>
    **1. install.rs -- NEW file for extension install lifecycle:**
    Create `src-tauri/src/extensions/install.rs` with three Tauri commands:

    `extension_fetch_manifest(git_url: String) -> Result<String, String>`:
    - Clone the repo to a temp directory under `std::env::temp_dir().join("flowforge-ext-install")`
    - Use `tokio::task::spawn_blocking` with `git2::Repository::clone(&url, &temp_path)` for simple clone (do not use shallow clone -- git2 shallow clone support is unreliable; repos are small)
    - After clone, check for `flowforge.extension.json` in repo root. If missing, clean up temp dir and return `Err("No flowforge.extension.json found")`.
    - Read the manifest file contents as a string
    - Return `Ok(manifest_json_string)` -- the frontend will parse and display it
    - Keep the cloned temp dir alive for the next step (install). Include the temp path in the return somehow -- either serialize it as a JSON object with `{ manifest, tempPath }` or use a separate struct. Recommendation: return a JSON string that contains both the manifest content and the temp path. Use a helper struct:
      ```rust
      #[derive(Serialize, Deserialize, Type)]
      #[serde(rename_all = "camelCase")]
      pub struct ExtensionFetchResult {
          pub manifest_json: String,
          pub temp_path: String,
      }
      ```
      Return `Result<ExtensionFetchResult, String>`.

    `extension_install(temp_path: String, extensions_dir: String) -> Result<(), String>`:
    - Read `flowforge.extension.json` from `temp_path` to get the extension ID
    - Parse manifest to extract the `id` field (use `serde_json::from_str` into a minimal struct or `serde_json::Value`)
    - Target directory: `extensions_dir / extension_id`
    - If target already exists, return `Err("Extension already installed")` (do NOT silently overwrite)
    - Create extensions_dir if needed (`tokio::fs::create_dir_all`)
    - Move temp_path contents to target: use `tokio::fs::rename` (same filesystem) or copy+delete if cross-filesystem
    - Return `Ok(())`

    `extension_uninstall(extension_id: String, extensions_dir: String) -> Result<(), String>`:
    - Build path: `extensions_dir / extension_id`
    - Check path exists, return error if not
    - `tokio::fs::remove_dir_all(path)` to delete
    - Return `Ok(())`

    `extension_cancel_install(temp_path: String) -> Result<(), String>`:
    - If temp_path exists, `tokio::fs::remove_dir_all(temp_path)`
    - Return `Ok(())`

    **2. mod.rs -- Add install module:**
    Add to `src-tauri/src/extensions/mod.rs`:
    ```rust
    pub mod install;
    ```

    **3. lib.rs -- Register extension commands:**
    Add to the `use extensions::...` block: `install::{extension_fetch_manifest, extension_install, extension_uninstall, extension_cancel_install}`
    Add to `collect_commands![...]`:
    ```rust
    // Extension install commands
    extension_fetch_manifest,
    extension_install,
    extension_uninstall,
    extension_cancel_install,
    ```

    **4. Regenerate TypeScript bindings:**
    Run `cd /Users/phmatray/Repositories/github-phm/FlowForge && cargo build --manifest-path src-tauri/Cargo.toml 2>&1 | tail -20` to trigger specta binding generation.
    Then verify the new commands appear in `src/bindings.ts`: grep for `githubMergePullRequest`, `githubCreatePullRequest`, `githubGetBranchInfoForPr`, `extensionFetchManifest`, `extensionInstall`, `extensionUninstall`, `extensionCancelInstall`.

    Note: If bindings are only generated in `debug_assertions` mode (which they are -- see lib.rs), run with `cargo build --manifest-path src-tauri/Cargo.toml` (debug build, which is default). If the bindings still don't generate automatically, manually add the command signatures to `src/bindings.ts` following the existing pattern (tagged Result type with `{ status: "ok", data: T } | { status: "error", error: E }`). Reference Phase 35-02 decisions: "Manual bindings.ts additions for GitHub commands."
  </action>
  <verify>
    Run `cd /Users/phmatray/Repositories/github-phm/FlowForge && cargo check --manifest-path src-tauri/Cargo.toml` -- must compile without errors. Then verify `grep -c "extensionFetchManifest\|githubMergePullRequest\|githubGetBranchInfoForPr" src/bindings.ts` returns 3+ matches (or the commands exist in the generated file).
  </verify>
  <done>
    Extension install/uninstall commands compile and are registered. TypeScript bindings include all new commands: githubMergePullRequest, githubCreatePullRequest, githubGetBranchInfoForPr, extensionFetchManifest, extensionInstall, extensionUninstall, extensionCancelInstall.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --manifest-path src-tauri/Cargo.toml` passes
2. `src/bindings.ts` contains all 7 new command signatures
3. `GitHubError` enum has MergeNotAllowed, HeadChanged, ValidationFailed variants
4. `client.rs` has github_post and github_put functions
5. New commands are registered in collect_commands![] in lib.rs
</verification>

<success_criteria>
All Rust code compiles. TypeScript bindings are generated (or manually added) for all new commands. No existing functionality broken.
</success_criteria>

<output>
After completion, create `.planning/phases/36-github-write-operations-extension-manager/36-01-SUMMARY.md`
</output>
