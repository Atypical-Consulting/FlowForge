---
phase: 28-conventional-commit-blade
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/conventional-utils.ts
  - src/lib/conventional-utils.test.ts
  - src/stores/conventional.ts
  - src/components/topology/layoutUtils.ts
  - src/components/icons/CommitTypeIcon.tsx
autonomous: true

must_haves:
  truths:
    - "buildCommitMessage is a pure function importable without Zustand store dependency"
    - "parseConventionalMessage extracts type, scope, description, body, and breaking change from a CC string"
    - "Store delegates buildCommitMessage to the pure utility and extends with amend, pushAfterCommit, template, and frequency state"
    - "layoutUtils and CommitTypeIcon import the shared parser instead of maintaining local copies"
  artifacts:
    - path: "src/lib/conventional-utils.ts"
      provides: "buildCommitMessage and parseConventionalMessage pure functions"
      exports: ["buildCommitMessage", "parseConventionalMessage"]
    - path: "src/lib/conventional-utils.test.ts"
      provides: "Unit tests for pure utility functions"
      min_lines: 50
    - path: "src/stores/conventional.ts"
      provides: "Extended store with amend, push, template, and frequency state"
      contains: "isAmend"
  key_links:
    - from: "src/stores/conventional.ts"
      to: "src/lib/conventional-utils.ts"
      via: "import buildCommitMessage"
      pattern: "import.*buildCommitMessage.*from.*conventional-utils"
    - from: "src/components/topology/layoutUtils.ts"
      to: "src/lib/conventional-utils.ts"
      via: "import parseConventionalMessage"
      pattern: "import.*parseConventionalMessage.*from.*conventional-utils"
---

<objective>
Extract pure utility functions from the Zustand store and deduplicate the conventional commit parser, then extend the store with new state fields for the blade.

Purpose: Decouple pure logic from store state so both sidebar and blade can share it. Establish the extensible state shape before building new UI. This is the foundational refactoring that enables all subsequent plans.

Output: `src/lib/conventional-utils.ts` with `buildCommitMessage` and `parseConventionalMessage`, extended `conventional.ts` store, and unified parser across the codebase.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-conventional-commit-blade/28-RESEARCH.md

@src/stores/conventional.ts
@src/components/topology/layoutUtils.ts
@src/components/icons/CommitTypeIcon.tsx
@src/hooks/useConventionalCommit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pure utility functions and unit tests</name>
  <files>src/lib/conventional-utils.ts, src/lib/conventional-utils.test.ts</files>
  <action>
Create `src/lib/conventional-utils.ts` with two pure functions:

1. **`buildCommitMessage(parts: ConventionalMessageParts): string`**
   - Extract the logic from `conventional.ts` lines 158-188 (the `buildCommitMessage` method).
   - Define a `ConventionalMessageParts` interface: `{ commitType: CommitType | ""; scope: string; description: string; body: string; isBreaking: boolean; breakingDescription: string; }`.
   - Returns empty string if `commitType` or `description` is falsy.
   - Builds: `type(scope)!: description\n\nbody\n\nBREAKING CHANGE: breakingDescription`.

2. **`parseConventionalMessage(message: string): ConventionalMessageParts | null`**
   - Parse a full commit message string back into `ConventionalMessageParts`.
   - Use regex: `/^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(([^)]+)\))?(!)?\s*:\s*(.+)/` for the subject line.
   - If the message has a body (content after first blank line), extract it.
   - If body contains `BREAKING CHANGE: ...`, extract the breaking description and set `isBreaking: true`.
   - If `!` is present in subject, also set `isBreaking: true`.
   - Return `null` if the message does not match CC format.

Export both functions and the `ConventionalMessageParts` interface.

Create `src/lib/conventional-utils.test.ts` with Vitest unit tests covering:
- `buildCommitMessage`: empty inputs, type-only, type+scope, type+scope+description, with body, with breaking change, with both body and breaking.
- `parseConventionalMessage`: valid CC messages (all 11 types), with scope, without scope, with `!`, with body, with `BREAKING CHANGE:` footer, non-CC messages return null, empty string returns null.
- Round-trip: `parseConventionalMessage(buildCommitMessage(parts))` returns equivalent parts.
  </action>
  <verify>Run `npx vitest run src/lib/conventional-utils.test.ts` -- all tests pass.</verify>
  <done>Two pure functions exported from `conventional-utils.ts`, all unit tests pass, no store or React dependencies in the file.</done>
</task>

<task type="auto">
  <name>Task 2: Extend Zustand store with blade state and delegate to pure utility</name>
  <files>src/stores/conventional.ts</files>
  <action>
Modify `src/stores/conventional.ts`:

1. **Import and delegate `buildCommitMessage`:**
   - `import { buildCommitMessage as buildMessage } from "../lib/conventional-utils";`
   - Replace the inline `buildCommitMessage` implementation (lines 158-188) with a call to the pure function:
     ```typescript
     buildCommitMessage: () => {
       const { commitType, scope, description, body, isBreaking, breakingDescription } = get();
       return buildMessage({ commitType, scope, description, body, isBreaking, breakingDescription });
     },
     ```

2. **Add new state fields to `ConventionalState` interface:**
   - `isAmend: boolean` -- whether amend mode is active
   - `setIsAmend: (amend: boolean) => void`
   - `pushAfterCommit: boolean` -- user preference for commit+push workflow
   - `setPushAfterCommit: (push: boolean) => void`
   - `activeTemplate: CommitTemplate | null` -- currently applied template (import type from future `commit-templates.ts`, use inline type for now: `{ id: string; label: string; description: string; icon?: string; fields: { commitType: CommitType; scope?: string; description: string; body?: string; isBreaking?: boolean; breakingDescription?: string; } } | null`)
   - `setActiveTemplate: (template: ConventionalState["activeTemplate"]) => void`
   - `applyTemplate: (template: NonNullable<ConventionalState["activeTemplate"]>) => void` -- sets all form fields from `template.fields` and sets `activeTemplate`
   - `scopeFrequencies: ScopeSuggestion[]` -- scope usage frequency data (reuse existing `ScopeSuggestion` type)
   - `fetchScopeFrequencies: () => Promise<void>` -- fetches with `getScopeSuggestions(50)` (higher limit than current 20)

3. **Add initial values:**
   - `isAmend: false`, `pushAfterCommit: false`, `activeTemplate: null`, `scopeFrequencies: []`

4. **Add setters:**
   - `setIsAmend: (amend) => set({ isAmend: amend })`
   - `setPushAfterCommit: (push) => set({ pushAfterCommit: push })`
   - `setActiveTemplate: (template) => set({ activeTemplate: template })`
   - `applyTemplate: (template) => set({ commitType: template.fields.commitType, scope: template.fields.scope || "", description: template.fields.description, body: template.fields.body || "", isBreaking: template.fields.isBreaking || false, breakingDescription: template.fields.breakingDescription || "", activeTemplate: template })`
   - `fetchScopeFrequencies: async () => { try { const result = await commands.getScopeSuggestions(50); if (result.status === "ok") { set({ scopeFrequencies: result.data }); } } catch (e) { console.error("Failed to fetch scope frequencies:", e); } }`

5. **Update `reset()`:** Also reset `isAmend: false`, `pushAfterCommit` stays (user preference persists), `activeTemplate: null`. Do NOT reset `scopeFrequencies` (cached data).
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors (ignore pre-existing bindings.ts TS2440). The store still exports all existing functions.</verify>
  <done>Store delegates `buildCommitMessage` to pure function, new amend/push/template/frequency state fields are present with setters, `reset()` clears form but preserves preferences.</done>
</task>

<task type="auto">
  <name>Task 3: Unify conventional commit parser across codebase</name>
  <files>src/components/topology/layoutUtils.ts, src/components/icons/CommitTypeIcon.tsx</files>
  <action>
1. **Modify `src/components/topology/layoutUtils.ts`:**
   - Add import: `import { parseConventionalMessage } from "../../lib/conventional-utils";`
   - Replace the `parseConventionalType` function (line 182-187) with a thin wrapper that delegates to the new parser:
     ```typescript
     export function parseConventionalType(message: string): string | null {
       const parsed = parseConventionalMessage(message);
       return parsed ? parsed.commitType : null;
     }
     ```
   - This preserves the existing API (`parseConventionalType` still returns `string | null`) while eliminating the duplicate regex.

2. **Check `src/components/icons/CommitTypeIcon.tsx`:**
   - Read the file first. If it has its own conventional commit parsing regex, replace it with an import from `conventional-utils.ts`. If it already imports from `layoutUtils.ts` or `conventional.ts`, leave it as-is.
   - The goal is zero duplicate CC parsing logic -- all roads lead to `parseConventionalMessage`.

3. **Verify no other files have duplicate CC parsing:**
   - Grep for the regex pattern `feat|fix|docs.*:` in `.tsx?` files to find any remaining duplicates. If found, update them to import from `conventional-utils.ts`.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Grep for the old inline regex pattern in layoutUtils.ts -- it should be gone, replaced by the import.</verify>
  <done>Single source of truth for CC parsing in `conventional-utils.ts`. `layoutUtils.ts` delegates to it. No duplicate parsing regexes remain in the codebase.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/lib/conventional-utils.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- no new type errors
3. Existing sidebar commit flow is unaffected (store API unchanged)
4. `grep -r "parseConventionalType" src/` shows only `layoutUtils.ts` defining it (now as a wrapper)
</verification>

<success_criteria>
- Pure utility functions exist in `src/lib/conventional-utils.ts` with full test coverage
- Zustand store delegates to pure function instead of inline implementation
- Store extended with amend, push, template, and frequency state
- No duplicate CC parsing logic in the codebase
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/28-conventional-commit-blade/28-01-SUMMARY.md`
</output>
