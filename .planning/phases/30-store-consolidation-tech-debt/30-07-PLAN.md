---
phase: 30-store-consolidation-tech-debt
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/domain/ui-state/ui-state.test.ts
  - src/stores/domain/preferences/preferences.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "UI State store composes staging and command-palette slices with correct initial state"
    - "UI State store is registered for reset (resets on repo close)"
    - "Preferences store composes all 5 slices with correct initial state"
    - "Preferences store is NOT registered for reset (survives repo switches)"
    - "Preference slices load and save settings via persistent store"
  artifacts:
    - path: "src/stores/domain/ui-state/ui-state.test.ts"
      provides: "Tests for UI State domain store (staging + command palette slices)"
      min_lines: 60
    - path: "src/stores/domain/preferences/preferences.test.ts"
      provides: "Tests for Preferences domain store (5 slices)"
      min_lines: 80
  key_links:
    - from: "src/stores/domain/ui-state/ui-state.test.ts"
      to: "src/stores/domain/ui-state/index.ts"
      via: "import { useUIStore }"
      pattern: "useUIStore"
    - from: "src/stores/domain/preferences/preferences.test.ts"
      to: "src/stores/domain/preferences/index.ts"
      via: "import { usePreferencesStore }"
      pattern: "usePreferencesStore"
---

<objective>
Add unit tests for UI State and Preferences domain stores.

Purpose: UAT Test 8 requires test coverage for the 20 new files created during Phase 30 store consolidation. This plan covers the UI State store (staging + command palette slices) and the Preferences store (settings, theme, navigation, branch-metadata, review-checklist slices).

Output: Two test files covering all remaining domain store slices.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/30-store-consolidation-tech-debt/30-04-SUMMARY.md

@src/stores/domain/ui-state/index.ts
@src/stores/domain/ui-state/staging.slice.ts
@src/stores/domain/ui-state/command-palette.slice.ts
@src/stores/domain/preferences/index.ts
@src/stores/domain/preferences/settings.slice.ts
@src/stores/domain/preferences/theme.slice.ts
@src/stores/domain/preferences/navigation.slice.ts
@src/stores/domain/preferences/branch-metadata.slice.ts
@src/stores/domain/preferences/review-checklist.slice.ts
@src/stores/toast.test.ts
@src/stores/repository.test.ts
@src/test-utils/mocks/tauri-commands.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test UI State domain store (staging + command palette)</name>
  <files>src/stores/domain/ui-state/ui-state.test.ts</files>
  <action>
    Create `src/stores/domain/ui-state/ui-state.test.ts`:

    Import `useUIStore` from `./index`.
    No external mocks needed -- staging and command-palette slices are pure state (no Tauri commands or async I/O).

    Test groups and cases:

    **describe("UI State store composition")**:
    1. "has all slice state keys" -- assert getState() has: `stagingSelectedFile`, `stagingSelectedSection`, `stagingViewMode`, `stagingScrollPositions`, `stagingFileListScrollTop`, `paletteIsOpen`, `paletteQuery`, `paletteSelectedIndex`.
    2. "has correct initial state" -- assert stagingSelectedFile is null, stagingViewMode is "tree", paletteIsOpen is false, paletteQuery is "", paletteSelectedIndex is 0.

    **describe("staging slice")**:
    3. "selectFile sets selected file and section" -- create a mock FileChange object `{ path: "test.ts", status: "modified", additions: 1, deletions: 0 }`, call selectFile(file, "unstaged"), assert both stagingSelectedFile and stagingSelectedSection are set.
    4. "selectFile clears section when not provided" -- call selectFile(null), assert both are null.
    5. "setStagingViewMode toggles between tree and flat" -- call setStagingViewMode("flat"), assert stagingViewMode is "flat".
    6. "saveStagingScrollPosition persists scroll position per file" -- call saveStagingScrollPosition("src/main.ts", 150), assert stagingScrollPositions["src/main.ts"] is 150.
    7. "clearStagingScrollPositions resets all positions" -- save a position, call clearStagingScrollPositions(), assert empty object and stagingFileListScrollTop is 0.

    **describe("command palette slice")**:
    8. "openPalette sets paletteIsOpen and resets query" -- call openPalette(), assert paletteIsOpen is true, paletteQuery is "".
    9. "closePalette resets all palette state" -- openPalette, then closePalette, assert paletteIsOpen false and query/index reset.
    10. "togglePalette flips paletteIsOpen" -- togglePalette() from false -> true, togglePalette() again -> false.
    11. "setPaletteQuery sets query and resets selectedIndex" -- openPalette, setPaletteSelectedIndex(3), setPaletteQuery("test"), assert query is "test" and selectedIndex is 0.
    12. "setPaletteSelectedIndex sets index" -- call setPaletteSelectedIndex(5), assert paletteSelectedIndex is 5.

    **describe("reset behavior")**:
    13. "resets between tests (auto-reset verification)" -- assert all state is initial (verifies Zustand auto-reset mock works for this store).
  </action>
  <verify>
    - `npm test -- --run src/stores/domain/ui-state/ui-state.test.ts` passes all ~13 tests
    - `npx tsc --noEmit` passes
  </verify>
  <done>ui-state.test.ts has 13 passing tests covering staging slice, command palette slice, composition, and auto-reset.</done>
</task>

<task type="auto">
  <name>Task 2: Test Preferences domain store (5 slices)</name>
  <files>src/stores/domain/preferences/preferences.test.ts</files>
  <action>
    Create `src/stores/domain/preferences/preferences.test.ts`:

    Mock the persistent store (`src/lib/store.ts`):
    ```typescript
    const mockStoreData = vi.hoisted(() => new Map<string, unknown>());
    const mockStore = vi.hoisted(() => ({
      get: vi.fn((key: string) => Promise.resolve(mockStoreData.get(key) ?? null)),
      set: vi.fn((key: string, value: unknown) => { mockStoreData.set(key, value); return Promise.resolve(); }),
      save: vi.fn(() => Promise.resolve()),
    }));
    vi.mock("../../../lib/store", () => ({
      getStore: vi.fn(() => Promise.resolve(mockStore)),
    }));
    ```

    Mock toast for review-checklist slice error handling:
    ```typescript
    vi.mock("../../toast", () => ({
      toast: { error: vi.fn(), warning: vi.fn(), success: vi.fn(), info: vi.fn() },
    }));
    ```

    Import `usePreferencesStore` from `./index`.
    Import `resetAllStores` from `../../registry`.

    In beforeEach: `vi.clearAllMocks(); mockStoreData.clear();`

    Test groups and cases:

    **describe("Preferences store composition")**:
    1. "has all slice state keys" -- assert getState() has representative keys: `settingsActiveCategory`, `settingsData`, `themePreference`, `themeResolved`, `navRepoDropdownOpen`, `navPinnedRepoPaths`, `metaPinnedBranches`, `checklistCustomItems`.
    2. "has correct initial defaults" -- assert settingsData.general.defaultTab is "changes", themePreference is "system", navRepoDropdownOpen is false, navPinnedRepoPaths is [], checklistCustomItems has feature/release/hotfix keys.

    **describe("settings slice")**:
    3. "setSettingsCategory changes active category" -- call setSettingsCategory("git"), assert settingsActiveCategory is "git".
    4. "initSettings loads and merges saved settings" -- put partial settings in mockStoreData: `mockStoreData.set("settings", { general: { defaultTab: "topology" } })`, call initSettings(), assert settingsData.general.defaultTab is "topology" and other defaults preserved (git.defaultRemote is "origin").
    5. "updateSetting persists to store and updates state" -- call updateSetting("general", "defaultTab", "history"), assert mockStore.set was called with "settings" key and state reflects the change.

    **describe("theme slice")**:
    6. "initTheme defaults to system/mocha" -- call initTheme() with no saved data, assert themePreference is "system". Note: `resolveTheme("system")` calls `window.matchMedia` -- jsdom defaults to not matching dark mode, so themeResolved will be "latte". Assert themeIsLoading is false after init.
    7. "setTheme persists and updates state" -- call setTheme("dark"), assert themePreference is "dark", themeResolved is "mocha", mockStore.set was called.

    **describe("navigation slice")**:
    8. "toggleNavRepoDropdown toggles and closes branch dropdown" -- call toggleNavRepoDropdown(), assert navRepoDropdownOpen is true and navBranchDropdownOpen is false.
    9. "pinRepo adds to navPinnedRepoPaths and persists" -- call pinRepo("/test/repo"), assert navPinnedRepoPaths includes "/test/repo", mockStore.set was called with "nav-pinned-repos".
    10. "unpinRepo removes from navPinnedRepoPaths" -- pinRepo first, then unpinRepo, assert empty.
    11. "pinRepo is idempotent" -- call pinRepo("/test/repo") twice, assert navPinnedRepoPaths has length 1.
    12. "addNavRecentBranch caps at MAX_RECENT_BRANCHES (3)" -- add 4 branches for same repo, assert only the last 3 are kept with the newest first.

    **describe("branch-metadata slice")**:
    13. "pinBranch adds branch for repo" -- call pinBranch("/repo", "feature/a"), assert metaPinnedBranches["/repo"] includes "feature/a".
    14. "isBranchPinned returns correct boolean" -- pin a branch, assert isBranchPinned returns true. Assert false for unregistered branch.
    15. "recordBranchVisit adds entry with timestamp" -- call recordBranchVisit("/repo", "main"), assert metaRecentBranches["/repo"] has an entry with name "main" and a lastVisited timestamp.
    16. "getMetaScopePreference defaults to 'local'" -- call getMetaScopePreference("/repo"), assert returns "local".

    **describe("review-checklist slice")**:
    17. "getChecklistItems returns defaults for flow type" -- call getChecklistItems("feature"), assert returns 3 items matching DEFAULT_CHECKLIST.feature.
    18. "updateChecklistItems persists custom items" -- call updateChecklistItems("feature", [{ id: "custom1", label: "Custom check" }]), assert mockStore.set was called and state updated.
    19. "resetChecklistToDefaults restores default items" -- update items first, then resetChecklistToDefaults("feature"), assert items match DEFAULT_CHECKLIST.feature.
    20. "initChecklist loads saved items from store" -- put custom checklist data in mockStoreData, call initChecklist(), assert checklistCustomItems reflects saved data.

    **describe("reset behavior")**:
    21. "preferences store is NOT registered for reset" -- mutate some preferences state, call resetAllStores(), assert preferences state is STILL mutated (not reset). This verifies the deliberate design choice that preferences survive repo switches.
  </action>
  <verify>
    - `npm test -- --run src/stores/domain/preferences/preferences.test.ts` passes all ~21 tests
    - `npx tsc --noEmit` passes
  </verify>
  <done>preferences.test.ts has 21 passing tests covering all 5 preference slices (settings, theme, navigation, branch-metadata, review-checklist), persistence behavior, and non-reset verification.</done>
</task>

</tasks>

<verification>
- `npm test -- --run` passes all tests (82 existing + ~34 from this plan + tests from plan 06)
- `npx tsc --noEmit` produces zero new errors
- Two new test files exist covering all UI State and Preferences domain store slices
</verification>

<success_criteria>
- UI State store (staging + command palette) has comprehensive test coverage
- Preferences store (5 slices) has test coverage for state, persistence, and deliberate non-reset behavior
- All test patterns are consistent with existing repository.test.ts and toast.test.ts
- All new and existing tests pass
- UAT Test 8 gap is resolved (combined with plan 30-06)
</success_criteria>

<output>
After completion, create `.planning/phases/30-store-consolidation-tech-debt/30-07-SUMMARY.md`
</output>
