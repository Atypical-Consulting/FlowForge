---
phase: 30-store-consolidation-tech-debt
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/registry.test.ts
  - src/stores/createBladeStore.test.ts
  - src/stores/domain/git-ops/git-ops.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "resetAllStores() resets all registered stores to initial state"
    - "registerStoreForReset() registers a store that gets reset on resetAllStores()"
    - "createBladeStore() creates a store that is auto-registered for reset"
    - "GitOps domain store composes all 9 slices with correct initial state"
    - "GitOps slices set loading/error state correctly on success and failure"
  artifacts:
    - path: "src/stores/registry.test.ts"
      provides: "Tests for resetAllStores and registerStoreForReset"
      min_lines: 30
    - path: "src/stores/createBladeStore.test.ts"
      provides: "Tests for blade store factory with auto-reset"
      min_lines: 25
    - path: "src/stores/domain/git-ops/git-ops.test.ts"
      provides: "Tests for GitOps domain store composition and slice behavior"
      min_lines: 100
  key_links:
    - from: "src/stores/registry.test.ts"
      to: "src/stores/registry.ts"
      via: "import { resetAllStores, registerStoreForReset }"
      pattern: "registerStoreForReset|resetAllStores"
    - from: "src/stores/createBladeStore.test.ts"
      to: "src/stores/createBladeStore.ts"
      via: "import { createBladeStore }"
      pattern: "createBladeStore"
    - from: "src/stores/domain/git-ops/git-ops.test.ts"
      to: "src/stores/domain/git-ops/index.ts"
      via: "import { useGitOpsStore }"
      pattern: "useGitOpsStore"
---

<objective>
Add unit tests for store infrastructure (registry, factory) and GitOps domain store slices.

Purpose: UAT Test 8 requires test coverage for the 20 new files created during Phase 30 store consolidation. This plan covers the foundation (registry + factory) and the largest domain store (GitOps with 9 slices).

Output: Three test files covering store infrastructure and GitOps domain store behavior.
</objective>

<execution_context>
@/Users/phmatray/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phmatray/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/30-store-consolidation-tech-debt/30-03-SUMMARY.md
@.planning/phases/30-store-consolidation-tech-debt/30-04-SUMMARY.md

@src/stores/registry.ts
@src/stores/createBladeStore.ts
@src/stores/domain/git-ops/index.ts
@src/stores/domain/git-ops/types.ts
@src/stores/repository.test.ts
@src/stores/toast.test.ts
@src/test-utils/mocks/tauri-commands.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test registry and blade store factory</name>
  <files>src/stores/registry.test.ts, src/stores/createBladeStore.test.ts</files>
  <action>
    Create `src/stores/registry.test.ts`:
    - Import `resetAllStores`, `registerStoreForReset` from `./registry`
    - Import `create` from `zustand` to create test stores
    - Test cases:
      1. "resetAllStores resets a registered store to initial state" -- create a simple store with `{ count: 0, increment: () => ... }`, register it, mutate count to 5, call resetAllStores(), assert count is 0.
      2. "resetAllStores resets multiple registered stores" -- create two stores, register both, mutate both, reset, assert both are at initial state.
      3. "unregistered stores are not affected by resetAllStores" -- create a store but do NOT register it, mutate it, call resetAllStores(), assert it still has the mutated value.
      4. "resetAllStores can be called multiple times safely" -- register a store, call resetAllStores() twice in a row, no errors, state is initial.

    Create `src/stores/createBladeStore.test.ts`:
    - Import `createBladeStore` from `./createBladeStore`
    - Import `resetAllStores` from `./registry`
    - Test cases:
      1. "creates a store with initial state" -- use createBladeStore("test-blade", (set) => ({ value: "hello", setValue: (v: string) => set({ value: v }) })), assert getState().value === "hello".
      2. "auto-registers for reset" -- create blade store, mutate value, call resetAllStores(), assert value is back to initial.
      3. "store actions work correctly" -- create blade store with an action, call action, verify state change.

    Follow existing test patterns from `repository.test.ts` and `toast.test.ts` -- no need for bindings mocks since registry/factory are pure Zustand.

    IMPORTANT: The Zustand auto-reset mock at `__mocks__/zustand.ts` intercepts `create()` and auto-resets between tests. For `registry.test.ts`, the stores created inside tests will be auto-reset, but the `storeResetFns` Set in registry.ts is a module-level singleton and persists across tests. Keep this in mind -- each test should register its own stores and not depend on registrations from other tests. The `resetAllStores` function resets store STATE but does not clear the registered set.
  </action>
  <verify>
    - `npm test -- --run src/stores/registry.test.ts src/stores/createBladeStore.test.ts` passes all tests
    - `npx tsc --noEmit` passes
  </verify>
  <done>registry.test.ts has 4 passing tests. createBladeStore.test.ts has 3 passing tests. Both cover core reset and registration behavior.</done>
</task>

<task type="auto">
  <name>Task 2: Test GitOps domain store composition and representative slices</name>
  <files>src/stores/domain/git-ops/git-ops.test.ts</files>
  <action>
    Create `src/stores/domain/git-ops/git-ops.test.ts`:

    Mock setup (follow repository.test.ts pattern):
    ```typescript
    const mockCommands = vi.hoisted(() => ({
      listBranches: vi.fn(),
      listAllBranches: vi.fn(),
      createBranch: vi.fn(),
      checkoutBranch: vi.fn(),
      checkoutRemoteBranch: vi.fn(),
      deleteBranch: vi.fn(),
      mergeBranch: vi.fn(),
      abortMerge: vi.fn(),
      listTags: vi.fn(),
      deleteTag: vi.fn(),
      listStashes: vi.fn(),
      stashSave: vi.fn(),
      stashApply: vi.fn(),
      stashPop: vi.fn(),
      stashDrop: vi.fn(),
      openRepository: vi.fn(),
      getRepositoryStatus: vi.fn(),
      closeRepository: vi.fn(),
      listWorktrees: vi.fn(),
      createWorktree: vi.fn(),
      deleteWorktree: vi.fn(),
      getGitflowStatus: vi.fn(),
      initGitflow: vi.fn(),
      startFeature: vi.fn(),
      finishFeature: vi.fn(),
      startRelease: vi.fn(),
      finishRelease: vi.fn(),
      startHotfix: vi.fn(),
      finishHotfix: vi.fn(),
      abortGitflow: vi.fn(),
      getUndoInfo: vi.fn(),
      undoLastOperation: vi.fn(),
      getCommitGraph: vi.fn(),
      cloneRepository: vi.fn(),
    }));
    vi.mock("../../../bindings", () => ({ commands: mockCommands }));
    ```

    Also mock the navigation actor and toast to prevent side effects:
    ```typescript
    vi.mock("../../../machines/navigation/context", () => ({
      getNavigationActor: () => ({ send: vi.fn() }),
    }));
    vi.mock("../../toast", () => ({
      toast: { error: vi.fn(), success: vi.fn(), info: vi.fn(), warning: vi.fn() },
    }));
    vi.mock("../../registry", async (importOriginal) => {
      const actual = await importOriginal<typeof import("../../registry")>();
      return { ...actual };
    });
    ```

    Import `ok`, `err`, and factory functions from `../../../test-utils/mocks/tauri-commands`.
    Import `useGitOpsStore` from `./index`.

    Test groups and cases:

    **describe("GitOps store composition")**:
    1. "has all slice state keys in initial state" -- assert useGitOpsStore.getState() contains representative keys from each slice: `repoStatus`, `branchList`, `tagList`, `stashList`, `worktreeList`, `gitflowStatus`, `undoInfo`, `nodes`, `cloneIsCloning`.
    2. "all initial state values are defaults" -- assert repoStatus is null, branchList is [], tagList is [], etc.

    **describe("branches slice")**:
    3. "loadBranches sets branchList on success" -- mock listBranches to return ok([createBranchInfo()]), call loadBranches(), assert branchList has one entry and branchIsLoading is false.
    4. "loadBranches sets error on failure" -- mock listBranches to return err({ type: "NotARepository", message: "Error" }), call loadBranches(), assert branchError is set and branchIsLoading is false.
    5. "createBranch returns branch info on success" -- mock createBranch to return ok(createBranchInfo({ name: "feature/test" })), mock listBranches for the reload, call createBranch("feature/test", true), assert result is not null.

    **describe("tags slice")**:
    6. "loadTags sets tagList on success" -- mock listTags to return ok([createTagInfo()]), call loadTags(), assert tagList has one entry.
    7. "loadTags sets error on failure" -- mock listTags to return err, call loadTags(), assert tagError is set.
    8. "clearTagError resets error to null" -- set error via failed load, call clearTagError(), assert tagError is null.

    **describe("stash slice")**:
    9. "loadStashes sets stashList on success" -- mock listStashes ok, assert stashList populated.
    10. "saveStash returns true on success" -- mock stashSave ok and listStashes ok, call saveStash("msg", false), assert returns true.
    11. "saveStash returns false and sets error on failure" -- mock stashSave err, call saveStash, assert returns false and stashError set.

    **describe("clone slice")**:
    12. "startClone sets isCloning" -- call startClone(), assert cloneIsCloning is true.
    13. "updateCloneProgress sets progress" -- call updateCloneProgress({ ... }), assert cloneProgress updated.
    14. "resetClone clears all clone state" -- startClone, then resetClone, assert all clone state is initial.

    **describe("topology slice")**:
    15. "selectCommit sets topologySelectedCommit" -- call selectCommit("abc123"), assert value.
    16. "resetTopology clears all topology state" -- set some topology state, call resetTopology(), assert all defaults.

    In beforeEach, call `vi.clearAllMocks()` and set default mock resolved values using `ok()` helpers from test-utils.
  </action>
  <verify>
    - `npm test -- --run src/stores/domain/git-ops/git-ops.test.ts` passes all ~16 tests
    - `npx tsc --noEmit` passes
  </verify>
  <done>git-ops.test.ts has 16 passing tests covering store composition and representative behavior from branches, tags, stash, clone, and topology slices.</done>
</task>

</tasks>

<verification>
- `npm test -- --run` passes all tests (82 existing + ~23 new = ~105 total)
- `npx tsc --noEmit` produces zero new errors
- Three new test files exist and cover the store infrastructure and GitOps domain
</verification>

<success_criteria>
- registry.ts has test coverage for resetAllStores and registerStoreForReset
- createBladeStore.ts has test coverage for factory and auto-reset behavior
- GitOps domain store has test coverage for composition, initial state, and representative CRUD patterns
- All new and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/30-store-consolidation-tech-debt/30-06-SUMMARY.md`
</output>
