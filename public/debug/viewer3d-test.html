<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FlowForge 3D Viewer Debug Page</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #1e1e2e;
      color: #cdd6f4;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .header {
      background: #181825;
      padding: 12px 16px;
      border-bottom: 1px solid #313244;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
    }
    .header h1 { font-size: 14px; font-weight: 600; }
    .header .status {
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 4px;
      background: #313244;
    }
    .header .status.pass { background: #a6e3a1; color: #1e1e2e; }
    .header .status.fail { background: #f38ba8; color: #1e1e2e; }
    .header .status.pending { background: #fab387; color: #1e1e2e; }
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    .panel-left {
      width: 400px;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      border-right: 1px solid #313244;
      overflow: hidden;
    }
    .panel-right {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .section {
      padding: 12px 16px;
      border-bottom: 1px solid #313244;
    }
    .section h2 {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #a6adc8;
      margin-bottom: 8px;
    }
    .controls { display: flex; flex-direction: column; gap: 8px; }
    button {
      padding: 8px 16px;
      background: #89b4fa;
      color: #1e1e2e;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { background: #74c7ec; }
    button:disabled { background: #585b70; cursor: not-allowed; }
    button.secondary {
      background: #313244;
      color: #cdd6f4;
    }
    button.secondary:hover { background: #45475a; }
    input[type="file"] {
      font-size: 12px;
      color: #a6adc8;
    }
    input[type="file"]::file-selector-button {
      padding: 6px 12px;
      background: #313244;
      color: #cdd6f4;
      border: 1px solid #45475a;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 8px;
    }
    .log-container {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 11px;
      line-height: 1.6;
      background: #11111b;
    }
    .log-entry {
      padding: 2px 8px;
      border-radius: 3px;
    }
    .log-entry.info { color: #89b4fa; }
    .log-entry.success { color: #a6e3a1; }
    .log-entry.error { color: #f38ba8; }
    .log-entry.warn { color: #fab387; }
    .log-entry.data { color: #cba6f7; }
    .log-entry.step { color: #f9e2af; font-weight: 600; }
    .canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: #1e1e2e;
      z-index: 10;
      transition: opacity 0.3s;
    }
    .overlay.hidden { opacity: 0; pointer-events: none; }
    .overlay p { font-size: 13px; color: #a6adc8; }
    .test-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }
    .test-item {
      font-size: 11px;
      padding: 4px 8px;
      background: #181825;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .test-item .label { color: #a6adc8; }
    .test-item .value { font-weight: 500; }
    .test-item .value.ok { color: #a6e3a1; }
    .test-item .value.fail { color: #f38ba8; }
    .test-item .value.unknown { color: #585b70; }
    #base64-input {
      width: 100%;
      padding: 6px 8px;
      background: #181825;
      border: 1px solid #313244;
      border-radius: 4px;
      color: #cdd6f4;
      font-family: monospace;
      font-size: 11px;
      resize: vertical;
      min-height: 60px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>FlowForge 3D Viewer Debug</h1>
    <span id="overall-status" class="status pending">Pending</span>
    <span style="flex:1"></span>
    <button class="secondary" onclick="clearLog()">Clear Log</button>
    <button class="secondary" onclick="runAllTests()">Run All Tests</button>
  </div>

  <div class="main">
    <div class="panel-left">
      <!-- Environment Tests -->
      <div class="section">
        <h2>Environment Checks</h2>
        <div class="test-grid" id="env-tests">
          <div class="test-item">
            <span class="label">WebGL 2</span>
            <span id="test-webgl2" class="value unknown">--</span>
          </div>
          <div class="test-item">
            <span class="label">WebGL 1</span>
            <span id="test-webgl1" class="value unknown">--</span>
          </div>
          <div class="test-item">
            <span class="label">ArrayBuffer</span>
            <span id="test-arraybuffer" class="value unknown">--</span>
          </div>
          <div class="test-item">
            <span class="label">TextDecoder</span>
            <span id="test-textdecoder" class="value unknown">--</span>
          </div>
          <div class="test-item">
            <span class="label">atob()</span>
            <span id="test-atob" class="value unknown">--</span>
          </div>
          <div class="test-item">
            <span class="label">Uint8Array</span>
            <span id="test-uint8array" class="value unknown">--</span>
          </div>
          <div class="test-item">
            <span class="label">THREE.js</span>
            <span id="test-threejs" class="value unknown">--</span>
          </div>
          <div class="test-item">
            <span class="label">GLTFLoader</span>
            <span id="test-gltfloader" class="value unknown">--</span>
          </div>
        </div>
      </div>

      <!-- File Input -->
      <div class="section">
        <h2>Load GLB/GLTF File</h2>
        <div class="controls">
          <input type="file" id="file-input" accept=".glb,.gltf" />
          <button id="btn-load-file" onclick="loadFromFile()" disabled>
            Test: Direct File Load
          </button>
        </div>
      </div>

      <!-- Base64 Test -->
      <div class="section">
        <h2>Test Base64 Pipeline (simulates Tauri)</h2>
        <div class="controls">
          <textarea id="base64-input" placeholder="Paste base64-encoded GLB data here, or use 'Load File as Base64' button below..."></textarea>
          <button id="btn-load-base64" onclick="loadFromBase64()" disabled>
            Test: Base64 Decode + Parse
          </button>
          <button id="btn-file-to-base64" onclick="fileToBase64()" disabled>
            Load File as Base64 (round-trip test)
          </button>
        </div>
      </div>

      <!-- Sample Model -->
      <div class="section">
        <h2>Quick Test</h2>
        <div class="controls">
          <button onclick="loadSampleCube()">
            Test: Procedural Cube (no file needed)
          </button>
          <button onclick="fetchSampleModel()">
            Test: Fetch BoxAnimated.glb from GitHub
          </button>
        </div>
      </div>

      <!-- Log -->
      <div style="flex:1;display:flex;flex-direction:column;overflow:hidden">
        <div class="section" style="padding-bottom:4px">
          <h2>Debug Log</h2>
        </div>
        <div class="log-container" id="log-container"></div>
      </div>
    </div>

    <div class="panel-right">
      <div class="canvas-container" id="canvas-container">
        <canvas id="render-canvas"></canvas>
        <div class="overlay" id="canvas-overlay">
          <p>Load a .glb/.gltf file to test rendering</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Three.js from CDN (same version as FlowForge) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/loaders/GLTFLoader.js",
      "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // Make available globally for onclick handlers
    window.THREE = THREE;
    window.GLTFLoader = GLTFLoader;
    window.OrbitControls = OrbitControls;

    // ---- Logging ----
    const logContainer = document.getElementById('log-container');

    function log(msg, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      const time = new Date().toISOString().slice(11, 23);
      entry.textContent = `[${time}] ${msg}`;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
      // Also log to real console
      if (type === 'error') console.error(msg);
      else if (type === 'warn') console.warn(msg);
      else console.log(msg);
    }
    window.log = log;

    function clearLog() {
      logContainer.innerHTML = '';
    }
    window.clearLog = clearLog;

    // ---- Scene State ----
    let sceneState = null;

    function disposeScene() {
      if (!sceneState) return;
      log('Disposing previous scene...', 'info');
      cancelAnimationFrame(sceneState.animFrameId);
      sceneState.resizeObserver.disconnect();
      sceneState.controls.dispose();
      sceneState.scene.traverse((object) => {
        if (object instanceof THREE.Mesh) {
          if (object.geometry) object.geometry.dispose();
          if (object.material) {
            const materials = Array.isArray(object.material) ? object.material : [object.material];
            for (const mat of materials) {
              for (const val of Object.values(mat)) {
                if (val instanceof THREE.Texture) val.dispose();
              }
              mat.dispose();
            }
          }
        }
      });
      sceneState.renderer.dispose();
      sceneState = null;
    }

    function setupScene() {
      log('--- STEP: Setting up Three.js scene ---', 'step');
      disposeScene();

      const canvas = document.getElementById('render-canvas');
      const container = document.getElementById('canvas-container');

      // Create renderer
      log('Creating WebGLRenderer...', 'info');
      let renderer;
      try {
        renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          alpha: true,
        });
        log(`WebGLRenderer created OK (context: ${renderer.getContext().constructor.name})`, 'success');
      } catch (e) {
        log(`WebGLRenderer FAILED: ${e.message}`, 'error');
        return null;
      }

      renderer.setPixelRatio(window.devicePixelRatio);
      const rect = container.getBoundingClientRect();
      log(`Container dimensions: ${rect.width}x${rect.height}`, 'data');
      renderer.setSize(rect.width, rect.height);

      if (rect.width === 0 || rect.height === 0) {
        log('WARNING: Container has zero dimensions!', 'warn');
      }

      // Camera
      const aspect = rect.width / rect.height || 1;
      const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
      camera.position.set(0, 1, 3);

      // Scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1e1e2e);

      // Controls
      const controls = new OrbitControls(camera, canvas);
      controls.enableDamping = true;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight1.position.set(5, 10, 7.5);
      scene.add(dirLight1);
      const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
      dirLight2.position.set(-5, 5, -5);
      scene.add(dirLight2);

      // Animation
      let animFrameId = 0;
      const animate = () => {
        animFrameId = requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      };
      animate();

      // Resize
      const resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const { width, height } = entry.contentRect;
          if (width === 0 || height === 0) continue;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }
      });
      resizeObserver.observe(container);

      sceneState = { renderer, scene, camera, controls, animFrameId, resizeObserver };
      log('Scene setup complete', 'success');
      return sceneState;
    }

    function addModelToScene(gltf) {
      if (!sceneState) return;
      const { scene, camera, controls } = sceneState;

      // Center and scale (exact same logic as Viewer3dBlade)
      const box = new THREE.Box3().setFromObject(gltf.scene);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = maxDim > 0 ? 2 / maxDim : 1;
      gltf.scene.scale.multiplyScalar(scale);
      gltf.scene.position.sub(center.multiplyScalar(scale));
      scene.add(gltf.scene);

      camera.position.set(0, 1, 3);
      controls.target.set(0, 0, 0);
      controls.update();

      log(`Model dimensions: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'data');
      log(`Applied scale: ${scale.toFixed(4)}`, 'data');

      // Count meshes
      let meshCount = 0;
      gltf.scene.traverse((obj) => { if (obj instanceof THREE.Mesh) meshCount++; });
      log(`Model contains ${meshCount} mesh(es)`, 'data');

      // Hide overlay
      document.getElementById('canvas-overlay').classList.add('hidden');
      setStatus('pass', 'Rendered');
    }

    function parseArrayBuffer(arrayBuffer, label) {
      log(`--- STEP: Parsing ArrayBuffer (${label}) ---`, 'step');
      log(`ArrayBuffer byteLength: ${arrayBuffer.byteLength}`, 'data');
      log(`instanceof ArrayBuffer: ${arrayBuffer instanceof ArrayBuffer}`, 'data');

      if (arrayBuffer.byteLength === 0) {
        log('ERROR: ArrayBuffer is empty (0 bytes)', 'error');
        setStatus('fail', 'Empty buffer');
        return;
      }

      // Check GLB magic header
      const headerView = new Uint8Array(arrayBuffer, 0, Math.min(4, arrayBuffer.byteLength));
      const headerHex = Array.from(headerView).map(b => b.toString(16).padStart(2, '0')).join(' ');
      log(`First 4 bytes (hex): ${headerHex}`, 'data');

      const magic = new TextDecoder().decode(headerView);
      if (magic === 'glTF') {
        log('GLB magic header detected: "glTF" (binary format)', 'success');
      } else {
        log(`No GLB magic header (got "${magic}"), treating as GLTF JSON`, 'warn');
      }

      const state = setupScene();
      if (!state) {
        setStatus('fail', 'Scene setup failed');
        return;
      }

      log('Calling GLTFLoader.parse()...', 'info');
      const loader = new GLTFLoader();
      try {
        loader.parse(
          arrayBuffer,
          '',
          (gltf) => {
            log('GLTFLoader.parse() onLoad callback fired!', 'success');
            log(`  scenes: ${gltf.scenes?.length || 0}`, 'data');
            log(`  animations: ${gltf.animations?.length || 0}`, 'data');
            log(`  cameras: ${gltf.cameras?.length || 0}`, 'data');
            addModelToScene(gltf);
          },
          (error) => {
            log(`GLTFLoader.parse() onError callback: ${error?.message || error}`, 'error');
            if (error?.stack) log(`Stack: ${error.stack}`, 'error');
            setStatus('fail', 'Parse error');
          }
        );
      } catch (syncError) {
        log(`GLTFLoader.parse() SYNC THROW: ${syncError?.message || syncError}`, 'error');
        if (syncError?.stack) log(`Stack: ${syncError.stack}`, 'error');
        setStatus('fail', 'Sync parse error');
      }
    }
    window.parseArrayBuffer = parseArrayBuffer;

    // ---- Test: Load from file ----
    const fileInput = document.getElementById('file-input');
    fileInput.addEventListener('change', () => {
      document.getElementById('btn-load-file').disabled = !fileInput.files.length;
      document.getElementById('btn-file-to-base64').disabled = !fileInput.files.length;
    });

    function loadFromFile() {
      const file = fileInput.files[0];
      if (!file) return;
      log(`--- STEP: Loading file directly ---`, 'step');
      log(`File: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`, 'data');
      setStatus('pending', 'Loading...');

      const reader = new FileReader();
      reader.onload = () => {
        log(`FileReader complete, result byteLength: ${reader.result.byteLength}`, 'success');
        parseArrayBuffer(reader.result, 'direct file');
      };
      reader.onerror = () => {
        log(`FileReader failed: ${reader.error}`, 'error');
        setStatus('fail', 'File read failed');
      };
      reader.readAsArrayBuffer(file);
    }
    window.loadFromFile = loadFromFile;

    // ---- Test: Base64 pipeline (simulates Tauri flow) ----
    function loadFromBase64() {
      const base64 = document.getElementById('base64-input').value.trim();
      if (!base64) {
        log('No base64 data provided', 'warn');
        return;
      }
      log(`--- STEP: Base64 decode pipeline (simulating Tauri) ---`, 'step');
      log(`Base64 string length: ${base64.length} chars`, 'data');
      setStatus('pending', 'Decoding...');

      try {
        log('Calling atob()...', 'info');
        const binaryString = atob(base64);
        log(`atob() OK, binary string length: ${binaryString.length}`, 'success');

        log('Creating Uint8Array from charCodeAt loop...', 'info');
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        log(`Uint8Array created, length: ${bytes.length}`, 'success');

        const arrayBuffer = bytes.buffer;
        log(`ArrayBuffer from bytes.buffer:`, 'info');
        log(`  instanceof ArrayBuffer: ${arrayBuffer instanceof ArrayBuffer}`, 'data');
        log(`  byteLength: ${arrayBuffer.byteLength}`, 'data');
        log(`  bytes.byteOffset: ${bytes.byteOffset}`, 'data');
        log(`  bytes.byteLength: ${bytes.byteLength}`, 'data');

        if (arrayBuffer.byteLength !== binaryString.length) {
          log(`WARNING: Buffer byteLength (${arrayBuffer.byteLength}) !== decoded length (${binaryString.length})`, 'warn');
        }

        parseArrayBuffer(arrayBuffer, 'base64 decoded');
      } catch (e) {
        log(`Base64 decode FAILED: ${e.message}`, 'error');
        if (e.stack) log(`Stack: ${e.stack}`, 'error');
        setStatus('fail', 'Base64 decode failed');
      }
    }
    window.loadFromBase64 = loadFromBase64;

    // ---- Test: File to Base64 round-trip ----
    function fileToBase64() {
      const file = fileInput.files[0];
      if (!file) return;
      log(`--- STEP: File -> Base64 -> ArrayBuffer round-trip ---`, 'step');
      log(`File: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`, 'data');
      setStatus('pending', 'Converting...');

      const reader = new FileReader();
      reader.onload = () => {
        const arrayBuffer = reader.result;
        log(`Original ArrayBuffer byteLength: ${arrayBuffer.byteLength}`, 'data');

        // Encode to base64 (simulating Rust backend)
        log('Encoding to base64 (simulating Rust STANDARD encoding)...', 'info');
        const bytes = new Uint8Array(arrayBuffer);
        let binaryString = '';
        // Process in chunks to avoid call stack overflow
        const chunkSize = 65536;
        for (let i = 0; i < bytes.length; i += chunkSize) {
          const chunk = bytes.subarray(i, Math.min(i + chunkSize, bytes.length));
          binaryString += String.fromCharCode.apply(null, chunk);
        }
        const base64 = btoa(binaryString);
        log(`Base64 encoded, length: ${base64.length} chars`, 'success');

        // Now decode (simulating Viewer3dBlade.tsx lines 78-84)
        log('Decoding with atob() + Uint8Array (same as Viewer3dBlade)...', 'info');
        const decoded = atob(base64);
        const decodedBytes = new Uint8Array(decoded.length);
        for (let i = 0; i < decoded.length; i++) {
          decodedBytes[i] = decoded.charCodeAt(i);
        }
        const decodedBuffer = decodedBytes.buffer;

        log(`Decoded ArrayBuffer byteLength: ${decodedBuffer.byteLength}`, 'data');
        log(`Round-trip match: ${decodedBuffer.byteLength === arrayBuffer.byteLength ? 'YES' : 'NO'}`, decodedBuffer.byteLength === arrayBuffer.byteLength ? 'success' : 'error');

        // Byte-level comparison (first 100 bytes)
        const origBytes = new Uint8Array(arrayBuffer);
        const newBytes = new Uint8Array(decodedBuffer);
        let mismatch = -1;
        for (let i = 0; i < Math.min(origBytes.length, newBytes.length, 1000); i++) {
          if (origBytes[i] !== newBytes[i]) {
            mismatch = i;
            break;
          }
        }
        if (mismatch === -1) {
          log('Byte comparison (first 1000): MATCH', 'success');
        } else {
          log(`Byte MISMATCH at offset ${mismatch}: orig=${origBytes[mismatch]}, decoded=${newBytes[mismatch]}`, 'error');
        }

        parseArrayBuffer(decodedBuffer, 'base64 round-trip');
      };
      reader.onerror = () => {
        log(`FileReader failed: ${reader.error}`, 'error');
        setStatus('fail', 'File read failed');
      };
      reader.readAsArrayBuffer(file);
    }
    window.fileToBase64 = fileToBase64;

    // ---- Test: Procedural cube ----
    function loadSampleCube() {
      log(`--- STEP: Procedural cube (no file needed) ---`, 'step');
      setStatus('pending', 'Creating...');

      const state = setupScene();
      if (!state) {
        setStatus('fail', 'Scene setup failed');
        return;
      }

      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshStandardMaterial({ color: 0x89b4fa });
      const cube = new THREE.Mesh(geometry, material);
      state.scene.add(cube);

      state.camera.position.set(0, 1, 3);
      state.controls.target.set(0, 0, 0);
      state.controls.update();

      document.getElementById('canvas-overlay').classList.add('hidden');
      log('Procedural cube added to scene', 'success');
      setStatus('pass', 'Cube rendered');
    }
    window.loadSampleCube = loadSampleCube;

    // ---- Test: Fetch sample GLB from GitHub ----
    async function fetchSampleModel() {
      log(`--- STEP: Fetching BoxAnimated.glb from Khronos GitHub ---`, 'step');
      setStatus('pending', 'Fetching...');

      const url = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/BoxAnimated/glTF-Binary/BoxAnimated.glb';
      try {
        log(`Fetching: ${url}`, 'info');
        const response = await fetch(url);
        if (!response.ok) {
          log(`Fetch failed: ${response.status} ${response.statusText}`, 'error');
          setStatus('fail', 'Fetch failed');
          return;
        }
        const arrayBuffer = await response.arrayBuffer();
        log(`Fetched ${(arrayBuffer.byteLength / 1024).toFixed(1)} KB`, 'success');
        parseArrayBuffer(arrayBuffer, 'fetched from GitHub');
      } catch (e) {
        log(`Fetch error: ${e.message}`, 'error');
        setStatus('fail', 'Network error');
      }
    }
    window.fetchSampleModel = fetchSampleModel;

    // ---- Status ----
    function setStatus(type, text) {
      const el = document.getElementById('overall-status');
      el.className = `status ${type}`;
      el.textContent = text;
    }
    window.setStatus = setStatus;

    // ---- Environment Tests ----
    function runAllTests() {
      log('=== Running environment tests ===', 'step');

      // WebGL 2
      try {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl2');
        setTestResult('test-webgl2', !!gl);
        log(`WebGL 2: ${gl ? 'supported' : 'NOT supported'}`, gl ? 'success' : 'warn');
        if (gl) {
          log(`  Renderer: ${gl.getParameter(gl.RENDERER)}`, 'data');
          log(`  Vendor: ${gl.getParameter(gl.VENDOR)}`, 'data');
          log(`  Version: ${gl.getParameter(gl.VERSION)}`, 'data');
        }
      } catch (e) {
        setTestResult('test-webgl2', false);
        log(`WebGL 2 check failed: ${e.message}`, 'error');
      }

      // WebGL 1
      try {
        const c = document.createElement('canvas');
        const gl = c.getContext('webgl');
        setTestResult('test-webgl1', !!gl);
        log(`WebGL 1: ${gl ? 'supported' : 'NOT supported'}`, gl ? 'success' : 'warn');
      } catch (e) {
        setTestResult('test-webgl1', false);
        log(`WebGL 1 check failed: ${e.message}`, 'error');
      }

      // ArrayBuffer
      try {
        const ab = new ArrayBuffer(16);
        setTestResult('test-arraybuffer', ab.byteLength === 16);
        log(`ArrayBuffer: OK`, 'success');
      } catch (e) {
        setTestResult('test-arraybuffer', false);
        log(`ArrayBuffer: ${e.message}`, 'error');
      }

      // TextDecoder
      try {
        const td = new TextDecoder();
        const result = td.decode(new Uint8Array([72, 101, 108, 108, 111]));
        setTestResult('test-textdecoder', result === 'Hello');
        log(`TextDecoder: ${result === 'Hello' ? 'OK' : 'WRONG OUTPUT'}`, result === 'Hello' ? 'success' : 'error');
      } catch (e) {
        setTestResult('test-textdecoder', false);
        log(`TextDecoder: ${e.message}`, 'error');
      }

      // atob
      try {
        const result = atob('SGVsbG8=');
        setTestResult('test-atob', result === 'Hello');
        log(`atob(): ${result === 'Hello' ? 'OK' : 'WRONG OUTPUT'}`, result === 'Hello' ? 'success' : 'error');
      } catch (e) {
        setTestResult('test-atob', false);
        log(`atob(): ${e.message}`, 'error');
      }

      // Uint8Array
      try {
        const bytes = new Uint8Array([1, 2, 3]);
        const buf = bytes.buffer;
        const isAB = buf instanceof ArrayBuffer;
        setTestResult('test-uint8array', isAB && buf.byteLength === 3);
        log(`Uint8Array.buffer instanceof ArrayBuffer: ${isAB}`, isAB ? 'success' : 'error');
        log(`Uint8Array.buffer.byteLength: ${buf.byteLength}`, 'data');
      } catch (e) {
        setTestResult('test-uint8array', false);
        log(`Uint8Array: ${e.message}`, 'error');
      }

      // Three.js
      try {
        const ver = THREE.REVISION;
        setTestResult('test-threejs', !!ver);
        log(`THREE.js revision: ${ver}`, 'success');
      } catch (e) {
        setTestResult('test-threejs', false);
        log(`THREE.js: ${e.message}`, 'error');
      }

      // GLTFLoader
      try {
        const loader = new GLTFLoader();
        const hasParseMethod = typeof loader.parse === 'function';
        setTestResult('test-gltfloader', hasParseMethod);
        log(`GLTFLoader.parse: ${hasParseMethod ? 'available' : 'MISSING'}`, hasParseMethod ? 'success' : 'error');
      } catch (e) {
        setTestResult('test-gltfloader', false);
        log(`GLTFLoader: ${e.message}`, 'error');
      }

      log('=== Environment tests complete ===', 'step');
    }
    window.runAllTests = runAllTests;

    function setTestResult(id, ok) {
      const el = document.getElementById(id);
      el.textContent = ok ? 'OK' : 'FAIL';
      el.className = `value ${ok ? 'ok' : 'fail'}`;
    }

    // ---- Auto-run on load ----
    log('Page loaded, running environment tests...', 'info');
    runAllTests();
    document.getElementById('btn-load-base64').disabled = false;
  </script>
</body>
</html>
