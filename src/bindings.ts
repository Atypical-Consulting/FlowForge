
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async greet(name: string) : Promise<string> {
    return await TAURI_INVOKE("greet", { name });
},
/**
 * Open a Git repository at the specified path.
 * 
 * Validates the path exists and is a git repository,
 * then stores it as the current active repository.
 */
async openRepository(path: string) : Promise<Result<RepoStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_repository", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current repository status.
 * 
 * Returns branch name and dirty status for the currently open repository.
 */
async getRepositoryStatus() : Promise<Result<RepoStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_repository_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if a path is a valid Git repository.
 * 
 * Used for drag-drop validation before attempting to open.
 */
async isGitRepository(path: string) : Promise<Result<boolean, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_git_repository", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Close the current repository.
 * 
 * Clears the stored repository path.
 */
async closeRepository() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_repository") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current staging status of the repository.
 * 
 * Returns files grouped by staged (in index), unstaged (modified in workdir),
 * and untracked (new files not yet added).
 */
async getStagingStatus() : Promise<Result<StagingStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_staging_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage a single file for commit.
 * 
 * The path must be relative to the repository root.
 */
async stageFile(path: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage a single file (remove from index, keep workdir changes).
 * 
 * The path must be relative to the repository root.
 */
async unstageFile(path: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage all changed files.
 * 
 * Adds all modified, deleted, and new files to the index.
 */
async stageAll() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage all staged files.
 * 
 * Resets the index to match HEAD, keeping workdir changes.
 */
async unstageAll() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the diff for a specific file.
 * 
 * If `staged` is true, shows diff between HEAD and index.
 * If `staged` is false, shows diff between index and workdir.
 */
async getFileDiff(path: string, staged: boolean, contextLines: number) : Promise<Result<FileDiff, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_file_diff", { path, staged, contextLines }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new commit from staged changes.
 * 
 * Creates a commit with the given message from the current index (staged changes).
 * If `amend` is true, replaces the last commit instead of creating a new one.
 * 
 * # Errors
 * - `NoStagedChanges` if index is empty (nothing staged)
 * - `SignatureError` if git config lacks user.name/email
 * - Various git2 errors for other failures
 */
async createCommit(message: string, amend: boolean) : Promise<Result<CommitInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_commit", { message, amend }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get paginated commit history.
 * 
 * Returns commits starting from HEAD, sorted by time.
 * Use skip and limit for pagination.
 */
async getCommitHistory(skip: number, limit: number) : Promise<Result<CommitSummary[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_history", { skip, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get full details of a specific commit.
 */
async getCommitDetails(oid: string) : Promise<Result<CommitDetails, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_details", { oid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * IPC command to get the commit graph for visualization.
 * 
 * # Arguments
 * * `limit` - Maximum number of commits to return (default: 100, max: 500)
 * * `offset` - Number of commits to skip (default: 0)
 * * `state` - Repository state containing the current repo path
 * 
 * # Returns
 * A CommitGraph containing nodes and edges for visualization.
 */
async getCommitGraph(limit: number | null, offset: number | null) : Promise<Result<CommitGraph, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_graph", { limit, offset }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all configured remotes for the current repository.
 */
async getRemotes() : Promise<Result<RemoteInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_remotes") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch from a remote without merging.
 * 
 * Downloads objects and refs from the remote but does not modify
 * the working directory or current branch.
 */
async fetchFromRemote(remote: string, onProgress: TAURI_CHANNEL<SyncProgress>) : Promise<Result<SyncResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_from_remote", { remote, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Push current branch to a remote.
 * 
 * Sends local commits to the remote repository.
 */
async pushToRemote(remote: string, onProgress: TAURI_CHANNEL<SyncProgress>) : Promise<Result<SyncResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("push_to_remote", { remote, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Pull from a remote (fetch + merge).
 * 
 * Downloads objects from the remote and merges the tracking branch
 * into the current branch. Fast-forward merges are preferred.
 */
async pullFromRemote(remote: string, onProgress: TAURI_CHANNEL<SyncProgress>) : Promise<Result<SyncResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pull_from_remote", { remote, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all local branches in the repository.
 */
async listBranches() : Promise<Result<BranchInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_branches") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new branch from HEAD.
 */
async createBranch(name: string, checkout: boolean) : Promise<Result<BranchInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_branch", { name, checkout }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Switch to an existing branch.
 */
async checkoutBranch(branchName: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("checkout_branch", { branchName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a local branch.
 */
async deleteBranch(branchName: string, force: boolean) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_branch", { branchName, force }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all stash entries in the repository.
 */
async listStashes() : Promise<Result<StashEntry[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_stashes") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save current changes to stash.
 */
async stashSave(message: string | null, includeUntracked: boolean) : Promise<Result<string, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_save", { message, includeUntracked }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Apply a stash by index without removing it.
 */
async stashApply(index: number) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_apply", { index }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Apply a stash by index and remove it from the stash list.
 */
async stashPop(index: number) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_pop", { index }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Drop a stash by index without applying it.
 */
async stashDrop(index: number) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_drop", { index }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all tags in the repository.
 */
async listTags() : Promise<Result<TagInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_tags") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new tag.
 */
async createTag(name: string, message: string | null, targetOid: string | null) : Promise<Result<TagInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_tag", { name, message, targetOid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a tag by name.
 */
async deleteTag(name: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_tag", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Merge a source branch into the current branch.
 */
async mergeBranch(sourceBranch: string) : Promise<Result<MergeResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("merge_branch", { sourceBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the status of an in-progress merge.
 */
async getMergeStatus() : Promise<Result<MergeStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_merge_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Abort an in-progress merge.
 */
async abortMerge() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("abort_merge") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new feature branch from develop.
 */
async startFeature(name: string) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_feature", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finish the current feature branch, merging to develop.
 */
async finishFeature() : Promise<Result<null, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("finish_feature") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new release branch from develop.
 */
async startRelease(version: string) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_release", { version }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finish the current release branch.
 * Merges to main AND develop, creates version tag, deletes branch.
 */
async finishRelease(tagMessage: string | null) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("finish_release", { tagMessage }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new hotfix branch from main.
 */
async startHotfix(name: string) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_hotfix", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finish the current hotfix branch.
 * Merges to main AND develop, creates tag, deletes branch.
 */
async finishHotfix(tagMessage: string | null) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("finish_hotfix", { tagMessage }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get current Gitflow status for UI.
 */
async getGitflowStatus() : Promise<Result<GitflowStatus, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_gitflow_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Abort current Gitflow operation, returning to source branch.
 */
async abortGitflow() : Promise<Result<null, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("abort_gitflow") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate a conventional commit message.
 * 
 * Returns validation result with errors and warnings.
 */
async validateConventionalCommit(message: string) : Promise<ValidationResult> {
    return await TAURI_INVOKE("validate_conventional_commit", { message });
},
/**
 * Suggest a commit type based on staged files.
 * 
 * Analyzes the currently staged files and returns a type suggestion
 * with confidence level.
 */
async suggestCommitType() : Promise<Result<TypeSuggestion, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("suggest_commit_type") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get scope suggestions from commit history.
 * 
 * Extracts scopes used in previous commits, sorted by frequency.
 */
async getScopeSuggestions(limit: number | null) : Promise<Result<ScopeSuggestion[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_scope_suggestions", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Infer scope from staged files based on common directory.
 */
async inferScopeFromStaged() : Promise<Result<string | null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("infer_scope_from_staged") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Generate a changelog from commit history.
 * 
 * Generates markdown changelog grouped by commit type.
 */
async generateChangelogCmd(fromRef: string | null, toRef: string | null, version: string | null) : Promise<Result<ChangelogOutput, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_changelog_cmd", { fromRef, toRef, version }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Information about active Gitflow workflow.
 */
export type ActiveFlow = { flowType: FlowType; name: string; sourceBranch: string }
/**
 * Information about a local branch.
 */
export type BranchInfo = { 
/**
 * Branch name (e.g., "main", "feature/login")
 */
name: string; 
/**
 * True if this is the currently checked out branch
 */
isHead: boolean; 
/**
 * Short OID of the branch tip commit (7 chars)
 */
lastCommitOid: string; 
/**
 * Summary line of the tip commit
 */
lastCommitMessage: string; 
/**
 * Whether branch is merged into HEAD (None if IS head)
 */
isMerged: boolean | null }
/**
 * Branch type classification for Gitflow-based coloring.
 */
export type BranchType = 
/**
 * Main/master branch - stable production code
 */
"main" | 
/**
 * Develop branch - integration branch for features
 */
"develop" | 
/**
 * Feature branches - new features in development
 */
"feature" | 
/**
 * Release branches - preparing for production release
 */
"release" | 
/**
 * Hotfix branches - urgent production fixes
 */
"hotfix" | 
/**
 * Other branches that don't follow Gitflow naming
 */
"other"
/**
 * A commit entry for the changelog.
 */
export type ChangelogCommit = { 
/**
 * Short commit hash.
 */
hash: string; 
/**
 * Commit scope (optional).
 */
scope: string | null; 
/**
 * Commit description.
 */
description: string; 
/**
 * Whether this is a breaking change.
 */
breaking: boolean; 
/**
 * Commit author name.
 */
author: string; 
/**
 * Commit date in ISO format.
 */
date: string }
/**
 * Output from changelog generation.
 */
export type ChangelogOutput = { 
/**
 * Rendered markdown changelog.
 */
markdown: string; 
/**
 * Total number of commits included.
 */
commitCount: number; 
/**
 * Commits grouped by type.
 */
groups: CommitGroup[] }
/**
 * Full details of a commit.
 */
export type CommitDetails = { oid: string; shortOid: string; message: string; authorName: string; authorEmail: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number)
 */
authorTimestampMs: number; committerName: string; committerEmail: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number)
 */
committerTimestampMs: number; parentOids: string[]; filesChanged: FileChanged[] }
/**
 * Complete commit graph with nodes and edges for visualization.
 */
export type CommitGraph = { 
/**
 * All commit nodes in topological order
 */
nodes: GraphNode[]; 
/**
 * Edges representing parent-child relationships
 */
edges: GraphEdge[] }
/**
 * A group of commits by type.
 */
export type CommitGroup = { 
/**
 * Commit type (e.g., "feat", "fix").
 */
commitType: string; 
/**
 * Display title (e.g., "Features", "Bug Fixes").
 */
title: string; 
/**
 * Commits in this group.
 */
commits: ChangelogCommit[] }
/**
 * Information about a created commit.
 * 
 * Returned after successful commit creation to confirm
 * the commit was made and provide its identifiers.
 */
export type CommitInfo = { 
/**
 * Full commit OID (40 hex characters)
 */
oid: string; 
/**
 * Short commit OID (7 characters)
 */
shortOid: string; 
/**
 * Commit message
 */
message: string }
/**
 * Summary of a commit for list display.
 */
export type CommitSummary = { oid: string; shortOid: string; messageSubject: string; authorName: string; authorEmail: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number up to year 275760)
 */
timestampMs: number }
/**
 * Commit type enumeration.
 */
export type CommitType = "feat" | "fix" | "docs" | "style" | "refactor" | "perf" | "test" | "chore" | "ci" | "build" | "revert"
/**
 * Confidence level for type inference.
 */
export type Confidence = "high" | "medium" | "low"
/**
 * A single diff hunk with line range information.
 */
export type DiffHunk = { oldStart: number; oldLines: number; newStart: number; newLines: number; header: string }
/**
 * A single file change with its status and optional diff stats.
 */
export type FileChange = { path: string; status: FileStatus; additions: number | null; deletions: number | null }
/**
 * A file changed in a commit.
 */
export type FileChanged = { path: string; status: string; additions: number; deletions: number }
/**
 * Complete file diff with old/new content for Monaco DiffEditor.
 */
export type FileDiff = { path: string; oldContent: string; newContent: string; hunks: DiffHunk[]; isBinary: boolean; language: string }
/**
 * Status of a file in the working directory or index.
 */
export type FileStatus = "modified" | "added" | "deleted" | { renamed: { old_path: string } } | "untracked" | "conflicted"
/**
 * Flow type for active workflow.
 */
export type FlowType = "feature" | "release" | "hotfix"
/**
 * Git operation errors that serialize across the IPC boundary.
 * 
 * These errors are sent to the frontend as typed objects,
 * allowing proper error handling in TypeScript.
 */
export type GitError = { type: "NotFound"; message: string } | { type: "NotARepository"; message: string } | { type: "EmptyRepository" } | { type: "StatusError"; message: string } | { type: "OperationFailed"; message: string } | { type: "PathNotFound"; message: string } | { type: "Internal"; message: string } | { type: "NoStagedChanges" } | { type: "SignatureError"; message: string } | { type: "RemoteNotFound"; message: string } | { type: "AuthenticationFailed"; message: string } | { type: "PushRejected"; message: string } | { type: "NetworkError"; message: string } | { type: "BranchNotFound"; message: string } | { type: "CannotDeleteCurrentBranch" } | { type: "BranchNotMerged"; message: string } | { type: "InvalidBranchName"; message: string } | { type: "BranchAlreadyExists"; message: string } | { type: "DirtyWorkingDirectory" } | { type: "StashNotFound"; message: number } | { type: "NothingToStash" } | { type: "TagAlreadyExists"; message: string } | { type: "TagNotFound"; message: string } | { type: "NoMergeInProgress" }
/**
 * Gitflow operation errors that serialize across the IPC boundary.
 */
export type GitflowError = 
/**
 * Wrong branch context for the requested operation
 */
{ type: "InvalidContext"; data: { expected: string; actual: string } } | 
/**
 * Operation requires being on a feature branch
 */
{ type: "NotOnFeatureBranch" } | 
/**
 * Operation requires being on a release branch
 */
{ type: "NotOnReleaseBranch" } | 
/**
 * Operation requires being on a hotfix branch
 */
{ type: "NotOnHotfixBranch" } | 
/**
 * A release is already in progress
 */
{ type: "ReleaseInProgress"; data: string } | 
/**
 * A hotfix is already in progress
 */
{ type: "HotfixInProgress"; data: string } | 
/**
 * Merge conflicts encountered during finish operation
 */
{ type: "MergeConflict" } | 
/**
 * Repository has no commits yet
 */
{ type: "UnbornHead" } | 
/**
 * Specified branch was not found
 */
{ type: "BranchNotFound"; data: string } | 
/**
 * Branch already exists
 */
{ type: "BranchExists"; data: string } | 
/**
 * Repository is not configured for Gitflow (missing main or develop)
 */
{ type: "NotGitflowRepo" } | 
/**
 * Invalid branch name for Gitflow
 */
{ type: "InvalidBranchName"; data: string } | 
/**
 * Wrapped git2 error
 */
{ type: "Git"; data: string }
/**
 * Status of Gitflow operations for UI consumption.
 */
export type GitflowStatus = { currentBranch: string; isGitflowReady: boolean; canStartFeature: boolean; canFinishFeature: boolean; canStartRelease: boolean; canFinishRelease: boolean; canStartHotfix: boolean; canFinishHotfix: boolean; canAbort: boolean; activeFlow: ActiveFlow | null }
/**
 * An edge in the commit graph connecting parent and child commits.
 */
export type GraphEdge = { 
/**
 * SHA of the child commit (the commit that has this parent)
 */
from: string; 
/**
 * SHA of the parent commit
 */
to: string }
/**
 * A node in the commit graph representing a single commit.
 */
export type GraphNode = { 
/**
 * Full SHA-1 hash of the commit (40 chars)
 */
oid: string; 
/**
 * Short SHA-1 hash of the commit (7 chars)
 */
shortOid: string; 
/**
 * First line of the commit message
 */
message: string; 
/**
 * Author name
 */
author: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number up to year 275760)
 */
timestampMs: number; 
/**
 * Parent commit SHAs
 */
parents: string[]; 
/**
 * Classification of the branch type for coloring
 */
branchType: BranchType; 
/**
 * Lane/column position for visual layout (0-indexed from left)
 */
column: number; 
/**
 * Branch names pointing to this commit
 */
branchNames: string[] }
/**
 * Result of merge analysis.
 */
export type MergeAnalysisResult = 
/**
 * Already merged, nothing to do
 */
"upToDate" | 
/**
 * Can fast-forward without merge commit
 */
"fastForward" | 
/**
 * Requires merge commit
 */
"normal" | 
/**
 * HEAD doesn't exist yet
 */
"unborn"
/**
 * Result of a merge operation.
 */
export type MergeResult = { 
/**
 * Whether the merge was successful
 */
success: boolean; 
/**
 * Analysis result (what type of merge was performed)
 */
analysis: MergeAnalysisResult; 
/**
 * OID of merge commit (if created)
 */
commitOid: string | null; 
/**
 * True if fast-forward was used
 */
fastForwarded: boolean; 
/**
 * True if conflicts remain
 */
hasConflicts: boolean; 
/**
 * List of conflicted file paths
 */
conflictedFiles: string[] }
/**
 * Status of an in-progress merge.
 */
export type MergeStatus = { 
/**
 * Whether a merge is currently in progress
 */
inProgress: boolean; 
/**
 * List of conflicted file paths
 */
conflictedFiles: string[] }
/**
 * Information about a configured remote.
 */
export type RemoteInfo = { name: string; url: string }
/**
 * Repository status information sent to frontend.
 * 
 * This is a lightweight summary - we don't send raw git2 objects
 * across the IPC boundary.
 */
export type RepoStatus = { 
/**
 * Current branch name (or short commit hash if detached)
 */
branchName: string; 
/**
 * Whether the working directory has uncommitted changes
 */
isDirty: boolean; 
/**
 * Absolute path to the repository root
 */
repoPath: string; 
/**
 * Repository display name (folder name)
 */
repoName: string }
/**
 * A scope suggestion from commit history.
 */
export type ScopeSuggestion = { 
/**
 * The scope string.
 */
scope: string; 
/**
 * Number of times this scope has been used.
 */
usageCount: number }
/**
 * Complete staging status showing staged, unstaged, and untracked files.
 */
export type StagingStatus = { staged: FileChange[]; unstaged: FileChange[]; untracked: FileChange[] }
/**
 * A stash entry representing saved work.
 */
export type StashEntry = { 
/**
 * 0-based index for stash operations
 */
index: number; 
/**
 * Stash message
 */
message: string; 
/**
 * Commit OID of the stash
 */
oid: string }
/**
 * Progress events for remote sync operations.
 * Uses tagged enum serialization for frontend type safety.
 */
export type SyncProgress = { event: "started"; data: { operation: string } } | { event: "counting"; data: { current: number; total: number } } | { event: "compressing"; data: { current: number; total: number } } | { event: "transferring"; data: { current: number; total: number; bytes: number } } | { event: "resolving"; data: { current: number; total: number } } | { event: "finished"; data: { operation: string } } | { event: "error"; data: { message: string } }
/**
 * Result of a sync operation (push/pull/fetch).
 */
export type SyncResult = { success: boolean; message: string; commitsTransferred: number }
export type TAURI_CHANNEL<TSend> = null
/**
 * Information about a git tag.
 */
export type TagInfo = { 
/**
 * Tag name (e.g., "v1.0.0")
 */
name: string; 
/**
 * OID of the tag object (for annotated) or target commit (for lightweight)
 */
oid: string; 
/**
 * OID of the commit the tag points to
 */
targetOid: string; 
/**
 * Tag message (None for lightweight tags)
 */
message: string | null; 
/**
 * Tagger name (None for lightweight tags)
 */
tagger: string | null; 
/**
 * True for annotated tags, false for lightweight
 */
isAnnotated: boolean }
/**
 * A suggested commit type based on file analysis.
 */
export type TypeSuggestion = { 
/**
 * The suggested commit type.
 */
suggestedType: CommitType; 
/**
 * Confidence level of the suggestion.
 */
confidence: Confidence; 
/**
 * Reason for the suggestion.
 */
reason: string }
/**
 * A validation error.
 */
export type ValidationError = { 
/**
 * Error code for programmatic handling.
 */
code: string; 
/**
 * Human-readable error message.
 */
message: string; 
/**
 * Optional suggestion for fixing the error.
 */
suggestion: string | null }
/**
 * Result of validating a commit message.
 */
export type ValidationResult = { 
/**
 * Whether the message is valid.
 */
isValid: boolean; 
/**
 * Validation errors (if any).
 */
errors: ValidationError[]; 
/**
 * Validation warnings (if any).
 */
warnings: ValidationWarning[] }
/**
 * A validation warning.
 */
export type ValidationWarning = { 
/**
 * Warning code for programmatic handling.
 */
code: string; 
/**
 * Human-readable warning message.
 */
message: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
