
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async greet(name: string) : Promise<string> {
    return await TAURI_INVOKE("greet", { name });
},
/**
 * Open a Git repository at the specified path.
 * 
 * Validates the path exists and is a git repository,
 * then stores it as the current active repository.
 * Also starts a file watcher to detect external changes.
 */
async openRepository(path: string) : Promise<Result<RepoStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_repository", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current repository status.
 * 
 * Returns branch name and dirty status for the currently open repository.
 */
async getRepositoryStatus() : Promise<Result<RepoStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_repository_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if a path is a valid Git repository.
 * 
 * Used for drag-drop validation before attempting to open.
 */
async isGitRepository(path: string) : Promise<Result<boolean, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_git_repository", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Close the current repository.
 * 
 * Stops the file watcher and clears the stored repository path.
 */
async closeRepository() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_repository") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current staging status of the repository.
 * 
 * Returns files grouped by staged (in index), unstaged (modified in workdir),
 * and untracked (new files not yet added).
 */
async getStagingStatus() : Promise<Result<StagingStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_staging_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage a single file for commit.
 * 
 * The path must be relative to the repository root.
 */
async stageFile(path: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage a single file (remove from index, keep workdir changes).
 * 
 * The path must be relative to the repository root.
 */
async unstageFile(path: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage multiple files for commit in a single operation.
 * 
 * More efficient than calling stage_file repeatedly — performs a single index write.
 * Paths must be relative to the repository root.
 */
async stageFiles(paths: string[]) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_files", { paths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage multiple files (remove from index, keep workdir changes).
 * 
 * More efficient than calling unstage_file repeatedly — performs a single reset.
 * Paths must be relative to the repository root.
 */
async unstageFiles(paths: string[]) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_files", { paths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage all changed files.
 * 
 * Adds all modified, deleted, and new files to the index.
 */
async stageAll() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage all staged files.
 * 
 * Resets the index to match HEAD, keeping workdir changes.
 */
async unstageAll() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the diff for a specific file.
 * 
 * If `staged` is true, shows diff between HEAD and index.
 * If `staged` is false, shows diff between index and workdir.
 */
async getFileDiff(path: string, staged: boolean, contextLines: number) : Promise<Result<FileDiff, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_file_diff", { path, staged, contextLines }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the diff for a specific file at a given commit.
 * 
 * Shows the changes introduced by the commit (parent -> commit).
 */
async getCommitFileDiff(oid: string, path: string, contextLines: number) : Promise<Result<FileDiff, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_file_diff", { oid, path, contextLines }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a file's binary content as a base64 data URI from the working tree.
 * 
 * Returns a data URI like `data:image/png;base64,...` for use in `<img>` tags.
 */
async getFileBase64(filePath: string) : Promise<Result<string, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_file_base64", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a file's binary content as a base64 data URI from a specific commit.
 * 
 * Extracts the blob from the commit's tree and returns it as a data URI.
 */
async getCommitFileBase64(oid: string, filePath: string) : Promise<Result<string, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_file_base64", { oid, filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new commit from staged changes.
 * 
 * Creates a commit with the given message from the current index (staged changes).
 * If `amend` is true, replaces the last commit instead of creating a new one.
 * 
 * # Errors
 * - `NoStagedChanges` if index is empty (nothing staged)
 * - `SignatureError` if git config lacks user.name/email
 * - Various git2 errors for other failures
 */
async createCommit(message: string, amend: boolean) : Promise<Result<CommitInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_commit", { message, amend }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the last commit message for amend pre-fill.
 * 
 * Returns the HEAD commit's message parsed into subject and body components.
 */
async getLastCommitMessage() : Promise<Result<LastCommitMessage, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_last_commit_message") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get paginated commit history.
 * 
 * Returns commits starting from HEAD, sorted by time.
 * Use skip and limit for pagination.
 */
async getCommitHistory(skip: number, limit: number) : Promise<Result<CommitSummary[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_history", { skip, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get full details of a specific commit.
 */
async getCommitDetails(oid: string) : Promise<Result<CommitDetails, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_details", { oid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Search commits by message text.
 * Returns up to `limit` commits whose message contains `query` (case-insensitive).
 */
async searchCommits(query: string, limit: number) : Promise<Result<CommitSummary[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_commits", { query, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * IPC command to get the commit graph for visualization.
 * 
 * # Arguments
 * * `limit` - Maximum number of commits to return (default: 100, max: 500)
 * * `offset` - Number of commits to skip (default: 0)
 * * `state` - Repository state containing the current repo path
 * 
 * # Returns
 * A CommitGraph containing nodes and edges for visualization.
 */
async getCommitGraph(limit: number | null, offset: number | null) : Promise<Result<CommitGraph, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_graph", { limit, offset }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all configured remotes for the current repository.
 */
async getRemotes() : Promise<Result<RemoteInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_remotes") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch from a remote without merging.
 * 
 * Downloads objects and refs from the remote but does not modify
 * the working directory or current branch.
 */
async fetchFromRemote(remote: string, onProgress: TAURI_CHANNEL<SyncProgress>) : Promise<Result<SyncResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_from_remote", { remote, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Push current branch to a remote.
 * 
 * Sends local commits to the remote repository.
 */
async pushToRemote(remote: string, onProgress: TAURI_CHANNEL<SyncProgress>) : Promise<Result<SyncResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("push_to_remote", { remote, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Pull from a remote (fetch + merge).
 * 
 * Downloads objects from the remote and merges the tracking branch
 * into the current branch. Fast-forward merges are preferred.
 */
async pullFromRemote(remote: string, onProgress: TAURI_CHANNEL<SyncProgress>) : Promise<Result<SyncResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pull_from_remote", { remote, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all local branches in the repository.
 */
async listBranches() : Promise<Result<BranchInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_branches") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new branch from HEAD.
 */
async createBranch(name: string, checkout: boolean) : Promise<Result<BranchInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_branch", { name, checkout }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Switch to an existing branch.
 */
async checkoutBranch(branchName: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("checkout_branch", { branchName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a local branch.
 */
async deleteBranch(branchName: string, force: boolean) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_branch", { branchName, force }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all branches (local and optionally remote) in the repository.
 */
async listAllBranches(includeRemote: boolean) : Promise<Result<BranchInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_all_branches", { includeRemote }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checkout a remote branch by creating a local tracking branch.
 */
async checkoutRemoteBranch(remoteBranch: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("checkout_remote_branch", { remoteBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete multiple local branches in a single batch operation.
 */
async batchDeleteBranches(branchNames: string[], force: boolean) : Promise<Result<BatchDeleteResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("batch_delete_branches", { branchNames, force }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get recently checked-out branches from the HEAD reflog.
 */
async getRecentCheckouts(limit: number | null) : Promise<Result<RecentCheckout[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recent_checkouts", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all stash entries in the repository.
 */
async listStashes() : Promise<Result<StashEntry[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_stashes") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save current changes to stash.
 */
async stashSave(message: string | null, includeUntracked: boolean) : Promise<Result<string, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_save", { message, includeUntracked }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Apply a stash by index without removing it.
 */
async stashApply(index: number) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_apply", { index }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Apply a stash by index and remove it from the stash list.
 */
async stashPop(index: number) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_pop", { index }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Drop a stash by index without applying it.
 */
async stashDrop(index: number) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_drop", { index }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all tags in the repository.
 */
async listTags() : Promise<Result<TagInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_tags") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new tag.
 */
async createTag(name: string, message: string | null, targetOid: string | null) : Promise<Result<TagInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_tag", { name, message, targetOid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a tag by name.
 */
async deleteTag(name: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_tag", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Merge a source branch into the current branch.
 */
async mergeBranch(sourceBranch: string) : Promise<Result<MergeResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("merge_branch", { sourceBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the status of an in-progress merge.
 */
async getMergeStatus() : Promise<Result<MergeStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_merge_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Abort an in-progress merge.
 */
async abortMerge() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("abort_merge") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize Gitflow on a repository.
 * 
 * This command:
 * 1. Verifies the main branch exists
 * 2. Creates the develop branch if it doesn't exist
 * 3. Stores configuration in .git/config for git-flow CLI compatibility
 * 4. Checks out the develop branch
 * 5. Optionally pushes develop to origin
 */
async initGitflow(config: GitflowConfig, pushDevelop: boolean) : Promise<Result<GitflowInitResult, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_gitflow", { config, pushDevelop }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new feature branch from develop.
 */
async startFeature(name: string) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_feature", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finish the current feature branch, merging to develop.
 */
async finishFeature() : Promise<Result<null, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("finish_feature") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new release branch from develop.
 */
async startRelease(version: string) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_release", { version }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finish the current release branch.
 * Merges to main AND develop, creates version tag, deletes branch.
 */
async finishRelease(tagMessage: string | null) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("finish_release", { tagMessage }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new hotfix branch from main.
 */
async startHotfix(name: string) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_hotfix", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finish the current hotfix branch.
 * Merges to main AND develop, creates tag, deletes branch.
 */
async finishHotfix(tagMessage: string | null) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("finish_hotfix", { tagMessage }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get current Gitflow status for UI.
 */
async getGitflowStatus() : Promise<Result<GitflowStatus, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_gitflow_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Abort current Gitflow operation, returning to source branch.
 */
async abortGitflow() : Promise<Result<null, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("abort_gitflow") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate a conventional commit message.
 * 
 * Returns validation result with errors and warnings.
 */
async validateConventionalCommit(message: string) : Promise<ValidationResult> {
    return await TAURI_INVOKE("validate_conventional_commit", { message });
},
/**
 * Suggest a commit type based on staged files.
 * 
 * Analyzes the currently staged files and returns a type suggestion
 * with confidence level.
 */
async suggestCommitType() : Promise<Result<TypeSuggestion, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("suggest_commit_type") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get scope suggestions from commit history.
 * 
 * Extracts scopes used in previous commits, sorted by frequency.
 */
async getScopeSuggestions(limit: number | null) : Promise<Result<ScopeSuggestion[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_scope_suggestions", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Infer scope from staged files based on common directory.
 */
async inferScopeFromStaged() : Promise<Result<string | null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("infer_scope_from_staged") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Generate a changelog from commit history.
 * 
 * Generates markdown changelog grouped by commit type.
 */
async generateChangelogCmd(fromRef: string | null, toRef: string | null, version: string | null) : Promise<Result<ChangelogOutput, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_changelog_cmd", { fromRef, toRef, version }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all worktrees for the current repository.
 */
async listWorktrees() : Promise<Result<WorktreeInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_worktrees") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new worktree.
 */
async createWorktree(options: CreateWorktreeOptions) : Promise<Result<WorktreeInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_worktree", { options }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a worktree.
 */
async deleteWorktree(name: string, force: boolean, deleteBranch: boolean) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_worktree", { name, force, deleteBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get information about what can be undone.
 * Looks at HEAD reflog to find the previous state.
 */
async getUndoInfo() : Promise<Result<UndoInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_undo_info") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Undo the last operation by resetting HEAD to the previous reflog entry.
 */
async undoLastOperation() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("undo_last_operation") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Clone a Git repository with progress tracking.
 * 
 * Clones a repository from a URL to a local destination path,
 * sending progress events through the provided channel.
 * 
 * # Arguments
 * * `url` - The repository URL (HTTPS or SSH)
 * * `destination` - Local path where the repository will be cloned
 * * `on_progress` - Channel for sending progress events
 * 
 * # Returns
 * The path to the cloned repository on success
 */
async cloneRepository(url: string, destination: string, onProgress: TAURI_CHANNEL<CloneProgress>) : Promise<Result<string, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clone_repository", { url, destination, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize a new Git repository at the specified path.
 * 
 * Validates the path exists and is a directory that is not already a git repository,
 * then creates a new repository with an optional default branch name.
 * 
 * # Arguments
 * * `path` - Directory where the repository will be initialized
 * * `default_branch` - Optional initial branch name (defaults to "main")
 */
async gitInit(path: string, defaultBranch: string | null) : Promise<Result<InitResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("git_init", { path, defaultBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List files and directories at a given path within the repository.
 * 
 * Merges entries from the HEAD tree and the working directory so that
 * uncommitted/untracked files are also visible in the browser.
 * Pass an empty string for `path` to list the root directory.
 * Returns directories first, then files, both sorted alphabetically.
 */
async listRepoFiles(path: string) : Promise<Result<RepoFileEntry[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_repo_files", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Read file content from the repository at HEAD, with working-directory fallback.
 * 
 * First tries the git HEAD tree. If the file is not found there (e.g. uncommitted),
 * falls back to reading from the working directory on disk.
 * Binary files are returned as base64-encoded content.
 * Text files are returned as UTF-8 strings.
 */
async readRepoFile(filePath: string) : Promise<Result<RepoFileContent, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_repo_file", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Read the user's global git configuration.
 * 
 * Returns None for any value that is not set. Never errors —
 * if the config file cannot be opened, all fields are None.
 */
async getGitGlobalConfig() : Promise<Result<GitGlobalConfig, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_git_global_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set a value in the user's global git configuration.
 * 
 * # Arguments
 * * `key` - The config key (e.g. "user.name", "user.email", "init.defaultBranch")
 * * `value` - The value to set
 */
async setGitGlobalConfig(key: string, value: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_git_global_config", { key, value }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Information about active Gitflow workflow.
 */
export type ActiveFlow = { flowType: FlowType; name: string; sourceBranch: string }
/**
 * Result of a batch branch deletion operation.
 */
export type BatchDeleteResult = { 
/**
 * Per-branch results
 */
results: BranchDeleteResult[]; 
/**
 * Count of successfully deleted branches
 */
totalDeleted: number; 
/**
 * Count of branches that failed to delete
 */
totalFailed: number }
/**
 * Result of deleting a single branch in a batch operation.
 */
export type BranchDeleteResult = { 
/**
 * Branch name that was targeted
 */
name: string; 
/**
 * Whether the branch was successfully deleted
 */
deleted: boolean; 
/**
 * Error message if deletion failed
 */
error: string | null }
/**
 * Information about a branch (local or remote).
 */
export type BranchInfo = { 
/**
 * Branch name (e.g., "main", "feature/login", "origin/feature/x")
 */
name: string; 
/**
 * True if this is the currently checked out branch
 */
isHead: boolean; 
/**
 * Short OID of the branch tip commit (7 chars)
 */
lastCommitOid: string; 
/**
 * Summary line of the tip commit
 */
lastCommitMessage: string; 
/**
 * Whether branch is merged into HEAD (None if IS head)
 */
isMerged: boolean | null; 
/**
 * True for remote tracking branches, false for local
 */
isRemote: boolean; 
/**
 * Remote name (e.g., "origin") for remote branches, None for local
 */
remoteName: string | null }
/**
 * Branch type classification for Gitflow-based coloring.
 */
export type BranchType = 
/**
 * Main/master branch - stable production code
 */
"main" | 
/**
 * Develop branch - integration branch for features
 */
"develop" | 
/**
 * Feature branches - new features in development
 */
"feature" | 
/**
 * Release branches - preparing for production release
 */
"release" | 
/**
 * Hotfix branches - urgent production fixes
 */
"hotfix" | 
/**
 * Other branches that don't follow Gitflow naming
 */
"other"
/**
 * A commit entry for the changelog.
 */
export type ChangelogCommit = { 
/**
 * Short commit hash.
 */
hash: string; 
/**
 * Commit scope (optional).
 */
scope: string | null; 
/**
 * Commit description.
 */
description: string; 
/**
 * Whether this is a breaking change.
 */
breaking: boolean; 
/**
 * Commit author name.
 */
author: string; 
/**
 * Commit date in ISO format.
 */
date: string }
/**
 * Output from changelog generation.
 */
export type ChangelogOutput = { 
/**
 * Rendered markdown changelog.
 */
markdown: string; 
/**
 * Total number of commits included.
 */
commitCount: number; 
/**
 * Commits grouped by type.
 */
groups: CommitGroup[] }
/**
 * Progress events for clone operations.
 * 
 * Uses tagged enum serialization for frontend type safety.
 */
export type CloneProgress = 
/**
 * Clone operation started
 */
{ event: "started"; data: { url: string } } | 
/**
 * Receiving objects from remote
 */
{ event: "receiving"; data: { received: number; total: number; bytes: number } } | 
/**
 * Resolving deltas
 */
{ event: "resolving"; data: { current: number; total: number } } | 
/**
 * Checking out files
 */
{ event: "checkout"; data: { current: number; total: number; path: string } } | 
/**
 * Clone completed successfully
 */
{ event: "finished"; data: { path: string } }
/**
 * Full details of a commit.
 */
export type CommitDetails = { oid: string; shortOid: string; message: string; authorName: string; authorEmail: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number)
 */
authorTimestampMs: number; committerName: string; committerEmail: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number)
 */
committerTimestampMs: number; parentOids: string[]; filesChanged: FileChanged[] }
/**
 * Complete commit graph with nodes and edges for visualization.
 */
export type CommitGraph = { 
/**
 * All commit nodes in topological order
 */
nodes: GraphNode[]; 
/**
 * Edges representing parent-child relationships
 */
edges: GraphEdge[] }
/**
 * A group of commits by type.
 */
export type CommitGroup = { 
/**
 * Commit type (e.g., "feat", "fix").
 */
commitType: string; 
/**
 * Display title (e.g., "Features", "Bug Fixes").
 */
title: string; 
/**
 * Emoji for the commit type (e.g., sparkles for feat).
 */
emoji: string; 
/**
 * Commits in this group.
 */
commits: ChangelogCommit[] }
/**
 * Information about a created commit.
 * 
 * Returned after successful commit creation to confirm
 * the commit was made and provide its identifiers.
 */
export type CommitInfo = { 
/**
 * Full commit OID (40 hex characters)
 */
oid: string; 
/**
 * Short commit OID (7 characters)
 */
shortOid: string; 
/**
 * Commit message
 */
message: string }
/**
 * Summary of a commit for list display.
 */
export type CommitSummary = { oid: string; shortOid: string; messageSubject: string; authorName: string; authorEmail: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number up to year 275760)
 */
timestampMs: number }
/**
 * Commit type enumeration.
 */
export type CommitType = "feat" | "fix" | "docs" | "style" | "refactor" | "perf" | "test" | "chore" | "ci" | "build" | "revert"
/**
 * Confidence level for type inference.
 */
export type Confidence = "high" | "medium" | "low"
/**
 * Options for creating a new worktree.
 */
export type CreateWorktreeOptions = { 
/**
 * Name for the worktree
 */
name: string; 
/**
 * Path where the worktree will be created
 */
path: string; 
/**
 * Branch to checkout (None for detached HEAD at current commit)
 */
branch: string | null; 
/**
 * If true and branch is Some, create a new branch with that name
 */
createBranch: boolean }
/**
 * A single diff hunk with line range information.
 */
export type DiffHunk = { oldStart: number; oldLines: number; newStart: number; newLines: number; header: string }
/**
 * A single file change with its status and optional diff stats.
 */
export type FileChange = { path: string; status: FileStatus; additions: number | null; deletions: number | null }
/**
 * A file changed in a commit.
 */
export type FileChanged = { path: string; status: string; additions: number; deletions: number }
/**
 * Complete file diff with old/new content for Monaco DiffEditor.
 */
export type FileDiff = { path: string; oldContent: string; newContent: string; hunks: DiffHunk[]; isBinary: boolean; language: string }
/**
 * Status of a file in the working directory or index.
 */
export type FileStatus = "modified" | "added" | "deleted" | { renamed: { old_path: string } } | "untracked" | "conflicted"
/**
 * Flow type for active workflow.
 */
export type FlowType = "feature" | "release" | "hotfix"
/**
 * Git operation errors that serialize across the IPC boundary.
 * 
 * These errors are sent to the frontend as typed objects,
 * allowing proper error handling in TypeScript.
 */
export type GitError = { type: "NotFound"; message: string } | { type: "NotARepository"; message: string } | { type: "EmptyRepository" } | { type: "StatusError"; message: string } | { type: "OperationFailed"; message: string } | { type: "PathNotFound"; message: string } | { type: "Internal"; message: string } | { type: "NoStagedChanges" } | { type: "SignatureError"; message: string } | { type: "RemoteNotFound"; message: string } | { type: "AuthenticationFailed"; message: string } | { type: "PushRejected"; message: string } | { type: "NetworkError"; message: string } | { type: "BranchNotFound"; message: string } | { type: "CannotDeleteCurrentBranch" } | { type: "BranchNotMerged"; message: string } | { type: "InvalidBranchName"; message: string } | { type: "BranchAlreadyExists"; message: string } | { type: "DirtyWorkingDirectory" } | { type: "StashNotFound"; message: number } | { type: "NothingToStash" } | { type: "TagAlreadyExists"; message: string } | { type: "TagNotFound"; message: string } | { type: "NoMergeInProgress" } | { type: "InvalidUrl"; message: string } | { type: "PathExists"; message: string } | { type: "CloneFailed"; message: string } | { type: "InvalidPath"; message: string }
/**
 * Snapshot of relevant global git configuration values.
 */
export type GitGlobalConfig = { 
/**
 * user.name from global config, or None if unset.
 */
userName: string | null; 
/**
 * user.email from global config, or None if unset.
 */
userEmail: string | null; 
/**
 * init.defaultBranch from global config, or None if unset.
 */
defaultBranch: string | null }
/**
 * Configuration for Gitflow initialization.
 */
export type GitflowConfig = { 
/**
 * Main/production branch name (e.g., "main" or "master")
 */
mainBranch: string; 
/**
 * Development branch name (e.g., "develop")
 */
developBranch: string; 
/**
 * Prefix for feature branches (e.g., "feature/")
 */
featurePrefix: string; 
/**
 * Prefix for release branches (e.g., "release/")
 */
releasePrefix: string; 
/**
 * Prefix for hotfix branches (e.g., "hotfix/")
 */
hotfixPrefix: string }
/**
 * Context about the repository's Gitflow state.
 */
export type GitflowContext = { 
/**
 * Current Gitflow state derived from branch name
 */
state: GitflowState; 
/**
 * Current branch name
 */
currentBranch: string; 
/**
 * Whether the repository has a main/master branch
 */
hasMain: boolean; 
/**
 * Whether the repository has a develop branch
 */
hasDevelop: boolean; 
/**
 * Whether the repository has Gitflow initialized (config in .git/config)
 */
isInitialized: boolean }
/**
 * Gitflow operation errors that serialize across the IPC boundary.
 */
export type GitflowError = 
/**
 * Wrong branch context for the requested operation
 */
{ type: "InvalidContext"; data: { expected: string; actual: string } } | 
/**
 * Operation requires being on a feature branch
 */
{ type: "NotOnFeatureBranch" } | 
/**
 * Operation requires being on a release branch
 */
{ type: "NotOnReleaseBranch" } | 
/**
 * Operation requires being on a hotfix branch
 */
{ type: "NotOnHotfixBranch" } | 
/**
 * A release is already in progress
 */
{ type: "ReleaseInProgress"; data: string } | 
/**
 * A hotfix is already in progress
 */
{ type: "HotfixInProgress"; data: string } | 
/**
 * Merge conflicts encountered during finish operation
 */
{ type: "MergeConflict" } | 
/**
 * Working directory has uncommitted changes
 */
{ type: "DirtyWorkingTree" } | 
/**
 * Repository has no commits yet
 */
{ type: "UnbornHead" } | 
/**
 * Specified branch was not found
 */
{ type: "BranchNotFound"; data: string } | 
/**
 * Branch already exists
 */
{ type: "BranchExists"; data: string } | 
/**
 * Repository is not configured for Gitflow (missing main or develop)
 */
{ type: "NotGitflowRepo" } | 
/**
 * Invalid branch name for Gitflow
 */
{ type: "InvalidBranchName"; data: string } | 
/**
 * Wrapped git2 error
 */
{ type: "Git"; data: string }
/**
 * Result of Gitflow initialization.
 */
export type GitflowInitResult = { 
/**
 * Whether the develop branch was created (false if it already existed)
 */
developCreated: boolean; 
/**
 * Whether we switched to the develop branch
 */
switchedToDevelop: boolean }
/**
 * The current state of the Gitflow workflow.
 */
export type GitflowState = 
/**
 * No active workflow (on main, develop, or other)
 */
{ type: "Idle" } | 
/**
 * Working on a feature branch
 */
{ type: "Feature"; data: { name: string } } | 
/**
 * Working on a release branch
 */
{ type: "Release"; data: { version: string } } | 
/**
 * Working on a hotfix branch
 */
{ type: "Hotfix"; data: { name: string } }
/**
 * Status of Gitflow operations for UI consumption.
 */
export type GitflowStatus = { currentBranch: string; isGitflowReady: boolean; canStartFeature: boolean; canFinishFeature: boolean; canStartRelease: boolean; canFinishRelease: boolean; canStartHotfix: boolean; canFinishHotfix: boolean; canAbort: boolean; activeFlow: ActiveFlow | null; 
/**
 * Context about the repository's Gitflow state
 */
context: GitflowContext }
/**
 * An edge in the commit graph connecting parent and child commits.
 */
export type GraphEdge = { 
/**
 * SHA of the child commit (the commit that has this parent)
 */
from: string; 
/**
 * SHA of the parent commit
 */
to: string }
/**
 * A node in the commit graph representing a single commit.
 */
export type GraphNode = { 
/**
 * Full SHA-1 hash of the commit (40 chars)
 */
oid: string; 
/**
 * Short SHA-1 hash of the commit (7 chars)
 */
shortOid: string; 
/**
 * First line of the commit message
 */
message: string; 
/**
 * Author name
 */
author: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number up to year 275760)
 */
timestampMs: number; 
/**
 * Parent commit SHAs
 */
parents: string[]; 
/**
 * Classification of the branch type for coloring
 */
branchType: BranchType; 
/**
 * Lane/column position for visual layout (0-indexed from left)
 */
column: number; 
/**
 * Branch names pointing to this commit
 */
branchNames: string[]; 
/**
 * Whether this commit is a first-parent ancestor of HEAD
 */
isHeadAncestor: boolean; 
/**
 * The "ideological branch" name that owns this commit for coloring
 */
ideologicalBranch: string }
/**
 * Result of a successful git init operation.
 */
export type InitResult = { 
/**
 * Absolute path to the initialized repository.
 */
repoPath: string; 
/**
 * Name of the initial branch (e.g. "main").
 */
initialBranch: string }
/**
 * Last commit message with subject and body parsed separately.
 * 
 * Used for amend commit pre-fill functionality.
 */
export type LastCommitMessage = { 
/**
 * First line of the commit message
 */
subject: string; 
/**
 * Everything after the first blank line (if exists)
 */
body: string | null; 
/**
 * Full commit message
 */
fullMessage: string }
/**
 * Result of merge analysis.
 */
export type MergeAnalysisResult = 
/**
 * Already merged, nothing to do
 */
"upToDate" | 
/**
 * Can fast-forward without merge commit
 */
"fastForward" | 
/**
 * Requires merge commit
 */
"normal" | 
/**
 * HEAD doesn't exist yet
 */
"unborn"
/**
 * Result of a merge operation.
 */
export type MergeResult = { 
/**
 * Whether the merge was successful
 */
success: boolean; 
/**
 * Analysis result (what type of merge was performed)
 */
analysis: MergeAnalysisResult; 
/**
 * OID of merge commit (if created)
 */
commitOid: string | null; 
/**
 * True if fast-forward was used
 */
fastForwarded: boolean; 
/**
 * True if conflicts remain
 */
hasConflicts: boolean; 
/**
 * List of conflicted file paths
 */
conflictedFiles: string[] }
/**
 * Status of an in-progress merge.
 */
export type MergeStatus = { 
/**
 * Whether a merge is currently in progress
 */
inProgress: boolean; 
/**
 * List of conflicted file paths
 */
conflictedFiles: string[] }
/**
 * A recently checked-out branch extracted from the reflog.
 */
export type RecentCheckout = { 
/**
 * Branch name (bare, without refs/heads/ prefix)
 */
name: string; 
/**
 * Unix timestamp in milliseconds when the checkout occurred
 */
lastCheckoutMs: number }
/**
 * Information about a configured remote.
 */
export type RemoteInfo = { name: string; url: string }
/**
 * File content read from the repository at HEAD.
 */
export type RepoFileContent = { content: string; isBinary: boolean; size: number }
/**
 * A single entry in a repository directory listing.
 */
export type RepoFileEntry = { name: string; path: string; isDir: boolean; size: number }
/**
 * Repository status information sent to frontend.
 * 
 * This is a lightweight summary - we don't send raw git2 objects
 * across the IPC boundary.
 */
export type RepoStatus = { 
/**
 * Current branch name (or short commit hash if detached)
 */
branchName: string; 
/**
 * Whether the working directory has uncommitted changes
 */
isDirty: boolean; 
/**
 * Absolute path to the repository root
 */
repoPath: string; 
/**
 * Repository display name (folder name)
 */
repoName: string }
/**
 * A scope suggestion from commit history.
 */
export type ScopeSuggestion = { 
/**
 * The scope string.
 */
scope: string; 
/**
 * Number of times this scope has been used.
 */
usageCount: number }
/**
 * Complete staging status showing staged, unstaged, and untracked files.
 */
export type StagingStatus = { staged: FileChange[]; unstaged: FileChange[]; untracked: FileChange[] }
/**
 * A stash entry representing saved work.
 */
export type StashEntry = { 
/**
 * 0-based index for stash operations
 */
index: number; 
/**
 * Stash message
 */
message: string; 
/**
 * Commit OID of the stash
 */
oid: string }
/**
 * Progress events for remote sync operations.
 * Uses tagged enum serialization for frontend type safety.
 */
export type SyncProgress = { event: "started"; data: { operation: string } } | { event: "counting"; data: { current: number; total: number } } | { event: "compressing"; data: { current: number; total: number } } | { event: "transferring"; data: { current: number; total: number; bytes: number } } | { event: "resolving"; data: { current: number; total: number } } | { event: "finished"; data: { operation: string } } | { event: "error"; data: { message: string } }
/**
 * Result of a sync operation (push/pull/fetch).
 */
export type SyncResult = { success: boolean; message: string; commitsTransferred: number }
/**
 * Information about a git tag.
 */
export type TagInfo = { 
/**
 * Tag name (e.g., "v1.0.0")
 */
name: string; 
/**
 * OID of the tag object (for annotated) or target commit (for lightweight)
 */
oid: string; 
/**
 * OID of the commit the tag points to
 */
targetOid: string; 
/**
 * Tag message (None for lightweight tags)
 */
message: string | null; 
/**
 * Tagger name (None for lightweight tags)
 */
tagger: string | null; 
/**
 * True for annotated tags, false for lightweight
 */
isAnnotated: boolean; 
/**
 * Creation timestamp in milliseconds since epoch
 */
createdAtMs: number }
/**
 * A suggested commit type based on file analysis.
 */
export type TypeSuggestion = { 
/**
 * The suggested commit type.
 */
suggestedType: CommitType; 
/**
 * Confidence level of the suggestion.
 */
confidence: Confidence; 
/**
 * Reason for the suggestion.
 */
reason: string }
/**
 * Information about what can be undone
 */
export type UndoInfo = { 
/**
 * Whether undo is available
 */
canUndo: boolean; 
/**
 * Description of what will be undone
 */
description: string | null; 
/**
 * The reflog entry message
 */
reflogMessage: string | null; 
/**
 * The commit OID to revert to
 */
targetOid: string | null }
/**
 * A validation error.
 */
export type ValidationError = { 
/**
 * Error code for programmatic handling.
 */
code: string; 
/**
 * Human-readable error message.
 */
message: string; 
/**
 * Optional suggestion for fixing the error.
 */
suggestion: string | null }
/**
 * Result of validating a commit message.
 */
export type ValidationResult = { 
/**
 * Whether the message is valid.
 */
isValid: boolean; 
/**
 * Validation errors (if any).
 */
errors: ValidationError[]; 
/**
 * Validation warnings (if any).
 */
warnings: ValidationWarning[] }
/**
 * A validation warning.
 */
export type ValidationWarning = { 
/**
 * Warning code for programmatic handling.
 */
code: string; 
/**
 * Human-readable warning message.
 */
message: string }
/**
 * Information about a git worktree.
 */
export type WorktreeInfo = { 
/**
 * Worktree name (for linked worktrees) or "main" for the main worktree
 */
name: string; 
/**
 * Absolute path to the worktree directory
 */
path: string; 
/**
 * Branch checked out in this worktree (None if detached HEAD)
 */
branch: string | null; 
/**
 * Current status of the worktree
 */
status: WorktreeStatus; 
/**
 * True if this is the main worktree (not a linked worktree)
 */
isMain: boolean; 
/**
 * True if the worktree is locked
 */
isLocked: boolean }
/**
 * Status of a worktree's working directory.
 */
export type WorktreeStatus = 
/**
 * No uncommitted changes
 */
"clean" | 
/**
 * Has uncommitted changes
 */
"dirty" | 
/**
 * Has unresolved merge conflicts
 */
"conflicts" | 
/**
 * Worktree is invalid or corrupted
 */
"invalid"

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
