
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Open a Git repository at the specified path.
 * 
 * Validates the path exists and is a git repository,
 * then stores it as the current active repository.
 * Also starts a file watcher to detect external changes.
 */
async openRepository(path: string) : Promise<Result<RepoStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_repository", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current repository status.
 * 
 * Returns branch name and dirty status for the currently open repository.
 */
async getRepositoryStatus() : Promise<Result<RepoStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_repository_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if a path is a valid Git repository.
 * 
 * Used for drag-drop validation before attempting to open.
 */
async isGitRepository(path: string) : Promise<Result<boolean, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_git_repository", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Close the current repository.
 * 
 * Stops the file watcher and clears the stored repository path.
 */
async closeRepository() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_repository") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current staging status of the repository.
 * 
 * Returns files grouped by staged (in index), unstaged (modified in workdir),
 * and untracked (new files not yet added).
 */
async getStagingStatus() : Promise<Result<StagingStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_staging_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage a single file for commit.
 * 
 * The path must be relative to the repository root.
 */
async stageFile(path: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage a single file (remove from index, keep workdir changes).
 * 
 * The path must be relative to the repository root.
 */
async unstageFile(path: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage multiple files for commit in a single operation.
 * 
 * More efficient than calling stage_file repeatedly — performs a single index write.
 * Paths must be relative to the repository root.
 */
async stageFiles(paths: string[]) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_files", { paths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage multiple files (remove from index, keep workdir changes).
 * 
 * More efficient than calling unstage_file repeatedly — performs a single reset.
 * Paths must be relative to the repository root.
 */
async unstageFiles(paths: string[]) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_files", { paths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage all changed files.
 * 
 * Adds all modified, deleted, and new files to the index.
 */
async stageAll() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage all staged files.
 * 
 * Resets the index to match HEAD, keeping workdir changes.
 */
async unstageAll() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the diff for a specific file.
 * 
 * If `staged` is true, shows diff between HEAD and index.
 * If `staged` is false, shows diff between index and workdir.
 */
async getFileDiff(path: string, staged: boolean, contextLines: number) : Promise<Result<FileDiff, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_file_diff", { path, staged, contextLines }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get detailed per-line diff hunks for a file.
 * Returns enriched hunk data with individual line origins for interactive staging.
 */
async getFileDiffHunks(path: string, staged: boolean) : Promise<Result<DiffHunkDetail[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_file_diff_hunks", { path, staged }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage specific hunks of a file.
 * Uses Repository::apply() with hunk_callback to selectively stage hunks.
 */
async stageHunks(path: string, hunkIndices: number[]) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_hunks", { path, hunkIndices }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage specific hunks of a file.
 * Reverse-applies staged hunks by reconstructing content from HEAD.
 */
async unstageHunks(path: string, hunkIndices: number[]) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_hunks", { path, hunkIndices }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stage specific lines within a hunk.
 * Uses index.add_frombuffer() to construct partial staging content.
 */
async stageLines(path: string, hunkIndex: number, lineRanges: LineRange[]) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stage_lines", { path, hunkIndex, lineRanges }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unstage specific lines within a hunk.
 * Reverse of stage_lines: reverts selected lines back to HEAD state.
 */
async unstageLines(path: string, hunkIndex: number, lineRanges: LineRange[]) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unstage_lines", { path, hunkIndex, lineRanges }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the diff for a specific file at a given commit.
 *
 * Shows the changes introduced by the commit (parent -> commit).
 */
async getCommitFileDiff(oid: string, path: string, contextLines: number) : Promise<Result<FileDiff, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_file_diff", { oid, path, contextLines }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a file's binary content as a base64 data URI from the working tree.
 * 
 * Returns a data URI like `data:image/png;base64,...` for use in `<img>` tags.
 */
async getFileBase64(filePath: string) : Promise<Result<string, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_file_base64", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a file's binary content as a base64 data URI from a specific commit.
 * 
 * Extracts the blob from the commit's tree and returns it as a data URI.
 */
async getCommitFileBase64(oid: string, filePath: string) : Promise<Result<string, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_file_base64", { oid, filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new commit from staged changes.
 * 
 * Creates a commit with the given message from the current index (staged changes).
 * If `amend` is true, replaces the last commit instead of creating a new one.
 * 
 * # Errors
 * - `NoStagedChanges` if index is empty (nothing staged)
 * - `SignatureError` if git config lacks user.name/email
 * - Various git2 errors for other failures
 */
async createCommit(message: string, amend: boolean) : Promise<Result<CommitInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_commit", { message, amend }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the last commit message for amend pre-fill.
 * 
 * Returns the HEAD commit's message parsed into subject and body components.
 */
async getLastCommitMessage() : Promise<Result<LastCommitMessage, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_last_commit_message") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get paginated commit history.
 * 
 * Returns commits starting from HEAD, sorted by time.
 * Use skip and limit for pagination.
 */
async getCommitHistory(skip: number, limit: number) : Promise<Result<CommitSummary[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_history", { skip, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get full details of a specific commit.
 */
async getCommitDetails(oid: string) : Promise<Result<CommitDetails, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_details", { oid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Search commits by message text.
 * Returns up to `limit` commits whose message contains `query` (case-insensitive).
 */
async searchCommits(query: string, limit: number) : Promise<Result<CommitSummary[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_commits", { query, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * IPC command to get the commit graph for visualization.
 * 
 * # Arguments
 * * `limit` - Maximum number of commits to return (default: 100, max: 500)
 * * `offset` - Number of commits to skip (default: 0)
 * * `state` - Repository state containing the current repo path
 * 
 * # Returns
 * A CommitGraph containing nodes and edges for visualization.
 */
async getCommitGraph(limit: number | null, offset: number | null) : Promise<Result<CommitGraph, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_commit_graph", { limit, offset }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all configured remotes for the current repository.
 */
async getRemotes() : Promise<Result<RemoteInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_remotes") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch from a remote without merging.
 * 
 * Downloads objects and refs from the remote but does not modify
 * the working directory or current branch.
 */
async fetchFromRemote(remote: string, onProgress: TAURI_CHANNEL<SyncProgress>) : Promise<Result<SyncResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_from_remote", { remote, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Push current branch to a remote.
 * 
 * Sends local commits to the remote repository.
 */
async pushToRemote(remote: string, onProgress: TAURI_CHANNEL<SyncProgress>) : Promise<Result<SyncResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("push_to_remote", { remote, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Pull from a remote (fetch + merge).
 * 
 * Downloads objects from the remote and merges the tracking branch
 * into the current branch. Fast-forward merges are preferred.
 */
async pullFromRemote(remote: string, onProgress: TAURI_CHANNEL<SyncProgress>) : Promise<Result<SyncResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pull_from_remote", { remote, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all local branches in the repository.
 */
async listBranches() : Promise<Result<BranchInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_branches") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new branch from HEAD.
 */
async createBranch(name: string, checkout: boolean) : Promise<Result<BranchInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_branch", { name, checkout }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Switch to an existing branch.
 */
async checkoutBranch(branchName: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("checkout_branch", { branchName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a local branch.
 */
async deleteBranch(branchName: string, force: boolean) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_branch", { branchName, force }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all branches (local and optionally remote) in the repository.
 */
async listAllBranches(includeRemote: boolean) : Promise<Result<BranchInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_all_branches", { includeRemote }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checkout a remote branch by creating a local tracking branch.
 */
async checkoutRemoteBranch(remoteBranch: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("checkout_remote_branch", { remoteBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete multiple local branches in a single batch operation.
 */
async batchDeleteBranches(branchNames: string[], force: boolean) : Promise<Result<BatchDeleteResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("batch_delete_branches", { branchNames, force }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get recently checked-out branches from the HEAD reflog.
 */
async getRecentCheckouts(limit: number | null) : Promise<Result<RecentCheckout[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recent_checkouts", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get ahead/behind counts for a local branch relative to its upstream.
 * 
 * Returns `{ ahead: 0, behind: 0 }` when the branch has no upstream tracking branch.
 */
async getBranchAheadBehind(branchName: string) : Promise<Result<AheadBehind, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_branch_ahead_behind", { branchName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all stash entries in the repository.
 */
async listStashes() : Promise<Result<StashEntry[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_stashes") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save current changes to stash.
 */
async stashSave(message: string | null, includeUntracked: boolean) : Promise<Result<string, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_save", { message, includeUntracked }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Apply a stash by index without removing it.
 */
async stashApply(index: number) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_apply", { index }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Apply a stash by index and remove it from the stash list.
 */
async stashPop(index: number) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_pop", { index }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Drop a stash by index without applying it.
 */
async stashDrop(index: number) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stash_drop", { index }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all tags in the repository.
 */
async listTags() : Promise<Result<TagInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_tags") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new tag.
 */
async createTag(name: string, message: string | null, targetOid: string | null) : Promise<Result<TagInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_tag", { name, message, targetOid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a tag by name.
 */
async deleteTag(name: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_tag", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Merge a source branch into the current branch.
 */
async mergeBranch(sourceBranch: string) : Promise<Result<MergeResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("merge_branch", { sourceBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the status of an in-progress merge.
 */
async getMergeStatus() : Promise<Result<MergeStatus, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_merge_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Abort an in-progress merge.
 */
async abortMerge() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("abort_merge") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all conflicted file paths from the git index.
 * 
 * Returns an empty Vec if no conflicts exist (not an error).
 */
async listConflictFiles() : Promise<Result<string[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_conflict_files") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Read ours/theirs/base content for a specific conflicted file from index stages.
 * 
 * Uses git2 index stages (1=ancestor, 2=ours, 3=theirs) to read clean content
 * without conflict markers. Returns NotFound if the file is not in the conflict list.
 */
async getConflictContent(path: string) : Promise<Result<ConflictContent, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_conflict_content", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Write resolved content to a conflicted file, stage it, and clear the conflict.
 * 
 * Writes the resolved content to the working directory file, then stages it
 * via `index.add_path()` which automatically clears the conflict entry.
 */
async resolveConflictFile(path: string, content: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resolve_conflict_file", { path, content }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize Gitflow on a repository.
 * 
 * This command:
 * 1. Verifies the main branch exists
 * 2. Creates the develop branch if it doesn't exist
 * 3. Stores configuration in .git/config for git-flow CLI compatibility
 * 4. Checks out the develop branch
 * 5. Optionally pushes develop to origin
 */
async initGitflow(config: GitflowConfig, pushDevelop: boolean) : Promise<Result<GitflowInitResult, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_gitflow", { config, pushDevelop }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new feature branch from develop.
 */
async startFeature(name: string) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_feature", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finish the current feature branch, merging to develop.
 */
async finishFeature() : Promise<Result<null, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("finish_feature") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new release branch from develop.
 */
async startRelease(version: string) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_release", { version }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finish the current release branch.
 * Merges to main AND develop, creates version tag, deletes branch.
 */
async finishRelease(tagMessage: string | null) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("finish_release", { tagMessage }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new hotfix branch from main.
 */
async startHotfix(name: string) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_hotfix", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finish the current hotfix branch.
 * Merges to main AND develop, creates tag, deletes branch.
 */
async finishHotfix(tagMessage: string | null) : Promise<Result<string, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("finish_hotfix", { tagMessage }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get current Gitflow status for UI.
 */
async getGitflowStatus() : Promise<Result<GitflowStatus, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_gitflow_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Abort current Gitflow operation, returning to source branch.
 */
async abortGitflow() : Promise<Result<null, GitflowError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("abort_gitflow") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate a conventional commit message.
 * 
 * Returns validation result with errors and warnings.
 */
async validateConventionalCommit(message: string) : Promise<ValidationResult> {
    return await TAURI_INVOKE("validate_conventional_commit", { message });
},
/**
 * Suggest a commit type based on staged files.
 * 
 * Analyzes the currently staged files and returns a type suggestion
 * with confidence level.
 */
async suggestCommitType() : Promise<Result<TypeSuggestion, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("suggest_commit_type") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get scope suggestions from commit history.
 * 
 * Extracts scopes used in previous commits, sorted by frequency.
 */
async getScopeSuggestions(limit: number | null) : Promise<Result<ScopeSuggestion[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_scope_suggestions", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Infer scope from staged files based on common directory.
 */
async inferScopeFromStaged() : Promise<Result<string | null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("infer_scope_from_staged") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Generate a changelog from commit history.
 * 
 * Generates markdown changelog grouped by commit type.
 */
async generateChangelogCmd(fromRef: string | null, toRef: string | null, version: string | null) : Promise<Result<ChangelogOutput, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_changelog_cmd", { fromRef, toRef, version }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all worktrees for the current repository.
 */
async listWorktrees() : Promise<Result<WorktreeInfo[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_worktrees") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new worktree.
 */
async createWorktree(options: CreateWorktreeOptions) : Promise<Result<WorktreeInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_worktree", { options }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a worktree.
 */
async deleteWorktree(name: string, force: boolean, deleteBranch: boolean) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_worktree", { name, force, deleteBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get information about what can be undone.
 * Looks at HEAD reflog to find the previous state.
 */
async getUndoInfo() : Promise<Result<UndoInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_undo_info") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Undo the last operation by resetting HEAD to the previous reflog entry.
 */
async undoLastOperation() : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("undo_last_operation") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Clone a Git repository with progress tracking.
 * 
 * Clones a repository from a URL to a local destination path,
 * sending progress events through the provided channel.
 * 
 * # Arguments
 * * `url` - The repository URL (HTTPS or SSH)
 * * `destination` - Local path where the repository will be cloned
 * * `on_progress` - Channel for sending progress events
 * 
 * # Returns
 * The path to the cloned repository on success
 */
async cloneRepository(url: string, destination: string, onProgress: TAURI_CHANNEL<CloneProgress>) : Promise<Result<string, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clone_repository", { url, destination, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize a new Git repository at the specified path.
 * 
 * Validates the path exists and is a directory that is not already a git repository,
 * then creates a new repository with an optional default branch name.
 * 
 * # Arguments
 * * `path` - Directory where the repository will be initialized
 * * `default_branch` - Optional initial branch name (defaults to "main")
 */
async gitInit(path: string, defaultBranch: string | null) : Promise<Result<InitResult, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("git_init", { path, defaultBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all available .gitignore template names.
 * 
 * Attempts to fetch from GitHub API with a 5s timeout, falling back to
 * bundled templates on any error.
 */
async listGitignoreTemplates() : Promise<Result<GitignoreTemplateList, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_gitignore_templates") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the content of a single .gitignore template by name.
 * 
 * Tries GitHub API first, falls back to bundled templates.
 */
async getGitignoreTemplate(name: string) : Promise<Result<GitignoreTemplate, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_gitignore_template", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Detect project types by scanning for marker files in a directory.
 * 
 * Returns all detected project types with recommended .gitignore templates.
 */
async detectProjectType(path: string) : Promise<Result<ProjectDetection, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("detect_project_type", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Write initialization files (.gitignore, README.md, etc.) to a directory.
 */
async writeInitFiles(path: string, files: InitFile[]) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("write_init_files", { path, files }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch NuGet package information by package ID.
 * 
 * Queries the NuGet Search API and Registration API, returning
 * combined package metadata.
 */
async fetchNugetInfo(packageId: string) : Promise<Result<NugetPackageInfo, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_nuget_info", { packageId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List files and directories at a given path within the repository.
 * 
 * Merges entries from the HEAD tree and the working directory so that
 * uncommitted/untracked files are also visible in the browser.
 * Pass an empty string for `path` to list the root directory.
 * Returns directories first, then files, both sorted alphabetically.
 */
async listRepoFiles(path: string) : Promise<Result<RepoFileEntry[], GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_repo_files", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Read file content from the repository at HEAD, with working-directory fallback.
 * 
 * First tries the git HEAD tree. If the file is not found there (e.g. uncommitted),
 * falls back to reading from the working directory on disk.
 * Binary files are returned as base64-encoded content.
 * Text files are returned as UTF-8 strings.
 */
async readRepoFile(filePath: string) : Promise<Result<RepoFileContent, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_repo_file", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Read the user's global git configuration.
 * 
 * Returns None for any value that is not set. Never errors —
 * if the config file cannot be opened, all fields are None.
 */
async getGitGlobalConfig() : Promise<Result<GitGlobalConfig, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_git_global_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set a value in the user's global git configuration.
 * 
 * # Arguments
 * * `key` - The config key (e.g. "user.name", "user.email", "init.defaultBranch")
 * * `value` - The value to set
 */
async setGitGlobalConfig(key: string, value: string) : Promise<Result<null, GitError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_git_global_config", { key, value }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Discover extensions by scanning subdirectories for `flowforge.extension.json` manifests.
 * 
 * - If the `extensions_dir` does not exist, returns an empty array (extensions are optional).
 * - Invalid manifests (bad JSON, missing required fields) are skipped with a warning log.
 * - Only truly unrecoverable I/O errors (e.g. permission denied on an existing directory)
 * return `Err`.
 */
async discoverExtensions(extensionsDir: string) : Promise<Result<ExtensionManifest[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discover_extensions", { extensionsDir }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch an extension manifest from a Git repository URL.
 * 
 * Clones the repo to a temp directory, reads the manifest file,
 * and returns both the manifest JSON and the temp path for subsequent install.
 */
async extensionFetchManifest(gitUrl: string) : Promise<Result<ExtensionFetchResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("extension_fetch_manifest", { gitUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Install an extension from a previously fetched temp path.
 * 
 * Moves the cloned repository to the extensions directory under
 * the extension's ID extracted from the manifest.
 */
async extensionInstall(tempPath: string, extensionsDir: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("extension_install", { tempPath, extensionsDir }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Uninstall an extension by removing its directory.
 */
async extensionUninstall(extensionId: string, extensionsDir: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("extension_uninstall", { extensionId, extensionsDir }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Cancel an in-progress extension install by cleaning up the temp directory.
 */
async extensionCancelInstall(tempPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("extension_cancel_install", { tempPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initiate the GitHub OAuth Device Flow.
 * 
 * Returns device_code, user_code, and verification_uri for the frontend
 * to display to the user. The user visits the URI and enters the code.
 */
async githubStartDeviceFlow(scopes: string[]) : Promise<Result<DeviceFlowResponse, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_start_device_flow", { scopes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Poll GitHub for authorization status (single attempt).
 * 
 * This is NOT a loop -- the frontend controls polling via setTimeout
 * and calls this command once per interval. This avoids long-running
 * Tauri commands and gives the frontend full control over the UX.
 * 
 * Returns `AuthResult` on success or specific error variants that
 * the frontend uses for control flow:
 * - `AuthorizationPending`: user hasn't authorized yet, keep polling
 * - `SlowDown`: increase polling interval by 5 seconds
 * - `ExpiredToken`: device code expired, need to restart flow
 * - `AccessDenied`: user denied authorization
 */
async githubPollAuth(deviceCode: string, interval: number) : Promise<Result<AuthResult, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_poll_auth", { deviceCode, interval }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if the user is authenticated and return their info.
 * Validates the stored token against the GitHub API.
 * If the token is invalid, auto-deletes it from the keychain.
 */
async githubGetAuthStatus() : Promise<Result<AuthResult, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_get_auth_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Sign out by deleting the token from the OS keychain.
 */
async githubSignOut() : Promise<Result<null, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_sign_out") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Detect all GitHub remotes in the currently open repository.
 * 
 * Opens the git repository from RepositoryState (same pattern as
 * existing git commands) and iterates all remotes, parsing each
 * URL to find GitHub repositories.
 */
async githubDetectRemotes() : Promise<Result<GitHubRemoteInfo[], GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_detect_remotes") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check the current GitHub API rate limit for the authenticated user.
 * 
 * Retrieves the token from the keychain and queries the GitHub
 * rate limit endpoint to return current usage information.
 */
async githubCheckRateLimit() : Promise<Result<RateLimitInfo, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_check_rate_limit") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List pull requests for a repository with pagination.
 * 
 * Returns a paginated list of pull request summaries sorted by
 * most recently updated. The `state` parameter can be "open",
 * "closed", or "all".
 */
async githubListPullRequests(owner: string, repo: string, state: string, page: number, perPage: number) : Promise<Result<PullRequestListResponse, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_list_pull_requests", { owner, repo, state, page, perPage }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch full details for a single pull request including comments.
 * 
 * Makes two API calls: one for the PR detail and one for
 * the issue comments (which includes general discussion comments).
 */
async githubGetPullRequest(owner: string, repo: string, number: number) : Promise<Result<PullRequestDetail, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_get_pull_request", { owner, repo, number }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List issues for a repository with pagination.
 * 
 * Returns a paginated list of issue summaries sorted by most recently
 * updated. Pull requests are filtered out (GitHub's issues API returns
 * both issues and PRs). The `state` parameter can be "open", "closed",
 * or "all".
 */
async githubListIssues(owner: string, repo: string, state: string, page: number, perPage: number) : Promise<Result<IssueListResponse, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_list_issues", { owner, repo, state, page, perPage }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch full details for a single issue including comments.
 * 
 * Makes two API calls: one for the issue detail and one for
 * all comments on the issue.
 */
async githubGetIssue(owner: string, repo: string, number: number) : Promise<Result<IssueDetail, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_get_issue", { owner, repo, number }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Merge a pull request with a specified merge strategy.
 * 
 * Calls the GitHub REST API PUT endpoint for merging.
 * Supports merge commit, squash, and rebase strategies.
 */
async githubMergePullRequest(owner: string, repo: string, pullNumber: number, mergeMethod: string, commitTitle: string | null, commitMessage: string | null, sha: string | null) : Promise<Result<MergePullRequestResult, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_merge_pull_request", { owner, repo, pullNumber, mergeMethod, commitTitle, commitMessage, sha }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new pull request.
 * 
 * Creates a PR from the specified head branch to the base branch.
 * Optionally creates it as a draft.
 */
async githubCreatePullRequest(owner: string, repo: string, title: string, head: string, base: string, body: string | null, draft: boolean | null) : Promise<Result<CreatePullRequestResult, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_create_pull_request", { owner, repo, title, head, base, body, draft }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get branch information for pre-filling the Create PR form.
 * 
 * Reads the current branch, detects the default base (main/master),
 * generates a title from the branch name, and collects commit
 * messages ahead of the base branch.
 */
async githubGetBranchInfoForPr() : Promise<Result<BranchInfoForPr, GitHubError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("github_get_branch_info_for_pr") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Information about active Gitflow workflow.
 */
export type ActiveFlow = { flowType: FlowType; name: string; sourceBranch: string }
/**
 * How many commits a local branch is ahead/behind its upstream.
 */
export type AheadBehind = { 
/**
 * Commits on local not yet on upstream
 */
ahead: number; 
/**
 * Commits on upstream not yet on local
 */
behind: number }
/**
 * Result of an authentication check or successful auth flow.
 * NEVER contains the actual token -- only metadata about the
 * authenticated user. The token stays in Rust/keychain.
 */
export type AuthResult = { authenticated: boolean; username: string | null; avatarUrl: string | null; scopes: string[] }
/**
 * Result of a batch branch deletion operation.
 */
export type BatchDeleteResult = { 
/**
 * Per-branch results
 */
results: BranchDeleteResult[]; 
/**
 * Count of successfully deleted branches
 */
totalDeleted: number; 
/**
 * Count of branches that failed to delete
 */
totalFailed: number }
/**
 * Result of deleting a single branch in a batch operation.
 */
export type BranchDeleteResult = { 
/**
 * Branch name that was targeted
 */
name: string; 
/**
 * Whether the branch was successfully deleted
 */
deleted: boolean; 
/**
 * Error message if deletion failed
 */
error: string | null }
/**
 * Information about a branch (local or remote).
 */
export type BranchInfo = { 
/**
 * Branch name (e.g., "main", "feature/login", "origin/feature/x")
 */
name: string; 
/**
 * True if this is the currently checked out branch
 */
isHead: boolean; 
/**
 * Short OID of the branch tip commit (7 chars)
 */
lastCommitOid: string; 
/**
 * Summary line of the tip commit
 */
lastCommitMessage: string; 
/**
 * Whether branch is merged into HEAD (None if IS head)
 */
isMerged: boolean | null; 
/**
 * True for remote tracking branches, false for local
 */
isRemote: boolean; 
/**
 * Remote name (e.g., "origin") for remote branches, None for local
 */
remoteName: string | null }
/**
 * Branch information for pre-filling the Create PR form.
 */
export type BranchInfoForPr = { currentBranch: string; defaultBase: string; suggestedTitle: string; commitMessages: string[] }
/**
 * Branch type classification for Gitflow-based coloring.
 */
export type BranchType = 
/**
 * Main/master branch - stable production code
 */
"main" | 
/**
 * Develop branch - integration branch for features
 */
"develop" | 
/**
 * Feature branches - new features in development
 */
"feature" | 
/**
 * Release branches - preparing for production release
 */
"release" | 
/**
 * Hotfix branches - urgent production fixes
 */
"hotfix" | 
/**
 * Other branches that don't follow Gitflow naming
 */
"other"
/**
 * A commit entry for the changelog.
 */
export type ChangelogCommit = { 
/**
 * Short commit hash.
 */
hash: string; 
/**
 * Commit scope (optional).
 */
scope: string | null; 
/**
 * Commit description.
 */
description: string; 
/**
 * Whether this is a breaking change.
 */
breaking: boolean; 
/**
 * Commit author name.
 */
author: string; 
/**
 * Commit date in ISO format.
 */
date: string }
/**
 * Output from changelog generation.
 */
export type ChangelogOutput = { 
/**
 * Rendered markdown changelog.
 */
markdown: string; 
/**
 * Total number of commits included.
 */
commitCount: number; 
/**
 * Commits grouped by type.
 */
groups: CommitGroup[] }
/**
 * Progress events for clone operations.
 * 
 * Uses tagged enum serialization for frontend type safety.
 */
export type CloneProgress = 
/**
 * Clone operation started
 */
{ event: "started"; data: { url: string } } | 
/**
 * Receiving objects from remote
 */
{ event: "receiving"; data: { received: number; total: number; bytes: number } } | 
/**
 * Resolving deltas
 */
{ event: "resolving"; data: { current: number; total: number } } | 
/**
 * Checking out files
 */
{ event: "checkout"; data: { current: number; total: number; path: string } } | 
/**
 * Clone completed successfully
 */
{ event: "finished"; data: { path: string } }
/**
 * Comment info for frontend display.
 */
export type CommentInfo = { id: string; authorLogin: string; authorAvatarUrl: string; body: string; createdAt: string; updatedAt: string; htmlUrl: string }
/**
 * Full details of a commit.
 */
export type CommitDetails = { oid: string; shortOid: string; message: string; authorName: string; authorEmail: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number)
 */
authorTimestampMs: number; committerName: string; committerEmail: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number)
 */
committerTimestampMs: number; parentOids: string[]; filesChanged: FileChanged[] }
/**
 * Complete commit graph with nodes and edges for visualization.
 */
export type CommitGraph = { 
/**
 * All commit nodes in topological order
 */
nodes: GraphNode[]; 
/**
 * Edges representing parent-child relationships
 */
edges: GraphEdge[] }
/**
 * A group of commits by type.
 */
export type CommitGroup = { 
/**
 * Commit type (e.g., "feat", "fix").
 */
commitType: string; 
/**
 * Display title (e.g., "Features", "Bug Fixes").
 */
title: string; 
/**
 * Emoji for the commit type (e.g., sparkles for feat).
 */
emoji: string; 
/**
 * Commits in this group.
 */
commits: ChangelogCommit[] }
/**
 * Information about a created commit.
 * 
 * Returned after successful commit creation to confirm
 * the commit was made and provide its identifiers.
 */
export type CommitInfo = { 
/**
 * Full commit OID (40 hex characters)
 */
oid: string; 
/**
 * Short commit OID (7 characters)
 */
shortOid: string; 
/**
 * Commit message
 */
message: string }
/**
 * Summary of a commit for list display.
 */
export type CommitSummary = { oid: string; shortOid: string; messageSubject: string; authorName: string; authorEmail: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number up to year 275760)
 */
timestampMs: number }
/**
 * Commit type enumeration.
 */
export type CommitType = "feat" | "fix" | "docs" | "style" | "refactor" | "perf" | "test" | "chore" | "ci" | "build" | "revert"
/**
 * Confidence level for type inference.
 */
export type Confidence = "high" | "medium" | "low"
/**
 * Content from all three sides of a merge conflict.
 */
export type ConflictContent = { 
/**
 * Path of the conflicted file (relative to repo root)
 */
path: string; 
/**
 * Content from the "ours" side (current branch / HEAD)
 */
ours: string | null; 
/**
 * Content from the "theirs" side (incoming branch)
 */
theirs: string | null; 
/**
 * Content from the common ancestor (base)
 */
base: string | null; 
/**
 * Label for the "ours" side (e.g., "main" or "HEAD")
 */
oursName: string; 
/**
 * Label for the "theirs" side (e.g., "feature/xyz")
 */
theirsName: string }
/**
 * Result of creating a pull request.
 */
export type CreatePullRequestResult = { number: number; htmlUrl: string; title: string; state: string }
/**
 * Options for creating a new worktree.
 */
export type CreateWorktreeOptions = { 
/**
 * Name for the worktree
 */
name: string; 
/**
 * Path where the worktree will be created
 */
path: string; 
/**
 * Branch to checkout (None for detached HEAD at current commit)
 */
branch: string | null; 
/**
 * If true and branch is Some, create a new branch with that name
 */
createBranch: boolean }
export type DetectedProject = { projectType: string; markerFile: string; recommendedTemplates: string[] }
/**
 * Response from GitHub's device code endpoint.
 * Returned to the frontend so it can display the user_code
 * and verification_uri to the user.
 */
export type DeviceFlowResponse = { deviceCode: string; userCode: string; verificationUri: string; expiresIn: number; interval: number }
/**
 * A single diff hunk with line range information.
 */
export type DiffHunk = { oldStart: number; oldLines: number; newStart: number; newLines: number; header: string }
/**
 * Origin type of a diff line.
 */
export type DiffLineOrigin = "context" | "addition" | "deletion"
/**
 * A single line in a diff hunk with origin and line numbers.
 */
export type DiffLine = { origin: DiffLineOrigin; oldLineno: number | null; newLineno: number | null; content: string }
/**
 * Enhanced diff hunk with per-line detail for interactive staging.
 */
export type DiffHunkDetail = { index: number; oldStart: number; oldLines: number; newStart: number; newLines: number; header: string; lines: DiffLine[] }
/**
 * A contiguous range of lines for partial staging operations.
 */
export type LineRange = { start: number; end: number }
/**
 * A blade type contributed by an extension.
 */
export type ExtensionBladeContribution = { 
/**
 * The blade type identifier (used as the `type` field in navigation).
 */
type: string; 
/**
 * Display title for the blade.
 */
title: string; 
/**
 * Whether only one instance of this blade can be open at a time.
 */
singleton: boolean | null }
/**
 * A command contributed by an extension.
 */
export type ExtensionCommandContribution = { 
/**
 * Unique command identifier.
 */
id: string; 
/**
 * Display title for the command (shown in command palette).
 */
title: string; 
/**
 * Optional category for grouping in the command palette.
 */
category: string | null }
/**
 * Contribution points an extension can register.
 */
export type ExtensionContributes = { 
/**
 * Blade types contributed by this extension.
 */
blades: ExtensionBladeContribution[] | null; 
/**
 * Commands contributed by this extension.
 */
commands: ExtensionCommandContribution[] | null; 
/**
 * Toolbar actions contributed by this extension.
 */
toolbar: ExtensionToolbarContribution[] | null }
/**
 * Result of fetching an extension manifest from a Git URL.
 */
export type ExtensionFetchResult = { manifestJson: string; tempPath: string }
/**
 * Extension manifest parsed from `flowforge.extension.json`.
 * 
 * Matches the JSON schema that extensions ship alongside their entry point.
 * All field names use camelCase in JSON via the `rename_all` attribute.
 */
export type ExtensionManifest = { 
/**
 * Unique identifier for the extension (e.g. "github").
 */
id: string; 
/**
 * Human-readable display name.
 */
name: string; 
/**
 * Semantic version of the extension (e.g. "1.0.0").
 */
version: string; 
/**
 * Optional longer description of what the extension does.
 */
description: string | null; 
/**
 * API version the extension targets (e.g. "1").
 */
apiVersion: string; 
/**
 * Relative path to the JavaScript entry point (e.g. "index.js").
 */
main: string; 
/**
 * Contributions the extension registers (blades, commands, toolbar items).
 */
contributes: ExtensionContributes | null; 
/**
 * Permissions the extension requests (e.g. ["fs:read", "network"]).
 */
permissions: string[] | null; 
/**
 * Absolute path to the extension directory on disk.
 * Populated by discovery after parsing — not present in the JSON file.
 */
basePath?: string | null; 
/**
 * Trust level for the extension.
 * "built-in" for bundled extensions, "user-trusted" for user-installed,
 * "sandboxed" for untrusted third-party (future).
 * Defaults to "sandboxed" when not specified in the manifest JSON.
 */
trustLevel?: string }
/**
 * A toolbar action contributed by an extension.
 */
export type ExtensionToolbarContribution = { 
/**
 * Unique toolbar action identifier.
 */
id: string; 
/**
 * Display label for the toolbar action.
 */
label: string; 
/**
 * Toolbar group to place the action in (e.g. "vcs", "tools").
 */
group: string | null; 
/**
 * Sort priority within the group (lower values appear first).
 */
priority: number | null }
/**
 * A single file change with its status and optional diff stats.
 */
export type FileChange = { path: string; status: FileStatus; additions: number | null; deletions: number | null }
/**
 * A file changed in a commit.
 */
export type FileChanged = { path: string; status: string; additions: number; deletions: number }
/**
 * Complete file diff with old/new content for Monaco DiffEditor.
 */
export type FileDiff = { path: string; oldContent: string; newContent: string; hunks: DiffHunk[]; isBinary: boolean; language: string }
/**
 * Status of a file in the working directory or index.
 */
export type FileStatus = "modified" | "added" | "deleted" | { renamed: { old_path: string } } | "untracked" | "conflicted"
/**
 * Flow type for active workflow.
 */
export type FlowType = "feature" | "release" | "hotfix"
/**
 * Git operation errors that serialize across the IPC boundary.
 * 
 * These errors are sent to the frontend as typed objects,
 * allowing proper error handling in TypeScript.
 */
export type GitError = { type: "NotFound"; message: string } | { type: "NotARepository"; message: string } | { type: "EmptyRepository" } | { type: "StatusError"; message: string } | { type: "OperationFailed"; message: string } | { type: "PathNotFound"; message: string } | { type: "Internal"; message: string } | { type: "NoStagedChanges" } | { type: "SignatureError"; message: string } | { type: "RemoteNotFound"; message: string } | { type: "AuthenticationFailed"; message: string } | { type: "PushRejected"; message: string } | { type: "NetworkError"; message: string } | { type: "BranchNotFound"; message: string } | { type: "CannotDeleteCurrentBranch" } | { type: "BranchNotMerged"; message: string } | { type: "InvalidBranchName"; message: string } | { type: "BranchAlreadyExists"; message: string } | { type: "DirtyWorkingDirectory" } | { type: "StashNotFound"; message: number } | { type: "NothingToStash" } | { type: "TagAlreadyExists"; message: string } | { type: "TagNotFound"; message: string } | { type: "NoMergeInProgress" } | { type: "FileNotConflicted"; message: string } | { type: "InvalidUrl"; message: string } | { type: "PathExists"; message: string } | { type: "CloneFailed"; message: string } | { type: "InvalidPath"; message: string } | { type: "HunkIndexOutOfRange"; message: number } | { type: "LineRangeInvalid"; message: string } | { type: "BinaryPartialStaging" }
/**
 * Snapshot of relevant global git configuration values.
 */
export type GitGlobalConfig = { 
/**
 * user.name from global config, or None if unset.
 */
userName: string | null; 
/**
 * user.email from global config, or None if unset.
 */
userEmail: string | null; 
/**
 * init.defaultBranch from global config, or None if unset.
 */
defaultBranch: string | null }
/**
 * GitHub operation errors that serialize across the IPC boundary.
 * 
 * These errors are sent to the frontend as typed objects,
 * allowing proper error handling in TypeScript. The frontend
 * checks `err.type` to decide control flow (e.g., continue polling
 * on `AuthorizationPending`, increase interval on `SlowDown`).
 */
export type GitHubError = { type: "OAuthFailed"; message: string } | { type: "AuthorizationPending" } | { type: "AccessDenied" } | { type: "ExpiredToken" } | { type: "SlowDown" } | { type: "KeychainError"; message: string } | { type: "NetworkError"; message: string } | { type: "NotAuthenticated" } | { type: "RateLimitExceeded"; message: string } | { type: "Internal"; message: string } | { type: "Cancelled" } | { type: "ApiError"; message: string } | { type: "NotFound"; message: string } | { type: "Forbidden"; message: string } | { type: "MergeNotAllowed"; message: string } | { type: "HeadChanged"; message: string } | { type: "ValidationFailed"; message: string }
/**
 * Information about a detected GitHub remote in the current repository.
 */
export type GitHubRemoteInfo = { remoteName: string; owner: string; repo: string; url: string }
/**
 * Configuration for Gitflow initialization.
 */
export type GitflowConfig = { 
/**
 * Main/production branch name (e.g., "main" or "master")
 */
mainBranch: string; 
/**
 * Development branch name (e.g., "develop")
 */
developBranch: string; 
/**
 * Prefix for feature branches (e.g., "feature/")
 */
featurePrefix: string; 
/**
 * Prefix for release branches (e.g., "release/")
 */
releasePrefix: string; 
/**
 * Prefix for hotfix branches (e.g., "hotfix/")
 */
hotfixPrefix: string }
/**
 * Context about the repository's Gitflow state.
 */
export type GitflowContext = { 
/**
 * Current Gitflow state derived from branch name
 */
state: GitflowState; 
/**
 * Current branch name
 */
currentBranch: string; 
/**
 * Whether the repository has a main/master branch
 */
hasMain: boolean; 
/**
 * Whether the repository has a develop branch
 */
hasDevelop: boolean; 
/**
 * Whether the repository has Gitflow initialized (config in .git/config)
 */
isInitialized: boolean }
/**
 * Gitflow operation errors that serialize across the IPC boundary.
 */
export type GitflowError = 
/**
 * Wrong branch context for the requested operation
 */
{ type: "InvalidContext"; data: { expected: string; actual: string } } | 
/**
 * Operation requires being on a feature branch
 */
{ type: "NotOnFeatureBranch" } | 
/**
 * Operation requires being on a release branch
 */
{ type: "NotOnReleaseBranch" } | 
/**
 * Operation requires being on a hotfix branch
 */
{ type: "NotOnHotfixBranch" } | 
/**
 * A release is already in progress
 */
{ type: "ReleaseInProgress"; data: string } | 
/**
 * A hotfix is already in progress
 */
{ type: "HotfixInProgress"; data: string } | 
/**
 * Merge conflicts encountered during finish operation
 */
{ type: "MergeConflict" } | 
/**
 * Working directory has uncommitted changes
 */
{ type: "DirtyWorkingTree" } | 
/**
 * Repository has no commits yet
 */
{ type: "UnbornHead" } | 
/**
 * Specified branch was not found
 */
{ type: "BranchNotFound"; data: string } | 
/**
 * Branch already exists
 */
{ type: "BranchExists"; data: string } | 
/**
 * Repository is not configured for Gitflow (missing main or develop)
 */
{ type: "NotGitflowRepo" } | 
/**
 * Invalid branch name for Gitflow
 */
{ type: "InvalidBranchName"; data: string } | 
/**
 * Wrapped git2 error
 */
{ type: "Git"; data: string }
/**
 * Result of Gitflow initialization.
 */
export type GitflowInitResult = { 
/**
 * Whether the develop branch was created (false if it already existed)
 */
developCreated: boolean; 
/**
 * Whether we switched to the develop branch
 */
switchedToDevelop: boolean }
/**
 * The current state of the Gitflow workflow.
 */
export type GitflowState = 
/**
 * No active workflow (on main, develop, or other)
 */
{ type: "Idle" } | 
/**
 * Working on a feature branch
 */
{ type: "Feature"; data: { name: string } } | 
/**
 * Working on a release branch
 */
{ type: "Release"; data: { version: string } } | 
/**
 * Working on a hotfix branch
 */
{ type: "Hotfix"; data: { name: string } }
/**
 * Status of Gitflow operations for UI consumption.
 */
export type GitflowStatus = { currentBranch: string; isGitflowReady: boolean; canStartFeature: boolean; canFinishFeature: boolean; canStartRelease: boolean; canFinishRelease: boolean; canStartHotfix: boolean; canFinishHotfix: boolean; canAbort: boolean; activeFlow: ActiveFlow | null; 
/**
 * Context about the repository's Gitflow state
 */
context: GitflowContext }
export type GitignoreTemplate = { name: string; content: string; source: string }
export type GitignoreTemplateList = { templates: GitignoreTemplateName[]; source: string }
export type GitignoreTemplateName = { name: string; category: string }
/**
 * An edge in the commit graph connecting parent and child commits.
 */
export type GraphEdge = { 
/**
 * SHA of the child commit (the commit that has this parent)
 */
from: string; 
/**
 * SHA of the parent commit
 */
to: string }
/**
 * A node in the commit graph representing a single commit.
 */
export type GraphNode = { 
/**
 * Full SHA-1 hash of the commit (40 chars)
 */
oid: string; 
/**
 * Short SHA-1 hash of the commit (7 chars)
 */
shortOid: string; 
/**
 * First line of the commit message
 */
message: string; 
/**
 * Author name
 */
author: string; 
/**
 * Unix timestamp in milliseconds (safe for JS Number up to year 275760)
 */
timestampMs: number; 
/**
 * Parent commit SHAs
 */
parents: string[]; 
/**
 * Classification of the branch type for coloring
 */
branchType: BranchType; 
/**
 * Lane/column position for visual layout (0-indexed from left)
 */
column: number; 
/**
 * Branch names pointing to this commit
 */
branchNames: string[]; 
/**
 * Whether this commit is a first-parent ancestor of HEAD
 */
isHeadAncestor: boolean; 
/**
 * The "ideological branch" name that owns this commit for coloring
 */
ideologicalBranch: string }
export type InitFile = { filename: string; content: string }
/**
 * Result of a successful git init operation.
 */
export type InitResult = { 
/**
 * Absolute path to the initialized repository.
 */
repoPath: string; 
/**
 * Name of the initial branch (e.g. "main").
 */
initialBranch: string }
/**
 * Full issue detail with body, assignees, milestone, and comments.
 */
export type IssueDetail = { number: number; title: string; state: string; authorLogin: string; authorAvatarUrl: string; labels: LabelInfo[]; assignees: UserInfo[]; milestone: MilestoneInfo | null; body: string; createdAt: string; updatedAt: string; closedAt: string | null; htmlUrl: string; commentCount: number; comments: CommentInfo[] }
/**
 * Paginated list of issue summaries.
 */
export type IssueListResponse = { items: IssueSummary[]; hasNextPage: boolean; nextPage: number | null }
/**
 * Summary of an issue for list views.
 */
export type IssueSummary = { number: number; title: string; state: string; authorLogin: string; authorAvatarUrl: string; labels: LabelInfo[]; assigneeLogins: string[]; milestoneTitle: string | null; createdAt: string; updatedAt: string; htmlUrl: string; commentCount: number }
/**
 * Label info for frontend display.
 */
export type LabelInfo = { name: string; color: string; description: string | null }
/**
 * Last commit message with subject and body parsed separately.
 * 
 * Used for amend commit pre-fill functionality.
 */
export type LastCommitMessage = { 
/**
 * First line of the commit message
 */
subject: string; 
/**
 * Everything after the first blank line (if exists)
 */
body: string | null; 
/**
 * Full commit message
 */
fullMessage: string }
/**
 * Result of merge analysis.
 */
export type MergeAnalysisResult = 
/**
 * Already merged, nothing to do
 */
"upToDate" | 
/**
 * Can fast-forward without merge commit
 */
"fastForward" | 
/**
 * Requires merge commit
 */
"normal" | 
/**
 * HEAD doesn't exist yet
 */
"unborn"
/**
 * Result of merging a pull request.
 */
export type MergePullRequestResult = { merged: boolean; sha: string | null; message: string }
/**
 * Result of a merge operation.
 */
export type MergeResult = { 
/**
 * Whether the merge was successful
 */
success: boolean; 
/**
 * Analysis result (what type of merge was performed)
 */
analysis: MergeAnalysisResult; 
/**
 * OID of merge commit (if created)
 */
commitOid: string | null; 
/**
 * True if fast-forward was used
 */
fastForwarded: boolean; 
/**
 * True if conflicts remain
 */
hasConflicts: boolean; 
/**
 * List of conflicted file paths
 */
conflictedFiles: string[] }
/**
 * Status of an in-progress merge.
 */
export type MergeStatus = { 
/**
 * Whether a merge is currently in progress
 */
inProgress: boolean; 
/**
 * List of conflicted file paths
 */
conflictedFiles: string[] }
/**
 * Milestone info for frontend display.
 */
export type MilestoneInfo = { number: number; title: string; state: string }
export type NugetPackageInfo = { id: string; version: string; description: string; authors: string; totalDownloads: number; published: string; projectUrl: string | null; licenseUrl: string | null; tags: string[]; nugetUrl: string }
export type ProjectDetection = { detectedTypes: DetectedProject[] }
/**
 * Full pull request detail with body, stats, and comments.
 */
export type PullRequestDetail = { number: number; title: string; state: string; draft: boolean; merged: boolean; authorLogin: string; authorAvatarUrl: string; headRef: string; headSha: string; baseRef: string; labels: LabelInfo[]; body: string; createdAt: string; updatedAt: string; htmlUrl: string; commentCount: number; reviewCommentCount: number; commits: number; additions: number; deletions: number; changedFiles: number; comments: CommentInfo[] }
/**
 * Paginated list of pull request summaries.
 */
export type PullRequestListResponse = { items: PullRequestSummary[]; hasNextPage: boolean; nextPage: number | null }
/**
 * Summary of a pull request for list views.
 */
export type PullRequestSummary = { number: number; title: string; state: string; draft: boolean; merged: boolean; authorLogin: string; authorAvatarUrl: string; headRef: string; baseRef: string; labels: LabelInfo[]; createdAt: string; updatedAt: string; htmlUrl: string; commentCount: number }
/**
 * Rate limit information from the GitHub API.
 */
export type RateLimitInfo = { limit: number; remaining: number; reset: number; used: number }
/**
 * A recently checked-out branch extracted from the reflog.
 */
export type RecentCheckout = { 
/**
 * Branch name (bare, without refs/heads/ prefix)
 */
name: string; 
/**
 * Unix timestamp in milliseconds when the checkout occurred
 */
lastCheckoutMs: number }
/**
 * Information about a configured remote.
 */
export type RemoteInfo = { name: string; url: string }
/**
 * File content read from the repository at HEAD.
 */
export type RepoFileContent = { content: string; isBinary: boolean; size: number }
/**
 * A single entry in a repository directory listing.
 */
export type RepoFileEntry = { name: string; path: string; isDir: boolean; size: number }
/**
 * Repository status information sent to frontend.
 * 
 * This is a lightweight summary - we don't send raw git2 objects
 * across the IPC boundary.
 */
export type RepoStatus = { 
/**
 * Current branch name (or short commit hash if detached)
 */
branchName: string; 
/**
 * Whether the working directory has uncommitted changes
 */
isDirty: boolean; 
/**
 * Absolute path to the repository root
 */
repoPath: string; 
/**
 * Repository display name (folder name)
 */
repoName: string }
/**
 * A scope suggestion from commit history.
 */
export type ScopeSuggestion = { 
/**
 * The scope string.
 */
scope: string; 
/**
 * Number of times this scope has been used.
 */
usageCount: number }
/**
 * Complete staging status showing staged, unstaged, and untracked files.
 */
export type StagingStatus = { staged: FileChange[]; unstaged: FileChange[]; untracked: FileChange[] }
/**
 * A stash entry representing saved work.
 */
export type StashEntry = { 
/**
 * 0-based index for stash operations
 */
index: number; 
/**
 * Stash message
 */
message: string; 
/**
 * Commit OID of the stash
 */
oid: string }
/**
 * Progress events for remote sync operations.
 * Uses tagged enum serialization for frontend type safety.
 */
export type SyncProgress = { event: "started"; data: { operation: string } } | { event: "counting"; data: { current: number; total: number } } | { event: "compressing"; data: { current: number; total: number } } | { event: "transferring"; data: { current: number; total: number; bytes: number } } | { event: "resolving"; data: { current: number; total: number } } | { event: "finished"; data: { operation: string } } | { event: "error"; data: { message: string } }
/**
 * Result of a sync operation (push/pull/fetch).
 */
export type SyncResult = { success: boolean; message: string; commitsTransferred: number }
/**
 * Information about a git tag.
 */
export type TagInfo = { 
/**
 * Tag name (e.g., "v1.0.0")
 */
name: string; 
/**
 * OID of the tag object (for annotated) or target commit (for lightweight)
 */
oid: string; 
/**
 * OID of the commit the tag points to
 */
targetOid: string; 
/**
 * Tag message (None for lightweight tags)
 */
message: string | null; 
/**
 * Tagger name (None for lightweight tags)
 */
tagger: string | null; 
/**
 * True for annotated tags, false for lightweight
 */
isAnnotated: boolean; 
/**
 * Creation timestamp in milliseconds since epoch
 */
createdAtMs: number }
/**
 * A suggested commit type based on file analysis.
 */
export type TypeSuggestion = { 
/**
 * The suggested commit type.
 */
suggestedType: CommitType; 
/**
 * Confidence level of the suggestion.
 */
confidence: Confidence; 
/**
 * Reason for the suggestion.
 */
reason: string }
/**
 * Information about what can be undone
 */
export type UndoInfo = { 
/**
 * Whether undo is available
 */
canUndo: boolean; 
/**
 * Description of what will be undone
 */
description: string | null; 
/**
 * The reflog entry message
 */
reflogMessage: string | null; 
/**
 * The commit OID to revert to
 */
targetOid: string | null }
/**
 * Minimal user info for frontend display.
 */
export type UserInfo = { login: string; avatarUrl: string }
/**
 * A validation error.
 */
export type ValidationError = { 
/**
 * Error code for programmatic handling.
 */
code: string; 
/**
 * Human-readable error message.
 */
message: string; 
/**
 * Optional suggestion for fixing the error.
 */
suggestion: string | null }
/**
 * Result of validating a commit message.
 */
export type ValidationResult = { 
/**
 * Whether the message is valid.
 */
isValid: boolean; 
/**
 * Validation errors (if any).
 */
errors: ValidationError[]; 
/**
 * Validation warnings (if any).
 */
warnings: ValidationWarning[] }
/**
 * A validation warning.
 */
export type ValidationWarning = { 
/**
 * Warning code for programmatic handling.
 */
code: string; 
/**
 * Human-readable warning message.
 */
message: string }
/**
 * Information about a git worktree.
 */
export type WorktreeInfo = { 
/**
 * Worktree name (for linked worktrees) or "main" for the main worktree
 */
name: string; 
/**
 * Absolute path to the worktree directory
 */
path: string; 
/**
 * Branch checked out in this worktree (None if detached HEAD)
 */
branch: string | null; 
/**
 * Current status of the worktree
 */
status: WorktreeStatus; 
/**
 * True if this is the main worktree (not a linked worktree)
 */
isMain: boolean; 
/**
 * True if the worktree is locked
 */
isLocked: boolean }
/**
 * Status of a worktree's working directory.
 */
export type WorktreeStatus = 
/**
 * No uncommitted changes
 */
"clean" | 
/**
 * Has uncommitted changes
 */
"dirty" | 
/**
 * Has unresolved merge conflicts
 */
"conflicts" | 
/**
 * Worktree is invalid or corrupted
 */
"invalid"

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
